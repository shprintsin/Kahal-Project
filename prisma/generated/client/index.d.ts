
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Page
 * 
 */
export type Page = $Result.DefaultSelection<Prisma.$PagePayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model PostTag
 * 
 */
export type PostTag = $Result.DefaultSelection<Prisma.$PostTagPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model ResearchDataset
 * 
 */
export type ResearchDataset = $Result.DefaultSelection<Prisma.$ResearchDatasetPayload>
/**
 * Model DatasetResource
 * 
 */
export type DatasetResource = $Result.DefaultSelection<Prisma.$DatasetResourcePayload>
/**
 * Model Map
 * 
 */
export type Map = $Result.DefaultSelection<Prisma.$MapPayload>
/**
 * Model Layer
 * 
 */
export type Layer = $Result.DefaultSelection<Prisma.$LayerPayload>
/**
 * Model MapLayerAssociation
 * 
 */
export type MapLayerAssociation = $Result.DefaultSelection<Prisma.$MapLayerAssociationPayload>
/**
 * Model Collection
 * 
 */
export type Collection = $Result.DefaultSelection<Prisma.$CollectionPayload>
/**
 * Model Series
 * 
 */
export type Series = $Result.DefaultSelection<Prisma.$SeriesPayload>
/**
 * Model Volume
 * 
 */
export type Volume = $Result.DefaultSelection<Prisma.$VolumePayload>
/**
 * Model VolumePage
 * 
 */
export type VolumePage = $Result.DefaultSelection<Prisma.$VolumePagePayload>
/**
 * Model Artifact
 * 
 */
export type Artifact = $Result.DefaultSelection<Prisma.$ArtifactPayload>
/**
 * Model PageText
 * 
 */
export type PageText = $Result.DefaultSelection<Prisma.$PageTextPayload>
/**
 * Model PageData
 * 
 */
export type PageData = $Result.DefaultSelection<Prisma.$PageDataPayload>
/**
 * Model PageImage
 * 
 */
export type PageImage = $Result.DefaultSelection<Prisma.$PageImagePayload>
/**
 * Model StorageFile
 * 
 */
export type StorageFile = $Result.DefaultSelection<Prisma.$StorageFilePayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model Place
 * 
 */
export type Place = $Result.DefaultSelection<Prisma.$PlacePayload>
/**
 * Model AdministrativePlace
 * 
 */
export type AdministrativePlace = $Result.DefaultSelection<Prisma.$AdministrativePlacePayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model Region
 * 
 */
export type Region = $Result.DefaultSelection<Prisma.$RegionPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model ArtifactCategory
 * 
 */
export type ArtifactCategory = $Result.DefaultSelection<Prisma.$ArtifactCategoryPayload>
/**
 * Model Period
 * 
 */
export type Period = $Result.DefaultSelection<Prisma.$PeriodPayload>
/**
 * Model Menu
 * 
 */
export type Menu = $Result.DefaultSelection<Prisma.$MenuPayload>
/**
 * Model MenuItem
 * 
 */
export type MenuItem = $Result.DefaultSelection<Prisma.$MenuItemPayload>
/**
 * Model FooterColumn
 * 
 */
export type FooterColumn = $Result.DefaultSelection<Prisma.$FooterColumnPayload>
/**
 * Model FooterColumnItem
 * 
 */
export type FooterColumnItem = $Result.DefaultSelection<Prisma.$FooterColumnItemPayload>
/**
 * Model SiteSettings
 * 
 */
export type SiteSettings = $Result.DefaultSelection<Prisma.$SiteSettingsPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model DocumentPage
 * 
 */
export type DocumentPage = $Result.DefaultSelection<Prisma.$DocumentPagePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  EDITOR: 'EDITOR',
  CONTRIBUTOR: 'CONTRIBUTOR'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ContentLanguage: {
  PL: 'PL',
  HE: 'HE',
  EN: 'EN',
  YD: 'YD',
  RS: 'RS',
  LIT: 'LIT',
  LAT: 'LAT',
  DE: 'DE',
  NA: 'NA'
};

export type ContentLanguage = (typeof ContentLanguage)[keyof typeof ContentLanguage]


export const AppLanguage: {
  PL: 'PL',
  HE: 'HE',
  EN: 'EN'
};

export type AppLanguage = (typeof AppLanguage)[keyof typeof AppLanguage]


export const ContentStatus: {
  draft: 'draft',
  published: 'published',
  archived: 'archived',
  changes_requested: 'changes_requested'
};

export type ContentStatus = (typeof ContentStatus)[keyof typeof ContentStatus]


export const ResouceType: {
  XLSX: 'XLSX',
  CSV: 'CSV',
  JSON: 'JSON',
  PDF: 'PDF',
  HTML: 'HTML',
  DOCX: 'DOCX',
  ZIP: 'ZIP',
  TXT: 'TXT',
  XLS: 'XLS',
  PNG: 'PNG',
  JPG: 'JPG',
  TIFF: 'TIFF',
  URL: 'URL',
  UNKNOWN: 'UNKNOWN'
};

export type ResouceType = (typeof ResouceType)[keyof typeof ResouceType]


export const DataMaturity: {
  Raw: 'Raw',
  Preliminary: 'Preliminary',
  Provisional: 'Provisional',
  Validated: 'Validated'
};

export type DataMaturity = (typeof DataMaturity)[keyof typeof DataMaturity]


export const LayerType: {
  POINTS: 'POINTS',
  POLYGONS: 'POLYGONS',
  POLYLINES: 'POLYLINES',
  MULTI_POLYGONS: 'MULTI_POLYGONS',
  RASTER: 'RASTER'
};

export type LayerType = (typeof LayerType)[keyof typeof LayerType]


export const LayerSourceType: {
  url: 'url',
  database: 'database',
  inline: 'inline'
};

export type LayerSourceType = (typeof LayerSourceType)[keyof typeof LayerSourceType]


export const TextType: {
  TRANSCRIPTION: 'TRANSCRIPTION',
  TRANSLATION: 'TRANSLATION'
};

export type TextType = (typeof TextType)[keyof typeof TextType]


export const ImageUseType: {
  original_scan: 'original_scan',
  thumbnail: 'thumbnail',
  crop: 'crop'
};

export type ImageUseType = (typeof ImageUseType)[keyof typeof ImageUseType]


export const ItemVariant: {
  DEFAULT: 'DEFAULT',
  BUTTON_SOLID: 'BUTTON_SOLID',
  BUTTON_OUTLINE: 'BUTTON_OUTLINE',
  CARD: 'CARD'
};

export type ItemVariant = (typeof ItemVariant)[keyof typeof ItemVariant]


export const MenuType: {
  LINK_LIST: 'LINK_LIST',
  RICH_TEXT: 'RICH_TEXT'
};

export type MenuType = (typeof MenuType)[keyof typeof MenuType]


export const MenuLocation: {
  HEADER: 'HEADER',
  HERO_GRID: 'HERO_GRID',
  HERO_ACTIONS: 'HERO_ACTIONS',
  HERO_STRIP: 'HERO_STRIP',
  FOOTER: 'FOOTER'
};

export type MenuLocation = (typeof MenuLocation)[keyof typeof MenuLocation]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ContentLanguage = $Enums.ContentLanguage

export const ContentLanguage: typeof $Enums.ContentLanguage

export type AppLanguage = $Enums.AppLanguage

export const AppLanguage: typeof $Enums.AppLanguage

export type ContentStatus = $Enums.ContentStatus

export const ContentStatus: typeof $Enums.ContentStatus

export type ResouceType = $Enums.ResouceType

export const ResouceType: typeof $Enums.ResouceType

export type DataMaturity = $Enums.DataMaturity

export const DataMaturity: typeof $Enums.DataMaturity

export type LayerType = $Enums.LayerType

export const LayerType: typeof $Enums.LayerType

export type LayerSourceType = $Enums.LayerSourceType

export const LayerSourceType: typeof $Enums.LayerSourceType

export type TextType = $Enums.TextType

export const TextType: typeof $Enums.TextType

export type ImageUseType = $Enums.ImageUseType

export const ImageUseType: typeof $Enums.ImageUseType

export type ItemVariant = $Enums.ItemVariant

export const ItemVariant: typeof $Enums.ItemVariant

export type MenuType = $Enums.MenuType

export const MenuType: typeof $Enums.MenuType

export type MenuLocation = $Enums.MenuLocation

export const MenuLocation: typeof $Enums.MenuLocation

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Pages
 * const pages = await prisma.page.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Pages
   * const pages = await prisma.page.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.page`: Exposes CRUD operations for the **Page** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pages
    * const pages = await prisma.page.findMany()
    * ```
    */
  get page(): Prisma.PageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postTag`: Exposes CRUD operations for the **PostTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostTags
    * const postTags = await prisma.postTag.findMany()
    * ```
    */
  get postTag(): Prisma.PostTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.researchDataset`: Exposes CRUD operations for the **ResearchDataset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResearchDatasets
    * const researchDatasets = await prisma.researchDataset.findMany()
    * ```
    */
  get researchDataset(): Prisma.ResearchDatasetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.datasetResource`: Exposes CRUD operations for the **DatasetResource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DatasetResources
    * const datasetResources = await prisma.datasetResource.findMany()
    * ```
    */
  get datasetResource(): Prisma.DatasetResourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.map`: Exposes CRUD operations for the **Map** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Maps
    * const maps = await prisma.map.findMany()
    * ```
    */
  get map(): Prisma.MapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.layer`: Exposes CRUD operations for the **Layer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Layers
    * const layers = await prisma.layer.findMany()
    * ```
    */
  get layer(): Prisma.LayerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mapLayerAssociation`: Exposes CRUD operations for the **MapLayerAssociation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MapLayerAssociations
    * const mapLayerAssociations = await prisma.mapLayerAssociation.findMany()
    * ```
    */
  get mapLayerAssociation(): Prisma.MapLayerAssociationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collection`: Exposes CRUD operations for the **Collection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collections
    * const collections = await prisma.collection.findMany()
    * ```
    */
  get collection(): Prisma.CollectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.series`: Exposes CRUD operations for the **Series** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Series
    * const series = await prisma.series.findMany()
    * ```
    */
  get series(): Prisma.SeriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.volume`: Exposes CRUD operations for the **Volume** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Volumes
    * const volumes = await prisma.volume.findMany()
    * ```
    */
  get volume(): Prisma.VolumeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.volumePage`: Exposes CRUD operations for the **VolumePage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VolumePages
    * const volumePages = await prisma.volumePage.findMany()
    * ```
    */
  get volumePage(): Prisma.VolumePageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.artifact`: Exposes CRUD operations for the **Artifact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Artifacts
    * const artifacts = await prisma.artifact.findMany()
    * ```
    */
  get artifact(): Prisma.ArtifactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pageText`: Exposes CRUD operations for the **PageText** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PageTexts
    * const pageTexts = await prisma.pageText.findMany()
    * ```
    */
  get pageText(): Prisma.PageTextDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pageData`: Exposes CRUD operations for the **PageData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PageData
    * const pageData = await prisma.pageData.findMany()
    * ```
    */
  get pageData(): Prisma.PageDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pageImage`: Exposes CRUD operations for the **PageImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PageImages
    * const pageImages = await prisma.pageImage.findMany()
    * ```
    */
  get pageImage(): Prisma.PageImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.storageFile`: Exposes CRUD operations for the **StorageFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StorageFiles
    * const storageFiles = await prisma.storageFile.findMany()
    * ```
    */
  get storageFile(): Prisma.StorageFileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.place`: Exposes CRUD operations for the **Place** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Places
    * const places = await prisma.place.findMany()
    * ```
    */
  get place(): Prisma.PlaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.administrativePlace`: Exposes CRUD operations for the **AdministrativePlace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdministrativePlaces
    * const administrativePlaces = await prisma.administrativePlace.findMany()
    * ```
    */
  get administrativePlace(): Prisma.AdministrativePlaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.region`: Exposes CRUD operations for the **Region** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regions
    * const regions = await prisma.region.findMany()
    * ```
    */
  get region(): Prisma.RegionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.artifactCategory`: Exposes CRUD operations for the **ArtifactCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArtifactCategories
    * const artifactCategories = await prisma.artifactCategory.findMany()
    * ```
    */
  get artifactCategory(): Prisma.ArtifactCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.period`: Exposes CRUD operations for the **Period** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Periods
    * const periods = await prisma.period.findMany()
    * ```
    */
  get period(): Prisma.PeriodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menu`: Exposes CRUD operations for the **Menu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Menus
    * const menus = await prisma.menu.findMany()
    * ```
    */
  get menu(): Prisma.MenuDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menuItem`: Exposes CRUD operations for the **MenuItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MenuItems
    * const menuItems = await prisma.menuItem.findMany()
    * ```
    */
  get menuItem(): Prisma.MenuItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.footerColumn`: Exposes CRUD operations for the **FooterColumn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FooterColumns
    * const footerColumns = await prisma.footerColumn.findMany()
    * ```
    */
  get footerColumn(): Prisma.FooterColumnDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.footerColumnItem`: Exposes CRUD operations for the **FooterColumnItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FooterColumnItems
    * const footerColumnItems = await prisma.footerColumnItem.findMany()
    * ```
    */
  get footerColumnItem(): Prisma.FooterColumnItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.siteSettings`: Exposes CRUD operations for the **SiteSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SiteSettings
    * const siteSettings = await prisma.siteSettings.findMany()
    * ```
    */
  get siteSettings(): Prisma.SiteSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentPage`: Exposes CRUD operations for the **DocumentPage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentPages
    * const documentPages = await prisma.documentPage.findMany()
    * ```
    */
  get documentPage(): Prisma.DocumentPageDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Page: 'Page',
    Post: 'Post',
    PostTag: 'PostTag',
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    ResearchDataset: 'ResearchDataset',
    DatasetResource: 'DatasetResource',
    Map: 'Map',
    Layer: 'Layer',
    MapLayerAssociation: 'MapLayerAssociation',
    Collection: 'Collection',
    Series: 'Series',
    Volume: 'Volume',
    VolumePage: 'VolumePage',
    Artifact: 'Artifact',
    PageText: 'PageText',
    PageData: 'PageData',
    PageImage: 'PageImage',
    StorageFile: 'StorageFile',
    Media: 'Media',
    Place: 'Place',
    AdministrativePlace: 'AdministrativePlace',
    Tag: 'Tag',
    Region: 'Region',
    Category: 'Category',
    ArtifactCategory: 'ArtifactCategory',
    Period: 'Period',
    Menu: 'Menu',
    MenuItem: 'MenuItem',
    FooterColumn: 'FooterColumn',
    FooterColumnItem: 'FooterColumnItem',
    SiteSettings: 'SiteSettings',
    Document: 'Document',
    DocumentPage: 'DocumentPage'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "page" | "post" | "postTag" | "user" | "account" | "session" | "verificationToken" | "researchDataset" | "datasetResource" | "map" | "layer" | "mapLayerAssociation" | "collection" | "series" | "volume" | "volumePage" | "artifact" | "pageText" | "pageData" | "pageImage" | "storageFile" | "media" | "place" | "administrativePlace" | "tag" | "region" | "category" | "artifactCategory" | "period" | "menu" | "menuItem" | "footerColumn" | "footerColumnItem" | "siteSettings" | "document" | "documentPage"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Page: {
        payload: Prisma.$PagePayload<ExtArgs>
        fields: Prisma.PageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          findFirst: {
            args: Prisma.PageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          findMany: {
            args: Prisma.PageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          create: {
            args: Prisma.PageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          createMany: {
            args: Prisma.PageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          delete: {
            args: Prisma.PageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          update: {
            args: Prisma.PageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          deleteMany: {
            args: Prisma.PageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          upsert: {
            args: Prisma.PageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          aggregate: {
            args: Prisma.PageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePage>
          }
          groupBy: {
            args: Prisma.PageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PageCountArgs<ExtArgs>
            result: $Utils.Optional<PageCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      PostTag: {
        payload: Prisma.$PostTagPayload<ExtArgs>
        fields: Prisma.PostTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          findFirst: {
            args: Prisma.PostTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          findMany: {
            args: Prisma.PostTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>[]
          }
          create: {
            args: Prisma.PostTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          createMany: {
            args: Prisma.PostTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>[]
          }
          delete: {
            args: Prisma.PostTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          update: {
            args: Prisma.PostTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          deleteMany: {
            args: Prisma.PostTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>[]
          }
          upsert: {
            args: Prisma.PostTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          aggregate: {
            args: Prisma.PostTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostTag>
          }
          groupBy: {
            args: Prisma.PostTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostTagCountArgs<ExtArgs>
            result: $Utils.Optional<PostTagCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      ResearchDataset: {
        payload: Prisma.$ResearchDatasetPayload<ExtArgs>
        fields: Prisma.ResearchDatasetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResearchDatasetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchDatasetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResearchDatasetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchDatasetPayload>
          }
          findFirst: {
            args: Prisma.ResearchDatasetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchDatasetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResearchDatasetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchDatasetPayload>
          }
          findMany: {
            args: Prisma.ResearchDatasetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchDatasetPayload>[]
          }
          create: {
            args: Prisma.ResearchDatasetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchDatasetPayload>
          }
          createMany: {
            args: Prisma.ResearchDatasetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResearchDatasetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchDatasetPayload>[]
          }
          delete: {
            args: Prisma.ResearchDatasetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchDatasetPayload>
          }
          update: {
            args: Prisma.ResearchDatasetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchDatasetPayload>
          }
          deleteMany: {
            args: Prisma.ResearchDatasetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResearchDatasetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResearchDatasetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchDatasetPayload>[]
          }
          upsert: {
            args: Prisma.ResearchDatasetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResearchDatasetPayload>
          }
          aggregate: {
            args: Prisma.ResearchDatasetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResearchDataset>
          }
          groupBy: {
            args: Prisma.ResearchDatasetGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResearchDatasetGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResearchDatasetCountArgs<ExtArgs>
            result: $Utils.Optional<ResearchDatasetCountAggregateOutputType> | number
          }
        }
      }
      DatasetResource: {
        payload: Prisma.$DatasetResourcePayload<ExtArgs>
        fields: Prisma.DatasetResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DatasetResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DatasetResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetResourcePayload>
          }
          findFirst: {
            args: Prisma.DatasetResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DatasetResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetResourcePayload>
          }
          findMany: {
            args: Prisma.DatasetResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetResourcePayload>[]
          }
          create: {
            args: Prisma.DatasetResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetResourcePayload>
          }
          createMany: {
            args: Prisma.DatasetResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DatasetResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetResourcePayload>[]
          }
          delete: {
            args: Prisma.DatasetResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetResourcePayload>
          }
          update: {
            args: Prisma.DatasetResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetResourcePayload>
          }
          deleteMany: {
            args: Prisma.DatasetResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DatasetResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DatasetResourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetResourcePayload>[]
          }
          upsert: {
            args: Prisma.DatasetResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatasetResourcePayload>
          }
          aggregate: {
            args: Prisma.DatasetResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDatasetResource>
          }
          groupBy: {
            args: Prisma.DatasetResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DatasetResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DatasetResourceCountArgs<ExtArgs>
            result: $Utils.Optional<DatasetResourceCountAggregateOutputType> | number
          }
        }
      }
      Map: {
        payload: Prisma.$MapPayload<ExtArgs>
        fields: Prisma.MapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>
          }
          findFirst: {
            args: Prisma.MapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>
          }
          findMany: {
            args: Prisma.MapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>[]
          }
          create: {
            args: Prisma.MapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>
          }
          createMany: {
            args: Prisma.MapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>[]
          }
          delete: {
            args: Prisma.MapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>
          }
          update: {
            args: Prisma.MapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>
          }
          deleteMany: {
            args: Prisma.MapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>[]
          }
          upsert: {
            args: Prisma.MapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapPayload>
          }
          aggregate: {
            args: Prisma.MapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMap>
          }
          groupBy: {
            args: Prisma.MapGroupByArgs<ExtArgs>
            result: $Utils.Optional<MapGroupByOutputType>[]
          }
          count: {
            args: Prisma.MapCountArgs<ExtArgs>
            result: $Utils.Optional<MapCountAggregateOutputType> | number
          }
        }
      }
      Layer: {
        payload: Prisma.$LayerPayload<ExtArgs>
        fields: Prisma.LayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayerPayload>
          }
          findFirst: {
            args: Prisma.LayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayerPayload>
          }
          findMany: {
            args: Prisma.LayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayerPayload>[]
          }
          create: {
            args: Prisma.LayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayerPayload>
          }
          createMany: {
            args: Prisma.LayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LayerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayerPayload>[]
          }
          delete: {
            args: Prisma.LayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayerPayload>
          }
          update: {
            args: Prisma.LayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayerPayload>
          }
          deleteMany: {
            args: Prisma.LayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LayerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayerPayload>[]
          }
          upsert: {
            args: Prisma.LayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LayerPayload>
          }
          aggregate: {
            args: Prisma.LayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLayer>
          }
          groupBy: {
            args: Prisma.LayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<LayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.LayerCountArgs<ExtArgs>
            result: $Utils.Optional<LayerCountAggregateOutputType> | number
          }
        }
      }
      MapLayerAssociation: {
        payload: Prisma.$MapLayerAssociationPayload<ExtArgs>
        fields: Prisma.MapLayerAssociationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MapLayerAssociationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapLayerAssociationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MapLayerAssociationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapLayerAssociationPayload>
          }
          findFirst: {
            args: Prisma.MapLayerAssociationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapLayerAssociationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MapLayerAssociationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapLayerAssociationPayload>
          }
          findMany: {
            args: Prisma.MapLayerAssociationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapLayerAssociationPayload>[]
          }
          create: {
            args: Prisma.MapLayerAssociationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapLayerAssociationPayload>
          }
          createMany: {
            args: Prisma.MapLayerAssociationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MapLayerAssociationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapLayerAssociationPayload>[]
          }
          delete: {
            args: Prisma.MapLayerAssociationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapLayerAssociationPayload>
          }
          update: {
            args: Prisma.MapLayerAssociationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapLayerAssociationPayload>
          }
          deleteMany: {
            args: Prisma.MapLayerAssociationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MapLayerAssociationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MapLayerAssociationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapLayerAssociationPayload>[]
          }
          upsert: {
            args: Prisma.MapLayerAssociationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MapLayerAssociationPayload>
          }
          aggregate: {
            args: Prisma.MapLayerAssociationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMapLayerAssociation>
          }
          groupBy: {
            args: Prisma.MapLayerAssociationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MapLayerAssociationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MapLayerAssociationCountArgs<ExtArgs>
            result: $Utils.Optional<MapLayerAssociationCountAggregateOutputType> | number
          }
        }
      }
      Collection: {
        payload: Prisma.$CollectionPayload<ExtArgs>
        fields: Prisma.CollectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CollectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CollectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          findFirst: {
            args: Prisma.CollectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CollectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          findMany: {
            args: Prisma.CollectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>[]
          }
          create: {
            args: Prisma.CollectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          createMany: {
            args: Prisma.CollectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CollectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>[]
          }
          delete: {
            args: Prisma.CollectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          update: {
            args: Prisma.CollectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          deleteMany: {
            args: Prisma.CollectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CollectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CollectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>[]
          }
          upsert: {
            args: Prisma.CollectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CollectionPayload>
          }
          aggregate: {
            args: Prisma.CollectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollection>
          }
          groupBy: {
            args: Prisma.CollectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CollectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CollectionCountArgs<ExtArgs>
            result: $Utils.Optional<CollectionCountAggregateOutputType> | number
          }
        }
      }
      Series: {
        payload: Prisma.$SeriesPayload<ExtArgs>
        fields: Prisma.SeriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          findFirst: {
            args: Prisma.SeriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          findMany: {
            args: Prisma.SeriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>[]
          }
          create: {
            args: Prisma.SeriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          createMany: {
            args: Prisma.SeriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>[]
          }
          delete: {
            args: Prisma.SeriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          update: {
            args: Prisma.SeriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          deleteMany: {
            args: Prisma.SeriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>[]
          }
          upsert: {
            args: Prisma.SeriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          aggregate: {
            args: Prisma.SeriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeries>
          }
          groupBy: {
            args: Prisma.SeriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeriesCountArgs<ExtArgs>
            result: $Utils.Optional<SeriesCountAggregateOutputType> | number
          }
        }
      }
      Volume: {
        payload: Prisma.$VolumePayload<ExtArgs>
        fields: Prisma.VolumeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VolumeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VolumeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumePayload>
          }
          findFirst: {
            args: Prisma.VolumeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VolumeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumePayload>
          }
          findMany: {
            args: Prisma.VolumeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumePayload>[]
          }
          create: {
            args: Prisma.VolumeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumePayload>
          }
          createMany: {
            args: Prisma.VolumeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VolumeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumePayload>[]
          }
          delete: {
            args: Prisma.VolumeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumePayload>
          }
          update: {
            args: Prisma.VolumeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumePayload>
          }
          deleteMany: {
            args: Prisma.VolumeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VolumeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VolumeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumePayload>[]
          }
          upsert: {
            args: Prisma.VolumeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumePayload>
          }
          aggregate: {
            args: Prisma.VolumeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVolume>
          }
          groupBy: {
            args: Prisma.VolumeGroupByArgs<ExtArgs>
            result: $Utils.Optional<VolumeGroupByOutputType>[]
          }
          count: {
            args: Prisma.VolumeCountArgs<ExtArgs>
            result: $Utils.Optional<VolumeCountAggregateOutputType> | number
          }
        }
      }
      VolumePage: {
        payload: Prisma.$VolumePagePayload<ExtArgs>
        fields: Prisma.VolumePageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VolumePageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumePagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VolumePageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumePagePayload>
          }
          findFirst: {
            args: Prisma.VolumePageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumePagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VolumePageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumePagePayload>
          }
          findMany: {
            args: Prisma.VolumePageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumePagePayload>[]
          }
          create: {
            args: Prisma.VolumePageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumePagePayload>
          }
          createMany: {
            args: Prisma.VolumePageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VolumePageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumePagePayload>[]
          }
          delete: {
            args: Prisma.VolumePageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumePagePayload>
          }
          update: {
            args: Prisma.VolumePageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumePagePayload>
          }
          deleteMany: {
            args: Prisma.VolumePageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VolumePageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VolumePageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumePagePayload>[]
          }
          upsert: {
            args: Prisma.VolumePageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumePagePayload>
          }
          aggregate: {
            args: Prisma.VolumePageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVolumePage>
          }
          groupBy: {
            args: Prisma.VolumePageGroupByArgs<ExtArgs>
            result: $Utils.Optional<VolumePageGroupByOutputType>[]
          }
          count: {
            args: Prisma.VolumePageCountArgs<ExtArgs>
            result: $Utils.Optional<VolumePageCountAggregateOutputType> | number
          }
        }
      }
      Artifact: {
        payload: Prisma.$ArtifactPayload<ExtArgs>
        fields: Prisma.ArtifactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArtifactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArtifactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          findFirst: {
            args: Prisma.ArtifactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArtifactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          findMany: {
            args: Prisma.ArtifactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>[]
          }
          create: {
            args: Prisma.ArtifactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          createMany: {
            args: Prisma.ArtifactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArtifactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>[]
          }
          delete: {
            args: Prisma.ArtifactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          update: {
            args: Prisma.ArtifactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          deleteMany: {
            args: Prisma.ArtifactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArtifactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArtifactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>[]
          }
          upsert: {
            args: Prisma.ArtifactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactPayload>
          }
          aggregate: {
            args: Prisma.ArtifactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArtifact>
          }
          groupBy: {
            args: Prisma.ArtifactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArtifactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArtifactCountArgs<ExtArgs>
            result: $Utils.Optional<ArtifactCountAggregateOutputType> | number
          }
        }
      }
      PageText: {
        payload: Prisma.$PageTextPayload<ExtArgs>
        fields: Prisma.PageTextFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageTextFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTextPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageTextFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTextPayload>
          }
          findFirst: {
            args: Prisma.PageTextFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTextPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageTextFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTextPayload>
          }
          findMany: {
            args: Prisma.PageTextFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTextPayload>[]
          }
          create: {
            args: Prisma.PageTextCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTextPayload>
          }
          createMany: {
            args: Prisma.PageTextCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PageTextCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTextPayload>[]
          }
          delete: {
            args: Prisma.PageTextDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTextPayload>
          }
          update: {
            args: Prisma.PageTextUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTextPayload>
          }
          deleteMany: {
            args: Prisma.PageTextDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PageTextUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PageTextUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTextPayload>[]
          }
          upsert: {
            args: Prisma.PageTextUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageTextPayload>
          }
          aggregate: {
            args: Prisma.PageTextAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePageText>
          }
          groupBy: {
            args: Prisma.PageTextGroupByArgs<ExtArgs>
            result: $Utils.Optional<PageTextGroupByOutputType>[]
          }
          count: {
            args: Prisma.PageTextCountArgs<ExtArgs>
            result: $Utils.Optional<PageTextCountAggregateOutputType> | number
          }
        }
      }
      PageData: {
        payload: Prisma.$PageDataPayload<ExtArgs>
        fields: Prisma.PageDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageDataPayload>
          }
          findFirst: {
            args: Prisma.PageDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageDataPayload>
          }
          findMany: {
            args: Prisma.PageDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageDataPayload>[]
          }
          create: {
            args: Prisma.PageDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageDataPayload>
          }
          createMany: {
            args: Prisma.PageDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PageDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageDataPayload>[]
          }
          delete: {
            args: Prisma.PageDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageDataPayload>
          }
          update: {
            args: Prisma.PageDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageDataPayload>
          }
          deleteMany: {
            args: Prisma.PageDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PageDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PageDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageDataPayload>[]
          }
          upsert: {
            args: Prisma.PageDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageDataPayload>
          }
          aggregate: {
            args: Prisma.PageDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePageData>
          }
          groupBy: {
            args: Prisma.PageDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<PageDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.PageDataCountArgs<ExtArgs>
            result: $Utils.Optional<PageDataCountAggregateOutputType> | number
          }
        }
      }
      PageImage: {
        payload: Prisma.$PageImagePayload<ExtArgs>
        fields: Prisma.PageImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageImagePayload>
          }
          findFirst: {
            args: Prisma.PageImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageImagePayload>
          }
          findMany: {
            args: Prisma.PageImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageImagePayload>[]
          }
          create: {
            args: Prisma.PageImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageImagePayload>
          }
          createMany: {
            args: Prisma.PageImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PageImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageImagePayload>[]
          }
          delete: {
            args: Prisma.PageImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageImagePayload>
          }
          update: {
            args: Prisma.PageImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageImagePayload>
          }
          deleteMany: {
            args: Prisma.PageImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PageImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PageImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageImagePayload>[]
          }
          upsert: {
            args: Prisma.PageImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PageImagePayload>
          }
          aggregate: {
            args: Prisma.PageImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePageImage>
          }
          groupBy: {
            args: Prisma.PageImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PageImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PageImageCountArgs<ExtArgs>
            result: $Utils.Optional<PageImageCountAggregateOutputType> | number
          }
        }
      }
      StorageFile: {
        payload: Prisma.$StorageFilePayload<ExtArgs>
        fields: Prisma.StorageFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StorageFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StorageFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageFilePayload>
          }
          findFirst: {
            args: Prisma.StorageFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StorageFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageFilePayload>
          }
          findMany: {
            args: Prisma.StorageFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageFilePayload>[]
          }
          create: {
            args: Prisma.StorageFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageFilePayload>
          }
          createMany: {
            args: Prisma.StorageFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StorageFileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageFilePayload>[]
          }
          delete: {
            args: Prisma.StorageFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageFilePayload>
          }
          update: {
            args: Prisma.StorageFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageFilePayload>
          }
          deleteMany: {
            args: Prisma.StorageFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StorageFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StorageFileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageFilePayload>[]
          }
          upsert: {
            args: Prisma.StorageFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageFilePayload>
          }
          aggregate: {
            args: Prisma.StorageFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStorageFile>
          }
          groupBy: {
            args: Prisma.StorageFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<StorageFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.StorageFileCountArgs<ExtArgs>
            result: $Utils.Optional<StorageFileCountAggregateOutputType> | number
          }
        }
      }
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      Place: {
        payload: Prisma.$PlacePayload<ExtArgs>
        fields: Prisma.PlaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          findFirst: {
            args: Prisma.PlaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          findMany: {
            args: Prisma.PlaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>[]
          }
          create: {
            args: Prisma.PlaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          createMany: {
            args: Prisma.PlaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>[]
          }
          delete: {
            args: Prisma.PlaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          update: {
            args: Prisma.PlaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          deleteMany: {
            args: Prisma.PlaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>[]
          }
          upsert: {
            args: Prisma.PlaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacePayload>
          }
          aggregate: {
            args: Prisma.PlaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlace>
          }
          groupBy: {
            args: Prisma.PlaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaceCountArgs<ExtArgs>
            result: $Utils.Optional<PlaceCountAggregateOutputType> | number
          }
        }
      }
      AdministrativePlace: {
        payload: Prisma.$AdministrativePlacePayload<ExtArgs>
        fields: Prisma.AdministrativePlaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdministrativePlaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministrativePlacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdministrativePlaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministrativePlacePayload>
          }
          findFirst: {
            args: Prisma.AdministrativePlaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministrativePlacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdministrativePlaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministrativePlacePayload>
          }
          findMany: {
            args: Prisma.AdministrativePlaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministrativePlacePayload>[]
          }
          create: {
            args: Prisma.AdministrativePlaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministrativePlacePayload>
          }
          createMany: {
            args: Prisma.AdministrativePlaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdministrativePlaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministrativePlacePayload>[]
          }
          delete: {
            args: Prisma.AdministrativePlaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministrativePlacePayload>
          }
          update: {
            args: Prisma.AdministrativePlaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministrativePlacePayload>
          }
          deleteMany: {
            args: Prisma.AdministrativePlaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdministrativePlaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdministrativePlaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministrativePlacePayload>[]
          }
          upsert: {
            args: Prisma.AdministrativePlaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdministrativePlacePayload>
          }
          aggregate: {
            args: Prisma.AdministrativePlaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdministrativePlace>
          }
          groupBy: {
            args: Prisma.AdministrativePlaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdministrativePlaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdministrativePlaceCountArgs<ExtArgs>
            result: $Utils.Optional<AdministrativePlaceCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      Region: {
        payload: Prisma.$RegionPayload<ExtArgs>
        fields: Prisma.RegionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findFirst: {
            args: Prisma.RegionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findMany: {
            args: Prisma.RegionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          create: {
            args: Prisma.RegionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          createMany: {
            args: Prisma.RegionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          delete: {
            args: Prisma.RegionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          update: {
            args: Prisma.RegionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          deleteMany: {
            args: Prisma.RegionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RegionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          upsert: {
            args: Prisma.RegionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          aggregate: {
            args: Prisma.RegionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegion>
          }
          groupBy: {
            args: Prisma.RegionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegionCountArgs<ExtArgs>
            result: $Utils.Optional<RegionCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      ArtifactCategory: {
        payload: Prisma.$ArtifactCategoryPayload<ExtArgs>
        fields: Prisma.ArtifactCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArtifactCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArtifactCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactCategoryPayload>
          }
          findFirst: {
            args: Prisma.ArtifactCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArtifactCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactCategoryPayload>
          }
          findMany: {
            args: Prisma.ArtifactCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactCategoryPayload>[]
          }
          create: {
            args: Prisma.ArtifactCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactCategoryPayload>
          }
          createMany: {
            args: Prisma.ArtifactCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArtifactCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactCategoryPayload>[]
          }
          delete: {
            args: Prisma.ArtifactCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactCategoryPayload>
          }
          update: {
            args: Prisma.ArtifactCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ArtifactCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArtifactCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArtifactCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ArtifactCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactCategoryPayload>
          }
          aggregate: {
            args: Prisma.ArtifactCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArtifactCategory>
          }
          groupBy: {
            args: Prisma.ArtifactCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArtifactCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArtifactCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ArtifactCategoryCountAggregateOutputType> | number
          }
        }
      }
      Period: {
        payload: Prisma.$PeriodPayload<ExtArgs>
        fields: Prisma.PeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodPayload>
          }
          findFirst: {
            args: Prisma.PeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodPayload>
          }
          findMany: {
            args: Prisma.PeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodPayload>[]
          }
          create: {
            args: Prisma.PeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodPayload>
          }
          createMany: {
            args: Prisma.PeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PeriodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodPayload>[]
          }
          delete: {
            args: Prisma.PeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodPayload>
          }
          update: {
            args: Prisma.PeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodPayload>
          }
          deleteMany: {
            args: Prisma.PeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PeriodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodPayload>[]
          }
          upsert: {
            args: Prisma.PeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodPayload>
          }
          aggregate: {
            args: Prisma.PeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePeriod>
          }
          groupBy: {
            args: Prisma.PeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<PeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.PeriodCountArgs<ExtArgs>
            result: $Utils.Optional<PeriodCountAggregateOutputType> | number
          }
        }
      }
      Menu: {
        payload: Prisma.$MenuPayload<ExtArgs>
        fields: Prisma.MenuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          findFirst: {
            args: Prisma.MenuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          findMany: {
            args: Prisma.MenuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          create: {
            args: Prisma.MenuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          createMany: {
            args: Prisma.MenuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenuCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          delete: {
            args: Prisma.MenuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          update: {
            args: Prisma.MenuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          deleteMany: {
            args: Prisma.MenuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenuUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>[]
          }
          upsert: {
            args: Prisma.MenuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuPayload>
          }
          aggregate: {
            args: Prisma.MenuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenu>
          }
          groupBy: {
            args: Prisma.MenuGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenuCountArgs<ExtArgs>
            result: $Utils.Optional<MenuCountAggregateOutputType> | number
          }
        }
      }
      MenuItem: {
        payload: Prisma.$MenuItemPayload<ExtArgs>
        fields: Prisma.MenuItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MenuItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MenuItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          findFirst: {
            args: Prisma.MenuItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MenuItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          findMany: {
            args: Prisma.MenuItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>[]
          }
          create: {
            args: Prisma.MenuItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          createMany: {
            args: Prisma.MenuItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MenuItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>[]
          }
          delete: {
            args: Prisma.MenuItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          update: {
            args: Prisma.MenuItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          deleteMany: {
            args: Prisma.MenuItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MenuItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MenuItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>[]
          }
          upsert: {
            args: Prisma.MenuItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MenuItemPayload>
          }
          aggregate: {
            args: Prisma.MenuItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenuItem>
          }
          groupBy: {
            args: Prisma.MenuItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenuItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MenuItemCountArgs<ExtArgs>
            result: $Utils.Optional<MenuItemCountAggregateOutputType> | number
          }
        }
      }
      FooterColumn: {
        payload: Prisma.$FooterColumnPayload<ExtArgs>
        fields: Prisma.FooterColumnFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FooterColumnFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterColumnPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FooterColumnFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterColumnPayload>
          }
          findFirst: {
            args: Prisma.FooterColumnFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterColumnPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FooterColumnFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterColumnPayload>
          }
          findMany: {
            args: Prisma.FooterColumnFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterColumnPayload>[]
          }
          create: {
            args: Prisma.FooterColumnCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterColumnPayload>
          }
          createMany: {
            args: Prisma.FooterColumnCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FooterColumnCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterColumnPayload>[]
          }
          delete: {
            args: Prisma.FooterColumnDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterColumnPayload>
          }
          update: {
            args: Prisma.FooterColumnUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterColumnPayload>
          }
          deleteMany: {
            args: Prisma.FooterColumnDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FooterColumnUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FooterColumnUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterColumnPayload>[]
          }
          upsert: {
            args: Prisma.FooterColumnUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterColumnPayload>
          }
          aggregate: {
            args: Prisma.FooterColumnAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFooterColumn>
          }
          groupBy: {
            args: Prisma.FooterColumnGroupByArgs<ExtArgs>
            result: $Utils.Optional<FooterColumnGroupByOutputType>[]
          }
          count: {
            args: Prisma.FooterColumnCountArgs<ExtArgs>
            result: $Utils.Optional<FooterColumnCountAggregateOutputType> | number
          }
        }
      }
      FooterColumnItem: {
        payload: Prisma.$FooterColumnItemPayload<ExtArgs>
        fields: Prisma.FooterColumnItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FooterColumnItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterColumnItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FooterColumnItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterColumnItemPayload>
          }
          findFirst: {
            args: Prisma.FooterColumnItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterColumnItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FooterColumnItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterColumnItemPayload>
          }
          findMany: {
            args: Prisma.FooterColumnItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterColumnItemPayload>[]
          }
          create: {
            args: Prisma.FooterColumnItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterColumnItemPayload>
          }
          createMany: {
            args: Prisma.FooterColumnItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FooterColumnItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterColumnItemPayload>[]
          }
          delete: {
            args: Prisma.FooterColumnItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterColumnItemPayload>
          }
          update: {
            args: Prisma.FooterColumnItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterColumnItemPayload>
          }
          deleteMany: {
            args: Prisma.FooterColumnItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FooterColumnItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FooterColumnItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterColumnItemPayload>[]
          }
          upsert: {
            args: Prisma.FooterColumnItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FooterColumnItemPayload>
          }
          aggregate: {
            args: Prisma.FooterColumnItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFooterColumnItem>
          }
          groupBy: {
            args: Prisma.FooterColumnItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<FooterColumnItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.FooterColumnItemCountArgs<ExtArgs>
            result: $Utils.Optional<FooterColumnItemCountAggregateOutputType> | number
          }
        }
      }
      SiteSettings: {
        payload: Prisma.$SiteSettingsPayload<ExtArgs>
        fields: Prisma.SiteSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SiteSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SiteSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          findFirst: {
            args: Prisma.SiteSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SiteSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          findMany: {
            args: Prisma.SiteSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>[]
          }
          create: {
            args: Prisma.SiteSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          createMany: {
            args: Prisma.SiteSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SiteSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>[]
          }
          delete: {
            args: Prisma.SiteSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          update: {
            args: Prisma.SiteSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          deleteMany: {
            args: Prisma.SiteSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SiteSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SiteSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>[]
          }
          upsert: {
            args: Prisma.SiteSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SiteSettingsPayload>
          }
          aggregate: {
            args: Prisma.SiteSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSiteSettings>
          }
          groupBy: {
            args: Prisma.SiteSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SiteSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SiteSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SiteSettingsCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      DocumentPage: {
        payload: Prisma.$DocumentPagePayload<ExtArgs>
        fields: Prisma.DocumentPageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentPageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentPageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPagePayload>
          }
          findFirst: {
            args: Prisma.DocumentPageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentPageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPagePayload>
          }
          findMany: {
            args: Prisma.DocumentPageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPagePayload>[]
          }
          create: {
            args: Prisma.DocumentPageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPagePayload>
          }
          createMany: {
            args: Prisma.DocumentPageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentPageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPagePayload>[]
          }
          delete: {
            args: Prisma.DocumentPageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPagePayload>
          }
          update: {
            args: Prisma.DocumentPageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPagePayload>
          }
          deleteMany: {
            args: Prisma.DocumentPageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentPageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentPageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPagePayload>[]
          }
          upsert: {
            args: Prisma.DocumentPageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPagePayload>
          }
          aggregate: {
            args: Prisma.DocumentPageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentPage>
          }
          groupBy: {
            args: Prisma.DocumentPageGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentPageGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentPageCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentPageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    page?: PageOmit
    post?: PostOmit
    postTag?: PostTagOmit
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    researchDataset?: ResearchDatasetOmit
    datasetResource?: DatasetResourceOmit
    map?: MapOmit
    layer?: LayerOmit
    mapLayerAssociation?: MapLayerAssociationOmit
    collection?: CollectionOmit
    series?: SeriesOmit
    volume?: VolumeOmit
    volumePage?: VolumePageOmit
    artifact?: ArtifactOmit
    pageText?: PageTextOmit
    pageData?: PageDataOmit
    pageImage?: PageImageOmit
    storageFile?: StorageFileOmit
    media?: MediaOmit
    place?: PlaceOmit
    administrativePlace?: AdministrativePlaceOmit
    tag?: TagOmit
    region?: RegionOmit
    category?: CategoryOmit
    artifactCategory?: ArtifactCategoryOmit
    period?: PeriodOmit
    menu?: MenuOmit
    menuItem?: MenuItemOmit
    footerColumn?: FooterColumnOmit
    footerColumnItem?: FooterColumnItemOmit
    siteSettings?: SiteSettingsOmit
    document?: DocumentOmit
    documentPage?: DocumentPageOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PageCountOutputType
   */

  export type PageCountOutputType = {
    children: number
    regions: number
    tags: number
    menuItems: number
    footerItems: number
  }

  export type PageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | PageCountOutputTypeCountChildrenArgs
    regions?: boolean | PageCountOutputTypeCountRegionsArgs
    tags?: boolean | PageCountOutputTypeCountTagsArgs
    menuItems?: boolean | PageCountOutputTypeCountMenuItemsArgs
    footerItems?: boolean | PageCountOutputTypeCountFooterItemsArgs
  }

  // Custom InputTypes
  /**
   * PageCountOutputType without action
   */
  export type PageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageCountOutputType
     */
    select?: PageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PageCountOutputType without action
   */
  export type PageCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
  }

  /**
   * PageCountOutputType without action
   */
  export type PageCountOutputTypeCountRegionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
  }

  /**
   * PageCountOutputType without action
   */
  export type PageCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * PageCountOutputType without action
   */
  export type PageCountOutputTypeCountMenuItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuItemWhereInput
  }

  /**
   * PageCountOutputType without action
   */
  export type PageCountOutputTypeCountFooterItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FooterColumnItemWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    tags: number
    categories: number
    regions: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | PostCountOutputTypeCountTagsArgs
    categories?: boolean | PostCountOutputTypeCountCategoriesArgs
    regions?: boolean | PostCountOutputTypeCountRegionsArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostTagWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountRegionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    pageTexts: number
    pages: number
    posts: number
    sessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    pageTexts?: boolean | UserCountOutputTypeCountPageTextsArgs
    pages?: boolean | UserCountOutputTypeCountPagesArgs
    posts?: boolean | UserCountOutputTypeCountPostsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPageTextsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageTextWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * Count Type ResearchDatasetCountOutputType
   */

  export type ResearchDatasetCountOutputType = {
    resources: number
    regions: number
  }

  export type ResearchDatasetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resources?: boolean | ResearchDatasetCountOutputTypeCountResourcesArgs
    regions?: boolean | ResearchDatasetCountOutputTypeCountRegionsArgs
  }

  // Custom InputTypes
  /**
   * ResearchDatasetCountOutputType without action
   */
  export type ResearchDatasetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDatasetCountOutputType
     */
    select?: ResearchDatasetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResearchDatasetCountOutputType without action
   */
  export type ResearchDatasetCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatasetResourceWhereInput
  }

  /**
   * ResearchDatasetCountOutputType without action
   */
  export type ResearchDatasetCountOutputTypeCountRegionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
  }


  /**
   * Count Type MapCountOutputType
   */

  export type MapCountOutputType = {
    resources: number
    layers: number
    regions: number
    tags: number
  }

  export type MapCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resources?: boolean | MapCountOutputTypeCountResourcesArgs
    layers?: boolean | MapCountOutputTypeCountLayersArgs
    regions?: boolean | MapCountOutputTypeCountRegionsArgs
    tags?: boolean | MapCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * MapCountOutputType without action
   */
  export type MapCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapCountOutputType
     */
    select?: MapCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MapCountOutputType without action
   */
  export type MapCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatasetResourceWhereInput
  }

  /**
   * MapCountOutputType without action
   */
  export type MapCountOutputTypeCountLayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapLayerAssociationWhereInput
  }

  /**
   * MapCountOutputType without action
   */
  export type MapCountOutputTypeCountRegionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
  }

  /**
   * MapCountOutputType without action
   */
  export type MapCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }


  /**
   * Count Type LayerCountOutputType
   */

  export type LayerCountOutputType = {
    maps: number
    regions: number
    tags: number
  }

  export type LayerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maps?: boolean | LayerCountOutputTypeCountMapsArgs
    regions?: boolean | LayerCountOutputTypeCountRegionsArgs
    tags?: boolean | LayerCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * LayerCountOutputType without action
   */
  export type LayerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LayerCountOutputType
     */
    select?: LayerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LayerCountOutputType without action
   */
  export type LayerCountOutputTypeCountMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapLayerAssociationWhereInput
  }

  /**
   * LayerCountOutputType without action
   */
  export type LayerCountOutputTypeCountRegionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
  }

  /**
   * LayerCountOutputType without action
   */
  export type LayerCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }


  /**
   * Count Type CollectionCountOutputType
   */

  export type CollectionCountOutputType = {
    series: number
    regions: number
    tags: number
  }

  export type CollectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | CollectionCountOutputTypeCountSeriesArgs
    regions?: boolean | CollectionCountOutputTypeCountRegionsArgs
    tags?: boolean | CollectionCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CollectionCountOutputType
     */
    select?: CollectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountSeriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeriesWhereInput
  }

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountRegionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
  }

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }


  /**
   * Count Type SeriesCountOutputType
   */

  export type SeriesCountOutputType = {
    volumes: number
    categories: number
    regions: number
    tags: number
  }

  export type SeriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    volumes?: boolean | SeriesCountOutputTypeCountVolumesArgs
    categories?: boolean | SeriesCountOutputTypeCountCategoriesArgs
    regions?: boolean | SeriesCountOutputTypeCountRegionsArgs
    tags?: boolean | SeriesCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * SeriesCountOutputType without action
   */
  export type SeriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesCountOutputType
     */
    select?: SeriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeriesCountOutputType without action
   */
  export type SeriesCountOutputTypeCountVolumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VolumeWhereInput
  }

  /**
   * SeriesCountOutputType without action
   */
  export type SeriesCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * SeriesCountOutputType without action
   */
  export type SeriesCountOutputTypeCountRegionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
  }

  /**
   * SeriesCountOutputType without action
   */
  export type SeriesCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }


  /**
   * Count Type VolumeCountOutputType
   */

  export type VolumeCountOutputType = {
    pages: number
    regions: number
  }

  export type VolumeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pages?: boolean | VolumeCountOutputTypeCountPagesArgs
    regions?: boolean | VolumeCountOutputTypeCountRegionsArgs
  }

  // Custom InputTypes
  /**
   * VolumeCountOutputType without action
   */
  export type VolumeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumeCountOutputType
     */
    select?: VolumeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VolumeCountOutputType without action
   */
  export type VolumeCountOutputTypeCountPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VolumePageWhereInput
  }

  /**
   * VolumeCountOutputType without action
   */
  export type VolumeCountOutputTypeCountRegionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
  }


  /**
   * Count Type VolumePageCountOutputType
   */

  export type VolumePageCountOutputType = {
    images: number
    texts: number
    artifacts: number
  }

  export type VolumePageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | VolumePageCountOutputTypeCountImagesArgs
    texts?: boolean | VolumePageCountOutputTypeCountTextsArgs
    artifacts?: boolean | VolumePageCountOutputTypeCountArtifactsArgs
  }

  // Custom InputTypes
  /**
   * VolumePageCountOutputType without action
   */
  export type VolumePageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumePageCountOutputType
     */
    select?: VolumePageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VolumePageCountOutputType without action
   */
  export type VolumePageCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageImageWhereInput
  }

  /**
   * VolumePageCountOutputType without action
   */
  export type VolumePageCountOutputTypeCountTextsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageTextWhereInput
  }

  /**
   * VolumePageCountOutputType without action
   */
  export type VolumePageCountOutputTypeCountArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtifactWhereInput
  }


  /**
   * Count Type ArtifactCountOutputType
   */

  export type ArtifactCountOutputType = {
    periods: number
    places: number
    regions: number
    tags: number
    pages: number
  }

  export type ArtifactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    periods?: boolean | ArtifactCountOutputTypeCountPeriodsArgs
    places?: boolean | ArtifactCountOutputTypeCountPlacesArgs
    regions?: boolean | ArtifactCountOutputTypeCountRegionsArgs
    tags?: boolean | ArtifactCountOutputTypeCountTagsArgs
    pages?: boolean | ArtifactCountOutputTypeCountPagesArgs
  }

  // Custom InputTypes
  /**
   * ArtifactCountOutputType without action
   */
  export type ArtifactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactCountOutputType
     */
    select?: ArtifactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ArtifactCountOutputType without action
   */
  export type ArtifactCountOutputTypeCountPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PeriodWhereInput
  }

  /**
   * ArtifactCountOutputType without action
   */
  export type ArtifactCountOutputTypeCountPlacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceWhereInput
  }

  /**
   * ArtifactCountOutputType without action
   */
  export type ArtifactCountOutputTypeCountRegionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
  }

  /**
   * ArtifactCountOutputType without action
   */
  export type ArtifactCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * ArtifactCountOutputType without action
   */
  export type ArtifactCountOutputTypeCountPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VolumePageWhereInput
  }


  /**
   * Count Type StorageFileCountOutputType
   */

  export type StorageFileCountOutputType = {
    media: number
    pageImages: number
  }

  export type StorageFileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | StorageFileCountOutputTypeCountMediaArgs
    pageImages?: boolean | StorageFileCountOutputTypeCountPageImagesArgs
  }

  // Custom InputTypes
  /**
   * StorageFileCountOutputType without action
   */
  export type StorageFileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageFileCountOutputType
     */
    select?: StorageFileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StorageFileCountOutputType without action
   */
  export type StorageFileCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }

  /**
   * StorageFileCountOutputType without action
   */
  export type StorageFileCountOutputTypeCountPageImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageImageWhereInput
  }


  /**
   * Count Type MediaCountOutputType
   */

  export type MediaCountOutputType = {
    thumbnailForCategory: number
    thumbnailForCollections: number
    thumbnailForMaps: number
    thumbnailForPages: number
    thumbnailForPosts: number
    thumbnailForDataset: number
    thumbnailForSeries: number
    thumbnailForVolumes: number
  }

  export type MediaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thumbnailForCategory?: boolean | MediaCountOutputTypeCountThumbnailForCategoryArgs
    thumbnailForCollections?: boolean | MediaCountOutputTypeCountThumbnailForCollectionsArgs
    thumbnailForMaps?: boolean | MediaCountOutputTypeCountThumbnailForMapsArgs
    thumbnailForPages?: boolean | MediaCountOutputTypeCountThumbnailForPagesArgs
    thumbnailForPosts?: boolean | MediaCountOutputTypeCountThumbnailForPostsArgs
    thumbnailForDataset?: boolean | MediaCountOutputTypeCountThumbnailForDatasetArgs
    thumbnailForSeries?: boolean | MediaCountOutputTypeCountThumbnailForSeriesArgs
    thumbnailForVolumes?: boolean | MediaCountOutputTypeCountThumbnailForVolumesArgs
  }

  // Custom InputTypes
  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCountOutputType
     */
    select?: MediaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountThumbnailForCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountThumbnailForCollectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountThumbnailForMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountThumbnailForPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountThumbnailForPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountThumbnailForDatasetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchDatasetWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountThumbnailForSeriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeriesWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountThumbnailForVolumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VolumeWhereInput
  }


  /**
   * Count Type PlaceCountOutputType
   */

  export type PlaceCountOutputType = {
    administrativePlaces: number
    artifacts: number
  }

  export type PlaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    administrativePlaces?: boolean | PlaceCountOutputTypeCountAdministrativePlacesArgs
    artifacts?: boolean | PlaceCountOutputTypeCountArtifactsArgs
  }

  // Custom InputTypes
  /**
   * PlaceCountOutputType without action
   */
  export type PlaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaceCountOutputType
     */
    select?: PlaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlaceCountOutputType without action
   */
  export type PlaceCountOutputTypeCountAdministrativePlacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdministrativePlaceWhereInput
  }

  /**
   * PlaceCountOutputType without action
   */
  export type PlaceCountOutputTypeCountArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtifactWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    posts: number
    artifacts: number
    collections: number
    layers: number
    maps: number
    pages: number
    series: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | TagCountOutputTypeCountPostsArgs
    artifacts?: boolean | TagCountOutputTypeCountArtifactsArgs
    collections?: boolean | TagCountOutputTypeCountCollectionsArgs
    layers?: boolean | TagCountOutputTypeCountLayersArgs
    maps?: boolean | TagCountOutputTypeCountMapsArgs
    pages?: boolean | TagCountOutputTypeCountPagesArgs
    series?: boolean | TagCountOutputTypeCountSeriesArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostTagWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtifactWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountCollectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountLayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LayerWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountSeriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeriesWhereInput
  }


  /**
   * Count Type RegionCountOutputType
   */

  export type RegionCountOutputType = {
    artifacts: number
    collections: number
    layers: number
    maps: number
    pages: number
    posts: number
    datasets: number
    series: number
    volumes: number
  }

  export type RegionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifacts?: boolean | RegionCountOutputTypeCountArtifactsArgs
    collections?: boolean | RegionCountOutputTypeCountCollectionsArgs
    layers?: boolean | RegionCountOutputTypeCountLayersArgs
    maps?: boolean | RegionCountOutputTypeCountMapsArgs
    pages?: boolean | RegionCountOutputTypeCountPagesArgs
    posts?: boolean | RegionCountOutputTypeCountPostsArgs
    datasets?: boolean | RegionCountOutputTypeCountDatasetsArgs
    series?: boolean | RegionCountOutputTypeCountSeriesArgs
    volumes?: boolean | RegionCountOutputTypeCountVolumesArgs
  }

  // Custom InputTypes
  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCountOutputType
     */
    select?: RegionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtifactWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountCollectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountLayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LayerWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountDatasetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchDatasetWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountSeriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeriesWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountVolumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VolumeWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    layers: number
    maps: number
    datasets: number
    posts: number
    series: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    layers?: boolean | CategoryCountOutputTypeCountLayersArgs
    maps?: boolean | CategoryCountOutputTypeCountMapsArgs
    datasets?: boolean | CategoryCountOutputTypeCountDatasetsArgs
    posts?: boolean | CategoryCountOutputTypeCountPostsArgs
    series?: boolean | CategoryCountOutputTypeCountSeriesArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountLayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LayerWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountDatasetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchDatasetWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountSeriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeriesWhereInput
  }


  /**
   * Count Type ArtifactCategoryCountOutputType
   */

  export type ArtifactCategoryCountOutputType = {
    artifacts: number
  }

  export type ArtifactCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifacts?: boolean | ArtifactCategoryCountOutputTypeCountArtifactsArgs
  }

  // Custom InputTypes
  /**
   * ArtifactCategoryCountOutputType without action
   */
  export type ArtifactCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactCategoryCountOutputType
     */
    select?: ArtifactCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ArtifactCategoryCountOutputType without action
   */
  export type ArtifactCategoryCountOutputTypeCountArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtifactWhereInput
  }


  /**
   * Count Type PeriodCountOutputType
   */

  export type PeriodCountOutputType = {
    artifacts: number
  }

  export type PeriodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifacts?: boolean | PeriodCountOutputTypeCountArtifactsArgs
  }

  // Custom InputTypes
  /**
   * PeriodCountOutputType without action
   */
  export type PeriodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodCountOutputType
     */
    select?: PeriodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PeriodCountOutputType without action
   */
  export type PeriodCountOutputTypeCountArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtifactWhereInput
  }


  /**
   * Count Type MenuCountOutputType
   */

  export type MenuCountOutputType = {
    items: number
  }

  export type MenuCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | MenuCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * MenuCountOutputType without action
   */
  export type MenuCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuCountOutputType
     */
    select?: MenuCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MenuCountOutputType without action
   */
  export type MenuCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuItemWhereInput
  }


  /**
   * Count Type MenuItemCountOutputType
   */

  export type MenuItemCountOutputType = {
    children: number
  }

  export type MenuItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | MenuItemCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes
  /**
   * MenuItemCountOutputType without action
   */
  export type MenuItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItemCountOutputType
     */
    select?: MenuItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MenuItemCountOutputType without action
   */
  export type MenuItemCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuItemWhereInput
  }


  /**
   * Count Type FooterColumnCountOutputType
   */

  export type FooterColumnCountOutputType = {
    items: number
  }

  export type FooterColumnCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | FooterColumnCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * FooterColumnCountOutputType without action
   */
  export type FooterColumnCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumnCountOutputType
     */
    select?: FooterColumnCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FooterColumnCountOutputType without action
   */
  export type FooterColumnCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FooterColumnItemWhereInput
  }


  /**
   * Count Type DocumentCountOutputType
   */

  export type DocumentCountOutputType = {
    pages: number
  }

  export type DocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pages?: boolean | DocumentCountOutputTypeCountPagesArgs
  }

  // Custom InputTypes
  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentCountOutputType
     */
    select?: DocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentPageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Page
   */

  export type AggregatePage = {
    _count: PageCountAggregateOutputType | null
    _avg: PageAvgAggregateOutputType | null
    _sum: PageSumAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  export type PageAvgAggregateOutputType = {
    menuOrder: number | null
  }

  export type PageSumAggregateOutputType = {
    menuOrder: number | null
  }

  export type PageMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    title: string | null
    slug: string | null
    content: string | null
    excerpt: string | null
    sources: string | null
    citations: string | null
    language: $Enums.AppLanguage | null
    translationGroupId: string | null
    status: $Enums.ContentStatus | null
    authorId: string | null
    parentId: string | null
    metaDescription: string | null
    metaKeywords: string | null
    thumbnailId: string | null
    template: string | null
    menuOrder: number | null
    showInMenu: boolean | null
  }

  export type PageMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    title: string | null
    slug: string | null
    content: string | null
    excerpt: string | null
    sources: string | null
    citations: string | null
    language: $Enums.AppLanguage | null
    translationGroupId: string | null
    status: $Enums.ContentStatus | null
    authorId: string | null
    parentId: string | null
    metaDescription: string | null
    metaKeywords: string | null
    thumbnailId: string | null
    template: string | null
    menuOrder: number | null
    showInMenu: boolean | null
  }

  export type PageCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    title: number
    slug: number
    content: number
    excerpt: number
    sources: number
    citations: number
    language: number
    translationGroupId: number
    status: number
    authorId: number
    parentId: number
    metaDescription: number
    metaKeywords: number
    thumbnailId: number
    template: number
    menuOrder: number
    showInMenu: number
    _all: number
  }


  export type PageAvgAggregateInputType = {
    menuOrder?: true
  }

  export type PageSumAggregateInputType = {
    menuOrder?: true
  }

  export type PageMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    sources?: true
    citations?: true
    language?: true
    translationGroupId?: true
    status?: true
    authorId?: true
    parentId?: true
    metaDescription?: true
    metaKeywords?: true
    thumbnailId?: true
    template?: true
    menuOrder?: true
    showInMenu?: true
  }

  export type PageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    sources?: true
    citations?: true
    language?: true
    translationGroupId?: true
    status?: true
    authorId?: true
    parentId?: true
    metaDescription?: true
    metaKeywords?: true
    thumbnailId?: true
    template?: true
    menuOrder?: true
    showInMenu?: true
  }

  export type PageCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    slug?: true
    content?: true
    excerpt?: true
    sources?: true
    citations?: true
    language?: true
    translationGroupId?: true
    status?: true
    authorId?: true
    parentId?: true
    metaDescription?: true
    metaKeywords?: true
    thumbnailId?: true
    template?: true
    menuOrder?: true
    showInMenu?: true
    _all?: true
  }

  export type PageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Page to aggregate.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pages
    **/
    _count?: true | PageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PageMaxAggregateInputType
  }

  export type GetPageAggregateType<T extends PageAggregateArgs> = {
        [P in keyof T & keyof AggregatePage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePage[P]>
      : GetScalarType<T[P], AggregatePage[P]>
  }




  export type PageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
    orderBy?: PageOrderByWithAggregationInput | PageOrderByWithAggregationInput[]
    by: PageScalarFieldEnum[] | PageScalarFieldEnum
    having?: PageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageCountAggregateInputType | true
    _avg?: PageAvgAggregateInputType
    _sum?: PageSumAggregateInputType
    _min?: PageMinAggregateInputType
    _max?: PageMaxAggregateInputType
  }

  export type PageGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    title: string
    slug: string
    content: string | null
    excerpt: string | null
    sources: string | null
    citations: string | null
    language: $Enums.AppLanguage
    translationGroupId: string | null
    status: $Enums.ContentStatus
    authorId: string | null
    parentId: string | null
    metaDescription: string | null
    metaKeywords: string | null
    thumbnailId: string | null
    template: string | null
    menuOrder: number
    showInMenu: boolean
    _count: PageCountAggregateOutputType | null
    _avg: PageAvgAggregateOutputType | null
    _sum: PageSumAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  type GetPageGroupByPayload<T extends PageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PageGroupByOutputType[P]>
            : GetScalarType<T[P], PageGroupByOutputType[P]>
        }
      >
    >


  export type PageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    sources?: boolean
    citations?: boolean
    language?: boolean
    translationGroupId?: boolean
    status?: boolean
    authorId?: boolean
    parentId?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    thumbnailId?: boolean
    template?: boolean
    menuOrder?: boolean
    showInMenu?: boolean
    author?: boolean | Page$authorArgs<ExtArgs>
    parent?: boolean | Page$parentArgs<ExtArgs>
    children?: boolean | Page$childrenArgs<ExtArgs>
    thumbnail?: boolean | Page$thumbnailArgs<ExtArgs>
    regions?: boolean | Page$regionsArgs<ExtArgs>
    tags?: boolean | Page$tagsArgs<ExtArgs>
    menuItems?: boolean | Page$menuItemsArgs<ExtArgs>
    footerItems?: boolean | Page$footerItemsArgs<ExtArgs>
    _count?: boolean | PageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["page"]>

  export type PageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    sources?: boolean
    citations?: boolean
    language?: boolean
    translationGroupId?: boolean
    status?: boolean
    authorId?: boolean
    parentId?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    thumbnailId?: boolean
    template?: boolean
    menuOrder?: boolean
    showInMenu?: boolean
    author?: boolean | Page$authorArgs<ExtArgs>
    parent?: boolean | Page$parentArgs<ExtArgs>
    thumbnail?: boolean | Page$thumbnailArgs<ExtArgs>
  }, ExtArgs["result"]["page"]>

  export type PageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    sources?: boolean
    citations?: boolean
    language?: boolean
    translationGroupId?: boolean
    status?: boolean
    authorId?: boolean
    parentId?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    thumbnailId?: boolean
    template?: boolean
    menuOrder?: boolean
    showInMenu?: boolean
    author?: boolean | Page$authorArgs<ExtArgs>
    parent?: boolean | Page$parentArgs<ExtArgs>
    thumbnail?: boolean | Page$thumbnailArgs<ExtArgs>
  }, ExtArgs["result"]["page"]>

  export type PageSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    excerpt?: boolean
    sources?: boolean
    citations?: boolean
    language?: boolean
    translationGroupId?: boolean
    status?: boolean
    authorId?: boolean
    parentId?: boolean
    metaDescription?: boolean
    metaKeywords?: boolean
    thumbnailId?: boolean
    template?: boolean
    menuOrder?: boolean
    showInMenu?: boolean
  }

  export type PageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "title" | "slug" | "content" | "excerpt" | "sources" | "citations" | "language" | "translationGroupId" | "status" | "authorId" | "parentId" | "metaDescription" | "metaKeywords" | "thumbnailId" | "template" | "menuOrder" | "showInMenu", ExtArgs["result"]["page"]>
  export type PageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | Page$authorArgs<ExtArgs>
    parent?: boolean | Page$parentArgs<ExtArgs>
    children?: boolean | Page$childrenArgs<ExtArgs>
    thumbnail?: boolean | Page$thumbnailArgs<ExtArgs>
    regions?: boolean | Page$regionsArgs<ExtArgs>
    tags?: boolean | Page$tagsArgs<ExtArgs>
    menuItems?: boolean | Page$menuItemsArgs<ExtArgs>
    footerItems?: boolean | Page$footerItemsArgs<ExtArgs>
    _count?: boolean | PageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | Page$authorArgs<ExtArgs>
    parent?: boolean | Page$parentArgs<ExtArgs>
    thumbnail?: boolean | Page$thumbnailArgs<ExtArgs>
  }
  export type PageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | Page$authorArgs<ExtArgs>
    parent?: boolean | Page$parentArgs<ExtArgs>
    thumbnail?: boolean | Page$thumbnailArgs<ExtArgs>
  }

  export type $PagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Page"
    objects: {
      author: Prisma.$UserPayload<ExtArgs> | null
      parent: Prisma.$PagePayload<ExtArgs> | null
      children: Prisma.$PagePayload<ExtArgs>[]
      thumbnail: Prisma.$MediaPayload<ExtArgs> | null
      regions: Prisma.$RegionPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      menuItems: Prisma.$MenuItemPayload<ExtArgs>[]
      footerItems: Prisma.$FooterColumnItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      title: string
      slug: string
      content: string | null
      excerpt: string | null
      sources: string | null
      citations: string | null
      language: $Enums.AppLanguage
      translationGroupId: string | null
      status: $Enums.ContentStatus
      authorId: string | null
      parentId: string | null
      metaDescription: string | null
      metaKeywords: string | null
      thumbnailId: string | null
      template: string | null
      menuOrder: number
      showInMenu: boolean
    }, ExtArgs["result"]["page"]>
    composites: {}
  }

  type PageGetPayload<S extends boolean | null | undefined | PageDefaultArgs> = $Result.GetResult<Prisma.$PagePayload, S>

  type PageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PageCountAggregateInputType | true
    }

  export interface PageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Page'], meta: { name: 'Page' } }
    /**
     * Find zero or one Page that matches the filter.
     * @param {PageFindUniqueArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PageFindUniqueArgs>(args: SelectSubset<T, PageFindUniqueArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Page that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PageFindUniqueOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PageFindUniqueOrThrowArgs>(args: SelectSubset<T, PageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Page that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PageFindFirstArgs>(args?: SelectSubset<T, PageFindFirstArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Page that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PageFindFirstOrThrowArgs>(args?: SelectSubset<T, PageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pages
     * const pages = await prisma.page.findMany()
     * 
     * // Get first 10 Pages
     * const pages = await prisma.page.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pageWithIdOnly = await prisma.page.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PageFindManyArgs>(args?: SelectSubset<T, PageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Page.
     * @param {PageCreateArgs} args - Arguments to create a Page.
     * @example
     * // Create one Page
     * const Page = await prisma.page.create({
     *   data: {
     *     // ... data to create a Page
     *   }
     * })
     * 
     */
    create<T extends PageCreateArgs>(args: SelectSubset<T, PageCreateArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pages.
     * @param {PageCreateManyArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const page = await prisma.page.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PageCreateManyArgs>(args?: SelectSubset<T, PageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pages and returns the data saved in the database.
     * @param {PageCreateManyAndReturnArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const page = await prisma.page.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pages and only return the `id`
     * const pageWithIdOnly = await prisma.page.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PageCreateManyAndReturnArgs>(args?: SelectSubset<T, PageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Page.
     * @param {PageDeleteArgs} args - Arguments to delete one Page.
     * @example
     * // Delete one Page
     * const Page = await prisma.page.delete({
     *   where: {
     *     // ... filter to delete one Page
     *   }
     * })
     * 
     */
    delete<T extends PageDeleteArgs>(args: SelectSubset<T, PageDeleteArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Page.
     * @param {PageUpdateArgs} args - Arguments to update one Page.
     * @example
     * // Update one Page
     * const page = await prisma.page.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PageUpdateArgs>(args: SelectSubset<T, PageUpdateArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pages.
     * @param {PageDeleteManyArgs} args - Arguments to filter Pages to delete.
     * @example
     * // Delete a few Pages
     * const { count } = await prisma.page.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PageDeleteManyArgs>(args?: SelectSubset<T, PageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pages
     * const page = await prisma.page.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PageUpdateManyArgs>(args: SelectSubset<T, PageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages and returns the data updated in the database.
     * @param {PageUpdateManyAndReturnArgs} args - Arguments to update many Pages.
     * @example
     * // Update many Pages
     * const page = await prisma.page.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pages and only return the `id`
     * const pageWithIdOnly = await prisma.page.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PageUpdateManyAndReturnArgs>(args: SelectSubset<T, PageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Page.
     * @param {PageUpsertArgs} args - Arguments to update or create a Page.
     * @example
     * // Update or create a Page
     * const page = await prisma.page.upsert({
     *   create: {
     *     // ... data to create a Page
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Page we want to update
     *   }
     * })
     */
    upsert<T extends PageUpsertArgs>(args: SelectSubset<T, PageUpsertArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageCountArgs} args - Arguments to filter Pages to count.
     * @example
     * // Count the number of Pages
     * const count = await prisma.page.count({
     *   where: {
     *     // ... the filter for the Pages we want to count
     *   }
     * })
    **/
    count<T extends PageCountArgs>(
      args?: Subset<T, PageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PageAggregateArgs>(args: Subset<T, PageAggregateArgs>): Prisma.PrismaPromise<GetPageAggregateType<T>>

    /**
     * Group by Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageGroupByArgs['orderBy'] }
        : { orderBy?: PageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Page model
   */
  readonly fields: PageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Page.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends Page$authorArgs<ExtArgs> = {}>(args?: Subset<T, Page$authorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parent<T extends Page$parentArgs<ExtArgs> = {}>(args?: Subset<T, Page$parentArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Page$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Page$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    thumbnail<T extends Page$thumbnailArgs<ExtArgs> = {}>(args?: Subset<T, Page$thumbnailArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    regions<T extends Page$regionsArgs<ExtArgs> = {}>(args?: Subset<T, Page$regionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Page$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Page$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    menuItems<T extends Page$menuItemsArgs<ExtArgs> = {}>(args?: Subset<T, Page$menuItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    footerItems<T extends Page$footerItemsArgs<ExtArgs> = {}>(args?: Subset<T, Page$footerItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FooterColumnItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Page model
   */
  interface PageFieldRefs {
    readonly id: FieldRef<"Page", 'String'>
    readonly createdAt: FieldRef<"Page", 'DateTime'>
    readonly updatedAt: FieldRef<"Page", 'DateTime'>
    readonly title: FieldRef<"Page", 'String'>
    readonly slug: FieldRef<"Page", 'String'>
    readonly content: FieldRef<"Page", 'String'>
    readonly excerpt: FieldRef<"Page", 'String'>
    readonly sources: FieldRef<"Page", 'String'>
    readonly citations: FieldRef<"Page", 'String'>
    readonly language: FieldRef<"Page", 'AppLanguage'>
    readonly translationGroupId: FieldRef<"Page", 'String'>
    readonly status: FieldRef<"Page", 'ContentStatus'>
    readonly authorId: FieldRef<"Page", 'String'>
    readonly parentId: FieldRef<"Page", 'String'>
    readonly metaDescription: FieldRef<"Page", 'String'>
    readonly metaKeywords: FieldRef<"Page", 'String'>
    readonly thumbnailId: FieldRef<"Page", 'String'>
    readonly template: FieldRef<"Page", 'String'>
    readonly menuOrder: FieldRef<"Page", 'Int'>
    readonly showInMenu: FieldRef<"Page", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Page findUnique
   */
  export type PageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page findUniqueOrThrow
   */
  export type PageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page findFirst
   */
  export type PageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page findFirstOrThrow
   */
  export type PageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page findMany
   */
  export type PageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Pages to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page create
   */
  export type PageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The data needed to create a Page.
     */
    data: XOR<PageCreateInput, PageUncheckedCreateInput>
  }

  /**
   * Page createMany
   */
  export type PageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pages.
     */
    data: PageCreateManyInput | PageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Page createManyAndReturn
   */
  export type PageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * The data used to create many Pages.
     */
    data: PageCreateManyInput | PageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Page update
   */
  export type PageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The data needed to update a Page.
     */
    data: XOR<PageUpdateInput, PageUncheckedUpdateInput>
    /**
     * Choose, which Page to update.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page updateMany
   */
  export type PageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pages.
     */
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyInput>
    /**
     * Filter which Pages to update
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to update.
     */
    limit?: number
  }

  /**
   * Page updateManyAndReturn
   */
  export type PageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * The data used to update Pages.
     */
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyInput>
    /**
     * Filter which Pages to update
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Page upsert
   */
  export type PageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The filter to search for the Page to update in case it exists.
     */
    where: PageWhereUniqueInput
    /**
     * In case the Page found by the `where` argument doesn't exist, create a new Page with this data.
     */
    create: XOR<PageCreateInput, PageUncheckedCreateInput>
    /**
     * In case the Page was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageUpdateInput, PageUncheckedUpdateInput>
  }

  /**
   * Page delete
   */
  export type PageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter which Page to delete.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page deleteMany
   */
  export type PageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pages to delete
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to delete.
     */
    limit?: number
  }

  /**
   * Page.author
   */
  export type Page$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Page.parent
   */
  export type Page$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    where?: PageWhereInput
  }

  /**
   * Page.children
   */
  export type Page$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    where?: PageWhereInput
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    cursor?: PageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page.thumbnail
   */
  export type Page$thumbnailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Page.regions
   */
  export type Page$regionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    cursor?: RegionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Page.tags
   */
  export type Page$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Page.menuItems
   */
  export type Page$menuItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    where?: MenuItemWhereInput
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    cursor?: MenuItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * Page.footerItems
   */
  export type Page$footerItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumnItem
     */
    select?: FooterColumnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumnItem
     */
    omit?: FooterColumnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnItemInclude<ExtArgs> | null
    where?: FooterColumnItemWhereInput
    orderBy?: FooterColumnItemOrderByWithRelationInput | FooterColumnItemOrderByWithRelationInput[]
    cursor?: FooterColumnItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FooterColumnItemScalarFieldEnum | FooterColumnItemScalarFieldEnum[]
  }

  /**
   * Page without action
   */
  export type PageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    translationGroupId: string | null
    language: $Enums.AppLanguage | null
    title: string | null
    slug: string | null
    content: string | null
    sources: string | null
    excerpt: string | null
    status: $Enums.ContentStatus | null
    authorId: string | null
    thumbnailId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    translationGroupId: string | null
    language: $Enums.AppLanguage | null
    title: string | null
    slug: string | null
    content: string | null
    sources: string | null
    excerpt: string | null
    status: $Enums.ContentStatus | null
    authorId: string | null
    thumbnailId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    translationGroupId: number
    language: number
    title: number
    slug: number
    content: number
    sources: number
    excerpt: number
    status: number
    authorId: number
    thumbnailId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostMinAggregateInputType = {
    id?: true
    translationGroupId?: true
    language?: true
    title?: true
    slug?: true
    content?: true
    sources?: true
    excerpt?: true
    status?: true
    authorId?: true
    thumbnailId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    translationGroupId?: true
    language?: true
    title?: true
    slug?: true
    content?: true
    sources?: true
    excerpt?: true
    status?: true
    authorId?: true
    thumbnailId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    translationGroupId?: true
    language?: true
    title?: true
    slug?: true
    content?: true
    sources?: true
    excerpt?: true
    status?: true
    authorId?: true
    thumbnailId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    translationGroupId: string
    language: $Enums.AppLanguage
    title: string
    slug: string
    content: string | null
    sources: string | null
    excerpt: string | null
    status: $Enums.ContentStatus
    authorId: string | null
    thumbnailId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    translationGroupId?: boolean
    language?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    sources?: boolean
    excerpt?: boolean
    status?: boolean
    authorId?: boolean
    thumbnailId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tags?: boolean | Post$tagsArgs<ExtArgs>
    author?: boolean | Post$authorArgs<ExtArgs>
    thumbnail?: boolean | Post$thumbnailArgs<ExtArgs>
    categories?: boolean | Post$categoriesArgs<ExtArgs>
    regions?: boolean | Post$regionsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    translationGroupId?: boolean
    language?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    sources?: boolean
    excerpt?: boolean
    status?: boolean
    authorId?: boolean
    thumbnailId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | Post$authorArgs<ExtArgs>
    thumbnail?: boolean | Post$thumbnailArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    translationGroupId?: boolean
    language?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    sources?: boolean
    excerpt?: boolean
    status?: boolean
    authorId?: boolean
    thumbnailId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | Post$authorArgs<ExtArgs>
    thumbnail?: boolean | Post$thumbnailArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    translationGroupId?: boolean
    language?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    sources?: boolean
    excerpt?: boolean
    status?: boolean
    authorId?: boolean
    thumbnailId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "translationGroupId" | "language" | "title" | "slug" | "content" | "sources" | "excerpt" | "status" | "authorId" | "thumbnailId" | "createdAt" | "updatedAt", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | Post$tagsArgs<ExtArgs>
    author?: boolean | Post$authorArgs<ExtArgs>
    thumbnail?: boolean | Post$thumbnailArgs<ExtArgs>
    categories?: boolean | Post$categoriesArgs<ExtArgs>
    regions?: boolean | Post$regionsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | Post$authorArgs<ExtArgs>
    thumbnail?: boolean | Post$thumbnailArgs<ExtArgs>
  }
  export type PostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | Post$authorArgs<ExtArgs>
    thumbnail?: boolean | Post$thumbnailArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      tags: Prisma.$PostTagPayload<ExtArgs>[]
      author: Prisma.$UserPayload<ExtArgs> | null
      thumbnail: Prisma.$MediaPayload<ExtArgs> | null
      categories: Prisma.$CategoryPayload<ExtArgs>[]
      regions: Prisma.$RegionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      translationGroupId: string
      language: $Enums.AppLanguage
      title: string
      slug: string
      content: string | null
      sources: string | null
      excerpt: string | null
      status: $Enums.ContentStatus
      authorId: string | null
      thumbnailId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {PostUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostUpdateManyAndReturnArgs>(args: SelectSubset<T, PostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tags<T extends Post$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Post$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    author<T extends Post$authorArgs<ExtArgs> = {}>(args?: Subset<T, Post$authorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    thumbnail<T extends Post$thumbnailArgs<ExtArgs> = {}>(args?: Subset<T, Post$thumbnailArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    categories<T extends Post$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Post$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    regions<T extends Post$regionsArgs<ExtArgs> = {}>(args?: Subset<T, Post$regionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly translationGroupId: FieldRef<"Post", 'String'>
    readonly language: FieldRef<"Post", 'AppLanguage'>
    readonly title: FieldRef<"Post", 'String'>
    readonly slug: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly sources: FieldRef<"Post", 'String'>
    readonly excerpt: FieldRef<"Post", 'String'>
    readonly status: FieldRef<"Post", 'ContentStatus'>
    readonly authorId: FieldRef<"Post", 'String'>
    readonly thumbnailId: FieldRef<"Post", 'String'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post updateManyAndReturn
   */
  export type PostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post.tags
   */
  export type Post$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    where?: PostTagWhereInput
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    cursor?: PostTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * Post.author
   */
  export type Post$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Post.thumbnail
   */
  export type Post$thumbnailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Post.categories
   */
  export type Post$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Post.regions
   */
  export type Post$regionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    cursor?: RegionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model PostTag
   */

  export type AggregatePostTag = {
    _count: PostTagCountAggregateOutputType | null
    _min: PostTagMinAggregateOutputType | null
    _max: PostTagMaxAggregateOutputType | null
  }

  export type PostTagMinAggregateOutputType = {
    postId: string | null
    tagId: string | null
  }

  export type PostTagMaxAggregateOutputType = {
    postId: string | null
    tagId: string | null
  }

  export type PostTagCountAggregateOutputType = {
    postId: number
    tagId: number
    _all: number
  }


  export type PostTagMinAggregateInputType = {
    postId?: true
    tagId?: true
  }

  export type PostTagMaxAggregateInputType = {
    postId?: true
    tagId?: true
  }

  export type PostTagCountAggregateInputType = {
    postId?: true
    tagId?: true
    _all?: true
  }

  export type PostTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostTag to aggregate.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostTags
    **/
    _count?: true | PostTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostTagMaxAggregateInputType
  }

  export type GetPostTagAggregateType<T extends PostTagAggregateArgs> = {
        [P in keyof T & keyof AggregatePostTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostTag[P]>
      : GetScalarType<T[P], AggregatePostTag[P]>
  }




  export type PostTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostTagWhereInput
    orderBy?: PostTagOrderByWithAggregationInput | PostTagOrderByWithAggregationInput[]
    by: PostTagScalarFieldEnum[] | PostTagScalarFieldEnum
    having?: PostTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostTagCountAggregateInputType | true
    _min?: PostTagMinAggregateInputType
    _max?: PostTagMaxAggregateInputType
  }

  export type PostTagGroupByOutputType = {
    postId: string
    tagId: string
    _count: PostTagCountAggregateOutputType | null
    _min: PostTagMinAggregateOutputType | null
    _max: PostTagMaxAggregateOutputType | null
  }

  type GetPostTagGroupByPayload<T extends PostTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostTagGroupByOutputType[P]>
            : GetScalarType<T[P], PostTagGroupByOutputType[P]>
        }
      >
    >


  export type PostTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    tagId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postTag"]>

  export type PostTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    tagId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postTag"]>

  export type PostTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    tagId?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postTag"]>

  export type PostTagSelectScalar = {
    postId?: boolean
    tagId?: boolean
  }

  export type PostTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"postId" | "tagId", ExtArgs["result"]["postTag"]>
  export type PostTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type PostTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type PostTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $PostTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostTag"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      postId: string
      tagId: string
    }, ExtArgs["result"]["postTag"]>
    composites: {}
  }

  type PostTagGetPayload<S extends boolean | null | undefined | PostTagDefaultArgs> = $Result.GetResult<Prisma.$PostTagPayload, S>

  type PostTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostTagCountAggregateInputType | true
    }

  export interface PostTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostTag'], meta: { name: 'PostTag' } }
    /**
     * Find zero or one PostTag that matches the filter.
     * @param {PostTagFindUniqueArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostTagFindUniqueArgs>(args: SelectSubset<T, PostTagFindUniqueArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostTagFindUniqueOrThrowArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostTagFindUniqueOrThrowArgs>(args: SelectSubset<T, PostTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagFindFirstArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostTagFindFirstArgs>(args?: SelectSubset<T, PostTagFindFirstArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagFindFirstOrThrowArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostTagFindFirstOrThrowArgs>(args?: SelectSubset<T, PostTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostTags
     * const postTags = await prisma.postTag.findMany()
     * 
     * // Get first 10 PostTags
     * const postTags = await prisma.postTag.findMany({ take: 10 })
     * 
     * // Only select the `postId`
     * const postTagWithPostIdOnly = await prisma.postTag.findMany({ select: { postId: true } })
     * 
     */
    findMany<T extends PostTagFindManyArgs>(args?: SelectSubset<T, PostTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostTag.
     * @param {PostTagCreateArgs} args - Arguments to create a PostTag.
     * @example
     * // Create one PostTag
     * const PostTag = await prisma.postTag.create({
     *   data: {
     *     // ... data to create a PostTag
     *   }
     * })
     * 
     */
    create<T extends PostTagCreateArgs>(args: SelectSubset<T, PostTagCreateArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostTags.
     * @param {PostTagCreateManyArgs} args - Arguments to create many PostTags.
     * @example
     * // Create many PostTags
     * const postTag = await prisma.postTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostTagCreateManyArgs>(args?: SelectSubset<T, PostTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostTags and returns the data saved in the database.
     * @param {PostTagCreateManyAndReturnArgs} args - Arguments to create many PostTags.
     * @example
     * // Create many PostTags
     * const postTag = await prisma.postTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostTags and only return the `postId`
     * const postTagWithPostIdOnly = await prisma.postTag.createManyAndReturn({
     *   select: { postId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostTagCreateManyAndReturnArgs>(args?: SelectSubset<T, PostTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostTag.
     * @param {PostTagDeleteArgs} args - Arguments to delete one PostTag.
     * @example
     * // Delete one PostTag
     * const PostTag = await prisma.postTag.delete({
     *   where: {
     *     // ... filter to delete one PostTag
     *   }
     * })
     * 
     */
    delete<T extends PostTagDeleteArgs>(args: SelectSubset<T, PostTagDeleteArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostTag.
     * @param {PostTagUpdateArgs} args - Arguments to update one PostTag.
     * @example
     * // Update one PostTag
     * const postTag = await prisma.postTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostTagUpdateArgs>(args: SelectSubset<T, PostTagUpdateArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostTags.
     * @param {PostTagDeleteManyArgs} args - Arguments to filter PostTags to delete.
     * @example
     * // Delete a few PostTags
     * const { count } = await prisma.postTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostTagDeleteManyArgs>(args?: SelectSubset<T, PostTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostTags
     * const postTag = await prisma.postTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostTagUpdateManyArgs>(args: SelectSubset<T, PostTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostTags and returns the data updated in the database.
     * @param {PostTagUpdateManyAndReturnArgs} args - Arguments to update many PostTags.
     * @example
     * // Update many PostTags
     * const postTag = await prisma.postTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostTags and only return the `postId`
     * const postTagWithPostIdOnly = await prisma.postTag.updateManyAndReturn({
     *   select: { postId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostTagUpdateManyAndReturnArgs>(args: SelectSubset<T, PostTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostTag.
     * @param {PostTagUpsertArgs} args - Arguments to update or create a PostTag.
     * @example
     * // Update or create a PostTag
     * const postTag = await prisma.postTag.upsert({
     *   create: {
     *     // ... data to create a PostTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostTag we want to update
     *   }
     * })
     */
    upsert<T extends PostTagUpsertArgs>(args: SelectSubset<T, PostTagUpsertArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagCountArgs} args - Arguments to filter PostTags to count.
     * @example
     * // Count the number of PostTags
     * const count = await prisma.postTag.count({
     *   where: {
     *     // ... the filter for the PostTags we want to count
     *   }
     * })
    **/
    count<T extends PostTagCountArgs>(
      args?: Subset<T, PostTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostTagAggregateArgs>(args: Subset<T, PostTagAggregateArgs>): Prisma.PrismaPromise<GetPostTagAggregateType<T>>

    /**
     * Group by PostTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostTagGroupByArgs['orderBy'] }
        : { orderBy?: PostTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostTag model
   */
  readonly fields: PostTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostTag model
   */
  interface PostTagFieldRefs {
    readonly postId: FieldRef<"PostTag", 'String'>
    readonly tagId: FieldRef<"PostTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PostTag findUnique
   */
  export type PostTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag findUniqueOrThrow
   */
  export type PostTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag findFirst
   */
  export type PostTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostTags.
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostTags.
     */
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * PostTag findFirstOrThrow
   */
  export type PostTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostTags.
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostTags.
     */
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * PostTag findMany
   */
  export type PostTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTags to fetch.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostTags.
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * PostTag create
   */
  export type PostTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * The data needed to create a PostTag.
     */
    data: XOR<PostTagCreateInput, PostTagUncheckedCreateInput>
  }

  /**
   * PostTag createMany
   */
  export type PostTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostTags.
     */
    data: PostTagCreateManyInput | PostTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostTag createManyAndReturn
   */
  export type PostTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * The data used to create many PostTags.
     */
    data: PostTagCreateManyInput | PostTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostTag update
   */
  export type PostTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * The data needed to update a PostTag.
     */
    data: XOR<PostTagUpdateInput, PostTagUncheckedUpdateInput>
    /**
     * Choose, which PostTag to update.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag updateMany
   */
  export type PostTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostTags.
     */
    data: XOR<PostTagUpdateManyMutationInput, PostTagUncheckedUpdateManyInput>
    /**
     * Filter which PostTags to update
     */
    where?: PostTagWhereInput
    /**
     * Limit how many PostTags to update.
     */
    limit?: number
  }

  /**
   * PostTag updateManyAndReturn
   */
  export type PostTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * The data used to update PostTags.
     */
    data: XOR<PostTagUpdateManyMutationInput, PostTagUncheckedUpdateManyInput>
    /**
     * Filter which PostTags to update
     */
    where?: PostTagWhereInput
    /**
     * Limit how many PostTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostTag upsert
   */
  export type PostTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * The filter to search for the PostTag to update in case it exists.
     */
    where: PostTagWhereUniqueInput
    /**
     * In case the PostTag found by the `where` argument doesn't exist, create a new PostTag with this data.
     */
    create: XOR<PostTagCreateInput, PostTagUncheckedCreateInput>
    /**
     * In case the PostTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostTagUpdateInput, PostTagUncheckedUpdateInput>
  }

  /**
   * PostTag delete
   */
  export type PostTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter which PostTag to delete.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag deleteMany
   */
  export type PostTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostTags to delete
     */
    where?: PostTagWhereInput
    /**
     * Limit how many PostTags to delete.
     */
    limit?: number
  }

  /**
   * PostTag without action
   */
  export type PostTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    emailVerified: Date | null
    image: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    emailVerified: Date | null
    image: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    passwordHash: number
    role: number
    createdAt: number
    emailVerified: number
    image: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    emailVerified?: true
    image?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    emailVerified?: true
    image?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    passwordHash?: true
    role?: true
    createdAt?: true
    emailVerified?: true
    image?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    passwordHash: string | null
    role: $Enums.UserRole
    createdAt: Date
    emailVerified: Date | null
    image: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    emailVerified?: boolean
    image?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    pageTexts?: boolean | User$pageTextsArgs<ExtArgs>
    pages?: boolean | User$pagesArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    emailVerified?: boolean
    image?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    emailVerified?: boolean
    image?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    passwordHash?: boolean
    role?: boolean
    createdAt?: boolean
    emailVerified?: boolean
    image?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "passwordHash" | "role" | "createdAt" | "emailVerified" | "image", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    pageTexts?: boolean | User$pageTextsArgs<ExtArgs>
    pages?: boolean | User$pagesArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      pageTexts: Prisma.$PageTextPayload<ExtArgs>[]
      pages: Prisma.$PagePayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      passwordHash: string | null
      role: $Enums.UserRole
      createdAt: Date
      emailVerified: Date | null
      image: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pageTexts<T extends User$pageTextsArgs<ExtArgs> = {}>(args?: Subset<T, User$pageTextsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageTextPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pages<T extends User$pagesArgs<ExtArgs> = {}>(args?: Subset<T, User$pagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends User$postsArgs<ExtArgs> = {}>(args?: Subset<T, User$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.pageTexts
   */
  export type User$pageTextsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageText
     */
    select?: PageTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageText
     */
    omit?: PageTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTextInclude<ExtArgs> | null
    where?: PageTextWhereInput
    orderBy?: PageTextOrderByWithRelationInput | PageTextOrderByWithRelationInput[]
    cursor?: PageTextWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageTextScalarFieldEnum | PageTextScalarFieldEnum[]
  }

  /**
   * User.pages
   */
  export type User$pagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    where?: PageWhereInput
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    cursor?: PageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * User.posts
   */
  export type User$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model ResearchDataset
   */

  export type AggregateResearchDataset = {
    _count: ResearchDatasetCountAggregateOutputType | null
    _avg: ResearchDatasetAvgAggregateOutputType | null
    _sum: ResearchDatasetSumAggregateOutputType | null
    _min: ResearchDatasetMinAggregateOutputType | null
    _max: ResearchDatasetMaxAggregateOutputType | null
  }

  export type ResearchDatasetAvgAggregateOutputType = {
    maxYear: number | null
    minYear: number | null
  }

  export type ResearchDatasetSumAggregateOutputType = {
    maxYear: number | null
    minYear: number | null
  }

  export type ResearchDatasetMinAggregateOutputType = {
    id: string | null
    slug: string | null
    status: $Enums.ContentStatus | null
    maturity: $Enums.DataMaturity | null
    version: string | null
    license: string | null
    thumbnailId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    title: string | null
    categoryId: string | null
    citationText: string | null
    codebookText: string | null
    maxYear: number | null
    minYear: number | null
    sources: string | null
    isVisible: boolean | null
  }

  export type ResearchDatasetMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    status: $Enums.ContentStatus | null
    maturity: $Enums.DataMaturity | null
    version: string | null
    license: string | null
    thumbnailId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    title: string | null
    categoryId: string | null
    citationText: string | null
    codebookText: string | null
    maxYear: number | null
    minYear: number | null
    sources: string | null
    isVisible: boolean | null
  }

  export type ResearchDatasetCountAggregateOutputType = {
    id: number
    slug: number
    titleI18n: number
    codebookTextI18n: number
    status: number
    maturity: number
    version: number
    license: number
    thumbnailId: number
    createdAt: number
    updatedAt: number
    description: number
    title: number
    categoryId: number
    citationText: number
    codebookText: number
    maxYear: number
    minYear: number
    sources: number
    isVisible: number
    sourcesI18n: number
    descriptionI18n: number
    _all: number
  }


  export type ResearchDatasetAvgAggregateInputType = {
    maxYear?: true
    minYear?: true
  }

  export type ResearchDatasetSumAggregateInputType = {
    maxYear?: true
    minYear?: true
  }

  export type ResearchDatasetMinAggregateInputType = {
    id?: true
    slug?: true
    status?: true
    maturity?: true
    version?: true
    license?: true
    thumbnailId?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    title?: true
    categoryId?: true
    citationText?: true
    codebookText?: true
    maxYear?: true
    minYear?: true
    sources?: true
    isVisible?: true
  }

  export type ResearchDatasetMaxAggregateInputType = {
    id?: true
    slug?: true
    status?: true
    maturity?: true
    version?: true
    license?: true
    thumbnailId?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    title?: true
    categoryId?: true
    citationText?: true
    codebookText?: true
    maxYear?: true
    minYear?: true
    sources?: true
    isVisible?: true
  }

  export type ResearchDatasetCountAggregateInputType = {
    id?: true
    slug?: true
    titleI18n?: true
    codebookTextI18n?: true
    status?: true
    maturity?: true
    version?: true
    license?: true
    thumbnailId?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    title?: true
    categoryId?: true
    citationText?: true
    codebookText?: true
    maxYear?: true
    minYear?: true
    sources?: true
    isVisible?: true
    sourcesI18n?: true
    descriptionI18n?: true
    _all?: true
  }

  export type ResearchDatasetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResearchDataset to aggregate.
     */
    where?: ResearchDatasetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchDatasets to fetch.
     */
    orderBy?: ResearchDatasetOrderByWithRelationInput | ResearchDatasetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResearchDatasetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchDatasets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchDatasets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResearchDatasets
    **/
    _count?: true | ResearchDatasetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResearchDatasetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResearchDatasetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResearchDatasetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResearchDatasetMaxAggregateInputType
  }

  export type GetResearchDatasetAggregateType<T extends ResearchDatasetAggregateArgs> = {
        [P in keyof T & keyof AggregateResearchDataset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResearchDataset[P]>
      : GetScalarType<T[P], AggregateResearchDataset[P]>
  }




  export type ResearchDatasetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResearchDatasetWhereInput
    orderBy?: ResearchDatasetOrderByWithAggregationInput | ResearchDatasetOrderByWithAggregationInput[]
    by: ResearchDatasetScalarFieldEnum[] | ResearchDatasetScalarFieldEnum
    having?: ResearchDatasetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResearchDatasetCountAggregateInputType | true
    _avg?: ResearchDatasetAvgAggregateInputType
    _sum?: ResearchDatasetSumAggregateInputType
    _min?: ResearchDatasetMinAggregateInputType
    _max?: ResearchDatasetMaxAggregateInputType
  }

  export type ResearchDatasetGroupByOutputType = {
    id: string
    slug: string
    titleI18n: JsonValue | null
    codebookTextI18n: JsonValue | null
    status: $Enums.ContentStatus
    maturity: $Enums.DataMaturity
    version: string | null
    license: string | null
    thumbnailId: string | null
    createdAt: Date
    updatedAt: Date
    description: string | null
    title: string
    categoryId: string | null
    citationText: string | null
    codebookText: string | null
    maxYear: number | null
    minYear: number | null
    sources: string | null
    isVisible: boolean
    sourcesI18n: JsonValue | null
    descriptionI18n: JsonValue | null
    _count: ResearchDatasetCountAggregateOutputType | null
    _avg: ResearchDatasetAvgAggregateOutputType | null
    _sum: ResearchDatasetSumAggregateOutputType | null
    _min: ResearchDatasetMinAggregateOutputType | null
    _max: ResearchDatasetMaxAggregateOutputType | null
  }

  type GetResearchDatasetGroupByPayload<T extends ResearchDatasetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResearchDatasetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResearchDatasetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResearchDatasetGroupByOutputType[P]>
            : GetScalarType<T[P], ResearchDatasetGroupByOutputType[P]>
        }
      >
    >


  export type ResearchDatasetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    titleI18n?: boolean
    codebookTextI18n?: boolean
    status?: boolean
    maturity?: boolean
    version?: boolean
    license?: boolean
    thumbnailId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    title?: boolean
    categoryId?: boolean
    citationText?: boolean
    codebookText?: boolean
    maxYear?: boolean
    minYear?: boolean
    sources?: boolean
    isVisible?: boolean
    sourcesI18n?: boolean
    descriptionI18n?: boolean
    resources?: boolean | ResearchDataset$resourcesArgs<ExtArgs>
    category?: boolean | ResearchDataset$categoryArgs<ExtArgs>
    thumbnail?: boolean | ResearchDataset$thumbnailArgs<ExtArgs>
    regions?: boolean | ResearchDataset$regionsArgs<ExtArgs>
    _count?: boolean | ResearchDatasetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["researchDataset"]>

  export type ResearchDatasetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    titleI18n?: boolean
    codebookTextI18n?: boolean
    status?: boolean
    maturity?: boolean
    version?: boolean
    license?: boolean
    thumbnailId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    title?: boolean
    categoryId?: boolean
    citationText?: boolean
    codebookText?: boolean
    maxYear?: boolean
    minYear?: boolean
    sources?: boolean
    isVisible?: boolean
    sourcesI18n?: boolean
    descriptionI18n?: boolean
    category?: boolean | ResearchDataset$categoryArgs<ExtArgs>
    thumbnail?: boolean | ResearchDataset$thumbnailArgs<ExtArgs>
  }, ExtArgs["result"]["researchDataset"]>

  export type ResearchDatasetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    titleI18n?: boolean
    codebookTextI18n?: boolean
    status?: boolean
    maturity?: boolean
    version?: boolean
    license?: boolean
    thumbnailId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    title?: boolean
    categoryId?: boolean
    citationText?: boolean
    codebookText?: boolean
    maxYear?: boolean
    minYear?: boolean
    sources?: boolean
    isVisible?: boolean
    sourcesI18n?: boolean
    descriptionI18n?: boolean
    category?: boolean | ResearchDataset$categoryArgs<ExtArgs>
    thumbnail?: boolean | ResearchDataset$thumbnailArgs<ExtArgs>
  }, ExtArgs["result"]["researchDataset"]>

  export type ResearchDatasetSelectScalar = {
    id?: boolean
    slug?: boolean
    titleI18n?: boolean
    codebookTextI18n?: boolean
    status?: boolean
    maturity?: boolean
    version?: boolean
    license?: boolean
    thumbnailId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    title?: boolean
    categoryId?: boolean
    citationText?: boolean
    codebookText?: boolean
    maxYear?: boolean
    minYear?: boolean
    sources?: boolean
    isVisible?: boolean
    sourcesI18n?: boolean
    descriptionI18n?: boolean
  }

  export type ResearchDatasetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "titleI18n" | "codebookTextI18n" | "status" | "maturity" | "version" | "license" | "thumbnailId" | "createdAt" | "updatedAt" | "description" | "title" | "categoryId" | "citationText" | "codebookText" | "maxYear" | "minYear" | "sources" | "isVisible" | "sourcesI18n" | "descriptionI18n", ExtArgs["result"]["researchDataset"]>
  export type ResearchDatasetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resources?: boolean | ResearchDataset$resourcesArgs<ExtArgs>
    category?: boolean | ResearchDataset$categoryArgs<ExtArgs>
    thumbnail?: boolean | ResearchDataset$thumbnailArgs<ExtArgs>
    regions?: boolean | ResearchDataset$regionsArgs<ExtArgs>
    _count?: boolean | ResearchDatasetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResearchDatasetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ResearchDataset$categoryArgs<ExtArgs>
    thumbnail?: boolean | ResearchDataset$thumbnailArgs<ExtArgs>
  }
  export type ResearchDatasetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | ResearchDataset$categoryArgs<ExtArgs>
    thumbnail?: boolean | ResearchDataset$thumbnailArgs<ExtArgs>
  }

  export type $ResearchDatasetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResearchDataset"
    objects: {
      resources: Prisma.$DatasetResourcePayload<ExtArgs>[]
      category: Prisma.$CategoryPayload<ExtArgs> | null
      thumbnail: Prisma.$MediaPayload<ExtArgs> | null
      regions: Prisma.$RegionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      titleI18n: Prisma.JsonValue | null
      codebookTextI18n: Prisma.JsonValue | null
      status: $Enums.ContentStatus
      maturity: $Enums.DataMaturity
      version: string | null
      license: string | null
      thumbnailId: string | null
      createdAt: Date
      updatedAt: Date
      description: string | null
      title: string
      categoryId: string | null
      citationText: string | null
      codebookText: string | null
      maxYear: number | null
      minYear: number | null
      sources: string | null
      isVisible: boolean
      sourcesI18n: Prisma.JsonValue | null
      descriptionI18n: Prisma.JsonValue | null
    }, ExtArgs["result"]["researchDataset"]>
    composites: {}
  }

  type ResearchDatasetGetPayload<S extends boolean | null | undefined | ResearchDatasetDefaultArgs> = $Result.GetResult<Prisma.$ResearchDatasetPayload, S>

  type ResearchDatasetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResearchDatasetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResearchDatasetCountAggregateInputType | true
    }

  export interface ResearchDatasetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResearchDataset'], meta: { name: 'ResearchDataset' } }
    /**
     * Find zero or one ResearchDataset that matches the filter.
     * @param {ResearchDatasetFindUniqueArgs} args - Arguments to find a ResearchDataset
     * @example
     * // Get one ResearchDataset
     * const researchDataset = await prisma.researchDataset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResearchDatasetFindUniqueArgs>(args: SelectSubset<T, ResearchDatasetFindUniqueArgs<ExtArgs>>): Prisma__ResearchDatasetClient<$Result.GetResult<Prisma.$ResearchDatasetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResearchDataset that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResearchDatasetFindUniqueOrThrowArgs} args - Arguments to find a ResearchDataset
     * @example
     * // Get one ResearchDataset
     * const researchDataset = await prisma.researchDataset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResearchDatasetFindUniqueOrThrowArgs>(args: SelectSubset<T, ResearchDatasetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResearchDatasetClient<$Result.GetResult<Prisma.$ResearchDatasetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResearchDataset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchDatasetFindFirstArgs} args - Arguments to find a ResearchDataset
     * @example
     * // Get one ResearchDataset
     * const researchDataset = await prisma.researchDataset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResearchDatasetFindFirstArgs>(args?: SelectSubset<T, ResearchDatasetFindFirstArgs<ExtArgs>>): Prisma__ResearchDatasetClient<$Result.GetResult<Prisma.$ResearchDatasetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResearchDataset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchDatasetFindFirstOrThrowArgs} args - Arguments to find a ResearchDataset
     * @example
     * // Get one ResearchDataset
     * const researchDataset = await prisma.researchDataset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResearchDatasetFindFirstOrThrowArgs>(args?: SelectSubset<T, ResearchDatasetFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResearchDatasetClient<$Result.GetResult<Prisma.$ResearchDatasetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResearchDatasets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchDatasetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResearchDatasets
     * const researchDatasets = await prisma.researchDataset.findMany()
     * 
     * // Get first 10 ResearchDatasets
     * const researchDatasets = await prisma.researchDataset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const researchDatasetWithIdOnly = await prisma.researchDataset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResearchDatasetFindManyArgs>(args?: SelectSubset<T, ResearchDatasetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchDatasetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResearchDataset.
     * @param {ResearchDatasetCreateArgs} args - Arguments to create a ResearchDataset.
     * @example
     * // Create one ResearchDataset
     * const ResearchDataset = await prisma.researchDataset.create({
     *   data: {
     *     // ... data to create a ResearchDataset
     *   }
     * })
     * 
     */
    create<T extends ResearchDatasetCreateArgs>(args: SelectSubset<T, ResearchDatasetCreateArgs<ExtArgs>>): Prisma__ResearchDatasetClient<$Result.GetResult<Prisma.$ResearchDatasetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResearchDatasets.
     * @param {ResearchDatasetCreateManyArgs} args - Arguments to create many ResearchDatasets.
     * @example
     * // Create many ResearchDatasets
     * const researchDataset = await prisma.researchDataset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResearchDatasetCreateManyArgs>(args?: SelectSubset<T, ResearchDatasetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResearchDatasets and returns the data saved in the database.
     * @param {ResearchDatasetCreateManyAndReturnArgs} args - Arguments to create many ResearchDatasets.
     * @example
     * // Create many ResearchDatasets
     * const researchDataset = await prisma.researchDataset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResearchDatasets and only return the `id`
     * const researchDatasetWithIdOnly = await prisma.researchDataset.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResearchDatasetCreateManyAndReturnArgs>(args?: SelectSubset<T, ResearchDatasetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchDatasetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResearchDataset.
     * @param {ResearchDatasetDeleteArgs} args - Arguments to delete one ResearchDataset.
     * @example
     * // Delete one ResearchDataset
     * const ResearchDataset = await prisma.researchDataset.delete({
     *   where: {
     *     // ... filter to delete one ResearchDataset
     *   }
     * })
     * 
     */
    delete<T extends ResearchDatasetDeleteArgs>(args: SelectSubset<T, ResearchDatasetDeleteArgs<ExtArgs>>): Prisma__ResearchDatasetClient<$Result.GetResult<Prisma.$ResearchDatasetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResearchDataset.
     * @param {ResearchDatasetUpdateArgs} args - Arguments to update one ResearchDataset.
     * @example
     * // Update one ResearchDataset
     * const researchDataset = await prisma.researchDataset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResearchDatasetUpdateArgs>(args: SelectSubset<T, ResearchDatasetUpdateArgs<ExtArgs>>): Prisma__ResearchDatasetClient<$Result.GetResult<Prisma.$ResearchDatasetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResearchDatasets.
     * @param {ResearchDatasetDeleteManyArgs} args - Arguments to filter ResearchDatasets to delete.
     * @example
     * // Delete a few ResearchDatasets
     * const { count } = await prisma.researchDataset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResearchDatasetDeleteManyArgs>(args?: SelectSubset<T, ResearchDatasetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResearchDatasets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchDatasetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResearchDatasets
     * const researchDataset = await prisma.researchDataset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResearchDatasetUpdateManyArgs>(args: SelectSubset<T, ResearchDatasetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResearchDatasets and returns the data updated in the database.
     * @param {ResearchDatasetUpdateManyAndReturnArgs} args - Arguments to update many ResearchDatasets.
     * @example
     * // Update many ResearchDatasets
     * const researchDataset = await prisma.researchDataset.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResearchDatasets and only return the `id`
     * const researchDatasetWithIdOnly = await prisma.researchDataset.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResearchDatasetUpdateManyAndReturnArgs>(args: SelectSubset<T, ResearchDatasetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchDatasetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResearchDataset.
     * @param {ResearchDatasetUpsertArgs} args - Arguments to update or create a ResearchDataset.
     * @example
     * // Update or create a ResearchDataset
     * const researchDataset = await prisma.researchDataset.upsert({
     *   create: {
     *     // ... data to create a ResearchDataset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResearchDataset we want to update
     *   }
     * })
     */
    upsert<T extends ResearchDatasetUpsertArgs>(args: SelectSubset<T, ResearchDatasetUpsertArgs<ExtArgs>>): Prisma__ResearchDatasetClient<$Result.GetResult<Prisma.$ResearchDatasetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResearchDatasets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchDatasetCountArgs} args - Arguments to filter ResearchDatasets to count.
     * @example
     * // Count the number of ResearchDatasets
     * const count = await prisma.researchDataset.count({
     *   where: {
     *     // ... the filter for the ResearchDatasets we want to count
     *   }
     * })
    **/
    count<T extends ResearchDatasetCountArgs>(
      args?: Subset<T, ResearchDatasetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResearchDatasetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResearchDataset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchDatasetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResearchDatasetAggregateArgs>(args: Subset<T, ResearchDatasetAggregateArgs>): Prisma.PrismaPromise<GetResearchDatasetAggregateType<T>>

    /**
     * Group by ResearchDataset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResearchDatasetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResearchDatasetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResearchDatasetGroupByArgs['orderBy'] }
        : { orderBy?: ResearchDatasetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResearchDatasetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResearchDatasetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResearchDataset model
   */
  readonly fields: ResearchDatasetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResearchDataset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResearchDatasetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resources<T extends ResearchDataset$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, ResearchDataset$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    category<T extends ResearchDataset$categoryArgs<ExtArgs> = {}>(args?: Subset<T, ResearchDataset$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    thumbnail<T extends ResearchDataset$thumbnailArgs<ExtArgs> = {}>(args?: Subset<T, ResearchDataset$thumbnailArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    regions<T extends ResearchDataset$regionsArgs<ExtArgs> = {}>(args?: Subset<T, ResearchDataset$regionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResearchDataset model
   */
  interface ResearchDatasetFieldRefs {
    readonly id: FieldRef<"ResearchDataset", 'String'>
    readonly slug: FieldRef<"ResearchDataset", 'String'>
    readonly titleI18n: FieldRef<"ResearchDataset", 'Json'>
    readonly codebookTextI18n: FieldRef<"ResearchDataset", 'Json'>
    readonly status: FieldRef<"ResearchDataset", 'ContentStatus'>
    readonly maturity: FieldRef<"ResearchDataset", 'DataMaturity'>
    readonly version: FieldRef<"ResearchDataset", 'String'>
    readonly license: FieldRef<"ResearchDataset", 'String'>
    readonly thumbnailId: FieldRef<"ResearchDataset", 'String'>
    readonly createdAt: FieldRef<"ResearchDataset", 'DateTime'>
    readonly updatedAt: FieldRef<"ResearchDataset", 'DateTime'>
    readonly description: FieldRef<"ResearchDataset", 'String'>
    readonly title: FieldRef<"ResearchDataset", 'String'>
    readonly categoryId: FieldRef<"ResearchDataset", 'String'>
    readonly citationText: FieldRef<"ResearchDataset", 'String'>
    readonly codebookText: FieldRef<"ResearchDataset", 'String'>
    readonly maxYear: FieldRef<"ResearchDataset", 'Int'>
    readonly minYear: FieldRef<"ResearchDataset", 'Int'>
    readonly sources: FieldRef<"ResearchDataset", 'String'>
    readonly isVisible: FieldRef<"ResearchDataset", 'Boolean'>
    readonly sourcesI18n: FieldRef<"ResearchDataset", 'Json'>
    readonly descriptionI18n: FieldRef<"ResearchDataset", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * ResearchDataset findUnique
   */
  export type ResearchDatasetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDataset
     */
    select?: ResearchDatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchDataset
     */
    omit?: ResearchDatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDatasetInclude<ExtArgs> | null
    /**
     * Filter, which ResearchDataset to fetch.
     */
    where: ResearchDatasetWhereUniqueInput
  }

  /**
   * ResearchDataset findUniqueOrThrow
   */
  export type ResearchDatasetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDataset
     */
    select?: ResearchDatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchDataset
     */
    omit?: ResearchDatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDatasetInclude<ExtArgs> | null
    /**
     * Filter, which ResearchDataset to fetch.
     */
    where: ResearchDatasetWhereUniqueInput
  }

  /**
   * ResearchDataset findFirst
   */
  export type ResearchDatasetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDataset
     */
    select?: ResearchDatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchDataset
     */
    omit?: ResearchDatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDatasetInclude<ExtArgs> | null
    /**
     * Filter, which ResearchDataset to fetch.
     */
    where?: ResearchDatasetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchDatasets to fetch.
     */
    orderBy?: ResearchDatasetOrderByWithRelationInput | ResearchDatasetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResearchDatasets.
     */
    cursor?: ResearchDatasetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchDatasets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchDatasets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResearchDatasets.
     */
    distinct?: ResearchDatasetScalarFieldEnum | ResearchDatasetScalarFieldEnum[]
  }

  /**
   * ResearchDataset findFirstOrThrow
   */
  export type ResearchDatasetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDataset
     */
    select?: ResearchDatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchDataset
     */
    omit?: ResearchDatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDatasetInclude<ExtArgs> | null
    /**
     * Filter, which ResearchDataset to fetch.
     */
    where?: ResearchDatasetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchDatasets to fetch.
     */
    orderBy?: ResearchDatasetOrderByWithRelationInput | ResearchDatasetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResearchDatasets.
     */
    cursor?: ResearchDatasetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchDatasets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchDatasets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResearchDatasets.
     */
    distinct?: ResearchDatasetScalarFieldEnum | ResearchDatasetScalarFieldEnum[]
  }

  /**
   * ResearchDataset findMany
   */
  export type ResearchDatasetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDataset
     */
    select?: ResearchDatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchDataset
     */
    omit?: ResearchDatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDatasetInclude<ExtArgs> | null
    /**
     * Filter, which ResearchDatasets to fetch.
     */
    where?: ResearchDatasetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResearchDatasets to fetch.
     */
    orderBy?: ResearchDatasetOrderByWithRelationInput | ResearchDatasetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResearchDatasets.
     */
    cursor?: ResearchDatasetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResearchDatasets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResearchDatasets.
     */
    skip?: number
    distinct?: ResearchDatasetScalarFieldEnum | ResearchDatasetScalarFieldEnum[]
  }

  /**
   * ResearchDataset create
   */
  export type ResearchDatasetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDataset
     */
    select?: ResearchDatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchDataset
     */
    omit?: ResearchDatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDatasetInclude<ExtArgs> | null
    /**
     * The data needed to create a ResearchDataset.
     */
    data: XOR<ResearchDatasetCreateInput, ResearchDatasetUncheckedCreateInput>
  }

  /**
   * ResearchDataset createMany
   */
  export type ResearchDatasetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResearchDatasets.
     */
    data: ResearchDatasetCreateManyInput | ResearchDatasetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResearchDataset createManyAndReturn
   */
  export type ResearchDatasetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDataset
     */
    select?: ResearchDatasetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchDataset
     */
    omit?: ResearchDatasetOmit<ExtArgs> | null
    /**
     * The data used to create many ResearchDatasets.
     */
    data: ResearchDatasetCreateManyInput | ResearchDatasetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDatasetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResearchDataset update
   */
  export type ResearchDatasetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDataset
     */
    select?: ResearchDatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchDataset
     */
    omit?: ResearchDatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDatasetInclude<ExtArgs> | null
    /**
     * The data needed to update a ResearchDataset.
     */
    data: XOR<ResearchDatasetUpdateInput, ResearchDatasetUncheckedUpdateInput>
    /**
     * Choose, which ResearchDataset to update.
     */
    where: ResearchDatasetWhereUniqueInput
  }

  /**
   * ResearchDataset updateMany
   */
  export type ResearchDatasetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResearchDatasets.
     */
    data: XOR<ResearchDatasetUpdateManyMutationInput, ResearchDatasetUncheckedUpdateManyInput>
    /**
     * Filter which ResearchDatasets to update
     */
    where?: ResearchDatasetWhereInput
    /**
     * Limit how many ResearchDatasets to update.
     */
    limit?: number
  }

  /**
   * ResearchDataset updateManyAndReturn
   */
  export type ResearchDatasetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDataset
     */
    select?: ResearchDatasetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchDataset
     */
    omit?: ResearchDatasetOmit<ExtArgs> | null
    /**
     * The data used to update ResearchDatasets.
     */
    data: XOR<ResearchDatasetUpdateManyMutationInput, ResearchDatasetUncheckedUpdateManyInput>
    /**
     * Filter which ResearchDatasets to update
     */
    where?: ResearchDatasetWhereInput
    /**
     * Limit how many ResearchDatasets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDatasetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResearchDataset upsert
   */
  export type ResearchDatasetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDataset
     */
    select?: ResearchDatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchDataset
     */
    omit?: ResearchDatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDatasetInclude<ExtArgs> | null
    /**
     * The filter to search for the ResearchDataset to update in case it exists.
     */
    where: ResearchDatasetWhereUniqueInput
    /**
     * In case the ResearchDataset found by the `where` argument doesn't exist, create a new ResearchDataset with this data.
     */
    create: XOR<ResearchDatasetCreateInput, ResearchDatasetUncheckedCreateInput>
    /**
     * In case the ResearchDataset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResearchDatasetUpdateInput, ResearchDatasetUncheckedUpdateInput>
  }

  /**
   * ResearchDataset delete
   */
  export type ResearchDatasetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDataset
     */
    select?: ResearchDatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchDataset
     */
    omit?: ResearchDatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDatasetInclude<ExtArgs> | null
    /**
     * Filter which ResearchDataset to delete.
     */
    where: ResearchDatasetWhereUniqueInput
  }

  /**
   * ResearchDataset deleteMany
   */
  export type ResearchDatasetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResearchDatasets to delete
     */
    where?: ResearchDatasetWhereInput
    /**
     * Limit how many ResearchDatasets to delete.
     */
    limit?: number
  }

  /**
   * ResearchDataset.resources
   */
  export type ResearchDataset$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetResource
     */
    select?: DatasetResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatasetResource
     */
    omit?: DatasetResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetResourceInclude<ExtArgs> | null
    where?: DatasetResourceWhereInput
    orderBy?: DatasetResourceOrderByWithRelationInput | DatasetResourceOrderByWithRelationInput[]
    cursor?: DatasetResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DatasetResourceScalarFieldEnum | DatasetResourceScalarFieldEnum[]
  }

  /**
   * ResearchDataset.category
   */
  export type ResearchDataset$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * ResearchDataset.thumbnail
   */
  export type ResearchDataset$thumbnailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * ResearchDataset.regions
   */
  export type ResearchDataset$regionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    cursor?: RegionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * ResearchDataset without action
   */
  export type ResearchDatasetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDataset
     */
    select?: ResearchDatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchDataset
     */
    omit?: ResearchDatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDatasetInclude<ExtArgs> | null
  }


  /**
   * Model DatasetResource
   */

  export type AggregateDatasetResource = {
    _count: DatasetResourceCountAggregateOutputType | null
    _min: DatasetResourceMinAggregateOutputType | null
    _max: DatasetResourceMaxAggregateOutputType | null
  }

  export type DatasetResourceMinAggregateOutputType = {
    id: string | null
    datasetId: string | null
    url: string | null
    isMainFile: boolean | null
    createdAt: Date | null
    name: string | null
    slug: string | null
    format: $Enums.ResouceType | null
    filename: string | null
    mimeType: string | null
    mapId: string | null
  }

  export type DatasetResourceMaxAggregateOutputType = {
    id: string | null
    datasetId: string | null
    url: string | null
    isMainFile: boolean | null
    createdAt: Date | null
    name: string | null
    slug: string | null
    format: $Enums.ResouceType | null
    filename: string | null
    mimeType: string | null
    mapId: string | null
  }

  export type DatasetResourceCountAggregateOutputType = {
    id: number
    datasetId: number
    url: number
    isMainFile: number
    createdAt: number
    name: number
    slug: number
    format: number
    filename: number
    mimeType: number
    excerptI18n: number
    mapId: number
    _all: number
  }


  export type DatasetResourceMinAggregateInputType = {
    id?: true
    datasetId?: true
    url?: true
    isMainFile?: true
    createdAt?: true
    name?: true
    slug?: true
    format?: true
    filename?: true
    mimeType?: true
    mapId?: true
  }

  export type DatasetResourceMaxAggregateInputType = {
    id?: true
    datasetId?: true
    url?: true
    isMainFile?: true
    createdAt?: true
    name?: true
    slug?: true
    format?: true
    filename?: true
    mimeType?: true
    mapId?: true
  }

  export type DatasetResourceCountAggregateInputType = {
    id?: true
    datasetId?: true
    url?: true
    isMainFile?: true
    createdAt?: true
    name?: true
    slug?: true
    format?: true
    filename?: true
    mimeType?: true
    excerptI18n?: true
    mapId?: true
    _all?: true
  }

  export type DatasetResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DatasetResource to aggregate.
     */
    where?: DatasetResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetResources to fetch.
     */
    orderBy?: DatasetResourceOrderByWithRelationInput | DatasetResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DatasetResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DatasetResources
    **/
    _count?: true | DatasetResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DatasetResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DatasetResourceMaxAggregateInputType
  }

  export type GetDatasetResourceAggregateType<T extends DatasetResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateDatasetResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDatasetResource[P]>
      : GetScalarType<T[P], AggregateDatasetResource[P]>
  }




  export type DatasetResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatasetResourceWhereInput
    orderBy?: DatasetResourceOrderByWithAggregationInput | DatasetResourceOrderByWithAggregationInput[]
    by: DatasetResourceScalarFieldEnum[] | DatasetResourceScalarFieldEnum
    having?: DatasetResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DatasetResourceCountAggregateInputType | true
    _min?: DatasetResourceMinAggregateInputType
    _max?: DatasetResourceMaxAggregateInputType
  }

  export type DatasetResourceGroupByOutputType = {
    id: string
    datasetId: string | null
    url: string
    isMainFile: boolean
    createdAt: Date
    name: string
    slug: string
    format: $Enums.ResouceType
    filename: string | null
    mimeType: string | null
    excerptI18n: JsonValue | null
    mapId: string | null
    _count: DatasetResourceCountAggregateOutputType | null
    _min: DatasetResourceMinAggregateOutputType | null
    _max: DatasetResourceMaxAggregateOutputType | null
  }

  type GetDatasetResourceGroupByPayload<T extends DatasetResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DatasetResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DatasetResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DatasetResourceGroupByOutputType[P]>
            : GetScalarType<T[P], DatasetResourceGroupByOutputType[P]>
        }
      >
    >


  export type DatasetResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datasetId?: boolean
    url?: boolean
    isMainFile?: boolean
    createdAt?: boolean
    name?: boolean
    slug?: boolean
    format?: boolean
    filename?: boolean
    mimeType?: boolean
    excerptI18n?: boolean
    mapId?: boolean
    dataset?: boolean | DatasetResource$datasetArgs<ExtArgs>
    map?: boolean | DatasetResource$mapArgs<ExtArgs>
  }, ExtArgs["result"]["datasetResource"]>

  export type DatasetResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datasetId?: boolean
    url?: boolean
    isMainFile?: boolean
    createdAt?: boolean
    name?: boolean
    slug?: boolean
    format?: boolean
    filename?: boolean
    mimeType?: boolean
    excerptI18n?: boolean
    mapId?: boolean
    dataset?: boolean | DatasetResource$datasetArgs<ExtArgs>
    map?: boolean | DatasetResource$mapArgs<ExtArgs>
  }, ExtArgs["result"]["datasetResource"]>

  export type DatasetResourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    datasetId?: boolean
    url?: boolean
    isMainFile?: boolean
    createdAt?: boolean
    name?: boolean
    slug?: boolean
    format?: boolean
    filename?: boolean
    mimeType?: boolean
    excerptI18n?: boolean
    mapId?: boolean
    dataset?: boolean | DatasetResource$datasetArgs<ExtArgs>
    map?: boolean | DatasetResource$mapArgs<ExtArgs>
  }, ExtArgs["result"]["datasetResource"]>

  export type DatasetResourceSelectScalar = {
    id?: boolean
    datasetId?: boolean
    url?: boolean
    isMainFile?: boolean
    createdAt?: boolean
    name?: boolean
    slug?: boolean
    format?: boolean
    filename?: boolean
    mimeType?: boolean
    excerptI18n?: boolean
    mapId?: boolean
  }

  export type DatasetResourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "datasetId" | "url" | "isMainFile" | "createdAt" | "name" | "slug" | "format" | "filename" | "mimeType" | "excerptI18n" | "mapId", ExtArgs["result"]["datasetResource"]>
  export type DatasetResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dataset?: boolean | DatasetResource$datasetArgs<ExtArgs>
    map?: boolean | DatasetResource$mapArgs<ExtArgs>
  }
  export type DatasetResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dataset?: boolean | DatasetResource$datasetArgs<ExtArgs>
    map?: boolean | DatasetResource$mapArgs<ExtArgs>
  }
  export type DatasetResourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dataset?: boolean | DatasetResource$datasetArgs<ExtArgs>
    map?: boolean | DatasetResource$mapArgs<ExtArgs>
  }

  export type $DatasetResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DatasetResource"
    objects: {
      dataset: Prisma.$ResearchDatasetPayload<ExtArgs> | null
      map: Prisma.$MapPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      datasetId: string | null
      url: string
      isMainFile: boolean
      createdAt: Date
      name: string
      slug: string
      format: $Enums.ResouceType
      filename: string | null
      mimeType: string | null
      excerptI18n: Prisma.JsonValue | null
      mapId: string | null
    }, ExtArgs["result"]["datasetResource"]>
    composites: {}
  }

  type DatasetResourceGetPayload<S extends boolean | null | undefined | DatasetResourceDefaultArgs> = $Result.GetResult<Prisma.$DatasetResourcePayload, S>

  type DatasetResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DatasetResourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DatasetResourceCountAggregateInputType | true
    }

  export interface DatasetResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DatasetResource'], meta: { name: 'DatasetResource' } }
    /**
     * Find zero or one DatasetResource that matches the filter.
     * @param {DatasetResourceFindUniqueArgs} args - Arguments to find a DatasetResource
     * @example
     * // Get one DatasetResource
     * const datasetResource = await prisma.datasetResource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DatasetResourceFindUniqueArgs>(args: SelectSubset<T, DatasetResourceFindUniqueArgs<ExtArgs>>): Prisma__DatasetResourceClient<$Result.GetResult<Prisma.$DatasetResourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DatasetResource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DatasetResourceFindUniqueOrThrowArgs} args - Arguments to find a DatasetResource
     * @example
     * // Get one DatasetResource
     * const datasetResource = await prisma.datasetResource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DatasetResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, DatasetResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DatasetResourceClient<$Result.GetResult<Prisma.$DatasetResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DatasetResource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetResourceFindFirstArgs} args - Arguments to find a DatasetResource
     * @example
     * // Get one DatasetResource
     * const datasetResource = await prisma.datasetResource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DatasetResourceFindFirstArgs>(args?: SelectSubset<T, DatasetResourceFindFirstArgs<ExtArgs>>): Prisma__DatasetResourceClient<$Result.GetResult<Prisma.$DatasetResourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DatasetResource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetResourceFindFirstOrThrowArgs} args - Arguments to find a DatasetResource
     * @example
     * // Get one DatasetResource
     * const datasetResource = await prisma.datasetResource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DatasetResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, DatasetResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DatasetResourceClient<$Result.GetResult<Prisma.$DatasetResourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DatasetResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DatasetResources
     * const datasetResources = await prisma.datasetResource.findMany()
     * 
     * // Get first 10 DatasetResources
     * const datasetResources = await prisma.datasetResource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const datasetResourceWithIdOnly = await prisma.datasetResource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DatasetResourceFindManyArgs>(args?: SelectSubset<T, DatasetResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DatasetResource.
     * @param {DatasetResourceCreateArgs} args - Arguments to create a DatasetResource.
     * @example
     * // Create one DatasetResource
     * const DatasetResource = await prisma.datasetResource.create({
     *   data: {
     *     // ... data to create a DatasetResource
     *   }
     * })
     * 
     */
    create<T extends DatasetResourceCreateArgs>(args: SelectSubset<T, DatasetResourceCreateArgs<ExtArgs>>): Prisma__DatasetResourceClient<$Result.GetResult<Prisma.$DatasetResourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DatasetResources.
     * @param {DatasetResourceCreateManyArgs} args - Arguments to create many DatasetResources.
     * @example
     * // Create many DatasetResources
     * const datasetResource = await prisma.datasetResource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DatasetResourceCreateManyArgs>(args?: SelectSubset<T, DatasetResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DatasetResources and returns the data saved in the database.
     * @param {DatasetResourceCreateManyAndReturnArgs} args - Arguments to create many DatasetResources.
     * @example
     * // Create many DatasetResources
     * const datasetResource = await prisma.datasetResource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DatasetResources and only return the `id`
     * const datasetResourceWithIdOnly = await prisma.datasetResource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DatasetResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, DatasetResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetResourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DatasetResource.
     * @param {DatasetResourceDeleteArgs} args - Arguments to delete one DatasetResource.
     * @example
     * // Delete one DatasetResource
     * const DatasetResource = await prisma.datasetResource.delete({
     *   where: {
     *     // ... filter to delete one DatasetResource
     *   }
     * })
     * 
     */
    delete<T extends DatasetResourceDeleteArgs>(args: SelectSubset<T, DatasetResourceDeleteArgs<ExtArgs>>): Prisma__DatasetResourceClient<$Result.GetResult<Prisma.$DatasetResourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DatasetResource.
     * @param {DatasetResourceUpdateArgs} args - Arguments to update one DatasetResource.
     * @example
     * // Update one DatasetResource
     * const datasetResource = await prisma.datasetResource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DatasetResourceUpdateArgs>(args: SelectSubset<T, DatasetResourceUpdateArgs<ExtArgs>>): Prisma__DatasetResourceClient<$Result.GetResult<Prisma.$DatasetResourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DatasetResources.
     * @param {DatasetResourceDeleteManyArgs} args - Arguments to filter DatasetResources to delete.
     * @example
     * // Delete a few DatasetResources
     * const { count } = await prisma.datasetResource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DatasetResourceDeleteManyArgs>(args?: SelectSubset<T, DatasetResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DatasetResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DatasetResources
     * const datasetResource = await prisma.datasetResource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DatasetResourceUpdateManyArgs>(args: SelectSubset<T, DatasetResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DatasetResources and returns the data updated in the database.
     * @param {DatasetResourceUpdateManyAndReturnArgs} args - Arguments to update many DatasetResources.
     * @example
     * // Update many DatasetResources
     * const datasetResource = await prisma.datasetResource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DatasetResources and only return the `id`
     * const datasetResourceWithIdOnly = await prisma.datasetResource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DatasetResourceUpdateManyAndReturnArgs>(args: SelectSubset<T, DatasetResourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetResourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DatasetResource.
     * @param {DatasetResourceUpsertArgs} args - Arguments to update or create a DatasetResource.
     * @example
     * // Update or create a DatasetResource
     * const datasetResource = await prisma.datasetResource.upsert({
     *   create: {
     *     // ... data to create a DatasetResource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DatasetResource we want to update
     *   }
     * })
     */
    upsert<T extends DatasetResourceUpsertArgs>(args: SelectSubset<T, DatasetResourceUpsertArgs<ExtArgs>>): Prisma__DatasetResourceClient<$Result.GetResult<Prisma.$DatasetResourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DatasetResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetResourceCountArgs} args - Arguments to filter DatasetResources to count.
     * @example
     * // Count the number of DatasetResources
     * const count = await prisma.datasetResource.count({
     *   where: {
     *     // ... the filter for the DatasetResources we want to count
     *   }
     * })
    **/
    count<T extends DatasetResourceCountArgs>(
      args?: Subset<T, DatasetResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatasetResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DatasetResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DatasetResourceAggregateArgs>(args: Subset<T, DatasetResourceAggregateArgs>): Prisma.PrismaPromise<GetDatasetResourceAggregateType<T>>

    /**
     * Group by DatasetResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatasetResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DatasetResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DatasetResourceGroupByArgs['orderBy'] }
        : { orderBy?: DatasetResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DatasetResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDatasetResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DatasetResource model
   */
  readonly fields: DatasetResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DatasetResource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DatasetResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dataset<T extends DatasetResource$datasetArgs<ExtArgs> = {}>(args?: Subset<T, DatasetResource$datasetArgs<ExtArgs>>): Prisma__ResearchDatasetClient<$Result.GetResult<Prisma.$ResearchDatasetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    map<T extends DatasetResource$mapArgs<ExtArgs> = {}>(args?: Subset<T, DatasetResource$mapArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DatasetResource model
   */
  interface DatasetResourceFieldRefs {
    readonly id: FieldRef<"DatasetResource", 'String'>
    readonly datasetId: FieldRef<"DatasetResource", 'String'>
    readonly url: FieldRef<"DatasetResource", 'String'>
    readonly isMainFile: FieldRef<"DatasetResource", 'Boolean'>
    readonly createdAt: FieldRef<"DatasetResource", 'DateTime'>
    readonly name: FieldRef<"DatasetResource", 'String'>
    readonly slug: FieldRef<"DatasetResource", 'String'>
    readonly format: FieldRef<"DatasetResource", 'ResouceType'>
    readonly filename: FieldRef<"DatasetResource", 'String'>
    readonly mimeType: FieldRef<"DatasetResource", 'String'>
    readonly excerptI18n: FieldRef<"DatasetResource", 'Json'>
    readonly mapId: FieldRef<"DatasetResource", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DatasetResource findUnique
   */
  export type DatasetResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetResource
     */
    select?: DatasetResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatasetResource
     */
    omit?: DatasetResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetResourceInclude<ExtArgs> | null
    /**
     * Filter, which DatasetResource to fetch.
     */
    where: DatasetResourceWhereUniqueInput
  }

  /**
   * DatasetResource findUniqueOrThrow
   */
  export type DatasetResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetResource
     */
    select?: DatasetResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatasetResource
     */
    omit?: DatasetResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetResourceInclude<ExtArgs> | null
    /**
     * Filter, which DatasetResource to fetch.
     */
    where: DatasetResourceWhereUniqueInput
  }

  /**
   * DatasetResource findFirst
   */
  export type DatasetResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetResource
     */
    select?: DatasetResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatasetResource
     */
    omit?: DatasetResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetResourceInclude<ExtArgs> | null
    /**
     * Filter, which DatasetResource to fetch.
     */
    where?: DatasetResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetResources to fetch.
     */
    orderBy?: DatasetResourceOrderByWithRelationInput | DatasetResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatasetResources.
     */
    cursor?: DatasetResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatasetResources.
     */
    distinct?: DatasetResourceScalarFieldEnum | DatasetResourceScalarFieldEnum[]
  }

  /**
   * DatasetResource findFirstOrThrow
   */
  export type DatasetResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetResource
     */
    select?: DatasetResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatasetResource
     */
    omit?: DatasetResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetResourceInclude<ExtArgs> | null
    /**
     * Filter, which DatasetResource to fetch.
     */
    where?: DatasetResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetResources to fetch.
     */
    orderBy?: DatasetResourceOrderByWithRelationInput | DatasetResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatasetResources.
     */
    cursor?: DatasetResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatasetResources.
     */
    distinct?: DatasetResourceScalarFieldEnum | DatasetResourceScalarFieldEnum[]
  }

  /**
   * DatasetResource findMany
   */
  export type DatasetResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetResource
     */
    select?: DatasetResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatasetResource
     */
    omit?: DatasetResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetResourceInclude<ExtArgs> | null
    /**
     * Filter, which DatasetResources to fetch.
     */
    where?: DatasetResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatasetResources to fetch.
     */
    orderBy?: DatasetResourceOrderByWithRelationInput | DatasetResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DatasetResources.
     */
    cursor?: DatasetResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatasetResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatasetResources.
     */
    skip?: number
    distinct?: DatasetResourceScalarFieldEnum | DatasetResourceScalarFieldEnum[]
  }

  /**
   * DatasetResource create
   */
  export type DatasetResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetResource
     */
    select?: DatasetResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatasetResource
     */
    omit?: DatasetResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a DatasetResource.
     */
    data: XOR<DatasetResourceCreateInput, DatasetResourceUncheckedCreateInput>
  }

  /**
   * DatasetResource createMany
   */
  export type DatasetResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DatasetResources.
     */
    data: DatasetResourceCreateManyInput | DatasetResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DatasetResource createManyAndReturn
   */
  export type DatasetResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetResource
     */
    select?: DatasetResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DatasetResource
     */
    omit?: DatasetResourceOmit<ExtArgs> | null
    /**
     * The data used to create many DatasetResources.
     */
    data: DatasetResourceCreateManyInput | DatasetResourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetResourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DatasetResource update
   */
  export type DatasetResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetResource
     */
    select?: DatasetResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatasetResource
     */
    omit?: DatasetResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a DatasetResource.
     */
    data: XOR<DatasetResourceUpdateInput, DatasetResourceUncheckedUpdateInput>
    /**
     * Choose, which DatasetResource to update.
     */
    where: DatasetResourceWhereUniqueInput
  }

  /**
   * DatasetResource updateMany
   */
  export type DatasetResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DatasetResources.
     */
    data: XOR<DatasetResourceUpdateManyMutationInput, DatasetResourceUncheckedUpdateManyInput>
    /**
     * Filter which DatasetResources to update
     */
    where?: DatasetResourceWhereInput
    /**
     * Limit how many DatasetResources to update.
     */
    limit?: number
  }

  /**
   * DatasetResource updateManyAndReturn
   */
  export type DatasetResourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetResource
     */
    select?: DatasetResourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DatasetResource
     */
    omit?: DatasetResourceOmit<ExtArgs> | null
    /**
     * The data used to update DatasetResources.
     */
    data: XOR<DatasetResourceUpdateManyMutationInput, DatasetResourceUncheckedUpdateManyInput>
    /**
     * Filter which DatasetResources to update
     */
    where?: DatasetResourceWhereInput
    /**
     * Limit how many DatasetResources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetResourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DatasetResource upsert
   */
  export type DatasetResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetResource
     */
    select?: DatasetResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatasetResource
     */
    omit?: DatasetResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the DatasetResource to update in case it exists.
     */
    where: DatasetResourceWhereUniqueInput
    /**
     * In case the DatasetResource found by the `where` argument doesn't exist, create a new DatasetResource with this data.
     */
    create: XOR<DatasetResourceCreateInput, DatasetResourceUncheckedCreateInput>
    /**
     * In case the DatasetResource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DatasetResourceUpdateInput, DatasetResourceUncheckedUpdateInput>
  }

  /**
   * DatasetResource delete
   */
  export type DatasetResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetResource
     */
    select?: DatasetResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatasetResource
     */
    omit?: DatasetResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetResourceInclude<ExtArgs> | null
    /**
     * Filter which DatasetResource to delete.
     */
    where: DatasetResourceWhereUniqueInput
  }

  /**
   * DatasetResource deleteMany
   */
  export type DatasetResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DatasetResources to delete
     */
    where?: DatasetResourceWhereInput
    /**
     * Limit how many DatasetResources to delete.
     */
    limit?: number
  }

  /**
   * DatasetResource.dataset
   */
  export type DatasetResource$datasetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDataset
     */
    select?: ResearchDatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchDataset
     */
    omit?: ResearchDatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDatasetInclude<ExtArgs> | null
    where?: ResearchDatasetWhereInput
  }

  /**
   * DatasetResource.map
   */
  export type DatasetResource$mapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    where?: MapWhereInput
  }

  /**
   * DatasetResource without action
   */
  export type DatasetResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetResource
     */
    select?: DatasetResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatasetResource
     */
    omit?: DatasetResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetResourceInclude<ExtArgs> | null
  }


  /**
   * Model Map
   */

  export type AggregateMap = {
    _count: MapCountAggregateOutputType | null
    _avg: MapAvgAggregateOutputType | null
    _sum: MapSumAggregateOutputType | null
    _min: MapMinAggregateOutputType | null
    _max: MapMaxAggregateOutputType | null
  }

  export type MapAvgAggregateOutputType = {
    year: number | null
    yearMax: number | null
    yearMin: number | null
  }

  export type MapSumAggregateOutputType = {
    year: number | null
    yearMax: number | null
    yearMin: number | null
  }

  export type MapMinAggregateOutputType = {
    id: string | null
    slug: string | null
    year: number | null
    version: string | null
    thumbnailId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    period: string | null
    title: string | null
    yearMax: number | null
    yearMin: number | null
    categoryId: string | null
    status: $Enums.ContentStatus | null
  }

  export type MapMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    year: number | null
    version: string | null
    thumbnailId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    period: string | null
    title: string | null
    yearMax: number | null
    yearMin: number | null
    categoryId: string | null
    status: $Enums.ContentStatus | null
  }

  export type MapCountAggregateOutputType = {
    id: number
    slug: number
    titleI18n: number
    descriptionI18n: number
    year: number
    version: number
    thumbnailId: number
    config: number
    globalStyleConfig: number
    referenceLinks: number
    createdAt: number
    updatedAt: number
    description: number
    period: number
    title: number
    yearMax: number
    yearMin: number
    categoryId: number
    status: number
    _all: number
  }


  export type MapAvgAggregateInputType = {
    year?: true
    yearMax?: true
    yearMin?: true
  }

  export type MapSumAggregateInputType = {
    year?: true
    yearMax?: true
    yearMin?: true
  }

  export type MapMinAggregateInputType = {
    id?: true
    slug?: true
    year?: true
    version?: true
    thumbnailId?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    period?: true
    title?: true
    yearMax?: true
    yearMin?: true
    categoryId?: true
    status?: true
  }

  export type MapMaxAggregateInputType = {
    id?: true
    slug?: true
    year?: true
    version?: true
    thumbnailId?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    period?: true
    title?: true
    yearMax?: true
    yearMin?: true
    categoryId?: true
    status?: true
  }

  export type MapCountAggregateInputType = {
    id?: true
    slug?: true
    titleI18n?: true
    descriptionI18n?: true
    year?: true
    version?: true
    thumbnailId?: true
    config?: true
    globalStyleConfig?: true
    referenceLinks?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    period?: true
    title?: true
    yearMax?: true
    yearMin?: true
    categoryId?: true
    status?: true
    _all?: true
  }

  export type MapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Map to aggregate.
     */
    where?: MapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maps to fetch.
     */
    orderBy?: MapOrderByWithRelationInput | MapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Maps
    **/
    _count?: true | MapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapMaxAggregateInputType
  }

  export type GetMapAggregateType<T extends MapAggregateArgs> = {
        [P in keyof T & keyof AggregateMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMap[P]>
      : GetScalarType<T[P], AggregateMap[P]>
  }




  export type MapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapWhereInput
    orderBy?: MapOrderByWithAggregationInput | MapOrderByWithAggregationInput[]
    by: MapScalarFieldEnum[] | MapScalarFieldEnum
    having?: MapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapCountAggregateInputType | true
    _avg?: MapAvgAggregateInputType
    _sum?: MapSumAggregateInputType
    _min?: MapMinAggregateInputType
    _max?: MapMaxAggregateInputType
  }

  export type MapGroupByOutputType = {
    id: string
    slug: string
    titleI18n: JsonValue | null
    descriptionI18n: JsonValue | null
    year: number | null
    version: string | null
    thumbnailId: string | null
    config: JsonValue | null
    globalStyleConfig: JsonValue | null
    referenceLinks: JsonValue | null
    createdAt: Date
    updatedAt: Date
    description: string | null
    period: string | null
    title: string
    yearMax: number | null
    yearMin: number | null
    categoryId: string | null
    status: $Enums.ContentStatus
    _count: MapCountAggregateOutputType | null
    _avg: MapAvgAggregateOutputType | null
    _sum: MapSumAggregateOutputType | null
    _min: MapMinAggregateOutputType | null
    _max: MapMaxAggregateOutputType | null
  }

  type GetMapGroupByPayload<T extends MapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapGroupByOutputType[P]>
            : GetScalarType<T[P], MapGroupByOutputType[P]>
        }
      >
    >


  export type MapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    titleI18n?: boolean
    descriptionI18n?: boolean
    year?: boolean
    version?: boolean
    thumbnailId?: boolean
    config?: boolean
    globalStyleConfig?: boolean
    referenceLinks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    period?: boolean
    title?: boolean
    yearMax?: boolean
    yearMin?: boolean
    categoryId?: boolean
    status?: boolean
    resources?: boolean | Map$resourcesArgs<ExtArgs>
    layers?: boolean | Map$layersArgs<ExtArgs>
    category?: boolean | Map$categoryArgs<ExtArgs>
    thumbnail?: boolean | Map$thumbnailArgs<ExtArgs>
    regions?: boolean | Map$regionsArgs<ExtArgs>
    tags?: boolean | Map$tagsArgs<ExtArgs>
    _count?: boolean | MapCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["map"]>

  export type MapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    titleI18n?: boolean
    descriptionI18n?: boolean
    year?: boolean
    version?: boolean
    thumbnailId?: boolean
    config?: boolean
    globalStyleConfig?: boolean
    referenceLinks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    period?: boolean
    title?: boolean
    yearMax?: boolean
    yearMin?: boolean
    categoryId?: boolean
    status?: boolean
    category?: boolean | Map$categoryArgs<ExtArgs>
    thumbnail?: boolean | Map$thumbnailArgs<ExtArgs>
  }, ExtArgs["result"]["map"]>

  export type MapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    titleI18n?: boolean
    descriptionI18n?: boolean
    year?: boolean
    version?: boolean
    thumbnailId?: boolean
    config?: boolean
    globalStyleConfig?: boolean
    referenceLinks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    period?: boolean
    title?: boolean
    yearMax?: boolean
    yearMin?: boolean
    categoryId?: boolean
    status?: boolean
    category?: boolean | Map$categoryArgs<ExtArgs>
    thumbnail?: boolean | Map$thumbnailArgs<ExtArgs>
  }, ExtArgs["result"]["map"]>

  export type MapSelectScalar = {
    id?: boolean
    slug?: boolean
    titleI18n?: boolean
    descriptionI18n?: boolean
    year?: boolean
    version?: boolean
    thumbnailId?: boolean
    config?: boolean
    globalStyleConfig?: boolean
    referenceLinks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    period?: boolean
    title?: boolean
    yearMax?: boolean
    yearMin?: boolean
    categoryId?: boolean
    status?: boolean
  }

  export type MapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "titleI18n" | "descriptionI18n" | "year" | "version" | "thumbnailId" | "config" | "globalStyleConfig" | "referenceLinks" | "createdAt" | "updatedAt" | "description" | "period" | "title" | "yearMax" | "yearMin" | "categoryId" | "status", ExtArgs["result"]["map"]>
  export type MapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resources?: boolean | Map$resourcesArgs<ExtArgs>
    layers?: boolean | Map$layersArgs<ExtArgs>
    category?: boolean | Map$categoryArgs<ExtArgs>
    thumbnail?: boolean | Map$thumbnailArgs<ExtArgs>
    regions?: boolean | Map$regionsArgs<ExtArgs>
    tags?: boolean | Map$tagsArgs<ExtArgs>
    _count?: boolean | MapCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Map$categoryArgs<ExtArgs>
    thumbnail?: boolean | Map$thumbnailArgs<ExtArgs>
  }
  export type MapIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Map$categoryArgs<ExtArgs>
    thumbnail?: boolean | Map$thumbnailArgs<ExtArgs>
  }

  export type $MapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Map"
    objects: {
      resources: Prisma.$DatasetResourcePayload<ExtArgs>[]
      layers: Prisma.$MapLayerAssociationPayload<ExtArgs>[]
      category: Prisma.$CategoryPayload<ExtArgs> | null
      thumbnail: Prisma.$MediaPayload<ExtArgs> | null
      regions: Prisma.$RegionPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      titleI18n: Prisma.JsonValue | null
      descriptionI18n: Prisma.JsonValue | null
      year: number | null
      version: string | null
      thumbnailId: string | null
      config: Prisma.JsonValue | null
      globalStyleConfig: Prisma.JsonValue | null
      referenceLinks: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      description: string | null
      period: string | null
      title: string
      yearMax: number | null
      yearMin: number | null
      categoryId: string | null
      status: $Enums.ContentStatus
    }, ExtArgs["result"]["map"]>
    composites: {}
  }

  type MapGetPayload<S extends boolean | null | undefined | MapDefaultArgs> = $Result.GetResult<Prisma.$MapPayload, S>

  type MapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MapCountAggregateInputType | true
    }

  export interface MapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Map'], meta: { name: 'Map' } }
    /**
     * Find zero or one Map that matches the filter.
     * @param {MapFindUniqueArgs} args - Arguments to find a Map
     * @example
     * // Get one Map
     * const map = await prisma.map.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MapFindUniqueArgs>(args: SelectSubset<T, MapFindUniqueArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Map that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MapFindUniqueOrThrowArgs} args - Arguments to find a Map
     * @example
     * // Get one Map
     * const map = await prisma.map.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MapFindUniqueOrThrowArgs>(args: SelectSubset<T, MapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Map that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapFindFirstArgs} args - Arguments to find a Map
     * @example
     * // Get one Map
     * const map = await prisma.map.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MapFindFirstArgs>(args?: SelectSubset<T, MapFindFirstArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Map that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapFindFirstOrThrowArgs} args - Arguments to find a Map
     * @example
     * // Get one Map
     * const map = await prisma.map.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MapFindFirstOrThrowArgs>(args?: SelectSubset<T, MapFindFirstOrThrowArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Maps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Maps
     * const maps = await prisma.map.findMany()
     * 
     * // Get first 10 Maps
     * const maps = await prisma.map.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mapWithIdOnly = await prisma.map.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MapFindManyArgs>(args?: SelectSubset<T, MapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Map.
     * @param {MapCreateArgs} args - Arguments to create a Map.
     * @example
     * // Create one Map
     * const Map = await prisma.map.create({
     *   data: {
     *     // ... data to create a Map
     *   }
     * })
     * 
     */
    create<T extends MapCreateArgs>(args: SelectSubset<T, MapCreateArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Maps.
     * @param {MapCreateManyArgs} args - Arguments to create many Maps.
     * @example
     * // Create many Maps
     * const map = await prisma.map.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MapCreateManyArgs>(args?: SelectSubset<T, MapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Maps and returns the data saved in the database.
     * @param {MapCreateManyAndReturnArgs} args - Arguments to create many Maps.
     * @example
     * // Create many Maps
     * const map = await prisma.map.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Maps and only return the `id`
     * const mapWithIdOnly = await prisma.map.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MapCreateManyAndReturnArgs>(args?: SelectSubset<T, MapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Map.
     * @param {MapDeleteArgs} args - Arguments to delete one Map.
     * @example
     * // Delete one Map
     * const Map = await prisma.map.delete({
     *   where: {
     *     // ... filter to delete one Map
     *   }
     * })
     * 
     */
    delete<T extends MapDeleteArgs>(args: SelectSubset<T, MapDeleteArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Map.
     * @param {MapUpdateArgs} args - Arguments to update one Map.
     * @example
     * // Update one Map
     * const map = await prisma.map.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MapUpdateArgs>(args: SelectSubset<T, MapUpdateArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Maps.
     * @param {MapDeleteManyArgs} args - Arguments to filter Maps to delete.
     * @example
     * // Delete a few Maps
     * const { count } = await prisma.map.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MapDeleteManyArgs>(args?: SelectSubset<T, MapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Maps
     * const map = await prisma.map.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MapUpdateManyArgs>(args: SelectSubset<T, MapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maps and returns the data updated in the database.
     * @param {MapUpdateManyAndReturnArgs} args - Arguments to update many Maps.
     * @example
     * // Update many Maps
     * const map = await prisma.map.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Maps and only return the `id`
     * const mapWithIdOnly = await prisma.map.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MapUpdateManyAndReturnArgs>(args: SelectSubset<T, MapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Map.
     * @param {MapUpsertArgs} args - Arguments to update or create a Map.
     * @example
     * // Update or create a Map
     * const map = await prisma.map.upsert({
     *   create: {
     *     // ... data to create a Map
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Map we want to update
     *   }
     * })
     */
    upsert<T extends MapUpsertArgs>(args: SelectSubset<T, MapUpsertArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapCountArgs} args - Arguments to filter Maps to count.
     * @example
     * // Count the number of Maps
     * const count = await prisma.map.count({
     *   where: {
     *     // ... the filter for the Maps we want to count
     *   }
     * })
    **/
    count<T extends MapCountArgs>(
      args?: Subset<T, MapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapAggregateArgs>(args: Subset<T, MapAggregateArgs>): Prisma.PrismaPromise<GetMapAggregateType<T>>

    /**
     * Group by Map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapGroupByArgs['orderBy'] }
        : { orderBy?: MapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Map model
   */
  readonly fields: MapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Map.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resources<T extends Map$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, Map$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatasetResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    layers<T extends Map$layersArgs<ExtArgs> = {}>(args?: Subset<T, Map$layersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapLayerAssociationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    category<T extends Map$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Map$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    thumbnail<T extends Map$thumbnailArgs<ExtArgs> = {}>(args?: Subset<T, Map$thumbnailArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    regions<T extends Map$regionsArgs<ExtArgs> = {}>(args?: Subset<T, Map$regionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Map$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Map$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Map model
   */
  interface MapFieldRefs {
    readonly id: FieldRef<"Map", 'String'>
    readonly slug: FieldRef<"Map", 'String'>
    readonly titleI18n: FieldRef<"Map", 'Json'>
    readonly descriptionI18n: FieldRef<"Map", 'Json'>
    readonly year: FieldRef<"Map", 'Int'>
    readonly version: FieldRef<"Map", 'String'>
    readonly thumbnailId: FieldRef<"Map", 'String'>
    readonly config: FieldRef<"Map", 'Json'>
    readonly globalStyleConfig: FieldRef<"Map", 'Json'>
    readonly referenceLinks: FieldRef<"Map", 'Json'>
    readonly createdAt: FieldRef<"Map", 'DateTime'>
    readonly updatedAt: FieldRef<"Map", 'DateTime'>
    readonly description: FieldRef<"Map", 'String'>
    readonly period: FieldRef<"Map", 'String'>
    readonly title: FieldRef<"Map", 'String'>
    readonly yearMax: FieldRef<"Map", 'Int'>
    readonly yearMin: FieldRef<"Map", 'Int'>
    readonly categoryId: FieldRef<"Map", 'String'>
    readonly status: FieldRef<"Map", 'ContentStatus'>
  }
    

  // Custom InputTypes
  /**
   * Map findUnique
   */
  export type MapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * Filter, which Map to fetch.
     */
    where: MapWhereUniqueInput
  }

  /**
   * Map findUniqueOrThrow
   */
  export type MapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * Filter, which Map to fetch.
     */
    where: MapWhereUniqueInput
  }

  /**
   * Map findFirst
   */
  export type MapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * Filter, which Map to fetch.
     */
    where?: MapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maps to fetch.
     */
    orderBy?: MapOrderByWithRelationInput | MapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maps.
     */
    cursor?: MapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maps.
     */
    distinct?: MapScalarFieldEnum | MapScalarFieldEnum[]
  }

  /**
   * Map findFirstOrThrow
   */
  export type MapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * Filter, which Map to fetch.
     */
    where?: MapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maps to fetch.
     */
    orderBy?: MapOrderByWithRelationInput | MapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maps.
     */
    cursor?: MapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maps.
     */
    distinct?: MapScalarFieldEnum | MapScalarFieldEnum[]
  }

  /**
   * Map findMany
   */
  export type MapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * Filter, which Maps to fetch.
     */
    where?: MapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maps to fetch.
     */
    orderBy?: MapOrderByWithRelationInput | MapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Maps.
     */
    cursor?: MapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maps.
     */
    skip?: number
    distinct?: MapScalarFieldEnum | MapScalarFieldEnum[]
  }

  /**
   * Map create
   */
  export type MapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * The data needed to create a Map.
     */
    data: XOR<MapCreateInput, MapUncheckedCreateInput>
  }

  /**
   * Map createMany
   */
  export type MapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Maps.
     */
    data: MapCreateManyInput | MapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Map createManyAndReturn
   */
  export type MapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * The data used to create many Maps.
     */
    data: MapCreateManyInput | MapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Map update
   */
  export type MapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * The data needed to update a Map.
     */
    data: XOR<MapUpdateInput, MapUncheckedUpdateInput>
    /**
     * Choose, which Map to update.
     */
    where: MapWhereUniqueInput
  }

  /**
   * Map updateMany
   */
  export type MapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Maps.
     */
    data: XOR<MapUpdateManyMutationInput, MapUncheckedUpdateManyInput>
    /**
     * Filter which Maps to update
     */
    where?: MapWhereInput
    /**
     * Limit how many Maps to update.
     */
    limit?: number
  }

  /**
   * Map updateManyAndReturn
   */
  export type MapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * The data used to update Maps.
     */
    data: XOR<MapUpdateManyMutationInput, MapUncheckedUpdateManyInput>
    /**
     * Filter which Maps to update
     */
    where?: MapWhereInput
    /**
     * Limit how many Maps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Map upsert
   */
  export type MapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * The filter to search for the Map to update in case it exists.
     */
    where: MapWhereUniqueInput
    /**
     * In case the Map found by the `where` argument doesn't exist, create a new Map with this data.
     */
    create: XOR<MapCreateInput, MapUncheckedCreateInput>
    /**
     * In case the Map was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MapUpdateInput, MapUncheckedUpdateInput>
  }

  /**
   * Map delete
   */
  export type MapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    /**
     * Filter which Map to delete.
     */
    where: MapWhereUniqueInput
  }

  /**
   * Map deleteMany
   */
  export type MapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maps to delete
     */
    where?: MapWhereInput
    /**
     * Limit how many Maps to delete.
     */
    limit?: number
  }

  /**
   * Map.resources
   */
  export type Map$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatasetResource
     */
    select?: DatasetResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatasetResource
     */
    omit?: DatasetResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatasetResourceInclude<ExtArgs> | null
    where?: DatasetResourceWhereInput
    orderBy?: DatasetResourceOrderByWithRelationInput | DatasetResourceOrderByWithRelationInput[]
    cursor?: DatasetResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DatasetResourceScalarFieldEnum | DatasetResourceScalarFieldEnum[]
  }

  /**
   * Map.layers
   */
  export type Map$layersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapLayerAssociation
     */
    select?: MapLayerAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapLayerAssociation
     */
    omit?: MapLayerAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapLayerAssociationInclude<ExtArgs> | null
    where?: MapLayerAssociationWhereInput
    orderBy?: MapLayerAssociationOrderByWithRelationInput | MapLayerAssociationOrderByWithRelationInput[]
    cursor?: MapLayerAssociationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MapLayerAssociationScalarFieldEnum | MapLayerAssociationScalarFieldEnum[]
  }

  /**
   * Map.category
   */
  export type Map$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Map.thumbnail
   */
  export type Map$thumbnailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Map.regions
   */
  export type Map$regionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    cursor?: RegionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Map.tags
   */
  export type Map$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Map without action
   */
  export type MapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
  }


  /**
   * Model Layer
   */

  export type AggregateLayer = {
    _count: LayerCountAggregateOutputType | null
    _avg: LayerAvgAggregateOutputType | null
    _sum: LayerSumAggregateOutputType | null
    _min: LayerMinAggregateOutputType | null
    _max: LayerMaxAggregateOutputType | null
  }

  export type LayerAvgAggregateOutputType = {
    minYear: number | null
    maxYear: number | null
  }

  export type LayerSumAggregateOutputType = {
    minYear: number | null
    maxYear: number | null
  }

  export type LayerMinAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    description: string | null
    filename: string | null
    status: $Enums.ContentStatus | null
    version: string | null
    categoryId: string | null
    type: $Enums.LayerType | null
    citationText: string | null
    codebookText: string | null
    sources: string | null
    license: string | null
    maturity: $Enums.DataMaturity | null
    minYear: number | null
    maxYear: number | null
    sourceType: $Enums.LayerSourceType | null
    sourceUrl: string | null
    downloadUrl: string | null
    thumbnail: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LayerMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    description: string | null
    filename: string | null
    status: $Enums.ContentStatus | null
    version: string | null
    categoryId: string | null
    type: $Enums.LayerType | null
    citationText: string | null
    codebookText: string | null
    sources: string | null
    license: string | null
    maturity: $Enums.DataMaturity | null
    minYear: number | null
    maxYear: number | null
    sourceType: $Enums.LayerSourceType | null
    sourceUrl: string | null
    downloadUrl: string | null
    thumbnail: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LayerCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    nameI18n: number
    description: number
    descriptionI18n: number
    filename: number
    status: number
    version: number
    categoryId: number
    type: number
    citationText: number
    citationTextI18n: number
    codebookText: number
    codebookTextI18n: number
    sources: number
    sourcesI18n: number
    license: number
    maturity: number
    minYear: number
    maxYear: number
    sourceType: number
    sourceUrl: number
    downloadUrl: number
    geoJsonData: number
    styleConfig: number
    thumbnail: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LayerAvgAggregateInputType = {
    minYear?: true
    maxYear?: true
  }

  export type LayerSumAggregateInputType = {
    minYear?: true
    maxYear?: true
  }

  export type LayerMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    filename?: true
    status?: true
    version?: true
    categoryId?: true
    type?: true
    citationText?: true
    codebookText?: true
    sources?: true
    license?: true
    maturity?: true
    minYear?: true
    maxYear?: true
    sourceType?: true
    sourceUrl?: true
    downloadUrl?: true
    thumbnail?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LayerMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    description?: true
    filename?: true
    status?: true
    version?: true
    categoryId?: true
    type?: true
    citationText?: true
    codebookText?: true
    sources?: true
    license?: true
    maturity?: true
    minYear?: true
    maxYear?: true
    sourceType?: true
    sourceUrl?: true
    downloadUrl?: true
    thumbnail?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LayerCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    nameI18n?: true
    description?: true
    descriptionI18n?: true
    filename?: true
    status?: true
    version?: true
    categoryId?: true
    type?: true
    citationText?: true
    citationTextI18n?: true
    codebookText?: true
    codebookTextI18n?: true
    sources?: true
    sourcesI18n?: true
    license?: true
    maturity?: true
    minYear?: true
    maxYear?: true
    sourceType?: true
    sourceUrl?: true
    downloadUrl?: true
    geoJsonData?: true
    styleConfig?: true
    thumbnail?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Layer to aggregate.
     */
    where?: LayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Layers to fetch.
     */
    orderBy?: LayerOrderByWithRelationInput | LayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Layers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Layers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Layers
    **/
    _count?: true | LayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LayerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LayerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LayerMaxAggregateInputType
  }

  export type GetLayerAggregateType<T extends LayerAggregateArgs> = {
        [P in keyof T & keyof AggregateLayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLayer[P]>
      : GetScalarType<T[P], AggregateLayer[P]>
  }




  export type LayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LayerWhereInput
    orderBy?: LayerOrderByWithAggregationInput | LayerOrderByWithAggregationInput[]
    by: LayerScalarFieldEnum[] | LayerScalarFieldEnum
    having?: LayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LayerCountAggregateInputType | true
    _avg?: LayerAvgAggregateInputType
    _sum?: LayerSumAggregateInputType
    _min?: LayerMinAggregateInputType
    _max?: LayerMaxAggregateInputType
  }

  export type LayerGroupByOutputType = {
    id: string
    slug: string
    name: string
    nameI18n: JsonValue | null
    description: string | null
    descriptionI18n: JsonValue | null
    filename: string | null
    status: $Enums.ContentStatus
    version: string | null
    categoryId: string | null
    type: $Enums.LayerType
    citationText: string | null
    citationTextI18n: JsonValue | null
    codebookText: string | null
    codebookTextI18n: JsonValue | null
    sources: string | null
    sourcesI18n: JsonValue | null
    license: string | null
    maturity: $Enums.DataMaturity
    minYear: number | null
    maxYear: number | null
    sourceType: $Enums.LayerSourceType
    sourceUrl: string | null
    downloadUrl: string | null
    geoJsonData: JsonValue | null
    styleConfig: JsonValue
    thumbnail: string | null
    createdAt: Date
    updatedAt: Date
    _count: LayerCountAggregateOutputType | null
    _avg: LayerAvgAggregateOutputType | null
    _sum: LayerSumAggregateOutputType | null
    _min: LayerMinAggregateOutputType | null
    _max: LayerMaxAggregateOutputType | null
  }

  type GetLayerGroupByPayload<T extends LayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LayerGroupByOutputType[P]>
            : GetScalarType<T[P], LayerGroupByOutputType[P]>
        }
      >
    >


  export type LayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    nameI18n?: boolean
    description?: boolean
    descriptionI18n?: boolean
    filename?: boolean
    status?: boolean
    version?: boolean
    categoryId?: boolean
    type?: boolean
    citationText?: boolean
    citationTextI18n?: boolean
    codebookText?: boolean
    codebookTextI18n?: boolean
    sources?: boolean
    sourcesI18n?: boolean
    license?: boolean
    maturity?: boolean
    minYear?: boolean
    maxYear?: boolean
    sourceType?: boolean
    sourceUrl?: boolean
    downloadUrl?: boolean
    geoJsonData?: boolean
    styleConfig?: boolean
    thumbnail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Layer$categoryArgs<ExtArgs>
    maps?: boolean | Layer$mapsArgs<ExtArgs>
    regions?: boolean | Layer$regionsArgs<ExtArgs>
    tags?: boolean | Layer$tagsArgs<ExtArgs>
    _count?: boolean | LayerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["layer"]>

  export type LayerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    nameI18n?: boolean
    description?: boolean
    descriptionI18n?: boolean
    filename?: boolean
    status?: boolean
    version?: boolean
    categoryId?: boolean
    type?: boolean
    citationText?: boolean
    citationTextI18n?: boolean
    codebookText?: boolean
    codebookTextI18n?: boolean
    sources?: boolean
    sourcesI18n?: boolean
    license?: boolean
    maturity?: boolean
    minYear?: boolean
    maxYear?: boolean
    sourceType?: boolean
    sourceUrl?: boolean
    downloadUrl?: boolean
    geoJsonData?: boolean
    styleConfig?: boolean
    thumbnail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Layer$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["layer"]>

  export type LayerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    nameI18n?: boolean
    description?: boolean
    descriptionI18n?: boolean
    filename?: boolean
    status?: boolean
    version?: boolean
    categoryId?: boolean
    type?: boolean
    citationText?: boolean
    citationTextI18n?: boolean
    codebookText?: boolean
    codebookTextI18n?: boolean
    sources?: boolean
    sourcesI18n?: boolean
    license?: boolean
    maturity?: boolean
    minYear?: boolean
    maxYear?: boolean
    sourceType?: boolean
    sourceUrl?: boolean
    downloadUrl?: boolean
    geoJsonData?: boolean
    styleConfig?: boolean
    thumbnail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Layer$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["layer"]>

  export type LayerSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    nameI18n?: boolean
    description?: boolean
    descriptionI18n?: boolean
    filename?: boolean
    status?: boolean
    version?: boolean
    categoryId?: boolean
    type?: boolean
    citationText?: boolean
    citationTextI18n?: boolean
    codebookText?: boolean
    codebookTextI18n?: boolean
    sources?: boolean
    sourcesI18n?: boolean
    license?: boolean
    maturity?: boolean
    minYear?: boolean
    maxYear?: boolean
    sourceType?: boolean
    sourceUrl?: boolean
    downloadUrl?: boolean
    geoJsonData?: boolean
    styleConfig?: boolean
    thumbnail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LayerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "name" | "nameI18n" | "description" | "descriptionI18n" | "filename" | "status" | "version" | "categoryId" | "type" | "citationText" | "citationTextI18n" | "codebookText" | "codebookTextI18n" | "sources" | "sourcesI18n" | "license" | "maturity" | "minYear" | "maxYear" | "sourceType" | "sourceUrl" | "downloadUrl" | "geoJsonData" | "styleConfig" | "thumbnail" | "createdAt" | "updatedAt", ExtArgs["result"]["layer"]>
  export type LayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Layer$categoryArgs<ExtArgs>
    maps?: boolean | Layer$mapsArgs<ExtArgs>
    regions?: boolean | Layer$regionsArgs<ExtArgs>
    tags?: boolean | Layer$tagsArgs<ExtArgs>
    _count?: boolean | LayerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LayerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Layer$categoryArgs<ExtArgs>
  }
  export type LayerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Layer$categoryArgs<ExtArgs>
  }

  export type $LayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Layer"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs> | null
      maps: Prisma.$MapLayerAssociationPayload<ExtArgs>[]
      regions: Prisma.$RegionPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      name: string
      nameI18n: Prisma.JsonValue | null
      description: string | null
      descriptionI18n: Prisma.JsonValue | null
      filename: string | null
      status: $Enums.ContentStatus
      version: string | null
      categoryId: string | null
      type: $Enums.LayerType
      citationText: string | null
      citationTextI18n: Prisma.JsonValue | null
      codebookText: string | null
      codebookTextI18n: Prisma.JsonValue | null
      sources: string | null
      sourcesI18n: Prisma.JsonValue | null
      license: string | null
      maturity: $Enums.DataMaturity
      minYear: number | null
      maxYear: number | null
      sourceType: $Enums.LayerSourceType
      sourceUrl: string | null
      downloadUrl: string | null
      geoJsonData: Prisma.JsonValue | null
      styleConfig: Prisma.JsonValue
      thumbnail: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["layer"]>
    composites: {}
  }

  type LayerGetPayload<S extends boolean | null | undefined | LayerDefaultArgs> = $Result.GetResult<Prisma.$LayerPayload, S>

  type LayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LayerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LayerCountAggregateInputType | true
    }

  export interface LayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Layer'], meta: { name: 'Layer' } }
    /**
     * Find zero or one Layer that matches the filter.
     * @param {LayerFindUniqueArgs} args - Arguments to find a Layer
     * @example
     * // Get one Layer
     * const layer = await prisma.layer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LayerFindUniqueArgs>(args: SelectSubset<T, LayerFindUniqueArgs<ExtArgs>>): Prisma__LayerClient<$Result.GetResult<Prisma.$LayerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Layer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LayerFindUniqueOrThrowArgs} args - Arguments to find a Layer
     * @example
     * // Get one Layer
     * const layer = await prisma.layer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LayerFindUniqueOrThrowArgs>(args: SelectSubset<T, LayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LayerClient<$Result.GetResult<Prisma.$LayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Layer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayerFindFirstArgs} args - Arguments to find a Layer
     * @example
     * // Get one Layer
     * const layer = await prisma.layer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LayerFindFirstArgs>(args?: SelectSubset<T, LayerFindFirstArgs<ExtArgs>>): Prisma__LayerClient<$Result.GetResult<Prisma.$LayerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Layer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayerFindFirstOrThrowArgs} args - Arguments to find a Layer
     * @example
     * // Get one Layer
     * const layer = await prisma.layer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LayerFindFirstOrThrowArgs>(args?: SelectSubset<T, LayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__LayerClient<$Result.GetResult<Prisma.$LayerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Layers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Layers
     * const layers = await prisma.layer.findMany()
     * 
     * // Get first 10 Layers
     * const layers = await prisma.layer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const layerWithIdOnly = await prisma.layer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LayerFindManyArgs>(args?: SelectSubset<T, LayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Layer.
     * @param {LayerCreateArgs} args - Arguments to create a Layer.
     * @example
     * // Create one Layer
     * const Layer = await prisma.layer.create({
     *   data: {
     *     // ... data to create a Layer
     *   }
     * })
     * 
     */
    create<T extends LayerCreateArgs>(args: SelectSubset<T, LayerCreateArgs<ExtArgs>>): Prisma__LayerClient<$Result.GetResult<Prisma.$LayerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Layers.
     * @param {LayerCreateManyArgs} args - Arguments to create many Layers.
     * @example
     * // Create many Layers
     * const layer = await prisma.layer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LayerCreateManyArgs>(args?: SelectSubset<T, LayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Layers and returns the data saved in the database.
     * @param {LayerCreateManyAndReturnArgs} args - Arguments to create many Layers.
     * @example
     * // Create many Layers
     * const layer = await prisma.layer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Layers and only return the `id`
     * const layerWithIdOnly = await prisma.layer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LayerCreateManyAndReturnArgs>(args?: SelectSubset<T, LayerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LayerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Layer.
     * @param {LayerDeleteArgs} args - Arguments to delete one Layer.
     * @example
     * // Delete one Layer
     * const Layer = await prisma.layer.delete({
     *   where: {
     *     // ... filter to delete one Layer
     *   }
     * })
     * 
     */
    delete<T extends LayerDeleteArgs>(args: SelectSubset<T, LayerDeleteArgs<ExtArgs>>): Prisma__LayerClient<$Result.GetResult<Prisma.$LayerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Layer.
     * @param {LayerUpdateArgs} args - Arguments to update one Layer.
     * @example
     * // Update one Layer
     * const layer = await prisma.layer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LayerUpdateArgs>(args: SelectSubset<T, LayerUpdateArgs<ExtArgs>>): Prisma__LayerClient<$Result.GetResult<Prisma.$LayerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Layers.
     * @param {LayerDeleteManyArgs} args - Arguments to filter Layers to delete.
     * @example
     * // Delete a few Layers
     * const { count } = await prisma.layer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LayerDeleteManyArgs>(args?: SelectSubset<T, LayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Layers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Layers
     * const layer = await prisma.layer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LayerUpdateManyArgs>(args: SelectSubset<T, LayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Layers and returns the data updated in the database.
     * @param {LayerUpdateManyAndReturnArgs} args - Arguments to update many Layers.
     * @example
     * // Update many Layers
     * const layer = await prisma.layer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Layers and only return the `id`
     * const layerWithIdOnly = await prisma.layer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LayerUpdateManyAndReturnArgs>(args: SelectSubset<T, LayerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LayerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Layer.
     * @param {LayerUpsertArgs} args - Arguments to update or create a Layer.
     * @example
     * // Update or create a Layer
     * const layer = await prisma.layer.upsert({
     *   create: {
     *     // ... data to create a Layer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Layer we want to update
     *   }
     * })
     */
    upsert<T extends LayerUpsertArgs>(args: SelectSubset<T, LayerUpsertArgs<ExtArgs>>): Prisma__LayerClient<$Result.GetResult<Prisma.$LayerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Layers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayerCountArgs} args - Arguments to filter Layers to count.
     * @example
     * // Count the number of Layers
     * const count = await prisma.layer.count({
     *   where: {
     *     // ... the filter for the Layers we want to count
     *   }
     * })
    **/
    count<T extends LayerCountArgs>(
      args?: Subset<T, LayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Layer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LayerAggregateArgs>(args: Subset<T, LayerAggregateArgs>): Prisma.PrismaPromise<GetLayerAggregateType<T>>

    /**
     * Group by Layer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LayerGroupByArgs['orderBy'] }
        : { orderBy?: LayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Layer model
   */
  readonly fields: LayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Layer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends Layer$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Layer$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    maps<T extends Layer$mapsArgs<ExtArgs> = {}>(args?: Subset<T, Layer$mapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapLayerAssociationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    regions<T extends Layer$regionsArgs<ExtArgs> = {}>(args?: Subset<T, Layer$regionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Layer$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Layer$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Layer model
   */
  interface LayerFieldRefs {
    readonly id: FieldRef<"Layer", 'String'>
    readonly slug: FieldRef<"Layer", 'String'>
    readonly name: FieldRef<"Layer", 'String'>
    readonly nameI18n: FieldRef<"Layer", 'Json'>
    readonly description: FieldRef<"Layer", 'String'>
    readonly descriptionI18n: FieldRef<"Layer", 'Json'>
    readonly filename: FieldRef<"Layer", 'String'>
    readonly status: FieldRef<"Layer", 'ContentStatus'>
    readonly version: FieldRef<"Layer", 'String'>
    readonly categoryId: FieldRef<"Layer", 'String'>
    readonly type: FieldRef<"Layer", 'LayerType'>
    readonly citationText: FieldRef<"Layer", 'String'>
    readonly citationTextI18n: FieldRef<"Layer", 'Json'>
    readonly codebookText: FieldRef<"Layer", 'String'>
    readonly codebookTextI18n: FieldRef<"Layer", 'Json'>
    readonly sources: FieldRef<"Layer", 'String'>
    readonly sourcesI18n: FieldRef<"Layer", 'Json'>
    readonly license: FieldRef<"Layer", 'String'>
    readonly maturity: FieldRef<"Layer", 'DataMaturity'>
    readonly minYear: FieldRef<"Layer", 'Int'>
    readonly maxYear: FieldRef<"Layer", 'Int'>
    readonly sourceType: FieldRef<"Layer", 'LayerSourceType'>
    readonly sourceUrl: FieldRef<"Layer", 'String'>
    readonly downloadUrl: FieldRef<"Layer", 'String'>
    readonly geoJsonData: FieldRef<"Layer", 'Json'>
    readonly styleConfig: FieldRef<"Layer", 'Json'>
    readonly thumbnail: FieldRef<"Layer", 'String'>
    readonly createdAt: FieldRef<"Layer", 'DateTime'>
    readonly updatedAt: FieldRef<"Layer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Layer findUnique
   */
  export type LayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layer
     */
    select?: LayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layer
     */
    omit?: LayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayerInclude<ExtArgs> | null
    /**
     * Filter, which Layer to fetch.
     */
    where: LayerWhereUniqueInput
  }

  /**
   * Layer findUniqueOrThrow
   */
  export type LayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layer
     */
    select?: LayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layer
     */
    omit?: LayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayerInclude<ExtArgs> | null
    /**
     * Filter, which Layer to fetch.
     */
    where: LayerWhereUniqueInput
  }

  /**
   * Layer findFirst
   */
  export type LayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layer
     */
    select?: LayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layer
     */
    omit?: LayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayerInclude<ExtArgs> | null
    /**
     * Filter, which Layer to fetch.
     */
    where?: LayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Layers to fetch.
     */
    orderBy?: LayerOrderByWithRelationInput | LayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Layers.
     */
    cursor?: LayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Layers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Layers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Layers.
     */
    distinct?: LayerScalarFieldEnum | LayerScalarFieldEnum[]
  }

  /**
   * Layer findFirstOrThrow
   */
  export type LayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layer
     */
    select?: LayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layer
     */
    omit?: LayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayerInclude<ExtArgs> | null
    /**
     * Filter, which Layer to fetch.
     */
    where?: LayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Layers to fetch.
     */
    orderBy?: LayerOrderByWithRelationInput | LayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Layers.
     */
    cursor?: LayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Layers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Layers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Layers.
     */
    distinct?: LayerScalarFieldEnum | LayerScalarFieldEnum[]
  }

  /**
   * Layer findMany
   */
  export type LayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layer
     */
    select?: LayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layer
     */
    omit?: LayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayerInclude<ExtArgs> | null
    /**
     * Filter, which Layers to fetch.
     */
    where?: LayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Layers to fetch.
     */
    orderBy?: LayerOrderByWithRelationInput | LayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Layers.
     */
    cursor?: LayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Layers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Layers.
     */
    skip?: number
    distinct?: LayerScalarFieldEnum | LayerScalarFieldEnum[]
  }

  /**
   * Layer create
   */
  export type LayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layer
     */
    select?: LayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layer
     */
    omit?: LayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayerInclude<ExtArgs> | null
    /**
     * The data needed to create a Layer.
     */
    data: XOR<LayerCreateInput, LayerUncheckedCreateInput>
  }

  /**
   * Layer createMany
   */
  export type LayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Layers.
     */
    data: LayerCreateManyInput | LayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Layer createManyAndReturn
   */
  export type LayerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layer
     */
    select?: LayerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Layer
     */
    omit?: LayerOmit<ExtArgs> | null
    /**
     * The data used to create many Layers.
     */
    data: LayerCreateManyInput | LayerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Layer update
   */
  export type LayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layer
     */
    select?: LayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layer
     */
    omit?: LayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayerInclude<ExtArgs> | null
    /**
     * The data needed to update a Layer.
     */
    data: XOR<LayerUpdateInput, LayerUncheckedUpdateInput>
    /**
     * Choose, which Layer to update.
     */
    where: LayerWhereUniqueInput
  }

  /**
   * Layer updateMany
   */
  export type LayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Layers.
     */
    data: XOR<LayerUpdateManyMutationInput, LayerUncheckedUpdateManyInput>
    /**
     * Filter which Layers to update
     */
    where?: LayerWhereInput
    /**
     * Limit how many Layers to update.
     */
    limit?: number
  }

  /**
   * Layer updateManyAndReturn
   */
  export type LayerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layer
     */
    select?: LayerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Layer
     */
    omit?: LayerOmit<ExtArgs> | null
    /**
     * The data used to update Layers.
     */
    data: XOR<LayerUpdateManyMutationInput, LayerUncheckedUpdateManyInput>
    /**
     * Filter which Layers to update
     */
    where?: LayerWhereInput
    /**
     * Limit how many Layers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Layer upsert
   */
  export type LayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layer
     */
    select?: LayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layer
     */
    omit?: LayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayerInclude<ExtArgs> | null
    /**
     * The filter to search for the Layer to update in case it exists.
     */
    where: LayerWhereUniqueInput
    /**
     * In case the Layer found by the `where` argument doesn't exist, create a new Layer with this data.
     */
    create: XOR<LayerCreateInput, LayerUncheckedCreateInput>
    /**
     * In case the Layer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LayerUpdateInput, LayerUncheckedUpdateInput>
  }

  /**
   * Layer delete
   */
  export type LayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layer
     */
    select?: LayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layer
     */
    omit?: LayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayerInclude<ExtArgs> | null
    /**
     * Filter which Layer to delete.
     */
    where: LayerWhereUniqueInput
  }

  /**
   * Layer deleteMany
   */
  export type LayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Layers to delete
     */
    where?: LayerWhereInput
    /**
     * Limit how many Layers to delete.
     */
    limit?: number
  }

  /**
   * Layer.category
   */
  export type Layer$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Layer.maps
   */
  export type Layer$mapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapLayerAssociation
     */
    select?: MapLayerAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapLayerAssociation
     */
    omit?: MapLayerAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapLayerAssociationInclude<ExtArgs> | null
    where?: MapLayerAssociationWhereInput
    orderBy?: MapLayerAssociationOrderByWithRelationInput | MapLayerAssociationOrderByWithRelationInput[]
    cursor?: MapLayerAssociationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MapLayerAssociationScalarFieldEnum | MapLayerAssociationScalarFieldEnum[]
  }

  /**
   * Layer.regions
   */
  export type Layer$regionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    cursor?: RegionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Layer.tags
   */
  export type Layer$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Layer without action
   */
  export type LayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layer
     */
    select?: LayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layer
     */
    omit?: LayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayerInclude<ExtArgs> | null
  }


  /**
   * Model MapLayerAssociation
   */

  export type AggregateMapLayerAssociation = {
    _count: MapLayerAssociationCountAggregateOutputType | null
    _avg: MapLayerAssociationAvgAggregateOutputType | null
    _sum: MapLayerAssociationSumAggregateOutputType | null
    _min: MapLayerAssociationMinAggregateOutputType | null
    _max: MapLayerAssociationMaxAggregateOutputType | null
  }

  export type MapLayerAssociationAvgAggregateOutputType = {
    zIndex: number | null
  }

  export type MapLayerAssociationSumAggregateOutputType = {
    zIndex: number | null
  }

  export type MapLayerAssociationMinAggregateOutputType = {
    id: string | null
    mapId: string | null
    layerId: string | null
    zIndex: number | null
    isVisible: boolean | null
    isVisibleByDefault: boolean | null
    createdAt: Date | null
  }

  export type MapLayerAssociationMaxAggregateOutputType = {
    id: string | null
    mapId: string | null
    layerId: string | null
    zIndex: number | null
    isVisible: boolean | null
    isVisibleByDefault: boolean | null
    createdAt: Date | null
  }

  export type MapLayerAssociationCountAggregateOutputType = {
    id: number
    mapId: number
    layerId: number
    zIndex: number
    isVisible: number
    isVisibleByDefault: number
    styleOverride: number
    interactionConfig: number
    createdAt: number
    _all: number
  }


  export type MapLayerAssociationAvgAggregateInputType = {
    zIndex?: true
  }

  export type MapLayerAssociationSumAggregateInputType = {
    zIndex?: true
  }

  export type MapLayerAssociationMinAggregateInputType = {
    id?: true
    mapId?: true
    layerId?: true
    zIndex?: true
    isVisible?: true
    isVisibleByDefault?: true
    createdAt?: true
  }

  export type MapLayerAssociationMaxAggregateInputType = {
    id?: true
    mapId?: true
    layerId?: true
    zIndex?: true
    isVisible?: true
    isVisibleByDefault?: true
    createdAt?: true
  }

  export type MapLayerAssociationCountAggregateInputType = {
    id?: true
    mapId?: true
    layerId?: true
    zIndex?: true
    isVisible?: true
    isVisibleByDefault?: true
    styleOverride?: true
    interactionConfig?: true
    createdAt?: true
    _all?: true
  }

  export type MapLayerAssociationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MapLayerAssociation to aggregate.
     */
    where?: MapLayerAssociationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapLayerAssociations to fetch.
     */
    orderBy?: MapLayerAssociationOrderByWithRelationInput | MapLayerAssociationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MapLayerAssociationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapLayerAssociations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapLayerAssociations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MapLayerAssociations
    **/
    _count?: true | MapLayerAssociationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MapLayerAssociationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MapLayerAssociationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MapLayerAssociationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MapLayerAssociationMaxAggregateInputType
  }

  export type GetMapLayerAssociationAggregateType<T extends MapLayerAssociationAggregateArgs> = {
        [P in keyof T & keyof AggregateMapLayerAssociation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMapLayerAssociation[P]>
      : GetScalarType<T[P], AggregateMapLayerAssociation[P]>
  }




  export type MapLayerAssociationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MapLayerAssociationWhereInput
    orderBy?: MapLayerAssociationOrderByWithAggregationInput | MapLayerAssociationOrderByWithAggregationInput[]
    by: MapLayerAssociationScalarFieldEnum[] | MapLayerAssociationScalarFieldEnum
    having?: MapLayerAssociationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MapLayerAssociationCountAggregateInputType | true
    _avg?: MapLayerAssociationAvgAggregateInputType
    _sum?: MapLayerAssociationSumAggregateInputType
    _min?: MapLayerAssociationMinAggregateInputType
    _max?: MapLayerAssociationMaxAggregateInputType
  }

  export type MapLayerAssociationGroupByOutputType = {
    id: string
    mapId: string
    layerId: string
    zIndex: number
    isVisible: boolean
    isVisibleByDefault: boolean
    styleOverride: JsonValue | null
    interactionConfig: JsonValue | null
    createdAt: Date
    _count: MapLayerAssociationCountAggregateOutputType | null
    _avg: MapLayerAssociationAvgAggregateOutputType | null
    _sum: MapLayerAssociationSumAggregateOutputType | null
    _min: MapLayerAssociationMinAggregateOutputType | null
    _max: MapLayerAssociationMaxAggregateOutputType | null
  }

  type GetMapLayerAssociationGroupByPayload<T extends MapLayerAssociationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MapLayerAssociationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MapLayerAssociationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MapLayerAssociationGroupByOutputType[P]>
            : GetScalarType<T[P], MapLayerAssociationGroupByOutputType[P]>
        }
      >
    >


  export type MapLayerAssociationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mapId?: boolean
    layerId?: boolean
    zIndex?: boolean
    isVisible?: boolean
    isVisibleByDefault?: boolean
    styleOverride?: boolean
    interactionConfig?: boolean
    createdAt?: boolean
    layer?: boolean | LayerDefaultArgs<ExtArgs>
    map?: boolean | MapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mapLayerAssociation"]>

  export type MapLayerAssociationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mapId?: boolean
    layerId?: boolean
    zIndex?: boolean
    isVisible?: boolean
    isVisibleByDefault?: boolean
    styleOverride?: boolean
    interactionConfig?: boolean
    createdAt?: boolean
    layer?: boolean | LayerDefaultArgs<ExtArgs>
    map?: boolean | MapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mapLayerAssociation"]>

  export type MapLayerAssociationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mapId?: boolean
    layerId?: boolean
    zIndex?: boolean
    isVisible?: boolean
    isVisibleByDefault?: boolean
    styleOverride?: boolean
    interactionConfig?: boolean
    createdAt?: boolean
    layer?: boolean | LayerDefaultArgs<ExtArgs>
    map?: boolean | MapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mapLayerAssociation"]>

  export type MapLayerAssociationSelectScalar = {
    id?: boolean
    mapId?: boolean
    layerId?: boolean
    zIndex?: boolean
    isVisible?: boolean
    isVisibleByDefault?: boolean
    styleOverride?: boolean
    interactionConfig?: boolean
    createdAt?: boolean
  }

  export type MapLayerAssociationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mapId" | "layerId" | "zIndex" | "isVisible" | "isVisibleByDefault" | "styleOverride" | "interactionConfig" | "createdAt", ExtArgs["result"]["mapLayerAssociation"]>
  export type MapLayerAssociationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    layer?: boolean | LayerDefaultArgs<ExtArgs>
    map?: boolean | MapDefaultArgs<ExtArgs>
  }
  export type MapLayerAssociationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    layer?: boolean | LayerDefaultArgs<ExtArgs>
    map?: boolean | MapDefaultArgs<ExtArgs>
  }
  export type MapLayerAssociationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    layer?: boolean | LayerDefaultArgs<ExtArgs>
    map?: boolean | MapDefaultArgs<ExtArgs>
  }

  export type $MapLayerAssociationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MapLayerAssociation"
    objects: {
      layer: Prisma.$LayerPayload<ExtArgs>
      map: Prisma.$MapPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mapId: string
      layerId: string
      zIndex: number
      isVisible: boolean
      isVisibleByDefault: boolean
      styleOverride: Prisma.JsonValue | null
      interactionConfig: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["mapLayerAssociation"]>
    composites: {}
  }

  type MapLayerAssociationGetPayload<S extends boolean | null | undefined | MapLayerAssociationDefaultArgs> = $Result.GetResult<Prisma.$MapLayerAssociationPayload, S>

  type MapLayerAssociationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MapLayerAssociationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MapLayerAssociationCountAggregateInputType | true
    }

  export interface MapLayerAssociationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MapLayerAssociation'], meta: { name: 'MapLayerAssociation' } }
    /**
     * Find zero or one MapLayerAssociation that matches the filter.
     * @param {MapLayerAssociationFindUniqueArgs} args - Arguments to find a MapLayerAssociation
     * @example
     * // Get one MapLayerAssociation
     * const mapLayerAssociation = await prisma.mapLayerAssociation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MapLayerAssociationFindUniqueArgs>(args: SelectSubset<T, MapLayerAssociationFindUniqueArgs<ExtArgs>>): Prisma__MapLayerAssociationClient<$Result.GetResult<Prisma.$MapLayerAssociationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MapLayerAssociation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MapLayerAssociationFindUniqueOrThrowArgs} args - Arguments to find a MapLayerAssociation
     * @example
     * // Get one MapLayerAssociation
     * const mapLayerAssociation = await prisma.mapLayerAssociation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MapLayerAssociationFindUniqueOrThrowArgs>(args: SelectSubset<T, MapLayerAssociationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MapLayerAssociationClient<$Result.GetResult<Prisma.$MapLayerAssociationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MapLayerAssociation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapLayerAssociationFindFirstArgs} args - Arguments to find a MapLayerAssociation
     * @example
     * // Get one MapLayerAssociation
     * const mapLayerAssociation = await prisma.mapLayerAssociation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MapLayerAssociationFindFirstArgs>(args?: SelectSubset<T, MapLayerAssociationFindFirstArgs<ExtArgs>>): Prisma__MapLayerAssociationClient<$Result.GetResult<Prisma.$MapLayerAssociationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MapLayerAssociation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapLayerAssociationFindFirstOrThrowArgs} args - Arguments to find a MapLayerAssociation
     * @example
     * // Get one MapLayerAssociation
     * const mapLayerAssociation = await prisma.mapLayerAssociation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MapLayerAssociationFindFirstOrThrowArgs>(args?: SelectSubset<T, MapLayerAssociationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MapLayerAssociationClient<$Result.GetResult<Prisma.$MapLayerAssociationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MapLayerAssociations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapLayerAssociationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MapLayerAssociations
     * const mapLayerAssociations = await prisma.mapLayerAssociation.findMany()
     * 
     * // Get first 10 MapLayerAssociations
     * const mapLayerAssociations = await prisma.mapLayerAssociation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mapLayerAssociationWithIdOnly = await prisma.mapLayerAssociation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MapLayerAssociationFindManyArgs>(args?: SelectSubset<T, MapLayerAssociationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapLayerAssociationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MapLayerAssociation.
     * @param {MapLayerAssociationCreateArgs} args - Arguments to create a MapLayerAssociation.
     * @example
     * // Create one MapLayerAssociation
     * const MapLayerAssociation = await prisma.mapLayerAssociation.create({
     *   data: {
     *     // ... data to create a MapLayerAssociation
     *   }
     * })
     * 
     */
    create<T extends MapLayerAssociationCreateArgs>(args: SelectSubset<T, MapLayerAssociationCreateArgs<ExtArgs>>): Prisma__MapLayerAssociationClient<$Result.GetResult<Prisma.$MapLayerAssociationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MapLayerAssociations.
     * @param {MapLayerAssociationCreateManyArgs} args - Arguments to create many MapLayerAssociations.
     * @example
     * // Create many MapLayerAssociations
     * const mapLayerAssociation = await prisma.mapLayerAssociation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MapLayerAssociationCreateManyArgs>(args?: SelectSubset<T, MapLayerAssociationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MapLayerAssociations and returns the data saved in the database.
     * @param {MapLayerAssociationCreateManyAndReturnArgs} args - Arguments to create many MapLayerAssociations.
     * @example
     * // Create many MapLayerAssociations
     * const mapLayerAssociation = await prisma.mapLayerAssociation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MapLayerAssociations and only return the `id`
     * const mapLayerAssociationWithIdOnly = await prisma.mapLayerAssociation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MapLayerAssociationCreateManyAndReturnArgs>(args?: SelectSubset<T, MapLayerAssociationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapLayerAssociationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MapLayerAssociation.
     * @param {MapLayerAssociationDeleteArgs} args - Arguments to delete one MapLayerAssociation.
     * @example
     * // Delete one MapLayerAssociation
     * const MapLayerAssociation = await prisma.mapLayerAssociation.delete({
     *   where: {
     *     // ... filter to delete one MapLayerAssociation
     *   }
     * })
     * 
     */
    delete<T extends MapLayerAssociationDeleteArgs>(args: SelectSubset<T, MapLayerAssociationDeleteArgs<ExtArgs>>): Prisma__MapLayerAssociationClient<$Result.GetResult<Prisma.$MapLayerAssociationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MapLayerAssociation.
     * @param {MapLayerAssociationUpdateArgs} args - Arguments to update one MapLayerAssociation.
     * @example
     * // Update one MapLayerAssociation
     * const mapLayerAssociation = await prisma.mapLayerAssociation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MapLayerAssociationUpdateArgs>(args: SelectSubset<T, MapLayerAssociationUpdateArgs<ExtArgs>>): Prisma__MapLayerAssociationClient<$Result.GetResult<Prisma.$MapLayerAssociationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MapLayerAssociations.
     * @param {MapLayerAssociationDeleteManyArgs} args - Arguments to filter MapLayerAssociations to delete.
     * @example
     * // Delete a few MapLayerAssociations
     * const { count } = await prisma.mapLayerAssociation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MapLayerAssociationDeleteManyArgs>(args?: SelectSubset<T, MapLayerAssociationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapLayerAssociations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapLayerAssociationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MapLayerAssociations
     * const mapLayerAssociation = await prisma.mapLayerAssociation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MapLayerAssociationUpdateManyArgs>(args: SelectSubset<T, MapLayerAssociationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MapLayerAssociations and returns the data updated in the database.
     * @param {MapLayerAssociationUpdateManyAndReturnArgs} args - Arguments to update many MapLayerAssociations.
     * @example
     * // Update many MapLayerAssociations
     * const mapLayerAssociation = await prisma.mapLayerAssociation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MapLayerAssociations and only return the `id`
     * const mapLayerAssociationWithIdOnly = await prisma.mapLayerAssociation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MapLayerAssociationUpdateManyAndReturnArgs>(args: SelectSubset<T, MapLayerAssociationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapLayerAssociationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MapLayerAssociation.
     * @param {MapLayerAssociationUpsertArgs} args - Arguments to update or create a MapLayerAssociation.
     * @example
     * // Update or create a MapLayerAssociation
     * const mapLayerAssociation = await prisma.mapLayerAssociation.upsert({
     *   create: {
     *     // ... data to create a MapLayerAssociation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MapLayerAssociation we want to update
     *   }
     * })
     */
    upsert<T extends MapLayerAssociationUpsertArgs>(args: SelectSubset<T, MapLayerAssociationUpsertArgs<ExtArgs>>): Prisma__MapLayerAssociationClient<$Result.GetResult<Prisma.$MapLayerAssociationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MapLayerAssociations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapLayerAssociationCountArgs} args - Arguments to filter MapLayerAssociations to count.
     * @example
     * // Count the number of MapLayerAssociations
     * const count = await prisma.mapLayerAssociation.count({
     *   where: {
     *     // ... the filter for the MapLayerAssociations we want to count
     *   }
     * })
    **/
    count<T extends MapLayerAssociationCountArgs>(
      args?: Subset<T, MapLayerAssociationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MapLayerAssociationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MapLayerAssociation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapLayerAssociationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MapLayerAssociationAggregateArgs>(args: Subset<T, MapLayerAssociationAggregateArgs>): Prisma.PrismaPromise<GetMapLayerAssociationAggregateType<T>>

    /**
     * Group by MapLayerAssociation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MapLayerAssociationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MapLayerAssociationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MapLayerAssociationGroupByArgs['orderBy'] }
        : { orderBy?: MapLayerAssociationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MapLayerAssociationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMapLayerAssociationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MapLayerAssociation model
   */
  readonly fields: MapLayerAssociationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MapLayerAssociation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MapLayerAssociationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    layer<T extends LayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LayerDefaultArgs<ExtArgs>>): Prisma__LayerClient<$Result.GetResult<Prisma.$LayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    map<T extends MapDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MapDefaultArgs<ExtArgs>>): Prisma__MapClient<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MapLayerAssociation model
   */
  interface MapLayerAssociationFieldRefs {
    readonly id: FieldRef<"MapLayerAssociation", 'String'>
    readonly mapId: FieldRef<"MapLayerAssociation", 'String'>
    readonly layerId: FieldRef<"MapLayerAssociation", 'String'>
    readonly zIndex: FieldRef<"MapLayerAssociation", 'Int'>
    readonly isVisible: FieldRef<"MapLayerAssociation", 'Boolean'>
    readonly isVisibleByDefault: FieldRef<"MapLayerAssociation", 'Boolean'>
    readonly styleOverride: FieldRef<"MapLayerAssociation", 'Json'>
    readonly interactionConfig: FieldRef<"MapLayerAssociation", 'Json'>
    readonly createdAt: FieldRef<"MapLayerAssociation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MapLayerAssociation findUnique
   */
  export type MapLayerAssociationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapLayerAssociation
     */
    select?: MapLayerAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapLayerAssociation
     */
    omit?: MapLayerAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapLayerAssociationInclude<ExtArgs> | null
    /**
     * Filter, which MapLayerAssociation to fetch.
     */
    where: MapLayerAssociationWhereUniqueInput
  }

  /**
   * MapLayerAssociation findUniqueOrThrow
   */
  export type MapLayerAssociationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapLayerAssociation
     */
    select?: MapLayerAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapLayerAssociation
     */
    omit?: MapLayerAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapLayerAssociationInclude<ExtArgs> | null
    /**
     * Filter, which MapLayerAssociation to fetch.
     */
    where: MapLayerAssociationWhereUniqueInput
  }

  /**
   * MapLayerAssociation findFirst
   */
  export type MapLayerAssociationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapLayerAssociation
     */
    select?: MapLayerAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapLayerAssociation
     */
    omit?: MapLayerAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapLayerAssociationInclude<ExtArgs> | null
    /**
     * Filter, which MapLayerAssociation to fetch.
     */
    where?: MapLayerAssociationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapLayerAssociations to fetch.
     */
    orderBy?: MapLayerAssociationOrderByWithRelationInput | MapLayerAssociationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MapLayerAssociations.
     */
    cursor?: MapLayerAssociationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapLayerAssociations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapLayerAssociations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MapLayerAssociations.
     */
    distinct?: MapLayerAssociationScalarFieldEnum | MapLayerAssociationScalarFieldEnum[]
  }

  /**
   * MapLayerAssociation findFirstOrThrow
   */
  export type MapLayerAssociationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapLayerAssociation
     */
    select?: MapLayerAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapLayerAssociation
     */
    omit?: MapLayerAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapLayerAssociationInclude<ExtArgs> | null
    /**
     * Filter, which MapLayerAssociation to fetch.
     */
    where?: MapLayerAssociationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapLayerAssociations to fetch.
     */
    orderBy?: MapLayerAssociationOrderByWithRelationInput | MapLayerAssociationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MapLayerAssociations.
     */
    cursor?: MapLayerAssociationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapLayerAssociations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapLayerAssociations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MapLayerAssociations.
     */
    distinct?: MapLayerAssociationScalarFieldEnum | MapLayerAssociationScalarFieldEnum[]
  }

  /**
   * MapLayerAssociation findMany
   */
  export type MapLayerAssociationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapLayerAssociation
     */
    select?: MapLayerAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapLayerAssociation
     */
    omit?: MapLayerAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapLayerAssociationInclude<ExtArgs> | null
    /**
     * Filter, which MapLayerAssociations to fetch.
     */
    where?: MapLayerAssociationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MapLayerAssociations to fetch.
     */
    orderBy?: MapLayerAssociationOrderByWithRelationInput | MapLayerAssociationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MapLayerAssociations.
     */
    cursor?: MapLayerAssociationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MapLayerAssociations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MapLayerAssociations.
     */
    skip?: number
    distinct?: MapLayerAssociationScalarFieldEnum | MapLayerAssociationScalarFieldEnum[]
  }

  /**
   * MapLayerAssociation create
   */
  export type MapLayerAssociationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapLayerAssociation
     */
    select?: MapLayerAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapLayerAssociation
     */
    omit?: MapLayerAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapLayerAssociationInclude<ExtArgs> | null
    /**
     * The data needed to create a MapLayerAssociation.
     */
    data: XOR<MapLayerAssociationCreateInput, MapLayerAssociationUncheckedCreateInput>
  }

  /**
   * MapLayerAssociation createMany
   */
  export type MapLayerAssociationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MapLayerAssociations.
     */
    data: MapLayerAssociationCreateManyInput | MapLayerAssociationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MapLayerAssociation createManyAndReturn
   */
  export type MapLayerAssociationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapLayerAssociation
     */
    select?: MapLayerAssociationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MapLayerAssociation
     */
    omit?: MapLayerAssociationOmit<ExtArgs> | null
    /**
     * The data used to create many MapLayerAssociations.
     */
    data: MapLayerAssociationCreateManyInput | MapLayerAssociationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapLayerAssociationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MapLayerAssociation update
   */
  export type MapLayerAssociationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapLayerAssociation
     */
    select?: MapLayerAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapLayerAssociation
     */
    omit?: MapLayerAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapLayerAssociationInclude<ExtArgs> | null
    /**
     * The data needed to update a MapLayerAssociation.
     */
    data: XOR<MapLayerAssociationUpdateInput, MapLayerAssociationUncheckedUpdateInput>
    /**
     * Choose, which MapLayerAssociation to update.
     */
    where: MapLayerAssociationWhereUniqueInput
  }

  /**
   * MapLayerAssociation updateMany
   */
  export type MapLayerAssociationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MapLayerAssociations.
     */
    data: XOR<MapLayerAssociationUpdateManyMutationInput, MapLayerAssociationUncheckedUpdateManyInput>
    /**
     * Filter which MapLayerAssociations to update
     */
    where?: MapLayerAssociationWhereInput
    /**
     * Limit how many MapLayerAssociations to update.
     */
    limit?: number
  }

  /**
   * MapLayerAssociation updateManyAndReturn
   */
  export type MapLayerAssociationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapLayerAssociation
     */
    select?: MapLayerAssociationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MapLayerAssociation
     */
    omit?: MapLayerAssociationOmit<ExtArgs> | null
    /**
     * The data used to update MapLayerAssociations.
     */
    data: XOR<MapLayerAssociationUpdateManyMutationInput, MapLayerAssociationUncheckedUpdateManyInput>
    /**
     * Filter which MapLayerAssociations to update
     */
    where?: MapLayerAssociationWhereInput
    /**
     * Limit how many MapLayerAssociations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapLayerAssociationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MapLayerAssociation upsert
   */
  export type MapLayerAssociationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapLayerAssociation
     */
    select?: MapLayerAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapLayerAssociation
     */
    omit?: MapLayerAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapLayerAssociationInclude<ExtArgs> | null
    /**
     * The filter to search for the MapLayerAssociation to update in case it exists.
     */
    where: MapLayerAssociationWhereUniqueInput
    /**
     * In case the MapLayerAssociation found by the `where` argument doesn't exist, create a new MapLayerAssociation with this data.
     */
    create: XOR<MapLayerAssociationCreateInput, MapLayerAssociationUncheckedCreateInput>
    /**
     * In case the MapLayerAssociation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MapLayerAssociationUpdateInput, MapLayerAssociationUncheckedUpdateInput>
  }

  /**
   * MapLayerAssociation delete
   */
  export type MapLayerAssociationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapLayerAssociation
     */
    select?: MapLayerAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapLayerAssociation
     */
    omit?: MapLayerAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapLayerAssociationInclude<ExtArgs> | null
    /**
     * Filter which MapLayerAssociation to delete.
     */
    where: MapLayerAssociationWhereUniqueInput
  }

  /**
   * MapLayerAssociation deleteMany
   */
  export type MapLayerAssociationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MapLayerAssociations to delete
     */
    where?: MapLayerAssociationWhereInput
    /**
     * Limit how many MapLayerAssociations to delete.
     */
    limit?: number
  }

  /**
   * MapLayerAssociation without action
   */
  export type MapLayerAssociationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MapLayerAssociation
     */
    select?: MapLayerAssociationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MapLayerAssociation
     */
    omit?: MapLayerAssociationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapLayerAssociationInclude<ExtArgs> | null
  }


  /**
   * Model Collection
   */

  export type AggregateCollection = {
    _count: CollectionCountAggregateOutputType | null
    _avg: CollectionAvgAggregateOutputType | null
    _sum: CollectionSumAggregateOutputType | null
    _min: CollectionMinAggregateOutputType | null
    _max: CollectionMaxAggregateOutputType | null
  }

  export type CollectionAvgAggregateOutputType = {
    yearMax: number | null
    yearMin: number | null
  }

  export type CollectionSumAggregateOutputType = {
    yearMax: number | null
    yearMin: number | null
  }

  export type CollectionMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    thumbnailId: string | null
    name: string | null
    referenceCode: string | null
    yearMax: number | null
    yearMin: number | null
  }

  export type CollectionMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    thumbnailId: string | null
    name: string | null
    referenceCode: string | null
    yearMax: number | null
    yearMin: number | null
  }

  export type CollectionCountAggregateOutputType = {
    id: number
    nameI18n: number
    descriptionI18n: number
    createdAt: number
    thumbnailId: number
    name: number
    referenceCode: number
    yearMax: number
    yearMin: number
    _all: number
  }


  export type CollectionAvgAggregateInputType = {
    yearMax?: true
    yearMin?: true
  }

  export type CollectionSumAggregateInputType = {
    yearMax?: true
    yearMin?: true
  }

  export type CollectionMinAggregateInputType = {
    id?: true
    createdAt?: true
    thumbnailId?: true
    name?: true
    referenceCode?: true
    yearMax?: true
    yearMin?: true
  }

  export type CollectionMaxAggregateInputType = {
    id?: true
    createdAt?: true
    thumbnailId?: true
    name?: true
    referenceCode?: true
    yearMax?: true
    yearMin?: true
  }

  export type CollectionCountAggregateInputType = {
    id?: true
    nameI18n?: true
    descriptionI18n?: true
    createdAt?: true
    thumbnailId?: true
    name?: true
    referenceCode?: true
    yearMax?: true
    yearMin?: true
    _all?: true
  }

  export type CollectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Collection to aggregate.
     */
    where?: CollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Collections
    **/
    _count?: true | CollectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CollectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CollectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionMaxAggregateInputType
  }

  export type GetCollectionAggregateType<T extends CollectionAggregateArgs> = {
        [P in keyof T & keyof AggregateCollection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollection[P]>
      : GetScalarType<T[P], AggregateCollection[P]>
  }




  export type CollectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CollectionWhereInput
    orderBy?: CollectionOrderByWithAggregationInput | CollectionOrderByWithAggregationInput[]
    by: CollectionScalarFieldEnum[] | CollectionScalarFieldEnum
    having?: CollectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionCountAggregateInputType | true
    _avg?: CollectionAvgAggregateInputType
    _sum?: CollectionSumAggregateInputType
    _min?: CollectionMinAggregateInputType
    _max?: CollectionMaxAggregateInputType
  }

  export type CollectionGroupByOutputType = {
    id: string
    nameI18n: JsonValue
    descriptionI18n: JsonValue | null
    createdAt: Date
    thumbnailId: string | null
    name: string
    referenceCode: string | null
    yearMax: number | null
    yearMin: number | null
    _count: CollectionCountAggregateOutputType | null
    _avg: CollectionAvgAggregateOutputType | null
    _sum: CollectionSumAggregateOutputType | null
    _min: CollectionMinAggregateOutputType | null
    _max: CollectionMaxAggregateOutputType | null
  }

  type GetCollectionGroupByPayload<T extends CollectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CollectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionGroupByOutputType[P]>
        }
      >
    >


  export type CollectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nameI18n?: boolean
    descriptionI18n?: boolean
    createdAt?: boolean
    thumbnailId?: boolean
    name?: boolean
    referenceCode?: boolean
    yearMax?: boolean
    yearMin?: boolean
    thumbnail?: boolean | Collection$thumbnailArgs<ExtArgs>
    series?: boolean | Collection$seriesArgs<ExtArgs>
    regions?: boolean | Collection$regionsArgs<ExtArgs>
    tags?: boolean | Collection$tagsArgs<ExtArgs>
    _count?: boolean | CollectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["collection"]>

  export type CollectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nameI18n?: boolean
    descriptionI18n?: boolean
    createdAt?: boolean
    thumbnailId?: boolean
    name?: boolean
    referenceCode?: boolean
    yearMax?: boolean
    yearMin?: boolean
    thumbnail?: boolean | Collection$thumbnailArgs<ExtArgs>
  }, ExtArgs["result"]["collection"]>

  export type CollectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nameI18n?: boolean
    descriptionI18n?: boolean
    createdAt?: boolean
    thumbnailId?: boolean
    name?: boolean
    referenceCode?: boolean
    yearMax?: boolean
    yearMin?: boolean
    thumbnail?: boolean | Collection$thumbnailArgs<ExtArgs>
  }, ExtArgs["result"]["collection"]>

  export type CollectionSelectScalar = {
    id?: boolean
    nameI18n?: boolean
    descriptionI18n?: boolean
    createdAt?: boolean
    thumbnailId?: boolean
    name?: boolean
    referenceCode?: boolean
    yearMax?: boolean
    yearMin?: boolean
  }

  export type CollectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nameI18n" | "descriptionI18n" | "createdAt" | "thumbnailId" | "name" | "referenceCode" | "yearMax" | "yearMin", ExtArgs["result"]["collection"]>
  export type CollectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thumbnail?: boolean | Collection$thumbnailArgs<ExtArgs>
    series?: boolean | Collection$seriesArgs<ExtArgs>
    regions?: boolean | Collection$regionsArgs<ExtArgs>
    tags?: boolean | Collection$tagsArgs<ExtArgs>
    _count?: boolean | CollectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CollectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thumbnail?: boolean | Collection$thumbnailArgs<ExtArgs>
  }
  export type CollectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thumbnail?: boolean | Collection$thumbnailArgs<ExtArgs>
  }

  export type $CollectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Collection"
    objects: {
      thumbnail: Prisma.$MediaPayload<ExtArgs> | null
      series: Prisma.$SeriesPayload<ExtArgs>[]
      regions: Prisma.$RegionPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nameI18n: Prisma.JsonValue
      descriptionI18n: Prisma.JsonValue | null
      createdAt: Date
      thumbnailId: string | null
      name: string
      referenceCode: string | null
      yearMax: number | null
      yearMin: number | null
    }, ExtArgs["result"]["collection"]>
    composites: {}
  }

  type CollectionGetPayload<S extends boolean | null | undefined | CollectionDefaultArgs> = $Result.GetResult<Prisma.$CollectionPayload, S>

  type CollectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CollectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CollectionCountAggregateInputType | true
    }

  export interface CollectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Collection'], meta: { name: 'Collection' } }
    /**
     * Find zero or one Collection that matches the filter.
     * @param {CollectionFindUniqueArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CollectionFindUniqueArgs>(args: SelectSubset<T, CollectionFindUniqueArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Collection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CollectionFindUniqueOrThrowArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CollectionFindUniqueOrThrowArgs>(args: SelectSubset<T, CollectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Collection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionFindFirstArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CollectionFindFirstArgs>(args?: SelectSubset<T, CollectionFindFirstArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Collection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionFindFirstOrThrowArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CollectionFindFirstOrThrowArgs>(args?: SelectSubset<T, CollectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Collections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collections
     * const collections = await prisma.collection.findMany()
     * 
     * // Get first 10 Collections
     * const collections = await prisma.collection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectionWithIdOnly = await prisma.collection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CollectionFindManyArgs>(args?: SelectSubset<T, CollectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Collection.
     * @param {CollectionCreateArgs} args - Arguments to create a Collection.
     * @example
     * // Create one Collection
     * const Collection = await prisma.collection.create({
     *   data: {
     *     // ... data to create a Collection
     *   }
     * })
     * 
     */
    create<T extends CollectionCreateArgs>(args: SelectSubset<T, CollectionCreateArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Collections.
     * @param {CollectionCreateManyArgs} args - Arguments to create many Collections.
     * @example
     * // Create many Collections
     * const collection = await prisma.collection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CollectionCreateManyArgs>(args?: SelectSubset<T, CollectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Collections and returns the data saved in the database.
     * @param {CollectionCreateManyAndReturnArgs} args - Arguments to create many Collections.
     * @example
     * // Create many Collections
     * const collection = await prisma.collection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Collections and only return the `id`
     * const collectionWithIdOnly = await prisma.collection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CollectionCreateManyAndReturnArgs>(args?: SelectSubset<T, CollectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Collection.
     * @param {CollectionDeleteArgs} args - Arguments to delete one Collection.
     * @example
     * // Delete one Collection
     * const Collection = await prisma.collection.delete({
     *   where: {
     *     // ... filter to delete one Collection
     *   }
     * })
     * 
     */
    delete<T extends CollectionDeleteArgs>(args: SelectSubset<T, CollectionDeleteArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Collection.
     * @param {CollectionUpdateArgs} args - Arguments to update one Collection.
     * @example
     * // Update one Collection
     * const collection = await prisma.collection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CollectionUpdateArgs>(args: SelectSubset<T, CollectionUpdateArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Collections.
     * @param {CollectionDeleteManyArgs} args - Arguments to filter Collections to delete.
     * @example
     * // Delete a few Collections
     * const { count } = await prisma.collection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CollectionDeleteManyArgs>(args?: SelectSubset<T, CollectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collections
     * const collection = await prisma.collection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CollectionUpdateManyArgs>(args: SelectSubset<T, CollectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collections and returns the data updated in the database.
     * @param {CollectionUpdateManyAndReturnArgs} args - Arguments to update many Collections.
     * @example
     * // Update many Collections
     * const collection = await prisma.collection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Collections and only return the `id`
     * const collectionWithIdOnly = await prisma.collection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CollectionUpdateManyAndReturnArgs>(args: SelectSubset<T, CollectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Collection.
     * @param {CollectionUpsertArgs} args - Arguments to update or create a Collection.
     * @example
     * // Update or create a Collection
     * const collection = await prisma.collection.upsert({
     *   create: {
     *     // ... data to create a Collection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collection we want to update
     *   }
     * })
     */
    upsert<T extends CollectionUpsertArgs>(args: SelectSubset<T, CollectionUpsertArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionCountArgs} args - Arguments to filter Collections to count.
     * @example
     * // Count the number of Collections
     * const count = await prisma.collection.count({
     *   where: {
     *     // ... the filter for the Collections we want to count
     *   }
     * })
    **/
    count<T extends CollectionCountArgs>(
      args?: Subset<T, CollectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionAggregateArgs>(args: Subset<T, CollectionAggregateArgs>): Prisma.PrismaPromise<GetCollectionAggregateType<T>>

    /**
     * Group by Collection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollectionGroupByArgs['orderBy'] }
        : { orderBy?: CollectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Collection model
   */
  readonly fields: CollectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Collection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CollectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    thumbnail<T extends Collection$thumbnailArgs<ExtArgs> = {}>(args?: Subset<T, Collection$thumbnailArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    series<T extends Collection$seriesArgs<ExtArgs> = {}>(args?: Subset<T, Collection$seriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    regions<T extends Collection$regionsArgs<ExtArgs> = {}>(args?: Subset<T, Collection$regionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Collection$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Collection$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Collection model
   */
  interface CollectionFieldRefs {
    readonly id: FieldRef<"Collection", 'String'>
    readonly nameI18n: FieldRef<"Collection", 'Json'>
    readonly descriptionI18n: FieldRef<"Collection", 'Json'>
    readonly createdAt: FieldRef<"Collection", 'DateTime'>
    readonly thumbnailId: FieldRef<"Collection", 'String'>
    readonly name: FieldRef<"Collection", 'String'>
    readonly referenceCode: FieldRef<"Collection", 'String'>
    readonly yearMax: FieldRef<"Collection", 'Int'>
    readonly yearMin: FieldRef<"Collection", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Collection findUnique
   */
  export type CollectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collection to fetch.
     */
    where: CollectionWhereUniqueInput
  }

  /**
   * Collection findUniqueOrThrow
   */
  export type CollectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collection to fetch.
     */
    where: CollectionWhereUniqueInput
  }

  /**
   * Collection findFirst
   */
  export type CollectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collection to fetch.
     */
    where?: CollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Collections.
     */
    cursor?: CollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Collections.
     */
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * Collection findFirstOrThrow
   */
  export type CollectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collection to fetch.
     */
    where?: CollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Collections.
     */
    cursor?: CollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Collections.
     */
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * Collection findMany
   */
  export type CollectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter, which Collections to fetch.
     */
    where?: CollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Collections to fetch.
     */
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Collections.
     */
    cursor?: CollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Collections.
     */
    skip?: number
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * Collection create
   */
  export type CollectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Collection.
     */
    data?: XOR<CollectionCreateInput, CollectionUncheckedCreateInput>
  }

  /**
   * Collection createMany
   */
  export type CollectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Collections.
     */
    data: CollectionCreateManyInput | CollectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Collection createManyAndReturn
   */
  export type CollectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * The data used to create many Collections.
     */
    data: CollectionCreateManyInput | CollectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Collection update
   */
  export type CollectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Collection.
     */
    data: XOR<CollectionUpdateInput, CollectionUncheckedUpdateInput>
    /**
     * Choose, which Collection to update.
     */
    where: CollectionWhereUniqueInput
  }

  /**
   * Collection updateMany
   */
  export type CollectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Collections.
     */
    data: XOR<CollectionUpdateManyMutationInput, CollectionUncheckedUpdateManyInput>
    /**
     * Filter which Collections to update
     */
    where?: CollectionWhereInput
    /**
     * Limit how many Collections to update.
     */
    limit?: number
  }

  /**
   * Collection updateManyAndReturn
   */
  export type CollectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * The data used to update Collections.
     */
    data: XOR<CollectionUpdateManyMutationInput, CollectionUncheckedUpdateManyInput>
    /**
     * Filter which Collections to update
     */
    where?: CollectionWhereInput
    /**
     * Limit how many Collections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Collection upsert
   */
  export type CollectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Collection to update in case it exists.
     */
    where: CollectionWhereUniqueInput
    /**
     * In case the Collection found by the `where` argument doesn't exist, create a new Collection with this data.
     */
    create: XOR<CollectionCreateInput, CollectionUncheckedCreateInput>
    /**
     * In case the Collection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CollectionUpdateInput, CollectionUncheckedUpdateInput>
  }

  /**
   * Collection delete
   */
  export type CollectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    /**
     * Filter which Collection to delete.
     */
    where: CollectionWhereUniqueInput
  }

  /**
   * Collection deleteMany
   */
  export type CollectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Collections to delete
     */
    where?: CollectionWhereInput
    /**
     * Limit how many Collections to delete.
     */
    limit?: number
  }

  /**
   * Collection.thumbnail
   */
  export type Collection$thumbnailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Collection.series
   */
  export type Collection$seriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    where?: SeriesWhereInput
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    cursor?: SeriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Collection.regions
   */
  export type Collection$regionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    cursor?: RegionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Collection.tags
   */
  export type Collection$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Collection without action
   */
  export type CollectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
  }


  /**
   * Model Series
   */

  export type AggregateSeries = {
    _count: SeriesCountAggregateOutputType | null
    _avg: SeriesAvgAggregateOutputType | null
    _sum: SeriesSumAggregateOutputType | null
    _min: SeriesMinAggregateOutputType | null
    _max: SeriesMaxAggregateOutputType | null
  }

  export type SeriesAvgAggregateOutputType = {
    indexNumber: number | null
    yearMax: number | null
    yearMin: number | null
  }

  export type SeriesSumAggregateOutputType = {
    indexNumber: number | null
    yearMax: number | null
    yearMin: number | null
  }

  export type SeriesMinAggregateOutputType = {
    id: string | null
    collectionId: string | null
    indexNumber: number | null
    volumeLabelFormat: string | null
    thumbnailId: string | null
    createdAt: Date | null
    slug: string | null
    name: string | null
    description: string | null
    license: string | null
    period: string | null
    sourceLink: string | null
    sources: string | null
    author: string | null
    editor: string | null
    referenceCode: string | null
    yearMax: number | null
    yearMin: number | null
  }

  export type SeriesMaxAggregateOutputType = {
    id: string | null
    collectionId: string | null
    indexNumber: number | null
    volumeLabelFormat: string | null
    thumbnailId: string | null
    createdAt: Date | null
    slug: string | null
    name: string | null
    description: string | null
    license: string | null
    period: string | null
    sourceLink: string | null
    sources: string | null
    author: string | null
    editor: string | null
    referenceCode: string | null
    yearMax: number | null
    yearMin: number | null
  }

  export type SeriesCountAggregateOutputType = {
    id: number
    collectionId: number
    nameI18n: number
    descriptionI18n: number
    indexNumber: number
    volumeLabelFormat: number
    thumbnailId: number
    createdAt: number
    slug: number
    name: number
    description: number
    license: number
    period: number
    sourceLink: number
    sources: number
    author: number
    editor: number
    referenceCode: number
    yearMax: number
    yearMin: number
    languages: number
    _all: number
  }


  export type SeriesAvgAggregateInputType = {
    indexNumber?: true
    yearMax?: true
    yearMin?: true
  }

  export type SeriesSumAggregateInputType = {
    indexNumber?: true
    yearMax?: true
    yearMin?: true
  }

  export type SeriesMinAggregateInputType = {
    id?: true
    collectionId?: true
    indexNumber?: true
    volumeLabelFormat?: true
    thumbnailId?: true
    createdAt?: true
    slug?: true
    name?: true
    description?: true
    license?: true
    period?: true
    sourceLink?: true
    sources?: true
    author?: true
    editor?: true
    referenceCode?: true
    yearMax?: true
    yearMin?: true
  }

  export type SeriesMaxAggregateInputType = {
    id?: true
    collectionId?: true
    indexNumber?: true
    volumeLabelFormat?: true
    thumbnailId?: true
    createdAt?: true
    slug?: true
    name?: true
    description?: true
    license?: true
    period?: true
    sourceLink?: true
    sources?: true
    author?: true
    editor?: true
    referenceCode?: true
    yearMax?: true
    yearMin?: true
  }

  export type SeriesCountAggregateInputType = {
    id?: true
    collectionId?: true
    nameI18n?: true
    descriptionI18n?: true
    indexNumber?: true
    volumeLabelFormat?: true
    thumbnailId?: true
    createdAt?: true
    slug?: true
    name?: true
    description?: true
    license?: true
    period?: true
    sourceLink?: true
    sources?: true
    author?: true
    editor?: true
    referenceCode?: true
    yearMax?: true
    yearMin?: true
    languages?: true
    _all?: true
  }

  export type SeriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Series to aggregate.
     */
    where?: SeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Series.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Series
    **/
    _count?: true | SeriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeriesMaxAggregateInputType
  }

  export type GetSeriesAggregateType<T extends SeriesAggregateArgs> = {
        [P in keyof T & keyof AggregateSeries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeries[P]>
      : GetScalarType<T[P], AggregateSeries[P]>
  }




  export type SeriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeriesWhereInput
    orderBy?: SeriesOrderByWithAggregationInput | SeriesOrderByWithAggregationInput[]
    by: SeriesScalarFieldEnum[] | SeriesScalarFieldEnum
    having?: SeriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeriesCountAggregateInputType | true
    _avg?: SeriesAvgAggregateInputType
    _sum?: SeriesSumAggregateInputType
    _min?: SeriesMinAggregateInputType
    _max?: SeriesMaxAggregateInputType
  }

  export type SeriesGroupByOutputType = {
    id: string
    collectionId: string | null
    nameI18n: JsonValue
    descriptionI18n: JsonValue | null
    indexNumber: number | null
    volumeLabelFormat: string | null
    thumbnailId: string | null
    createdAt: Date
    slug: string
    name: string
    description: string | null
    license: string | null
    period: string | null
    sourceLink: string | null
    sources: string | null
    author: string | null
    editor: string | null
    referenceCode: string | null
    yearMax: number | null
    yearMin: number | null
    languages: $Enums.ContentLanguage[]
    _count: SeriesCountAggregateOutputType | null
    _avg: SeriesAvgAggregateOutputType | null
    _sum: SeriesSumAggregateOutputType | null
    _min: SeriesMinAggregateOutputType | null
    _max: SeriesMaxAggregateOutputType | null
  }

  type GetSeriesGroupByPayload<T extends SeriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeriesGroupByOutputType[P]>
            : GetScalarType<T[P], SeriesGroupByOutputType[P]>
        }
      >
    >


  export type SeriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionId?: boolean
    nameI18n?: boolean
    descriptionI18n?: boolean
    indexNumber?: boolean
    volumeLabelFormat?: boolean
    thumbnailId?: boolean
    createdAt?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    license?: boolean
    period?: boolean
    sourceLink?: boolean
    sources?: boolean
    author?: boolean
    editor?: boolean
    referenceCode?: boolean
    yearMax?: boolean
    yearMin?: boolean
    languages?: boolean
    collection?: boolean | Series$collectionArgs<ExtArgs>
    thumbnail?: boolean | Series$thumbnailArgs<ExtArgs>
    volumes?: boolean | Series$volumesArgs<ExtArgs>
    categories?: boolean | Series$categoriesArgs<ExtArgs>
    regions?: boolean | Series$regionsArgs<ExtArgs>
    tags?: boolean | Series$tagsArgs<ExtArgs>
    _count?: boolean | SeriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["series"]>

  export type SeriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionId?: boolean
    nameI18n?: boolean
    descriptionI18n?: boolean
    indexNumber?: boolean
    volumeLabelFormat?: boolean
    thumbnailId?: boolean
    createdAt?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    license?: boolean
    period?: boolean
    sourceLink?: boolean
    sources?: boolean
    author?: boolean
    editor?: boolean
    referenceCode?: boolean
    yearMax?: boolean
    yearMin?: boolean
    languages?: boolean
    collection?: boolean | Series$collectionArgs<ExtArgs>
    thumbnail?: boolean | Series$thumbnailArgs<ExtArgs>
  }, ExtArgs["result"]["series"]>

  export type SeriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    collectionId?: boolean
    nameI18n?: boolean
    descriptionI18n?: boolean
    indexNumber?: boolean
    volumeLabelFormat?: boolean
    thumbnailId?: boolean
    createdAt?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    license?: boolean
    period?: boolean
    sourceLink?: boolean
    sources?: boolean
    author?: boolean
    editor?: boolean
    referenceCode?: boolean
    yearMax?: boolean
    yearMin?: boolean
    languages?: boolean
    collection?: boolean | Series$collectionArgs<ExtArgs>
    thumbnail?: boolean | Series$thumbnailArgs<ExtArgs>
  }, ExtArgs["result"]["series"]>

  export type SeriesSelectScalar = {
    id?: boolean
    collectionId?: boolean
    nameI18n?: boolean
    descriptionI18n?: boolean
    indexNumber?: boolean
    volumeLabelFormat?: boolean
    thumbnailId?: boolean
    createdAt?: boolean
    slug?: boolean
    name?: boolean
    description?: boolean
    license?: boolean
    period?: boolean
    sourceLink?: boolean
    sources?: boolean
    author?: boolean
    editor?: boolean
    referenceCode?: boolean
    yearMax?: boolean
    yearMin?: boolean
    languages?: boolean
  }

  export type SeriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "collectionId" | "nameI18n" | "descriptionI18n" | "indexNumber" | "volumeLabelFormat" | "thumbnailId" | "createdAt" | "slug" | "name" | "description" | "license" | "period" | "sourceLink" | "sources" | "author" | "editor" | "referenceCode" | "yearMax" | "yearMin" | "languages", ExtArgs["result"]["series"]>
  export type SeriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | Series$collectionArgs<ExtArgs>
    thumbnail?: boolean | Series$thumbnailArgs<ExtArgs>
    volumes?: boolean | Series$volumesArgs<ExtArgs>
    categories?: boolean | Series$categoriesArgs<ExtArgs>
    regions?: boolean | Series$regionsArgs<ExtArgs>
    tags?: boolean | Series$tagsArgs<ExtArgs>
    _count?: boolean | SeriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | Series$collectionArgs<ExtArgs>
    thumbnail?: boolean | Series$thumbnailArgs<ExtArgs>
  }
  export type SeriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | Series$collectionArgs<ExtArgs>
    thumbnail?: boolean | Series$thumbnailArgs<ExtArgs>
  }

  export type $SeriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Series"
    objects: {
      collection: Prisma.$CollectionPayload<ExtArgs> | null
      thumbnail: Prisma.$MediaPayload<ExtArgs> | null
      volumes: Prisma.$VolumePayload<ExtArgs>[]
      categories: Prisma.$CategoryPayload<ExtArgs>[]
      regions: Prisma.$RegionPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      collectionId: string | null
      nameI18n: Prisma.JsonValue
      descriptionI18n: Prisma.JsonValue | null
      indexNumber: number | null
      volumeLabelFormat: string | null
      thumbnailId: string | null
      createdAt: Date
      slug: string
      name: string
      description: string | null
      license: string | null
      period: string | null
      sourceLink: string | null
      sources: string | null
      author: string | null
      editor: string | null
      referenceCode: string | null
      yearMax: number | null
      yearMin: number | null
      languages: $Enums.ContentLanguage[]
    }, ExtArgs["result"]["series"]>
    composites: {}
  }

  type SeriesGetPayload<S extends boolean | null | undefined | SeriesDefaultArgs> = $Result.GetResult<Prisma.$SeriesPayload, S>

  type SeriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeriesCountAggregateInputType | true
    }

  export interface SeriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Series'], meta: { name: 'Series' } }
    /**
     * Find zero or one Series that matches the filter.
     * @param {SeriesFindUniqueArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeriesFindUniqueArgs>(args: SelectSubset<T, SeriesFindUniqueArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Series that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeriesFindUniqueOrThrowArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeriesFindUniqueOrThrowArgs>(args: SelectSubset<T, SeriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Series that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesFindFirstArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeriesFindFirstArgs>(args?: SelectSubset<T, SeriesFindFirstArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Series that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesFindFirstOrThrowArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeriesFindFirstOrThrowArgs>(args?: SelectSubset<T, SeriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Series that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Series
     * const series = await prisma.series.findMany()
     * 
     * // Get first 10 Series
     * const series = await prisma.series.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seriesWithIdOnly = await prisma.series.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeriesFindManyArgs>(args?: SelectSubset<T, SeriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Series.
     * @param {SeriesCreateArgs} args - Arguments to create a Series.
     * @example
     * // Create one Series
     * const Series = await prisma.series.create({
     *   data: {
     *     // ... data to create a Series
     *   }
     * })
     * 
     */
    create<T extends SeriesCreateArgs>(args: SelectSubset<T, SeriesCreateArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Series.
     * @param {SeriesCreateManyArgs} args - Arguments to create many Series.
     * @example
     * // Create many Series
     * const series = await prisma.series.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeriesCreateManyArgs>(args?: SelectSubset<T, SeriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Series and returns the data saved in the database.
     * @param {SeriesCreateManyAndReturnArgs} args - Arguments to create many Series.
     * @example
     * // Create many Series
     * const series = await prisma.series.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Series and only return the `id`
     * const seriesWithIdOnly = await prisma.series.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeriesCreateManyAndReturnArgs>(args?: SelectSubset<T, SeriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Series.
     * @param {SeriesDeleteArgs} args - Arguments to delete one Series.
     * @example
     * // Delete one Series
     * const Series = await prisma.series.delete({
     *   where: {
     *     // ... filter to delete one Series
     *   }
     * })
     * 
     */
    delete<T extends SeriesDeleteArgs>(args: SelectSubset<T, SeriesDeleteArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Series.
     * @param {SeriesUpdateArgs} args - Arguments to update one Series.
     * @example
     * // Update one Series
     * const series = await prisma.series.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeriesUpdateArgs>(args: SelectSubset<T, SeriesUpdateArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Series.
     * @param {SeriesDeleteManyArgs} args - Arguments to filter Series to delete.
     * @example
     * // Delete a few Series
     * const { count } = await prisma.series.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeriesDeleteManyArgs>(args?: SelectSubset<T, SeriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Series
     * const series = await prisma.series.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeriesUpdateManyArgs>(args: SelectSubset<T, SeriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Series and returns the data updated in the database.
     * @param {SeriesUpdateManyAndReturnArgs} args - Arguments to update many Series.
     * @example
     * // Update many Series
     * const series = await prisma.series.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Series and only return the `id`
     * const seriesWithIdOnly = await prisma.series.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeriesUpdateManyAndReturnArgs>(args: SelectSubset<T, SeriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Series.
     * @param {SeriesUpsertArgs} args - Arguments to update or create a Series.
     * @example
     * // Update or create a Series
     * const series = await prisma.series.upsert({
     *   create: {
     *     // ... data to create a Series
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Series we want to update
     *   }
     * })
     */
    upsert<T extends SeriesUpsertArgs>(args: SelectSubset<T, SeriesUpsertArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesCountArgs} args - Arguments to filter Series to count.
     * @example
     * // Count the number of Series
     * const count = await prisma.series.count({
     *   where: {
     *     // ... the filter for the Series we want to count
     *   }
     * })
    **/
    count<T extends SeriesCountArgs>(
      args?: Subset<T, SeriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeriesAggregateArgs>(args: Subset<T, SeriesAggregateArgs>): Prisma.PrismaPromise<GetSeriesAggregateType<T>>

    /**
     * Group by Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeriesGroupByArgs['orderBy'] }
        : { orderBy?: SeriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Series model
   */
  readonly fields: SeriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Series.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection<T extends Series$collectionArgs<ExtArgs> = {}>(args?: Subset<T, Series$collectionArgs<ExtArgs>>): Prisma__CollectionClient<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    thumbnail<T extends Series$thumbnailArgs<ExtArgs> = {}>(args?: Subset<T, Series$thumbnailArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    volumes<T extends Series$volumesArgs<ExtArgs> = {}>(args?: Subset<T, Series$volumesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends Series$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, Series$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    regions<T extends Series$regionsArgs<ExtArgs> = {}>(args?: Subset<T, Series$regionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Series$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Series$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Series model
   */
  interface SeriesFieldRefs {
    readonly id: FieldRef<"Series", 'String'>
    readonly collectionId: FieldRef<"Series", 'String'>
    readonly nameI18n: FieldRef<"Series", 'Json'>
    readonly descriptionI18n: FieldRef<"Series", 'Json'>
    readonly indexNumber: FieldRef<"Series", 'Int'>
    readonly volumeLabelFormat: FieldRef<"Series", 'String'>
    readonly thumbnailId: FieldRef<"Series", 'String'>
    readonly createdAt: FieldRef<"Series", 'DateTime'>
    readonly slug: FieldRef<"Series", 'String'>
    readonly name: FieldRef<"Series", 'String'>
    readonly description: FieldRef<"Series", 'String'>
    readonly license: FieldRef<"Series", 'String'>
    readonly period: FieldRef<"Series", 'String'>
    readonly sourceLink: FieldRef<"Series", 'String'>
    readonly sources: FieldRef<"Series", 'String'>
    readonly author: FieldRef<"Series", 'String'>
    readonly editor: FieldRef<"Series", 'String'>
    readonly referenceCode: FieldRef<"Series", 'String'>
    readonly yearMax: FieldRef<"Series", 'Int'>
    readonly yearMin: FieldRef<"Series", 'Int'>
    readonly languages: FieldRef<"Series", 'ContentLanguage[]'>
  }
    

  // Custom InputTypes
  /**
   * Series findUnique
   */
  export type SeriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where: SeriesWhereUniqueInput
  }

  /**
   * Series findUniqueOrThrow
   */
  export type SeriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where: SeriesWhereUniqueInput
  }

  /**
   * Series findFirst
   */
  export type SeriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where?: SeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Series.
     */
    cursor?: SeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Series.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Series.
     */
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Series findFirstOrThrow
   */
  export type SeriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where?: SeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Series.
     */
    cursor?: SeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Series.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Series.
     */
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Series findMany
   */
  export type SeriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where?: SeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Series.
     */
    cursor?: SeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Series.
     */
    skip?: number
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Series create
   */
  export type SeriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * The data needed to create a Series.
     */
    data: XOR<SeriesCreateInput, SeriesUncheckedCreateInput>
  }

  /**
   * Series createMany
   */
  export type SeriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Series.
     */
    data: SeriesCreateManyInput | SeriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Series createManyAndReturn
   */
  export type SeriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * The data used to create many Series.
     */
    data: SeriesCreateManyInput | SeriesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Series update
   */
  export type SeriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * The data needed to update a Series.
     */
    data: XOR<SeriesUpdateInput, SeriesUncheckedUpdateInput>
    /**
     * Choose, which Series to update.
     */
    where: SeriesWhereUniqueInput
  }

  /**
   * Series updateMany
   */
  export type SeriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Series.
     */
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyInput>
    /**
     * Filter which Series to update
     */
    where?: SeriesWhereInput
    /**
     * Limit how many Series to update.
     */
    limit?: number
  }

  /**
   * Series updateManyAndReturn
   */
  export type SeriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * The data used to update Series.
     */
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyInput>
    /**
     * Filter which Series to update
     */
    where?: SeriesWhereInput
    /**
     * Limit how many Series to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Series upsert
   */
  export type SeriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * The filter to search for the Series to update in case it exists.
     */
    where: SeriesWhereUniqueInput
    /**
     * In case the Series found by the `where` argument doesn't exist, create a new Series with this data.
     */
    create: XOR<SeriesCreateInput, SeriesUncheckedCreateInput>
    /**
     * In case the Series was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeriesUpdateInput, SeriesUncheckedUpdateInput>
  }

  /**
   * Series delete
   */
  export type SeriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter which Series to delete.
     */
    where: SeriesWhereUniqueInput
  }

  /**
   * Series deleteMany
   */
  export type SeriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Series to delete
     */
    where?: SeriesWhereInput
    /**
     * Limit how many Series to delete.
     */
    limit?: number
  }

  /**
   * Series.collection
   */
  export type Series$collectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    where?: CollectionWhereInput
  }

  /**
   * Series.thumbnail
   */
  export type Series$thumbnailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Series.volumes
   */
  export type Series$volumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volume
     */
    select?: VolumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volume
     */
    omit?: VolumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeInclude<ExtArgs> | null
    where?: VolumeWhereInput
    orderBy?: VolumeOrderByWithRelationInput | VolumeOrderByWithRelationInput[]
    cursor?: VolumeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VolumeScalarFieldEnum | VolumeScalarFieldEnum[]
  }

  /**
   * Series.categories
   */
  export type Series$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Series.regions
   */
  export type Series$regionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    cursor?: RegionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Series.tags
   */
  export type Series$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Series without action
   */
  export type SeriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
  }


  /**
   * Model Volume
   */

  export type AggregateVolume = {
    _count: VolumeCountAggregateOutputType | null
    _avg: VolumeAvgAggregateOutputType | null
    _sum: VolumeSumAggregateOutputType | null
    _min: VolumeMinAggregateOutputType | null
    _max: VolumeMaxAggregateOutputType | null
  }

  export type VolumeAvgAggregateOutputType = {
    indexNumber: number | null
    yearContent: number | null
    year: number | null
    yearMax: number | null
    yearMin: number | null
  }

  export type VolumeSumAggregateOutputType = {
    indexNumber: number | null
    yearContent: number | null
    year: number | null
    yearMax: number | null
    yearMin: number | null
  }

  export type VolumeMinAggregateOutputType = {
    id: string | null
    seriesId: string | null
    indexNumber: number | null
    languageOfContent: string | null
    yearContent: number | null
    thumbnailId: string | null
    createdAt: Date | null
    slug: string | null
    title: string | null
    description: string | null
    license: string | null
    sourceLink: string | null
    sources: string | null
    year: number | null
    author: string | null
    editor: string | null
    yearMax: number | null
    yearMin: number | null
  }

  export type VolumeMaxAggregateOutputType = {
    id: string | null
    seriesId: string | null
    indexNumber: number | null
    languageOfContent: string | null
    yearContent: number | null
    thumbnailId: string | null
    createdAt: Date | null
    slug: string | null
    title: string | null
    description: string | null
    license: string | null
    sourceLink: string | null
    sources: string | null
    year: number | null
    author: string | null
    editor: string | null
    yearMax: number | null
    yearMin: number | null
  }

  export type VolumeCountAggregateOutputType = {
    id: number
    seriesId: number
    indexNumber: number
    titleI18n: number
    descriptionI18n: number
    languageOfContent: number
    yearContent: number
    thumbnailId: number
    createdAt: number
    slug: number
    title: number
    description: number
    license: number
    sourceLink: number
    sources: number
    year: number
    author: number
    editor: number
    languages: number
    yearMax: number
    yearMin: number
    _all: number
  }


  export type VolumeAvgAggregateInputType = {
    indexNumber?: true
    yearContent?: true
    year?: true
    yearMax?: true
    yearMin?: true
  }

  export type VolumeSumAggregateInputType = {
    indexNumber?: true
    yearContent?: true
    year?: true
    yearMax?: true
    yearMin?: true
  }

  export type VolumeMinAggregateInputType = {
    id?: true
    seriesId?: true
    indexNumber?: true
    languageOfContent?: true
    yearContent?: true
    thumbnailId?: true
    createdAt?: true
    slug?: true
    title?: true
    description?: true
    license?: true
    sourceLink?: true
    sources?: true
    year?: true
    author?: true
    editor?: true
    yearMax?: true
    yearMin?: true
  }

  export type VolumeMaxAggregateInputType = {
    id?: true
    seriesId?: true
    indexNumber?: true
    languageOfContent?: true
    yearContent?: true
    thumbnailId?: true
    createdAt?: true
    slug?: true
    title?: true
    description?: true
    license?: true
    sourceLink?: true
    sources?: true
    year?: true
    author?: true
    editor?: true
    yearMax?: true
    yearMin?: true
  }

  export type VolumeCountAggregateInputType = {
    id?: true
    seriesId?: true
    indexNumber?: true
    titleI18n?: true
    descriptionI18n?: true
    languageOfContent?: true
    yearContent?: true
    thumbnailId?: true
    createdAt?: true
    slug?: true
    title?: true
    description?: true
    license?: true
    sourceLink?: true
    sources?: true
    year?: true
    author?: true
    editor?: true
    languages?: true
    yearMax?: true
    yearMin?: true
    _all?: true
  }

  export type VolumeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Volume to aggregate.
     */
    where?: VolumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Volumes to fetch.
     */
    orderBy?: VolumeOrderByWithRelationInput | VolumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VolumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Volumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Volumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Volumes
    **/
    _count?: true | VolumeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VolumeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VolumeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VolumeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VolumeMaxAggregateInputType
  }

  export type GetVolumeAggregateType<T extends VolumeAggregateArgs> = {
        [P in keyof T & keyof AggregateVolume]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVolume[P]>
      : GetScalarType<T[P], AggregateVolume[P]>
  }




  export type VolumeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VolumeWhereInput
    orderBy?: VolumeOrderByWithAggregationInput | VolumeOrderByWithAggregationInput[]
    by: VolumeScalarFieldEnum[] | VolumeScalarFieldEnum
    having?: VolumeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VolumeCountAggregateInputType | true
    _avg?: VolumeAvgAggregateInputType
    _sum?: VolumeSumAggregateInputType
    _min?: VolumeMinAggregateInputType
    _max?: VolumeMaxAggregateInputType
  }

  export type VolumeGroupByOutputType = {
    id: string
    seriesId: string | null
    indexNumber: number | null
    titleI18n: JsonValue
    descriptionI18n: JsonValue | null
    languageOfContent: string | null
    yearContent: number | null
    thumbnailId: string | null
    createdAt: Date
    slug: string
    title: string
    description: string | null
    license: string | null
    sourceLink: string | null
    sources: string | null
    year: number | null
    author: string | null
    editor: string | null
    languages: $Enums.ContentLanguage[]
    yearMax: number | null
    yearMin: number | null
    _count: VolumeCountAggregateOutputType | null
    _avg: VolumeAvgAggregateOutputType | null
    _sum: VolumeSumAggregateOutputType | null
    _min: VolumeMinAggregateOutputType | null
    _max: VolumeMaxAggregateOutputType | null
  }

  type GetVolumeGroupByPayload<T extends VolumeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VolumeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VolumeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VolumeGroupByOutputType[P]>
            : GetScalarType<T[P], VolumeGroupByOutputType[P]>
        }
      >
    >


  export type VolumeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seriesId?: boolean
    indexNumber?: boolean
    titleI18n?: boolean
    descriptionI18n?: boolean
    languageOfContent?: boolean
    yearContent?: boolean
    thumbnailId?: boolean
    createdAt?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    license?: boolean
    sourceLink?: boolean
    sources?: boolean
    year?: boolean
    author?: boolean
    editor?: boolean
    languages?: boolean
    yearMax?: boolean
    yearMin?: boolean
    pages?: boolean | Volume$pagesArgs<ExtArgs>
    series?: boolean | Volume$seriesArgs<ExtArgs>
    thumbnail?: boolean | Volume$thumbnailArgs<ExtArgs>
    regions?: boolean | Volume$regionsArgs<ExtArgs>
    _count?: boolean | VolumeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["volume"]>

  export type VolumeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seriesId?: boolean
    indexNumber?: boolean
    titleI18n?: boolean
    descriptionI18n?: boolean
    languageOfContent?: boolean
    yearContent?: boolean
    thumbnailId?: boolean
    createdAt?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    license?: boolean
    sourceLink?: boolean
    sources?: boolean
    year?: boolean
    author?: boolean
    editor?: boolean
    languages?: boolean
    yearMax?: boolean
    yearMin?: boolean
    series?: boolean | Volume$seriesArgs<ExtArgs>
    thumbnail?: boolean | Volume$thumbnailArgs<ExtArgs>
  }, ExtArgs["result"]["volume"]>

  export type VolumeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    seriesId?: boolean
    indexNumber?: boolean
    titleI18n?: boolean
    descriptionI18n?: boolean
    languageOfContent?: boolean
    yearContent?: boolean
    thumbnailId?: boolean
    createdAt?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    license?: boolean
    sourceLink?: boolean
    sources?: boolean
    year?: boolean
    author?: boolean
    editor?: boolean
    languages?: boolean
    yearMax?: boolean
    yearMin?: boolean
    series?: boolean | Volume$seriesArgs<ExtArgs>
    thumbnail?: boolean | Volume$thumbnailArgs<ExtArgs>
  }, ExtArgs["result"]["volume"]>

  export type VolumeSelectScalar = {
    id?: boolean
    seriesId?: boolean
    indexNumber?: boolean
    titleI18n?: boolean
    descriptionI18n?: boolean
    languageOfContent?: boolean
    yearContent?: boolean
    thumbnailId?: boolean
    createdAt?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    license?: boolean
    sourceLink?: boolean
    sources?: boolean
    year?: boolean
    author?: boolean
    editor?: boolean
    languages?: boolean
    yearMax?: boolean
    yearMin?: boolean
  }

  export type VolumeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "seriesId" | "indexNumber" | "titleI18n" | "descriptionI18n" | "languageOfContent" | "yearContent" | "thumbnailId" | "createdAt" | "slug" | "title" | "description" | "license" | "sourceLink" | "sources" | "year" | "author" | "editor" | "languages" | "yearMax" | "yearMin", ExtArgs["result"]["volume"]>
  export type VolumeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pages?: boolean | Volume$pagesArgs<ExtArgs>
    series?: boolean | Volume$seriesArgs<ExtArgs>
    thumbnail?: boolean | Volume$thumbnailArgs<ExtArgs>
    regions?: boolean | Volume$regionsArgs<ExtArgs>
    _count?: boolean | VolumeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VolumeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | Volume$seriesArgs<ExtArgs>
    thumbnail?: boolean | Volume$thumbnailArgs<ExtArgs>
  }
  export type VolumeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | Volume$seriesArgs<ExtArgs>
    thumbnail?: boolean | Volume$thumbnailArgs<ExtArgs>
  }

  export type $VolumePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Volume"
    objects: {
      pages: Prisma.$VolumePagePayload<ExtArgs>[]
      series: Prisma.$SeriesPayload<ExtArgs> | null
      thumbnail: Prisma.$MediaPayload<ExtArgs> | null
      regions: Prisma.$RegionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      seriesId: string | null
      indexNumber: number | null
      titleI18n: Prisma.JsonValue
      descriptionI18n: Prisma.JsonValue | null
      languageOfContent: string | null
      yearContent: number | null
      thumbnailId: string | null
      createdAt: Date
      slug: string
      title: string
      description: string | null
      license: string | null
      sourceLink: string | null
      sources: string | null
      year: number | null
      author: string | null
      editor: string | null
      languages: $Enums.ContentLanguage[]
      yearMax: number | null
      yearMin: number | null
    }, ExtArgs["result"]["volume"]>
    composites: {}
  }

  type VolumeGetPayload<S extends boolean | null | undefined | VolumeDefaultArgs> = $Result.GetResult<Prisma.$VolumePayload, S>

  type VolumeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VolumeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VolumeCountAggregateInputType | true
    }

  export interface VolumeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Volume'], meta: { name: 'Volume' } }
    /**
     * Find zero or one Volume that matches the filter.
     * @param {VolumeFindUniqueArgs} args - Arguments to find a Volume
     * @example
     * // Get one Volume
     * const volume = await prisma.volume.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VolumeFindUniqueArgs>(args: SelectSubset<T, VolumeFindUniqueArgs<ExtArgs>>): Prisma__VolumeClient<$Result.GetResult<Prisma.$VolumePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Volume that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VolumeFindUniqueOrThrowArgs} args - Arguments to find a Volume
     * @example
     * // Get one Volume
     * const volume = await prisma.volume.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VolumeFindUniqueOrThrowArgs>(args: SelectSubset<T, VolumeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VolumeClient<$Result.GetResult<Prisma.$VolumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Volume that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumeFindFirstArgs} args - Arguments to find a Volume
     * @example
     * // Get one Volume
     * const volume = await prisma.volume.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VolumeFindFirstArgs>(args?: SelectSubset<T, VolumeFindFirstArgs<ExtArgs>>): Prisma__VolumeClient<$Result.GetResult<Prisma.$VolumePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Volume that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumeFindFirstOrThrowArgs} args - Arguments to find a Volume
     * @example
     * // Get one Volume
     * const volume = await prisma.volume.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VolumeFindFirstOrThrowArgs>(args?: SelectSubset<T, VolumeFindFirstOrThrowArgs<ExtArgs>>): Prisma__VolumeClient<$Result.GetResult<Prisma.$VolumePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Volumes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Volumes
     * const volumes = await prisma.volume.findMany()
     * 
     * // Get first 10 Volumes
     * const volumes = await prisma.volume.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const volumeWithIdOnly = await prisma.volume.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VolumeFindManyArgs>(args?: SelectSubset<T, VolumeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Volume.
     * @param {VolumeCreateArgs} args - Arguments to create a Volume.
     * @example
     * // Create one Volume
     * const Volume = await prisma.volume.create({
     *   data: {
     *     // ... data to create a Volume
     *   }
     * })
     * 
     */
    create<T extends VolumeCreateArgs>(args: SelectSubset<T, VolumeCreateArgs<ExtArgs>>): Prisma__VolumeClient<$Result.GetResult<Prisma.$VolumePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Volumes.
     * @param {VolumeCreateManyArgs} args - Arguments to create many Volumes.
     * @example
     * // Create many Volumes
     * const volume = await prisma.volume.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VolumeCreateManyArgs>(args?: SelectSubset<T, VolumeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Volumes and returns the data saved in the database.
     * @param {VolumeCreateManyAndReturnArgs} args - Arguments to create many Volumes.
     * @example
     * // Create many Volumes
     * const volume = await prisma.volume.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Volumes and only return the `id`
     * const volumeWithIdOnly = await prisma.volume.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VolumeCreateManyAndReturnArgs>(args?: SelectSubset<T, VolumeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolumePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Volume.
     * @param {VolumeDeleteArgs} args - Arguments to delete one Volume.
     * @example
     * // Delete one Volume
     * const Volume = await prisma.volume.delete({
     *   where: {
     *     // ... filter to delete one Volume
     *   }
     * })
     * 
     */
    delete<T extends VolumeDeleteArgs>(args: SelectSubset<T, VolumeDeleteArgs<ExtArgs>>): Prisma__VolumeClient<$Result.GetResult<Prisma.$VolumePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Volume.
     * @param {VolumeUpdateArgs} args - Arguments to update one Volume.
     * @example
     * // Update one Volume
     * const volume = await prisma.volume.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VolumeUpdateArgs>(args: SelectSubset<T, VolumeUpdateArgs<ExtArgs>>): Prisma__VolumeClient<$Result.GetResult<Prisma.$VolumePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Volumes.
     * @param {VolumeDeleteManyArgs} args - Arguments to filter Volumes to delete.
     * @example
     * // Delete a few Volumes
     * const { count } = await prisma.volume.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VolumeDeleteManyArgs>(args?: SelectSubset<T, VolumeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Volumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Volumes
     * const volume = await prisma.volume.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VolumeUpdateManyArgs>(args: SelectSubset<T, VolumeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Volumes and returns the data updated in the database.
     * @param {VolumeUpdateManyAndReturnArgs} args - Arguments to update many Volumes.
     * @example
     * // Update many Volumes
     * const volume = await prisma.volume.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Volumes and only return the `id`
     * const volumeWithIdOnly = await prisma.volume.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VolumeUpdateManyAndReturnArgs>(args: SelectSubset<T, VolumeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolumePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Volume.
     * @param {VolumeUpsertArgs} args - Arguments to update or create a Volume.
     * @example
     * // Update or create a Volume
     * const volume = await prisma.volume.upsert({
     *   create: {
     *     // ... data to create a Volume
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Volume we want to update
     *   }
     * })
     */
    upsert<T extends VolumeUpsertArgs>(args: SelectSubset<T, VolumeUpsertArgs<ExtArgs>>): Prisma__VolumeClient<$Result.GetResult<Prisma.$VolumePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Volumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumeCountArgs} args - Arguments to filter Volumes to count.
     * @example
     * // Count the number of Volumes
     * const count = await prisma.volume.count({
     *   where: {
     *     // ... the filter for the Volumes we want to count
     *   }
     * })
    **/
    count<T extends VolumeCountArgs>(
      args?: Subset<T, VolumeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VolumeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Volume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VolumeAggregateArgs>(args: Subset<T, VolumeAggregateArgs>): Prisma.PrismaPromise<GetVolumeAggregateType<T>>

    /**
     * Group by Volume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VolumeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VolumeGroupByArgs['orderBy'] }
        : { orderBy?: VolumeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VolumeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVolumeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Volume model
   */
  readonly fields: VolumeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Volume.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VolumeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pages<T extends Volume$pagesArgs<ExtArgs> = {}>(args?: Subset<T, Volume$pagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolumePagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    series<T extends Volume$seriesArgs<ExtArgs> = {}>(args?: Subset<T, Volume$seriesArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    thumbnail<T extends Volume$thumbnailArgs<ExtArgs> = {}>(args?: Subset<T, Volume$thumbnailArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    regions<T extends Volume$regionsArgs<ExtArgs> = {}>(args?: Subset<T, Volume$regionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Volume model
   */
  interface VolumeFieldRefs {
    readonly id: FieldRef<"Volume", 'String'>
    readonly seriesId: FieldRef<"Volume", 'String'>
    readonly indexNumber: FieldRef<"Volume", 'Int'>
    readonly titleI18n: FieldRef<"Volume", 'Json'>
    readonly descriptionI18n: FieldRef<"Volume", 'Json'>
    readonly languageOfContent: FieldRef<"Volume", 'String'>
    readonly yearContent: FieldRef<"Volume", 'Int'>
    readonly thumbnailId: FieldRef<"Volume", 'String'>
    readonly createdAt: FieldRef<"Volume", 'DateTime'>
    readonly slug: FieldRef<"Volume", 'String'>
    readonly title: FieldRef<"Volume", 'String'>
    readonly description: FieldRef<"Volume", 'String'>
    readonly license: FieldRef<"Volume", 'String'>
    readonly sourceLink: FieldRef<"Volume", 'String'>
    readonly sources: FieldRef<"Volume", 'String'>
    readonly year: FieldRef<"Volume", 'Int'>
    readonly author: FieldRef<"Volume", 'String'>
    readonly editor: FieldRef<"Volume", 'String'>
    readonly languages: FieldRef<"Volume", 'ContentLanguage[]'>
    readonly yearMax: FieldRef<"Volume", 'Int'>
    readonly yearMin: FieldRef<"Volume", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Volume findUnique
   */
  export type VolumeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volume
     */
    select?: VolumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volume
     */
    omit?: VolumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeInclude<ExtArgs> | null
    /**
     * Filter, which Volume to fetch.
     */
    where: VolumeWhereUniqueInput
  }

  /**
   * Volume findUniqueOrThrow
   */
  export type VolumeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volume
     */
    select?: VolumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volume
     */
    omit?: VolumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeInclude<ExtArgs> | null
    /**
     * Filter, which Volume to fetch.
     */
    where: VolumeWhereUniqueInput
  }

  /**
   * Volume findFirst
   */
  export type VolumeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volume
     */
    select?: VolumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volume
     */
    omit?: VolumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeInclude<ExtArgs> | null
    /**
     * Filter, which Volume to fetch.
     */
    where?: VolumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Volumes to fetch.
     */
    orderBy?: VolumeOrderByWithRelationInput | VolumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Volumes.
     */
    cursor?: VolumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Volumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Volumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Volumes.
     */
    distinct?: VolumeScalarFieldEnum | VolumeScalarFieldEnum[]
  }

  /**
   * Volume findFirstOrThrow
   */
  export type VolumeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volume
     */
    select?: VolumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volume
     */
    omit?: VolumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeInclude<ExtArgs> | null
    /**
     * Filter, which Volume to fetch.
     */
    where?: VolumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Volumes to fetch.
     */
    orderBy?: VolumeOrderByWithRelationInput | VolumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Volumes.
     */
    cursor?: VolumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Volumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Volumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Volumes.
     */
    distinct?: VolumeScalarFieldEnum | VolumeScalarFieldEnum[]
  }

  /**
   * Volume findMany
   */
  export type VolumeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volume
     */
    select?: VolumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volume
     */
    omit?: VolumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeInclude<ExtArgs> | null
    /**
     * Filter, which Volumes to fetch.
     */
    where?: VolumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Volumes to fetch.
     */
    orderBy?: VolumeOrderByWithRelationInput | VolumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Volumes.
     */
    cursor?: VolumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Volumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Volumes.
     */
    skip?: number
    distinct?: VolumeScalarFieldEnum | VolumeScalarFieldEnum[]
  }

  /**
   * Volume create
   */
  export type VolumeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volume
     */
    select?: VolumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volume
     */
    omit?: VolumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeInclude<ExtArgs> | null
    /**
     * The data needed to create a Volume.
     */
    data: XOR<VolumeCreateInput, VolumeUncheckedCreateInput>
  }

  /**
   * Volume createMany
   */
  export type VolumeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Volumes.
     */
    data: VolumeCreateManyInput | VolumeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Volume createManyAndReturn
   */
  export type VolumeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volume
     */
    select?: VolumeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Volume
     */
    omit?: VolumeOmit<ExtArgs> | null
    /**
     * The data used to create many Volumes.
     */
    data: VolumeCreateManyInput | VolumeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Volume update
   */
  export type VolumeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volume
     */
    select?: VolumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volume
     */
    omit?: VolumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeInclude<ExtArgs> | null
    /**
     * The data needed to update a Volume.
     */
    data: XOR<VolumeUpdateInput, VolumeUncheckedUpdateInput>
    /**
     * Choose, which Volume to update.
     */
    where: VolumeWhereUniqueInput
  }

  /**
   * Volume updateMany
   */
  export type VolumeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Volumes.
     */
    data: XOR<VolumeUpdateManyMutationInput, VolumeUncheckedUpdateManyInput>
    /**
     * Filter which Volumes to update
     */
    where?: VolumeWhereInput
    /**
     * Limit how many Volumes to update.
     */
    limit?: number
  }

  /**
   * Volume updateManyAndReturn
   */
  export type VolumeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volume
     */
    select?: VolumeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Volume
     */
    omit?: VolumeOmit<ExtArgs> | null
    /**
     * The data used to update Volumes.
     */
    data: XOR<VolumeUpdateManyMutationInput, VolumeUncheckedUpdateManyInput>
    /**
     * Filter which Volumes to update
     */
    where?: VolumeWhereInput
    /**
     * Limit how many Volumes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Volume upsert
   */
  export type VolumeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volume
     */
    select?: VolumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volume
     */
    omit?: VolumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeInclude<ExtArgs> | null
    /**
     * The filter to search for the Volume to update in case it exists.
     */
    where: VolumeWhereUniqueInput
    /**
     * In case the Volume found by the `where` argument doesn't exist, create a new Volume with this data.
     */
    create: XOR<VolumeCreateInput, VolumeUncheckedCreateInput>
    /**
     * In case the Volume was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VolumeUpdateInput, VolumeUncheckedUpdateInput>
  }

  /**
   * Volume delete
   */
  export type VolumeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volume
     */
    select?: VolumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volume
     */
    omit?: VolumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeInclude<ExtArgs> | null
    /**
     * Filter which Volume to delete.
     */
    where: VolumeWhereUniqueInput
  }

  /**
   * Volume deleteMany
   */
  export type VolumeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Volumes to delete
     */
    where?: VolumeWhereInput
    /**
     * Limit how many Volumes to delete.
     */
    limit?: number
  }

  /**
   * Volume.pages
   */
  export type Volume$pagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumePage
     */
    select?: VolumePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolumePage
     */
    omit?: VolumePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumePageInclude<ExtArgs> | null
    where?: VolumePageWhereInput
    orderBy?: VolumePageOrderByWithRelationInput | VolumePageOrderByWithRelationInput[]
    cursor?: VolumePageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VolumePageScalarFieldEnum | VolumePageScalarFieldEnum[]
  }

  /**
   * Volume.series
   */
  export type Volume$seriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    where?: SeriesWhereInput
  }

  /**
   * Volume.thumbnail
   */
  export type Volume$thumbnailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Volume.regions
   */
  export type Volume$regionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    cursor?: RegionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Volume without action
   */
  export type VolumeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volume
     */
    select?: VolumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volume
     */
    omit?: VolumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeInclude<ExtArgs> | null
  }


  /**
   * Model VolumePage
   */

  export type AggregateVolumePage = {
    _count: VolumePageCountAggregateOutputType | null
    _avg: VolumePageAvgAggregateOutputType | null
    _sum: VolumePageSumAggregateOutputType | null
    _min: VolumePageMinAggregateOutputType | null
    _max: VolumePageMaxAggregateOutputType | null
  }

  export type VolumePageAvgAggregateOutputType = {
    sequenceIndex: number | null
  }

  export type VolumePageSumAggregateOutputType = {
    sequenceIndex: number | null
  }

  export type VolumePageMinAggregateOutputType = {
    id: string | null
    volumeId: string | null
    sequenceIndex: number | null
    label: string | null
    createdAt: Date | null
    isVisible: boolean | null
  }

  export type VolumePageMaxAggregateOutputType = {
    id: string | null
    volumeId: string | null
    sequenceIndex: number | null
    label: string | null
    createdAt: Date | null
    isVisible: boolean | null
  }

  export type VolumePageCountAggregateOutputType = {
    id: number
    volumeId: number
    sequenceIndex: number
    label: number
    createdAt: number
    isVisible: number
    _all: number
  }


  export type VolumePageAvgAggregateInputType = {
    sequenceIndex?: true
  }

  export type VolumePageSumAggregateInputType = {
    sequenceIndex?: true
  }

  export type VolumePageMinAggregateInputType = {
    id?: true
    volumeId?: true
    sequenceIndex?: true
    label?: true
    createdAt?: true
    isVisible?: true
  }

  export type VolumePageMaxAggregateInputType = {
    id?: true
    volumeId?: true
    sequenceIndex?: true
    label?: true
    createdAt?: true
    isVisible?: true
  }

  export type VolumePageCountAggregateInputType = {
    id?: true
    volumeId?: true
    sequenceIndex?: true
    label?: true
    createdAt?: true
    isVisible?: true
    _all?: true
  }

  export type VolumePageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VolumePage to aggregate.
     */
    where?: VolumePageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolumePages to fetch.
     */
    orderBy?: VolumePageOrderByWithRelationInput | VolumePageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VolumePageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolumePages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolumePages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VolumePages
    **/
    _count?: true | VolumePageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VolumePageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VolumePageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VolumePageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VolumePageMaxAggregateInputType
  }

  export type GetVolumePageAggregateType<T extends VolumePageAggregateArgs> = {
        [P in keyof T & keyof AggregateVolumePage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVolumePage[P]>
      : GetScalarType<T[P], AggregateVolumePage[P]>
  }




  export type VolumePageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VolumePageWhereInput
    orderBy?: VolumePageOrderByWithAggregationInput | VolumePageOrderByWithAggregationInput[]
    by: VolumePageScalarFieldEnum[] | VolumePageScalarFieldEnum
    having?: VolumePageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VolumePageCountAggregateInputType | true
    _avg?: VolumePageAvgAggregateInputType
    _sum?: VolumePageSumAggregateInputType
    _min?: VolumePageMinAggregateInputType
    _max?: VolumePageMaxAggregateInputType
  }

  export type VolumePageGroupByOutputType = {
    id: string
    volumeId: string | null
    sequenceIndex: number
    label: string
    createdAt: Date
    isVisible: boolean
    _count: VolumePageCountAggregateOutputType | null
    _avg: VolumePageAvgAggregateOutputType | null
    _sum: VolumePageSumAggregateOutputType | null
    _min: VolumePageMinAggregateOutputType | null
    _max: VolumePageMaxAggregateOutputType | null
  }

  type GetVolumePageGroupByPayload<T extends VolumePageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VolumePageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VolumePageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VolumePageGroupByOutputType[P]>
            : GetScalarType<T[P], VolumePageGroupByOutputType[P]>
        }
      >
    >


  export type VolumePageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    volumeId?: boolean
    sequenceIndex?: boolean
    label?: boolean
    createdAt?: boolean
    isVisible?: boolean
    data?: boolean | VolumePage$dataArgs<ExtArgs>
    images?: boolean | VolumePage$imagesArgs<ExtArgs>
    texts?: boolean | VolumePage$textsArgs<ExtArgs>
    volume?: boolean | VolumePage$volumeArgs<ExtArgs>
    artifacts?: boolean | VolumePage$artifactsArgs<ExtArgs>
    _count?: boolean | VolumePageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["volumePage"]>

  export type VolumePageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    volumeId?: boolean
    sequenceIndex?: boolean
    label?: boolean
    createdAt?: boolean
    isVisible?: boolean
    volume?: boolean | VolumePage$volumeArgs<ExtArgs>
  }, ExtArgs["result"]["volumePage"]>

  export type VolumePageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    volumeId?: boolean
    sequenceIndex?: boolean
    label?: boolean
    createdAt?: boolean
    isVisible?: boolean
    volume?: boolean | VolumePage$volumeArgs<ExtArgs>
  }, ExtArgs["result"]["volumePage"]>

  export type VolumePageSelectScalar = {
    id?: boolean
    volumeId?: boolean
    sequenceIndex?: boolean
    label?: boolean
    createdAt?: boolean
    isVisible?: boolean
  }

  export type VolumePageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "volumeId" | "sequenceIndex" | "label" | "createdAt" | "isVisible", ExtArgs["result"]["volumePage"]>
  export type VolumePageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    data?: boolean | VolumePage$dataArgs<ExtArgs>
    images?: boolean | VolumePage$imagesArgs<ExtArgs>
    texts?: boolean | VolumePage$textsArgs<ExtArgs>
    volume?: boolean | VolumePage$volumeArgs<ExtArgs>
    artifacts?: boolean | VolumePage$artifactsArgs<ExtArgs>
    _count?: boolean | VolumePageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VolumePageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    volume?: boolean | VolumePage$volumeArgs<ExtArgs>
  }
  export type VolumePageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    volume?: boolean | VolumePage$volumeArgs<ExtArgs>
  }

  export type $VolumePagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VolumePage"
    objects: {
      data: Prisma.$PageDataPayload<ExtArgs> | null
      images: Prisma.$PageImagePayload<ExtArgs>[]
      texts: Prisma.$PageTextPayload<ExtArgs>[]
      volume: Prisma.$VolumePayload<ExtArgs> | null
      artifacts: Prisma.$ArtifactPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      volumeId: string | null
      sequenceIndex: number
      label: string
      createdAt: Date
      isVisible: boolean
    }, ExtArgs["result"]["volumePage"]>
    composites: {}
  }

  type VolumePageGetPayload<S extends boolean | null | undefined | VolumePageDefaultArgs> = $Result.GetResult<Prisma.$VolumePagePayload, S>

  type VolumePageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VolumePageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VolumePageCountAggregateInputType | true
    }

  export interface VolumePageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VolumePage'], meta: { name: 'VolumePage' } }
    /**
     * Find zero or one VolumePage that matches the filter.
     * @param {VolumePageFindUniqueArgs} args - Arguments to find a VolumePage
     * @example
     * // Get one VolumePage
     * const volumePage = await prisma.volumePage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VolumePageFindUniqueArgs>(args: SelectSubset<T, VolumePageFindUniqueArgs<ExtArgs>>): Prisma__VolumePageClient<$Result.GetResult<Prisma.$VolumePagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VolumePage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VolumePageFindUniqueOrThrowArgs} args - Arguments to find a VolumePage
     * @example
     * // Get one VolumePage
     * const volumePage = await prisma.volumePage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VolumePageFindUniqueOrThrowArgs>(args: SelectSubset<T, VolumePageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VolumePageClient<$Result.GetResult<Prisma.$VolumePagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VolumePage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumePageFindFirstArgs} args - Arguments to find a VolumePage
     * @example
     * // Get one VolumePage
     * const volumePage = await prisma.volumePage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VolumePageFindFirstArgs>(args?: SelectSubset<T, VolumePageFindFirstArgs<ExtArgs>>): Prisma__VolumePageClient<$Result.GetResult<Prisma.$VolumePagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VolumePage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumePageFindFirstOrThrowArgs} args - Arguments to find a VolumePage
     * @example
     * // Get one VolumePage
     * const volumePage = await prisma.volumePage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VolumePageFindFirstOrThrowArgs>(args?: SelectSubset<T, VolumePageFindFirstOrThrowArgs<ExtArgs>>): Prisma__VolumePageClient<$Result.GetResult<Prisma.$VolumePagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VolumePages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumePageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VolumePages
     * const volumePages = await prisma.volumePage.findMany()
     * 
     * // Get first 10 VolumePages
     * const volumePages = await prisma.volumePage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const volumePageWithIdOnly = await prisma.volumePage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VolumePageFindManyArgs>(args?: SelectSubset<T, VolumePageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolumePagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VolumePage.
     * @param {VolumePageCreateArgs} args - Arguments to create a VolumePage.
     * @example
     * // Create one VolumePage
     * const VolumePage = await prisma.volumePage.create({
     *   data: {
     *     // ... data to create a VolumePage
     *   }
     * })
     * 
     */
    create<T extends VolumePageCreateArgs>(args: SelectSubset<T, VolumePageCreateArgs<ExtArgs>>): Prisma__VolumePageClient<$Result.GetResult<Prisma.$VolumePagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VolumePages.
     * @param {VolumePageCreateManyArgs} args - Arguments to create many VolumePages.
     * @example
     * // Create many VolumePages
     * const volumePage = await prisma.volumePage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VolumePageCreateManyArgs>(args?: SelectSubset<T, VolumePageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VolumePages and returns the data saved in the database.
     * @param {VolumePageCreateManyAndReturnArgs} args - Arguments to create many VolumePages.
     * @example
     * // Create many VolumePages
     * const volumePage = await prisma.volumePage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VolumePages and only return the `id`
     * const volumePageWithIdOnly = await prisma.volumePage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VolumePageCreateManyAndReturnArgs>(args?: SelectSubset<T, VolumePageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolumePagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VolumePage.
     * @param {VolumePageDeleteArgs} args - Arguments to delete one VolumePage.
     * @example
     * // Delete one VolumePage
     * const VolumePage = await prisma.volumePage.delete({
     *   where: {
     *     // ... filter to delete one VolumePage
     *   }
     * })
     * 
     */
    delete<T extends VolumePageDeleteArgs>(args: SelectSubset<T, VolumePageDeleteArgs<ExtArgs>>): Prisma__VolumePageClient<$Result.GetResult<Prisma.$VolumePagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VolumePage.
     * @param {VolumePageUpdateArgs} args - Arguments to update one VolumePage.
     * @example
     * // Update one VolumePage
     * const volumePage = await prisma.volumePage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VolumePageUpdateArgs>(args: SelectSubset<T, VolumePageUpdateArgs<ExtArgs>>): Prisma__VolumePageClient<$Result.GetResult<Prisma.$VolumePagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VolumePages.
     * @param {VolumePageDeleteManyArgs} args - Arguments to filter VolumePages to delete.
     * @example
     * // Delete a few VolumePages
     * const { count } = await prisma.volumePage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VolumePageDeleteManyArgs>(args?: SelectSubset<T, VolumePageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VolumePages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumePageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VolumePages
     * const volumePage = await prisma.volumePage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VolumePageUpdateManyArgs>(args: SelectSubset<T, VolumePageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VolumePages and returns the data updated in the database.
     * @param {VolumePageUpdateManyAndReturnArgs} args - Arguments to update many VolumePages.
     * @example
     * // Update many VolumePages
     * const volumePage = await prisma.volumePage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VolumePages and only return the `id`
     * const volumePageWithIdOnly = await prisma.volumePage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VolumePageUpdateManyAndReturnArgs>(args: SelectSubset<T, VolumePageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolumePagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VolumePage.
     * @param {VolumePageUpsertArgs} args - Arguments to update or create a VolumePage.
     * @example
     * // Update or create a VolumePage
     * const volumePage = await prisma.volumePage.upsert({
     *   create: {
     *     // ... data to create a VolumePage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VolumePage we want to update
     *   }
     * })
     */
    upsert<T extends VolumePageUpsertArgs>(args: SelectSubset<T, VolumePageUpsertArgs<ExtArgs>>): Prisma__VolumePageClient<$Result.GetResult<Prisma.$VolumePagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VolumePages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumePageCountArgs} args - Arguments to filter VolumePages to count.
     * @example
     * // Count the number of VolumePages
     * const count = await prisma.volumePage.count({
     *   where: {
     *     // ... the filter for the VolumePages we want to count
     *   }
     * })
    **/
    count<T extends VolumePageCountArgs>(
      args?: Subset<T, VolumePageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VolumePageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VolumePage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumePageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VolumePageAggregateArgs>(args: Subset<T, VolumePageAggregateArgs>): Prisma.PrismaPromise<GetVolumePageAggregateType<T>>

    /**
     * Group by VolumePage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumePageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VolumePageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VolumePageGroupByArgs['orderBy'] }
        : { orderBy?: VolumePageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VolumePageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVolumePageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VolumePage model
   */
  readonly fields: VolumePageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VolumePage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VolumePageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    data<T extends VolumePage$dataArgs<ExtArgs> = {}>(args?: Subset<T, VolumePage$dataArgs<ExtArgs>>): Prisma__PageDataClient<$Result.GetResult<Prisma.$PageDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    images<T extends VolumePage$imagesArgs<ExtArgs> = {}>(args?: Subset<T, VolumePage$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    texts<T extends VolumePage$textsArgs<ExtArgs> = {}>(args?: Subset<T, VolumePage$textsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageTextPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    volume<T extends VolumePage$volumeArgs<ExtArgs> = {}>(args?: Subset<T, VolumePage$volumeArgs<ExtArgs>>): Prisma__VolumeClient<$Result.GetResult<Prisma.$VolumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    artifacts<T extends VolumePage$artifactsArgs<ExtArgs> = {}>(args?: Subset<T, VolumePage$artifactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VolumePage model
   */
  interface VolumePageFieldRefs {
    readonly id: FieldRef<"VolumePage", 'String'>
    readonly volumeId: FieldRef<"VolumePage", 'String'>
    readonly sequenceIndex: FieldRef<"VolumePage", 'Int'>
    readonly label: FieldRef<"VolumePage", 'String'>
    readonly createdAt: FieldRef<"VolumePage", 'DateTime'>
    readonly isVisible: FieldRef<"VolumePage", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * VolumePage findUnique
   */
  export type VolumePageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumePage
     */
    select?: VolumePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolumePage
     */
    omit?: VolumePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumePageInclude<ExtArgs> | null
    /**
     * Filter, which VolumePage to fetch.
     */
    where: VolumePageWhereUniqueInput
  }

  /**
   * VolumePage findUniqueOrThrow
   */
  export type VolumePageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumePage
     */
    select?: VolumePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolumePage
     */
    omit?: VolumePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumePageInclude<ExtArgs> | null
    /**
     * Filter, which VolumePage to fetch.
     */
    where: VolumePageWhereUniqueInput
  }

  /**
   * VolumePage findFirst
   */
  export type VolumePageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumePage
     */
    select?: VolumePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolumePage
     */
    omit?: VolumePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumePageInclude<ExtArgs> | null
    /**
     * Filter, which VolumePage to fetch.
     */
    where?: VolumePageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolumePages to fetch.
     */
    orderBy?: VolumePageOrderByWithRelationInput | VolumePageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VolumePages.
     */
    cursor?: VolumePageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolumePages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolumePages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VolumePages.
     */
    distinct?: VolumePageScalarFieldEnum | VolumePageScalarFieldEnum[]
  }

  /**
   * VolumePage findFirstOrThrow
   */
  export type VolumePageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumePage
     */
    select?: VolumePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolumePage
     */
    omit?: VolumePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumePageInclude<ExtArgs> | null
    /**
     * Filter, which VolumePage to fetch.
     */
    where?: VolumePageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolumePages to fetch.
     */
    orderBy?: VolumePageOrderByWithRelationInput | VolumePageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VolumePages.
     */
    cursor?: VolumePageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolumePages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolumePages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VolumePages.
     */
    distinct?: VolumePageScalarFieldEnum | VolumePageScalarFieldEnum[]
  }

  /**
   * VolumePage findMany
   */
  export type VolumePageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumePage
     */
    select?: VolumePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolumePage
     */
    omit?: VolumePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumePageInclude<ExtArgs> | null
    /**
     * Filter, which VolumePages to fetch.
     */
    where?: VolumePageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolumePages to fetch.
     */
    orderBy?: VolumePageOrderByWithRelationInput | VolumePageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VolumePages.
     */
    cursor?: VolumePageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolumePages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolumePages.
     */
    skip?: number
    distinct?: VolumePageScalarFieldEnum | VolumePageScalarFieldEnum[]
  }

  /**
   * VolumePage create
   */
  export type VolumePageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumePage
     */
    select?: VolumePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolumePage
     */
    omit?: VolumePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumePageInclude<ExtArgs> | null
    /**
     * The data needed to create a VolumePage.
     */
    data: XOR<VolumePageCreateInput, VolumePageUncheckedCreateInput>
  }

  /**
   * VolumePage createMany
   */
  export type VolumePageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VolumePages.
     */
    data: VolumePageCreateManyInput | VolumePageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VolumePage createManyAndReturn
   */
  export type VolumePageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumePage
     */
    select?: VolumePageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VolumePage
     */
    omit?: VolumePageOmit<ExtArgs> | null
    /**
     * The data used to create many VolumePages.
     */
    data: VolumePageCreateManyInput | VolumePageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumePageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VolumePage update
   */
  export type VolumePageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumePage
     */
    select?: VolumePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolumePage
     */
    omit?: VolumePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumePageInclude<ExtArgs> | null
    /**
     * The data needed to update a VolumePage.
     */
    data: XOR<VolumePageUpdateInput, VolumePageUncheckedUpdateInput>
    /**
     * Choose, which VolumePage to update.
     */
    where: VolumePageWhereUniqueInput
  }

  /**
   * VolumePage updateMany
   */
  export type VolumePageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VolumePages.
     */
    data: XOR<VolumePageUpdateManyMutationInput, VolumePageUncheckedUpdateManyInput>
    /**
     * Filter which VolumePages to update
     */
    where?: VolumePageWhereInput
    /**
     * Limit how many VolumePages to update.
     */
    limit?: number
  }

  /**
   * VolumePage updateManyAndReturn
   */
  export type VolumePageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumePage
     */
    select?: VolumePageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VolumePage
     */
    omit?: VolumePageOmit<ExtArgs> | null
    /**
     * The data used to update VolumePages.
     */
    data: XOR<VolumePageUpdateManyMutationInput, VolumePageUncheckedUpdateManyInput>
    /**
     * Filter which VolumePages to update
     */
    where?: VolumePageWhereInput
    /**
     * Limit how many VolumePages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumePageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VolumePage upsert
   */
  export type VolumePageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumePage
     */
    select?: VolumePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolumePage
     */
    omit?: VolumePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumePageInclude<ExtArgs> | null
    /**
     * The filter to search for the VolumePage to update in case it exists.
     */
    where: VolumePageWhereUniqueInput
    /**
     * In case the VolumePage found by the `where` argument doesn't exist, create a new VolumePage with this data.
     */
    create: XOR<VolumePageCreateInput, VolumePageUncheckedCreateInput>
    /**
     * In case the VolumePage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VolumePageUpdateInput, VolumePageUncheckedUpdateInput>
  }

  /**
   * VolumePage delete
   */
  export type VolumePageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumePage
     */
    select?: VolumePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolumePage
     */
    omit?: VolumePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumePageInclude<ExtArgs> | null
    /**
     * Filter which VolumePage to delete.
     */
    where: VolumePageWhereUniqueInput
  }

  /**
   * VolumePage deleteMany
   */
  export type VolumePageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VolumePages to delete
     */
    where?: VolumePageWhereInput
    /**
     * Limit how many VolumePages to delete.
     */
    limit?: number
  }

  /**
   * VolumePage.data
   */
  export type VolumePage$dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageData
     */
    select?: PageDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageData
     */
    omit?: PageDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageDataInclude<ExtArgs> | null
    where?: PageDataWhereInput
  }

  /**
   * VolumePage.images
   */
  export type VolumePage$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageImage
     */
    select?: PageImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageImage
     */
    omit?: PageImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageImageInclude<ExtArgs> | null
    where?: PageImageWhereInput
    orderBy?: PageImageOrderByWithRelationInput | PageImageOrderByWithRelationInput[]
    cursor?: PageImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageImageScalarFieldEnum | PageImageScalarFieldEnum[]
  }

  /**
   * VolumePage.texts
   */
  export type VolumePage$textsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageText
     */
    select?: PageTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageText
     */
    omit?: PageTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTextInclude<ExtArgs> | null
    where?: PageTextWhereInput
    orderBy?: PageTextOrderByWithRelationInput | PageTextOrderByWithRelationInput[]
    cursor?: PageTextWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageTextScalarFieldEnum | PageTextScalarFieldEnum[]
  }

  /**
   * VolumePage.volume
   */
  export type VolumePage$volumeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volume
     */
    select?: VolumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volume
     */
    omit?: VolumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeInclude<ExtArgs> | null
    where?: VolumeWhereInput
  }

  /**
   * VolumePage.artifacts
   */
  export type VolumePage$artifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    where?: ArtifactWhereInput
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    cursor?: ArtifactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * VolumePage without action
   */
  export type VolumePageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumePage
     */
    select?: VolumePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolumePage
     */
    omit?: VolumePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumePageInclude<ExtArgs> | null
  }


  /**
   * Model Artifact
   */

  export type AggregateArtifact = {
    _count: ArtifactCountAggregateOutputType | null
    _avg: ArtifactAvgAggregateOutputType | null
    _sum: ArtifactSumAggregateOutputType | null
    _min: ArtifactMinAggregateOutputType | null
    _max: ArtifactMaxAggregateOutputType | null
  }

  export type ArtifactAvgAggregateOutputType = {
    year: number | null
  }

  export type ArtifactSumAggregateOutputType = {
    year: number | null
  }

  export type ArtifactMinAggregateOutputType = {
    id: string | null
    slug: string | null
    content: string | null
    year: number | null
    dateDisplay: string | null
    dateSort: Date | null
    excerpt: string | null
    createdAt: Date | null
    description: string | null
    displayScans: boolean | null
    displayTexts: boolean | null
    title: string | null
    artifactCategoryId: string | null
  }

  export type ArtifactMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    content: string | null
    year: number | null
    dateDisplay: string | null
    dateSort: Date | null
    excerpt: string | null
    createdAt: Date | null
    description: string | null
    displayScans: boolean | null
    displayTexts: boolean | null
    title: string | null
    artifactCategoryId: string | null
  }

  export type ArtifactCountAggregateOutputType = {
    id: number
    slug: number
    content: number
    contentI18n: number
    year: number
    dateDisplay: number
    dateSort: number
    excerpt: number
    excerptI18n: number
    createdAt: number
    description: number
    descriptionI18n: number
    displayScans: number
    displayTexts: number
    sources: number
    title: number
    titleI18n: number
    artifactCategoryId: number
    _all: number
  }


  export type ArtifactAvgAggregateInputType = {
    year?: true
  }

  export type ArtifactSumAggregateInputType = {
    year?: true
  }

  export type ArtifactMinAggregateInputType = {
    id?: true
    slug?: true
    content?: true
    year?: true
    dateDisplay?: true
    dateSort?: true
    excerpt?: true
    createdAt?: true
    description?: true
    displayScans?: true
    displayTexts?: true
    title?: true
    artifactCategoryId?: true
  }

  export type ArtifactMaxAggregateInputType = {
    id?: true
    slug?: true
    content?: true
    year?: true
    dateDisplay?: true
    dateSort?: true
    excerpt?: true
    createdAt?: true
    description?: true
    displayScans?: true
    displayTexts?: true
    title?: true
    artifactCategoryId?: true
  }

  export type ArtifactCountAggregateInputType = {
    id?: true
    slug?: true
    content?: true
    contentI18n?: true
    year?: true
    dateDisplay?: true
    dateSort?: true
    excerpt?: true
    excerptI18n?: true
    createdAt?: true
    description?: true
    descriptionI18n?: true
    displayScans?: true
    displayTexts?: true
    sources?: true
    title?: true
    titleI18n?: true
    artifactCategoryId?: true
    _all?: true
  }

  export type ArtifactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Artifact to aggregate.
     */
    where?: ArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artifacts to fetch.
     */
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Artifacts
    **/
    _count?: true | ArtifactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArtifactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArtifactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArtifactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArtifactMaxAggregateInputType
  }

  export type GetArtifactAggregateType<T extends ArtifactAggregateArgs> = {
        [P in keyof T & keyof AggregateArtifact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArtifact[P]>
      : GetScalarType<T[P], AggregateArtifact[P]>
  }




  export type ArtifactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtifactWhereInput
    orderBy?: ArtifactOrderByWithAggregationInput | ArtifactOrderByWithAggregationInput[]
    by: ArtifactScalarFieldEnum[] | ArtifactScalarFieldEnum
    having?: ArtifactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArtifactCountAggregateInputType | true
    _avg?: ArtifactAvgAggregateInputType
    _sum?: ArtifactSumAggregateInputType
    _min?: ArtifactMinAggregateInputType
    _max?: ArtifactMaxAggregateInputType
  }

  export type ArtifactGroupByOutputType = {
    id: string
    slug: string
    content: string
    contentI18n: JsonValue
    year: number | null
    dateDisplay: string | null
    dateSort: Date | null
    excerpt: string | null
    excerptI18n: JsonValue | null
    createdAt: Date
    description: string | null
    descriptionI18n: JsonValue | null
    displayScans: boolean
    displayTexts: boolean
    sources: JsonValue
    title: string
    titleI18n: JsonValue
    artifactCategoryId: string | null
    _count: ArtifactCountAggregateOutputType | null
    _avg: ArtifactAvgAggregateOutputType | null
    _sum: ArtifactSumAggregateOutputType | null
    _min: ArtifactMinAggregateOutputType | null
    _max: ArtifactMaxAggregateOutputType | null
  }

  type GetArtifactGroupByPayload<T extends ArtifactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArtifactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArtifactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArtifactGroupByOutputType[P]>
            : GetScalarType<T[P], ArtifactGroupByOutputType[P]>
        }
      >
    >


  export type ArtifactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    content?: boolean
    contentI18n?: boolean
    year?: boolean
    dateDisplay?: boolean
    dateSort?: boolean
    excerpt?: boolean
    excerptI18n?: boolean
    createdAt?: boolean
    description?: boolean
    descriptionI18n?: boolean
    displayScans?: boolean
    displayTexts?: boolean
    sources?: boolean
    title?: boolean
    titleI18n?: boolean
    artifactCategoryId?: boolean
    artifactCategory?: boolean | Artifact$artifactCategoryArgs<ExtArgs>
    periods?: boolean | Artifact$periodsArgs<ExtArgs>
    places?: boolean | Artifact$placesArgs<ExtArgs>
    regions?: boolean | Artifact$regionsArgs<ExtArgs>
    tags?: boolean | Artifact$tagsArgs<ExtArgs>
    pages?: boolean | Artifact$pagesArgs<ExtArgs>
    _count?: boolean | ArtifactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artifact"]>

  export type ArtifactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    content?: boolean
    contentI18n?: boolean
    year?: boolean
    dateDisplay?: boolean
    dateSort?: boolean
    excerpt?: boolean
    excerptI18n?: boolean
    createdAt?: boolean
    description?: boolean
    descriptionI18n?: boolean
    displayScans?: boolean
    displayTexts?: boolean
    sources?: boolean
    title?: boolean
    titleI18n?: boolean
    artifactCategoryId?: boolean
    artifactCategory?: boolean | Artifact$artifactCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["artifact"]>

  export type ArtifactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    content?: boolean
    contentI18n?: boolean
    year?: boolean
    dateDisplay?: boolean
    dateSort?: boolean
    excerpt?: boolean
    excerptI18n?: boolean
    createdAt?: boolean
    description?: boolean
    descriptionI18n?: boolean
    displayScans?: boolean
    displayTexts?: boolean
    sources?: boolean
    title?: boolean
    titleI18n?: boolean
    artifactCategoryId?: boolean
    artifactCategory?: boolean | Artifact$artifactCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["artifact"]>

  export type ArtifactSelectScalar = {
    id?: boolean
    slug?: boolean
    content?: boolean
    contentI18n?: boolean
    year?: boolean
    dateDisplay?: boolean
    dateSort?: boolean
    excerpt?: boolean
    excerptI18n?: boolean
    createdAt?: boolean
    description?: boolean
    descriptionI18n?: boolean
    displayScans?: boolean
    displayTexts?: boolean
    sources?: boolean
    title?: boolean
    titleI18n?: boolean
    artifactCategoryId?: boolean
  }

  export type ArtifactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "content" | "contentI18n" | "year" | "dateDisplay" | "dateSort" | "excerpt" | "excerptI18n" | "createdAt" | "description" | "descriptionI18n" | "displayScans" | "displayTexts" | "sources" | "title" | "titleI18n" | "artifactCategoryId", ExtArgs["result"]["artifact"]>
  export type ArtifactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifactCategory?: boolean | Artifact$artifactCategoryArgs<ExtArgs>
    periods?: boolean | Artifact$periodsArgs<ExtArgs>
    places?: boolean | Artifact$placesArgs<ExtArgs>
    regions?: boolean | Artifact$regionsArgs<ExtArgs>
    tags?: boolean | Artifact$tagsArgs<ExtArgs>
    pages?: boolean | Artifact$pagesArgs<ExtArgs>
    _count?: boolean | ArtifactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ArtifactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifactCategory?: boolean | Artifact$artifactCategoryArgs<ExtArgs>
  }
  export type ArtifactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifactCategory?: boolean | Artifact$artifactCategoryArgs<ExtArgs>
  }

  export type $ArtifactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Artifact"
    objects: {
      artifactCategory: Prisma.$ArtifactCategoryPayload<ExtArgs> | null
      periods: Prisma.$PeriodPayload<ExtArgs>[]
      places: Prisma.$PlacePayload<ExtArgs>[]
      regions: Prisma.$RegionPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
      pages: Prisma.$VolumePagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      content: string
      contentI18n: Prisma.JsonValue
      year: number | null
      dateDisplay: string | null
      dateSort: Date | null
      excerpt: string | null
      excerptI18n: Prisma.JsonValue | null
      createdAt: Date
      description: string | null
      descriptionI18n: Prisma.JsonValue | null
      displayScans: boolean
      displayTexts: boolean
      sources: Prisma.JsonValue
      title: string
      titleI18n: Prisma.JsonValue
      artifactCategoryId: string | null
    }, ExtArgs["result"]["artifact"]>
    composites: {}
  }

  type ArtifactGetPayload<S extends boolean | null | undefined | ArtifactDefaultArgs> = $Result.GetResult<Prisma.$ArtifactPayload, S>

  type ArtifactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArtifactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArtifactCountAggregateInputType | true
    }

  export interface ArtifactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Artifact'], meta: { name: 'Artifact' } }
    /**
     * Find zero or one Artifact that matches the filter.
     * @param {ArtifactFindUniqueArgs} args - Arguments to find a Artifact
     * @example
     * // Get one Artifact
     * const artifact = await prisma.artifact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArtifactFindUniqueArgs>(args: SelectSubset<T, ArtifactFindUniqueArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Artifact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArtifactFindUniqueOrThrowArgs} args - Arguments to find a Artifact
     * @example
     * // Get one Artifact
     * const artifact = await prisma.artifact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArtifactFindUniqueOrThrowArgs>(args: SelectSubset<T, ArtifactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Artifact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactFindFirstArgs} args - Arguments to find a Artifact
     * @example
     * // Get one Artifact
     * const artifact = await prisma.artifact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArtifactFindFirstArgs>(args?: SelectSubset<T, ArtifactFindFirstArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Artifact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactFindFirstOrThrowArgs} args - Arguments to find a Artifact
     * @example
     * // Get one Artifact
     * const artifact = await prisma.artifact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArtifactFindFirstOrThrowArgs>(args?: SelectSubset<T, ArtifactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Artifacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Artifacts
     * const artifacts = await prisma.artifact.findMany()
     * 
     * // Get first 10 Artifacts
     * const artifacts = await prisma.artifact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const artifactWithIdOnly = await prisma.artifact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArtifactFindManyArgs>(args?: SelectSubset<T, ArtifactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Artifact.
     * @param {ArtifactCreateArgs} args - Arguments to create a Artifact.
     * @example
     * // Create one Artifact
     * const Artifact = await prisma.artifact.create({
     *   data: {
     *     // ... data to create a Artifact
     *   }
     * })
     * 
     */
    create<T extends ArtifactCreateArgs>(args: SelectSubset<T, ArtifactCreateArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Artifacts.
     * @param {ArtifactCreateManyArgs} args - Arguments to create many Artifacts.
     * @example
     * // Create many Artifacts
     * const artifact = await prisma.artifact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArtifactCreateManyArgs>(args?: SelectSubset<T, ArtifactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Artifacts and returns the data saved in the database.
     * @param {ArtifactCreateManyAndReturnArgs} args - Arguments to create many Artifacts.
     * @example
     * // Create many Artifacts
     * const artifact = await prisma.artifact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Artifacts and only return the `id`
     * const artifactWithIdOnly = await prisma.artifact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArtifactCreateManyAndReturnArgs>(args?: SelectSubset<T, ArtifactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Artifact.
     * @param {ArtifactDeleteArgs} args - Arguments to delete one Artifact.
     * @example
     * // Delete one Artifact
     * const Artifact = await prisma.artifact.delete({
     *   where: {
     *     // ... filter to delete one Artifact
     *   }
     * })
     * 
     */
    delete<T extends ArtifactDeleteArgs>(args: SelectSubset<T, ArtifactDeleteArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Artifact.
     * @param {ArtifactUpdateArgs} args - Arguments to update one Artifact.
     * @example
     * // Update one Artifact
     * const artifact = await prisma.artifact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArtifactUpdateArgs>(args: SelectSubset<T, ArtifactUpdateArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Artifacts.
     * @param {ArtifactDeleteManyArgs} args - Arguments to filter Artifacts to delete.
     * @example
     * // Delete a few Artifacts
     * const { count } = await prisma.artifact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArtifactDeleteManyArgs>(args?: SelectSubset<T, ArtifactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Artifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Artifacts
     * const artifact = await prisma.artifact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArtifactUpdateManyArgs>(args: SelectSubset<T, ArtifactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Artifacts and returns the data updated in the database.
     * @param {ArtifactUpdateManyAndReturnArgs} args - Arguments to update many Artifacts.
     * @example
     * // Update many Artifacts
     * const artifact = await prisma.artifact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Artifacts and only return the `id`
     * const artifactWithIdOnly = await prisma.artifact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArtifactUpdateManyAndReturnArgs>(args: SelectSubset<T, ArtifactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Artifact.
     * @param {ArtifactUpsertArgs} args - Arguments to update or create a Artifact.
     * @example
     * // Update or create a Artifact
     * const artifact = await prisma.artifact.upsert({
     *   create: {
     *     // ... data to create a Artifact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Artifact we want to update
     *   }
     * })
     */
    upsert<T extends ArtifactUpsertArgs>(args: SelectSubset<T, ArtifactUpsertArgs<ExtArgs>>): Prisma__ArtifactClient<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Artifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactCountArgs} args - Arguments to filter Artifacts to count.
     * @example
     * // Count the number of Artifacts
     * const count = await prisma.artifact.count({
     *   where: {
     *     // ... the filter for the Artifacts we want to count
     *   }
     * })
    **/
    count<T extends ArtifactCountArgs>(
      args?: Subset<T, ArtifactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArtifactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Artifact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArtifactAggregateArgs>(args: Subset<T, ArtifactAggregateArgs>): Prisma.PrismaPromise<GetArtifactAggregateType<T>>

    /**
     * Group by Artifact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArtifactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArtifactGroupByArgs['orderBy'] }
        : { orderBy?: ArtifactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArtifactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArtifactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Artifact model
   */
  readonly fields: ArtifactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Artifact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArtifactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artifactCategory<T extends Artifact$artifactCategoryArgs<ExtArgs> = {}>(args?: Subset<T, Artifact$artifactCategoryArgs<ExtArgs>>): Prisma__ArtifactCategoryClient<$Result.GetResult<Prisma.$ArtifactCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    periods<T extends Artifact$periodsArgs<ExtArgs> = {}>(args?: Subset<T, Artifact$periodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    places<T extends Artifact$placesArgs<ExtArgs> = {}>(args?: Subset<T, Artifact$placesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    regions<T extends Artifact$regionsArgs<ExtArgs> = {}>(args?: Subset<T, Artifact$regionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Artifact$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Artifact$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pages<T extends Artifact$pagesArgs<ExtArgs> = {}>(args?: Subset<T, Artifact$pagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolumePagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Artifact model
   */
  interface ArtifactFieldRefs {
    readonly id: FieldRef<"Artifact", 'String'>
    readonly slug: FieldRef<"Artifact", 'String'>
    readonly content: FieldRef<"Artifact", 'String'>
    readonly contentI18n: FieldRef<"Artifact", 'Json'>
    readonly year: FieldRef<"Artifact", 'Int'>
    readonly dateDisplay: FieldRef<"Artifact", 'String'>
    readonly dateSort: FieldRef<"Artifact", 'DateTime'>
    readonly excerpt: FieldRef<"Artifact", 'String'>
    readonly excerptI18n: FieldRef<"Artifact", 'Json'>
    readonly createdAt: FieldRef<"Artifact", 'DateTime'>
    readonly description: FieldRef<"Artifact", 'String'>
    readonly descriptionI18n: FieldRef<"Artifact", 'Json'>
    readonly displayScans: FieldRef<"Artifact", 'Boolean'>
    readonly displayTexts: FieldRef<"Artifact", 'Boolean'>
    readonly sources: FieldRef<"Artifact", 'Json'>
    readonly title: FieldRef<"Artifact", 'String'>
    readonly titleI18n: FieldRef<"Artifact", 'Json'>
    readonly artifactCategoryId: FieldRef<"Artifact", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Artifact findUnique
   */
  export type ArtifactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter, which Artifact to fetch.
     */
    where: ArtifactWhereUniqueInput
  }

  /**
   * Artifact findUniqueOrThrow
   */
  export type ArtifactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter, which Artifact to fetch.
     */
    where: ArtifactWhereUniqueInput
  }

  /**
   * Artifact findFirst
   */
  export type ArtifactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter, which Artifact to fetch.
     */
    where?: ArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artifacts to fetch.
     */
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Artifacts.
     */
    cursor?: ArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Artifacts.
     */
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * Artifact findFirstOrThrow
   */
  export type ArtifactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter, which Artifact to fetch.
     */
    where?: ArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artifacts to fetch.
     */
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Artifacts.
     */
    cursor?: ArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Artifacts.
     */
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * Artifact findMany
   */
  export type ArtifactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter, which Artifacts to fetch.
     */
    where?: ArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Artifacts to fetch.
     */
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Artifacts.
     */
    cursor?: ArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Artifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Artifacts.
     */
    skip?: number
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * Artifact create
   */
  export type ArtifactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * The data needed to create a Artifact.
     */
    data: XOR<ArtifactCreateInput, ArtifactUncheckedCreateInput>
  }

  /**
   * Artifact createMany
   */
  export type ArtifactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Artifacts.
     */
    data: ArtifactCreateManyInput | ArtifactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Artifact createManyAndReturn
   */
  export type ArtifactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * The data used to create many Artifacts.
     */
    data: ArtifactCreateManyInput | ArtifactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Artifact update
   */
  export type ArtifactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * The data needed to update a Artifact.
     */
    data: XOR<ArtifactUpdateInput, ArtifactUncheckedUpdateInput>
    /**
     * Choose, which Artifact to update.
     */
    where: ArtifactWhereUniqueInput
  }

  /**
   * Artifact updateMany
   */
  export type ArtifactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Artifacts.
     */
    data: XOR<ArtifactUpdateManyMutationInput, ArtifactUncheckedUpdateManyInput>
    /**
     * Filter which Artifacts to update
     */
    where?: ArtifactWhereInput
    /**
     * Limit how many Artifacts to update.
     */
    limit?: number
  }

  /**
   * Artifact updateManyAndReturn
   */
  export type ArtifactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * The data used to update Artifacts.
     */
    data: XOR<ArtifactUpdateManyMutationInput, ArtifactUncheckedUpdateManyInput>
    /**
     * Filter which Artifacts to update
     */
    where?: ArtifactWhereInput
    /**
     * Limit how many Artifacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Artifact upsert
   */
  export type ArtifactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * The filter to search for the Artifact to update in case it exists.
     */
    where: ArtifactWhereUniqueInput
    /**
     * In case the Artifact found by the `where` argument doesn't exist, create a new Artifact with this data.
     */
    create: XOR<ArtifactCreateInput, ArtifactUncheckedCreateInput>
    /**
     * In case the Artifact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArtifactUpdateInput, ArtifactUncheckedUpdateInput>
  }

  /**
   * Artifact delete
   */
  export type ArtifactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    /**
     * Filter which Artifact to delete.
     */
    where: ArtifactWhereUniqueInput
  }

  /**
   * Artifact deleteMany
   */
  export type ArtifactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Artifacts to delete
     */
    where?: ArtifactWhereInput
    /**
     * Limit how many Artifacts to delete.
     */
    limit?: number
  }

  /**
   * Artifact.artifactCategory
   */
  export type Artifact$artifactCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactCategory
     */
    select?: ArtifactCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactCategory
     */
    omit?: ArtifactCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactCategoryInclude<ExtArgs> | null
    where?: ArtifactCategoryWhereInput
  }

  /**
   * Artifact.periods
   */
  export type Artifact$periodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodInclude<ExtArgs> | null
    where?: PeriodWhereInput
    orderBy?: PeriodOrderByWithRelationInput | PeriodOrderByWithRelationInput[]
    cursor?: PeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PeriodScalarFieldEnum | PeriodScalarFieldEnum[]
  }

  /**
   * Artifact.places
   */
  export type Artifact$placesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    where?: PlaceWhereInput
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    cursor?: PlaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaceScalarFieldEnum | PlaceScalarFieldEnum[]
  }

  /**
   * Artifact.regions
   */
  export type Artifact$regionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    cursor?: RegionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Artifact.tags
   */
  export type Artifact$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Artifact.pages
   */
  export type Artifact$pagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumePage
     */
    select?: VolumePageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VolumePage
     */
    omit?: VolumePageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumePageInclude<ExtArgs> | null
    where?: VolumePageWhereInput
    orderBy?: VolumePageOrderByWithRelationInput | VolumePageOrderByWithRelationInput[]
    cursor?: VolumePageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VolumePageScalarFieldEnum | VolumePageScalarFieldEnum[]
  }

  /**
   * Artifact without action
   */
  export type ArtifactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
  }


  /**
   * Model PageText
   */

  export type AggregatePageText = {
    _count: PageTextCountAggregateOutputType | null
    _avg: PageTextAvgAggregateOutputType | null
    _sum: PageTextSumAggregateOutputType | null
    _min: PageTextMinAggregateOutputType | null
    _max: PageTextMaxAggregateOutputType | null
  }

  export type PageTextAvgAggregateOutputType = {
    textAccuracy: number | null
  }

  export type PageTextSumAggregateOutputType = {
    textAccuracy: number | null
  }

  export type PageTextMinAggregateOutputType = {
    id: string | null
    pageId: string | null
    content: string | null
    type: $Enums.TextType | null
    language: $Enums.AppLanguage | null
    textAccuracy: number | null
    contributorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageTextMaxAggregateOutputType = {
    id: string | null
    pageId: string | null
    content: string | null
    type: $Enums.TextType | null
    language: $Enums.AppLanguage | null
    textAccuracy: number | null
    contributorId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageTextCountAggregateOutputType = {
    id: number
    pageId: number
    content: number
    type: number
    language: number
    textAccuracy: number
    contributorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PageTextAvgAggregateInputType = {
    textAccuracy?: true
  }

  export type PageTextSumAggregateInputType = {
    textAccuracy?: true
  }

  export type PageTextMinAggregateInputType = {
    id?: true
    pageId?: true
    content?: true
    type?: true
    language?: true
    textAccuracy?: true
    contributorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageTextMaxAggregateInputType = {
    id?: true
    pageId?: true
    content?: true
    type?: true
    language?: true
    textAccuracy?: true
    contributorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageTextCountAggregateInputType = {
    id?: true
    pageId?: true
    content?: true
    type?: true
    language?: true
    textAccuracy?: true
    contributorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PageTextAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PageText to aggregate.
     */
    where?: PageTextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageTexts to fetch.
     */
    orderBy?: PageTextOrderByWithRelationInput | PageTextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PageTextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageTexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageTexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PageTexts
    **/
    _count?: true | PageTextCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PageTextAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PageTextSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PageTextMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PageTextMaxAggregateInputType
  }

  export type GetPageTextAggregateType<T extends PageTextAggregateArgs> = {
        [P in keyof T & keyof AggregatePageText]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePageText[P]>
      : GetScalarType<T[P], AggregatePageText[P]>
  }




  export type PageTextGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageTextWhereInput
    orderBy?: PageTextOrderByWithAggregationInput | PageTextOrderByWithAggregationInput[]
    by: PageTextScalarFieldEnum[] | PageTextScalarFieldEnum
    having?: PageTextScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageTextCountAggregateInputType | true
    _avg?: PageTextAvgAggregateInputType
    _sum?: PageTextSumAggregateInputType
    _min?: PageTextMinAggregateInputType
    _max?: PageTextMaxAggregateInputType
  }

  export type PageTextGroupByOutputType = {
    id: string
    pageId: string
    content: string
    type: $Enums.TextType
    language: $Enums.AppLanguage
    textAccuracy: number | null
    contributorId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PageTextCountAggregateOutputType | null
    _avg: PageTextAvgAggregateOutputType | null
    _sum: PageTextSumAggregateOutputType | null
    _min: PageTextMinAggregateOutputType | null
    _max: PageTextMaxAggregateOutputType | null
  }

  type GetPageTextGroupByPayload<T extends PageTextGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageTextGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PageTextGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PageTextGroupByOutputType[P]>
            : GetScalarType<T[P], PageTextGroupByOutputType[P]>
        }
      >
    >


  export type PageTextSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageId?: boolean
    content?: boolean
    type?: boolean
    language?: boolean
    textAccuracy?: boolean
    contributorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contributor?: boolean | PageText$contributorArgs<ExtArgs>
    page?: boolean | VolumePageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pageText"]>

  export type PageTextSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageId?: boolean
    content?: boolean
    type?: boolean
    language?: boolean
    textAccuracy?: boolean
    contributorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contributor?: boolean | PageText$contributorArgs<ExtArgs>
    page?: boolean | VolumePageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pageText"]>

  export type PageTextSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageId?: boolean
    content?: boolean
    type?: boolean
    language?: boolean
    textAccuracy?: boolean
    contributorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contributor?: boolean | PageText$contributorArgs<ExtArgs>
    page?: boolean | VolumePageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pageText"]>

  export type PageTextSelectScalar = {
    id?: boolean
    pageId?: boolean
    content?: boolean
    type?: boolean
    language?: boolean
    textAccuracy?: boolean
    contributorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PageTextOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pageId" | "content" | "type" | "language" | "textAccuracy" | "contributorId" | "createdAt" | "updatedAt", ExtArgs["result"]["pageText"]>
  export type PageTextInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contributor?: boolean | PageText$contributorArgs<ExtArgs>
    page?: boolean | VolumePageDefaultArgs<ExtArgs>
  }
  export type PageTextIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contributor?: boolean | PageText$contributorArgs<ExtArgs>
    page?: boolean | VolumePageDefaultArgs<ExtArgs>
  }
  export type PageTextIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contributor?: boolean | PageText$contributorArgs<ExtArgs>
    page?: boolean | VolumePageDefaultArgs<ExtArgs>
  }

  export type $PageTextPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PageText"
    objects: {
      contributor: Prisma.$UserPayload<ExtArgs> | null
      page: Prisma.$VolumePagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pageId: string
      content: string
      type: $Enums.TextType
      language: $Enums.AppLanguage
      textAccuracy: number | null
      contributorId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pageText"]>
    composites: {}
  }

  type PageTextGetPayload<S extends boolean | null | undefined | PageTextDefaultArgs> = $Result.GetResult<Prisma.$PageTextPayload, S>

  type PageTextCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PageTextFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PageTextCountAggregateInputType | true
    }

  export interface PageTextDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PageText'], meta: { name: 'PageText' } }
    /**
     * Find zero or one PageText that matches the filter.
     * @param {PageTextFindUniqueArgs} args - Arguments to find a PageText
     * @example
     * // Get one PageText
     * const pageText = await prisma.pageText.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PageTextFindUniqueArgs>(args: SelectSubset<T, PageTextFindUniqueArgs<ExtArgs>>): Prisma__PageTextClient<$Result.GetResult<Prisma.$PageTextPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PageText that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PageTextFindUniqueOrThrowArgs} args - Arguments to find a PageText
     * @example
     * // Get one PageText
     * const pageText = await prisma.pageText.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PageTextFindUniqueOrThrowArgs>(args: SelectSubset<T, PageTextFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PageTextClient<$Result.GetResult<Prisma.$PageTextPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PageText that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTextFindFirstArgs} args - Arguments to find a PageText
     * @example
     * // Get one PageText
     * const pageText = await prisma.pageText.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PageTextFindFirstArgs>(args?: SelectSubset<T, PageTextFindFirstArgs<ExtArgs>>): Prisma__PageTextClient<$Result.GetResult<Prisma.$PageTextPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PageText that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTextFindFirstOrThrowArgs} args - Arguments to find a PageText
     * @example
     * // Get one PageText
     * const pageText = await prisma.pageText.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PageTextFindFirstOrThrowArgs>(args?: SelectSubset<T, PageTextFindFirstOrThrowArgs<ExtArgs>>): Prisma__PageTextClient<$Result.GetResult<Prisma.$PageTextPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PageTexts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTextFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PageTexts
     * const pageTexts = await prisma.pageText.findMany()
     * 
     * // Get first 10 PageTexts
     * const pageTexts = await prisma.pageText.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pageTextWithIdOnly = await prisma.pageText.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PageTextFindManyArgs>(args?: SelectSubset<T, PageTextFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageTextPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PageText.
     * @param {PageTextCreateArgs} args - Arguments to create a PageText.
     * @example
     * // Create one PageText
     * const PageText = await prisma.pageText.create({
     *   data: {
     *     // ... data to create a PageText
     *   }
     * })
     * 
     */
    create<T extends PageTextCreateArgs>(args: SelectSubset<T, PageTextCreateArgs<ExtArgs>>): Prisma__PageTextClient<$Result.GetResult<Prisma.$PageTextPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PageTexts.
     * @param {PageTextCreateManyArgs} args - Arguments to create many PageTexts.
     * @example
     * // Create many PageTexts
     * const pageText = await prisma.pageText.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PageTextCreateManyArgs>(args?: SelectSubset<T, PageTextCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PageTexts and returns the data saved in the database.
     * @param {PageTextCreateManyAndReturnArgs} args - Arguments to create many PageTexts.
     * @example
     * // Create many PageTexts
     * const pageText = await prisma.pageText.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PageTexts and only return the `id`
     * const pageTextWithIdOnly = await prisma.pageText.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PageTextCreateManyAndReturnArgs>(args?: SelectSubset<T, PageTextCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageTextPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PageText.
     * @param {PageTextDeleteArgs} args - Arguments to delete one PageText.
     * @example
     * // Delete one PageText
     * const PageText = await prisma.pageText.delete({
     *   where: {
     *     // ... filter to delete one PageText
     *   }
     * })
     * 
     */
    delete<T extends PageTextDeleteArgs>(args: SelectSubset<T, PageTextDeleteArgs<ExtArgs>>): Prisma__PageTextClient<$Result.GetResult<Prisma.$PageTextPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PageText.
     * @param {PageTextUpdateArgs} args - Arguments to update one PageText.
     * @example
     * // Update one PageText
     * const pageText = await prisma.pageText.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PageTextUpdateArgs>(args: SelectSubset<T, PageTextUpdateArgs<ExtArgs>>): Prisma__PageTextClient<$Result.GetResult<Prisma.$PageTextPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PageTexts.
     * @param {PageTextDeleteManyArgs} args - Arguments to filter PageTexts to delete.
     * @example
     * // Delete a few PageTexts
     * const { count } = await prisma.pageText.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PageTextDeleteManyArgs>(args?: SelectSubset<T, PageTextDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PageTexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTextUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PageTexts
     * const pageText = await prisma.pageText.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PageTextUpdateManyArgs>(args: SelectSubset<T, PageTextUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PageTexts and returns the data updated in the database.
     * @param {PageTextUpdateManyAndReturnArgs} args - Arguments to update many PageTexts.
     * @example
     * // Update many PageTexts
     * const pageText = await prisma.pageText.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PageTexts and only return the `id`
     * const pageTextWithIdOnly = await prisma.pageText.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PageTextUpdateManyAndReturnArgs>(args: SelectSubset<T, PageTextUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageTextPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PageText.
     * @param {PageTextUpsertArgs} args - Arguments to update or create a PageText.
     * @example
     * // Update or create a PageText
     * const pageText = await prisma.pageText.upsert({
     *   create: {
     *     // ... data to create a PageText
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PageText we want to update
     *   }
     * })
     */
    upsert<T extends PageTextUpsertArgs>(args: SelectSubset<T, PageTextUpsertArgs<ExtArgs>>): Prisma__PageTextClient<$Result.GetResult<Prisma.$PageTextPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PageTexts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTextCountArgs} args - Arguments to filter PageTexts to count.
     * @example
     * // Count the number of PageTexts
     * const count = await prisma.pageText.count({
     *   where: {
     *     // ... the filter for the PageTexts we want to count
     *   }
     * })
    **/
    count<T extends PageTextCountArgs>(
      args?: Subset<T, PageTextCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageTextCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PageText.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTextAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PageTextAggregateArgs>(args: Subset<T, PageTextAggregateArgs>): Prisma.PrismaPromise<GetPageTextAggregateType<T>>

    /**
     * Group by PageText.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageTextGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PageTextGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageTextGroupByArgs['orderBy'] }
        : { orderBy?: PageTextGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PageTextGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPageTextGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PageText model
   */
  readonly fields: PageTextFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PageText.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageTextClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contributor<T extends PageText$contributorArgs<ExtArgs> = {}>(args?: Subset<T, PageText$contributorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    page<T extends VolumePageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VolumePageDefaultArgs<ExtArgs>>): Prisma__VolumePageClient<$Result.GetResult<Prisma.$VolumePagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PageText model
   */
  interface PageTextFieldRefs {
    readonly id: FieldRef<"PageText", 'String'>
    readonly pageId: FieldRef<"PageText", 'String'>
    readonly content: FieldRef<"PageText", 'String'>
    readonly type: FieldRef<"PageText", 'TextType'>
    readonly language: FieldRef<"PageText", 'AppLanguage'>
    readonly textAccuracy: FieldRef<"PageText", 'Int'>
    readonly contributorId: FieldRef<"PageText", 'String'>
    readonly createdAt: FieldRef<"PageText", 'DateTime'>
    readonly updatedAt: FieldRef<"PageText", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PageText findUnique
   */
  export type PageTextFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageText
     */
    select?: PageTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageText
     */
    omit?: PageTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTextInclude<ExtArgs> | null
    /**
     * Filter, which PageText to fetch.
     */
    where: PageTextWhereUniqueInput
  }

  /**
   * PageText findUniqueOrThrow
   */
  export type PageTextFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageText
     */
    select?: PageTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageText
     */
    omit?: PageTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTextInclude<ExtArgs> | null
    /**
     * Filter, which PageText to fetch.
     */
    where: PageTextWhereUniqueInput
  }

  /**
   * PageText findFirst
   */
  export type PageTextFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageText
     */
    select?: PageTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageText
     */
    omit?: PageTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTextInclude<ExtArgs> | null
    /**
     * Filter, which PageText to fetch.
     */
    where?: PageTextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageTexts to fetch.
     */
    orderBy?: PageTextOrderByWithRelationInput | PageTextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PageTexts.
     */
    cursor?: PageTextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageTexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageTexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PageTexts.
     */
    distinct?: PageTextScalarFieldEnum | PageTextScalarFieldEnum[]
  }

  /**
   * PageText findFirstOrThrow
   */
  export type PageTextFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageText
     */
    select?: PageTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageText
     */
    omit?: PageTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTextInclude<ExtArgs> | null
    /**
     * Filter, which PageText to fetch.
     */
    where?: PageTextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageTexts to fetch.
     */
    orderBy?: PageTextOrderByWithRelationInput | PageTextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PageTexts.
     */
    cursor?: PageTextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageTexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageTexts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PageTexts.
     */
    distinct?: PageTextScalarFieldEnum | PageTextScalarFieldEnum[]
  }

  /**
   * PageText findMany
   */
  export type PageTextFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageText
     */
    select?: PageTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageText
     */
    omit?: PageTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTextInclude<ExtArgs> | null
    /**
     * Filter, which PageTexts to fetch.
     */
    where?: PageTextWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageTexts to fetch.
     */
    orderBy?: PageTextOrderByWithRelationInput | PageTextOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PageTexts.
     */
    cursor?: PageTextWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageTexts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageTexts.
     */
    skip?: number
    distinct?: PageTextScalarFieldEnum | PageTextScalarFieldEnum[]
  }

  /**
   * PageText create
   */
  export type PageTextCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageText
     */
    select?: PageTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageText
     */
    omit?: PageTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTextInclude<ExtArgs> | null
    /**
     * The data needed to create a PageText.
     */
    data: XOR<PageTextCreateInput, PageTextUncheckedCreateInput>
  }

  /**
   * PageText createMany
   */
  export type PageTextCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PageTexts.
     */
    data: PageTextCreateManyInput | PageTextCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PageText createManyAndReturn
   */
  export type PageTextCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageText
     */
    select?: PageTextSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PageText
     */
    omit?: PageTextOmit<ExtArgs> | null
    /**
     * The data used to create many PageTexts.
     */
    data: PageTextCreateManyInput | PageTextCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTextIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PageText update
   */
  export type PageTextUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageText
     */
    select?: PageTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageText
     */
    omit?: PageTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTextInclude<ExtArgs> | null
    /**
     * The data needed to update a PageText.
     */
    data: XOR<PageTextUpdateInput, PageTextUncheckedUpdateInput>
    /**
     * Choose, which PageText to update.
     */
    where: PageTextWhereUniqueInput
  }

  /**
   * PageText updateMany
   */
  export type PageTextUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PageTexts.
     */
    data: XOR<PageTextUpdateManyMutationInput, PageTextUncheckedUpdateManyInput>
    /**
     * Filter which PageTexts to update
     */
    where?: PageTextWhereInput
    /**
     * Limit how many PageTexts to update.
     */
    limit?: number
  }

  /**
   * PageText updateManyAndReturn
   */
  export type PageTextUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageText
     */
    select?: PageTextSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PageText
     */
    omit?: PageTextOmit<ExtArgs> | null
    /**
     * The data used to update PageTexts.
     */
    data: XOR<PageTextUpdateManyMutationInput, PageTextUncheckedUpdateManyInput>
    /**
     * Filter which PageTexts to update
     */
    where?: PageTextWhereInput
    /**
     * Limit how many PageTexts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTextIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PageText upsert
   */
  export type PageTextUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageText
     */
    select?: PageTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageText
     */
    omit?: PageTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTextInclude<ExtArgs> | null
    /**
     * The filter to search for the PageText to update in case it exists.
     */
    where: PageTextWhereUniqueInput
    /**
     * In case the PageText found by the `where` argument doesn't exist, create a new PageText with this data.
     */
    create: XOR<PageTextCreateInput, PageTextUncheckedCreateInput>
    /**
     * In case the PageText was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageTextUpdateInput, PageTextUncheckedUpdateInput>
  }

  /**
   * PageText delete
   */
  export type PageTextDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageText
     */
    select?: PageTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageText
     */
    omit?: PageTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTextInclude<ExtArgs> | null
    /**
     * Filter which PageText to delete.
     */
    where: PageTextWhereUniqueInput
  }

  /**
   * PageText deleteMany
   */
  export type PageTextDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PageTexts to delete
     */
    where?: PageTextWhereInput
    /**
     * Limit how many PageTexts to delete.
     */
    limit?: number
  }

  /**
   * PageText.contributor
   */
  export type PageText$contributorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PageText without action
   */
  export type PageTextDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageText
     */
    select?: PageTextSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageText
     */
    omit?: PageTextOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageTextInclude<ExtArgs> | null
  }


  /**
   * Model PageData
   */

  export type AggregatePageData = {
    _count: PageDataCountAggregateOutputType | null
    _min: PageDataMinAggregateOutputType | null
    _max: PageDataMaxAggregateOutputType | null
  }

  export type PageDataMinAggregateOutputType = {
    id: string | null
    pageId: string | null
    updatedAt: Date | null
  }

  export type PageDataMaxAggregateOutputType = {
    id: string | null
    pageId: string | null
    updatedAt: Date | null
  }

  export type PageDataCountAggregateOutputType = {
    id: number
    pageId: number
    ocrData: number
    updatedAt: number
    _all: number
  }


  export type PageDataMinAggregateInputType = {
    id?: true
    pageId?: true
    updatedAt?: true
  }

  export type PageDataMaxAggregateInputType = {
    id?: true
    pageId?: true
    updatedAt?: true
  }

  export type PageDataCountAggregateInputType = {
    id?: true
    pageId?: true
    ocrData?: true
    updatedAt?: true
    _all?: true
  }

  export type PageDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PageData to aggregate.
     */
    where?: PageDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageData to fetch.
     */
    orderBy?: PageDataOrderByWithRelationInput | PageDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PageDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PageData
    **/
    _count?: true | PageDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PageDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PageDataMaxAggregateInputType
  }

  export type GetPageDataAggregateType<T extends PageDataAggregateArgs> = {
        [P in keyof T & keyof AggregatePageData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePageData[P]>
      : GetScalarType<T[P], AggregatePageData[P]>
  }




  export type PageDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageDataWhereInput
    orderBy?: PageDataOrderByWithAggregationInput | PageDataOrderByWithAggregationInput[]
    by: PageDataScalarFieldEnum[] | PageDataScalarFieldEnum
    having?: PageDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageDataCountAggregateInputType | true
    _min?: PageDataMinAggregateInputType
    _max?: PageDataMaxAggregateInputType
  }

  export type PageDataGroupByOutputType = {
    id: string
    pageId: string
    ocrData: JsonValue
    updatedAt: Date
    _count: PageDataCountAggregateOutputType | null
    _min: PageDataMinAggregateOutputType | null
    _max: PageDataMaxAggregateOutputType | null
  }

  type GetPageDataGroupByPayload<T extends PageDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PageDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PageDataGroupByOutputType[P]>
            : GetScalarType<T[P], PageDataGroupByOutputType[P]>
        }
      >
    >


  export type PageDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageId?: boolean
    ocrData?: boolean
    updatedAt?: boolean
    page?: boolean | VolumePageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pageData"]>

  export type PageDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageId?: boolean
    ocrData?: boolean
    updatedAt?: boolean
    page?: boolean | VolumePageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pageData"]>

  export type PageDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageId?: boolean
    ocrData?: boolean
    updatedAt?: boolean
    page?: boolean | VolumePageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pageData"]>

  export type PageDataSelectScalar = {
    id?: boolean
    pageId?: boolean
    ocrData?: boolean
    updatedAt?: boolean
  }

  export type PageDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pageId" | "ocrData" | "updatedAt", ExtArgs["result"]["pageData"]>
  export type PageDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page?: boolean | VolumePageDefaultArgs<ExtArgs>
  }
  export type PageDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page?: boolean | VolumePageDefaultArgs<ExtArgs>
  }
  export type PageDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page?: boolean | VolumePageDefaultArgs<ExtArgs>
  }

  export type $PageDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PageData"
    objects: {
      page: Prisma.$VolumePagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pageId: string
      ocrData: Prisma.JsonValue
      updatedAt: Date
    }, ExtArgs["result"]["pageData"]>
    composites: {}
  }

  type PageDataGetPayload<S extends boolean | null | undefined | PageDataDefaultArgs> = $Result.GetResult<Prisma.$PageDataPayload, S>

  type PageDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PageDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PageDataCountAggregateInputType | true
    }

  export interface PageDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PageData'], meta: { name: 'PageData' } }
    /**
     * Find zero or one PageData that matches the filter.
     * @param {PageDataFindUniqueArgs} args - Arguments to find a PageData
     * @example
     * // Get one PageData
     * const pageData = await prisma.pageData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PageDataFindUniqueArgs>(args: SelectSubset<T, PageDataFindUniqueArgs<ExtArgs>>): Prisma__PageDataClient<$Result.GetResult<Prisma.$PageDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PageData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PageDataFindUniqueOrThrowArgs} args - Arguments to find a PageData
     * @example
     * // Get one PageData
     * const pageData = await prisma.pageData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PageDataFindUniqueOrThrowArgs>(args: SelectSubset<T, PageDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PageDataClient<$Result.GetResult<Prisma.$PageDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PageData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageDataFindFirstArgs} args - Arguments to find a PageData
     * @example
     * // Get one PageData
     * const pageData = await prisma.pageData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PageDataFindFirstArgs>(args?: SelectSubset<T, PageDataFindFirstArgs<ExtArgs>>): Prisma__PageDataClient<$Result.GetResult<Prisma.$PageDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PageData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageDataFindFirstOrThrowArgs} args - Arguments to find a PageData
     * @example
     * // Get one PageData
     * const pageData = await prisma.pageData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PageDataFindFirstOrThrowArgs>(args?: SelectSubset<T, PageDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__PageDataClient<$Result.GetResult<Prisma.$PageDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PageData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PageData
     * const pageData = await prisma.pageData.findMany()
     * 
     * // Get first 10 PageData
     * const pageData = await prisma.pageData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pageDataWithIdOnly = await prisma.pageData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PageDataFindManyArgs>(args?: SelectSubset<T, PageDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PageData.
     * @param {PageDataCreateArgs} args - Arguments to create a PageData.
     * @example
     * // Create one PageData
     * const PageData = await prisma.pageData.create({
     *   data: {
     *     // ... data to create a PageData
     *   }
     * })
     * 
     */
    create<T extends PageDataCreateArgs>(args: SelectSubset<T, PageDataCreateArgs<ExtArgs>>): Prisma__PageDataClient<$Result.GetResult<Prisma.$PageDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PageData.
     * @param {PageDataCreateManyArgs} args - Arguments to create many PageData.
     * @example
     * // Create many PageData
     * const pageData = await prisma.pageData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PageDataCreateManyArgs>(args?: SelectSubset<T, PageDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PageData and returns the data saved in the database.
     * @param {PageDataCreateManyAndReturnArgs} args - Arguments to create many PageData.
     * @example
     * // Create many PageData
     * const pageData = await prisma.pageData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PageData and only return the `id`
     * const pageDataWithIdOnly = await prisma.pageData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PageDataCreateManyAndReturnArgs>(args?: SelectSubset<T, PageDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PageData.
     * @param {PageDataDeleteArgs} args - Arguments to delete one PageData.
     * @example
     * // Delete one PageData
     * const PageData = await prisma.pageData.delete({
     *   where: {
     *     // ... filter to delete one PageData
     *   }
     * })
     * 
     */
    delete<T extends PageDataDeleteArgs>(args: SelectSubset<T, PageDataDeleteArgs<ExtArgs>>): Prisma__PageDataClient<$Result.GetResult<Prisma.$PageDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PageData.
     * @param {PageDataUpdateArgs} args - Arguments to update one PageData.
     * @example
     * // Update one PageData
     * const pageData = await prisma.pageData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PageDataUpdateArgs>(args: SelectSubset<T, PageDataUpdateArgs<ExtArgs>>): Prisma__PageDataClient<$Result.GetResult<Prisma.$PageDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PageData.
     * @param {PageDataDeleteManyArgs} args - Arguments to filter PageData to delete.
     * @example
     * // Delete a few PageData
     * const { count } = await prisma.pageData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PageDataDeleteManyArgs>(args?: SelectSubset<T, PageDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PageData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PageData
     * const pageData = await prisma.pageData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PageDataUpdateManyArgs>(args: SelectSubset<T, PageDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PageData and returns the data updated in the database.
     * @param {PageDataUpdateManyAndReturnArgs} args - Arguments to update many PageData.
     * @example
     * // Update many PageData
     * const pageData = await prisma.pageData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PageData and only return the `id`
     * const pageDataWithIdOnly = await prisma.pageData.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PageDataUpdateManyAndReturnArgs>(args: SelectSubset<T, PageDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PageData.
     * @param {PageDataUpsertArgs} args - Arguments to update or create a PageData.
     * @example
     * // Update or create a PageData
     * const pageData = await prisma.pageData.upsert({
     *   create: {
     *     // ... data to create a PageData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PageData we want to update
     *   }
     * })
     */
    upsert<T extends PageDataUpsertArgs>(args: SelectSubset<T, PageDataUpsertArgs<ExtArgs>>): Prisma__PageDataClient<$Result.GetResult<Prisma.$PageDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PageData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageDataCountArgs} args - Arguments to filter PageData to count.
     * @example
     * // Count the number of PageData
     * const count = await prisma.pageData.count({
     *   where: {
     *     // ... the filter for the PageData we want to count
     *   }
     * })
    **/
    count<T extends PageDataCountArgs>(
      args?: Subset<T, PageDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PageData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PageDataAggregateArgs>(args: Subset<T, PageDataAggregateArgs>): Prisma.PrismaPromise<GetPageDataAggregateType<T>>

    /**
     * Group by PageData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PageDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageDataGroupByArgs['orderBy'] }
        : { orderBy?: PageDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PageDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPageDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PageData model
   */
  readonly fields: PageDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PageData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    page<T extends VolumePageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VolumePageDefaultArgs<ExtArgs>>): Prisma__VolumePageClient<$Result.GetResult<Prisma.$VolumePagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PageData model
   */
  interface PageDataFieldRefs {
    readonly id: FieldRef<"PageData", 'String'>
    readonly pageId: FieldRef<"PageData", 'String'>
    readonly ocrData: FieldRef<"PageData", 'Json'>
    readonly updatedAt: FieldRef<"PageData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PageData findUnique
   */
  export type PageDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageData
     */
    select?: PageDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageData
     */
    omit?: PageDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageDataInclude<ExtArgs> | null
    /**
     * Filter, which PageData to fetch.
     */
    where: PageDataWhereUniqueInput
  }

  /**
   * PageData findUniqueOrThrow
   */
  export type PageDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageData
     */
    select?: PageDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageData
     */
    omit?: PageDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageDataInclude<ExtArgs> | null
    /**
     * Filter, which PageData to fetch.
     */
    where: PageDataWhereUniqueInput
  }

  /**
   * PageData findFirst
   */
  export type PageDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageData
     */
    select?: PageDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageData
     */
    omit?: PageDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageDataInclude<ExtArgs> | null
    /**
     * Filter, which PageData to fetch.
     */
    where?: PageDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageData to fetch.
     */
    orderBy?: PageDataOrderByWithRelationInput | PageDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PageData.
     */
    cursor?: PageDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PageData.
     */
    distinct?: PageDataScalarFieldEnum | PageDataScalarFieldEnum[]
  }

  /**
   * PageData findFirstOrThrow
   */
  export type PageDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageData
     */
    select?: PageDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageData
     */
    omit?: PageDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageDataInclude<ExtArgs> | null
    /**
     * Filter, which PageData to fetch.
     */
    where?: PageDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageData to fetch.
     */
    orderBy?: PageDataOrderByWithRelationInput | PageDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PageData.
     */
    cursor?: PageDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PageData.
     */
    distinct?: PageDataScalarFieldEnum | PageDataScalarFieldEnum[]
  }

  /**
   * PageData findMany
   */
  export type PageDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageData
     */
    select?: PageDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageData
     */
    omit?: PageDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageDataInclude<ExtArgs> | null
    /**
     * Filter, which PageData to fetch.
     */
    where?: PageDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageData to fetch.
     */
    orderBy?: PageDataOrderByWithRelationInput | PageDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PageData.
     */
    cursor?: PageDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageData.
     */
    skip?: number
    distinct?: PageDataScalarFieldEnum | PageDataScalarFieldEnum[]
  }

  /**
   * PageData create
   */
  export type PageDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageData
     */
    select?: PageDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageData
     */
    omit?: PageDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageDataInclude<ExtArgs> | null
    /**
     * The data needed to create a PageData.
     */
    data: XOR<PageDataCreateInput, PageDataUncheckedCreateInput>
  }

  /**
   * PageData createMany
   */
  export type PageDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PageData.
     */
    data: PageDataCreateManyInput | PageDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PageData createManyAndReturn
   */
  export type PageDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageData
     */
    select?: PageDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PageData
     */
    omit?: PageDataOmit<ExtArgs> | null
    /**
     * The data used to create many PageData.
     */
    data: PageDataCreateManyInput | PageDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PageData update
   */
  export type PageDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageData
     */
    select?: PageDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageData
     */
    omit?: PageDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageDataInclude<ExtArgs> | null
    /**
     * The data needed to update a PageData.
     */
    data: XOR<PageDataUpdateInput, PageDataUncheckedUpdateInput>
    /**
     * Choose, which PageData to update.
     */
    where: PageDataWhereUniqueInput
  }

  /**
   * PageData updateMany
   */
  export type PageDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PageData.
     */
    data: XOR<PageDataUpdateManyMutationInput, PageDataUncheckedUpdateManyInput>
    /**
     * Filter which PageData to update
     */
    where?: PageDataWhereInput
    /**
     * Limit how many PageData to update.
     */
    limit?: number
  }

  /**
   * PageData updateManyAndReturn
   */
  export type PageDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageData
     */
    select?: PageDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PageData
     */
    omit?: PageDataOmit<ExtArgs> | null
    /**
     * The data used to update PageData.
     */
    data: XOR<PageDataUpdateManyMutationInput, PageDataUncheckedUpdateManyInput>
    /**
     * Filter which PageData to update
     */
    where?: PageDataWhereInput
    /**
     * Limit how many PageData to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PageData upsert
   */
  export type PageDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageData
     */
    select?: PageDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageData
     */
    omit?: PageDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageDataInclude<ExtArgs> | null
    /**
     * The filter to search for the PageData to update in case it exists.
     */
    where: PageDataWhereUniqueInput
    /**
     * In case the PageData found by the `where` argument doesn't exist, create a new PageData with this data.
     */
    create: XOR<PageDataCreateInput, PageDataUncheckedCreateInput>
    /**
     * In case the PageData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageDataUpdateInput, PageDataUncheckedUpdateInput>
  }

  /**
   * PageData delete
   */
  export type PageDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageData
     */
    select?: PageDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageData
     */
    omit?: PageDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageDataInclude<ExtArgs> | null
    /**
     * Filter which PageData to delete.
     */
    where: PageDataWhereUniqueInput
  }

  /**
   * PageData deleteMany
   */
  export type PageDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PageData to delete
     */
    where?: PageDataWhereInput
    /**
     * Limit how many PageData to delete.
     */
    limit?: number
  }

  /**
   * PageData without action
   */
  export type PageDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageData
     */
    select?: PageDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageData
     */
    omit?: PageDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageDataInclude<ExtArgs> | null
  }


  /**
   * Model PageImage
   */

  export type AggregatePageImage = {
    _count: PageImageCountAggregateOutputType | null
    _min: PageImageMinAggregateOutputType | null
    _max: PageImageMaxAggregateOutputType | null
  }

  export type PageImageMinAggregateOutputType = {
    id: string | null
    pageId: string | null
    storageFileId: string | null
    useType: $Enums.ImageUseType | null
    createdAt: Date | null
  }

  export type PageImageMaxAggregateOutputType = {
    id: string | null
    pageId: string | null
    storageFileId: string | null
    useType: $Enums.ImageUseType | null
    createdAt: Date | null
  }

  export type PageImageCountAggregateOutputType = {
    id: number
    pageId: number
    storageFileId: number
    useType: number
    createdAt: number
    _all: number
  }


  export type PageImageMinAggregateInputType = {
    id?: true
    pageId?: true
    storageFileId?: true
    useType?: true
    createdAt?: true
  }

  export type PageImageMaxAggregateInputType = {
    id?: true
    pageId?: true
    storageFileId?: true
    useType?: true
    createdAt?: true
  }

  export type PageImageCountAggregateInputType = {
    id?: true
    pageId?: true
    storageFileId?: true
    useType?: true
    createdAt?: true
    _all?: true
  }

  export type PageImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PageImage to aggregate.
     */
    where?: PageImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageImages to fetch.
     */
    orderBy?: PageImageOrderByWithRelationInput | PageImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PageImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PageImages
    **/
    _count?: true | PageImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PageImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PageImageMaxAggregateInputType
  }

  export type GetPageImageAggregateType<T extends PageImageAggregateArgs> = {
        [P in keyof T & keyof AggregatePageImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePageImage[P]>
      : GetScalarType<T[P], AggregatePageImage[P]>
  }




  export type PageImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageImageWhereInput
    orderBy?: PageImageOrderByWithAggregationInput | PageImageOrderByWithAggregationInput[]
    by: PageImageScalarFieldEnum[] | PageImageScalarFieldEnum
    having?: PageImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageImageCountAggregateInputType | true
    _min?: PageImageMinAggregateInputType
    _max?: PageImageMaxAggregateInputType
  }

  export type PageImageGroupByOutputType = {
    id: string
    pageId: string
    storageFileId: string
    useType: $Enums.ImageUseType
    createdAt: Date
    _count: PageImageCountAggregateOutputType | null
    _min: PageImageMinAggregateOutputType | null
    _max: PageImageMaxAggregateOutputType | null
  }

  type GetPageImageGroupByPayload<T extends PageImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PageImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PageImageGroupByOutputType[P]>
            : GetScalarType<T[P], PageImageGroupByOutputType[P]>
        }
      >
    >


  export type PageImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageId?: boolean
    storageFileId?: boolean
    useType?: boolean
    createdAt?: boolean
    page?: boolean | VolumePageDefaultArgs<ExtArgs>
    storageFile?: boolean | StorageFileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pageImage"]>

  export type PageImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageId?: boolean
    storageFileId?: boolean
    useType?: boolean
    createdAt?: boolean
    page?: boolean | VolumePageDefaultArgs<ExtArgs>
    storageFile?: boolean | StorageFileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pageImage"]>

  export type PageImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageId?: boolean
    storageFileId?: boolean
    useType?: boolean
    createdAt?: boolean
    page?: boolean | VolumePageDefaultArgs<ExtArgs>
    storageFile?: boolean | StorageFileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pageImage"]>

  export type PageImageSelectScalar = {
    id?: boolean
    pageId?: boolean
    storageFileId?: boolean
    useType?: boolean
    createdAt?: boolean
  }

  export type PageImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pageId" | "storageFileId" | "useType" | "createdAt", ExtArgs["result"]["pageImage"]>
  export type PageImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page?: boolean | VolumePageDefaultArgs<ExtArgs>
    storageFile?: boolean | StorageFileDefaultArgs<ExtArgs>
  }
  export type PageImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page?: boolean | VolumePageDefaultArgs<ExtArgs>
    storageFile?: boolean | StorageFileDefaultArgs<ExtArgs>
  }
  export type PageImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page?: boolean | VolumePageDefaultArgs<ExtArgs>
    storageFile?: boolean | StorageFileDefaultArgs<ExtArgs>
  }

  export type $PageImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PageImage"
    objects: {
      page: Prisma.$VolumePagePayload<ExtArgs>
      storageFile: Prisma.$StorageFilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pageId: string
      storageFileId: string
      useType: $Enums.ImageUseType
      createdAt: Date
    }, ExtArgs["result"]["pageImage"]>
    composites: {}
  }

  type PageImageGetPayload<S extends boolean | null | undefined | PageImageDefaultArgs> = $Result.GetResult<Prisma.$PageImagePayload, S>

  type PageImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PageImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PageImageCountAggregateInputType | true
    }

  export interface PageImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PageImage'], meta: { name: 'PageImage' } }
    /**
     * Find zero or one PageImage that matches the filter.
     * @param {PageImageFindUniqueArgs} args - Arguments to find a PageImage
     * @example
     * // Get one PageImage
     * const pageImage = await prisma.pageImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PageImageFindUniqueArgs>(args: SelectSubset<T, PageImageFindUniqueArgs<ExtArgs>>): Prisma__PageImageClient<$Result.GetResult<Prisma.$PageImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PageImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PageImageFindUniqueOrThrowArgs} args - Arguments to find a PageImage
     * @example
     * // Get one PageImage
     * const pageImage = await prisma.pageImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PageImageFindUniqueOrThrowArgs>(args: SelectSubset<T, PageImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PageImageClient<$Result.GetResult<Prisma.$PageImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PageImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageImageFindFirstArgs} args - Arguments to find a PageImage
     * @example
     * // Get one PageImage
     * const pageImage = await prisma.pageImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PageImageFindFirstArgs>(args?: SelectSubset<T, PageImageFindFirstArgs<ExtArgs>>): Prisma__PageImageClient<$Result.GetResult<Prisma.$PageImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PageImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageImageFindFirstOrThrowArgs} args - Arguments to find a PageImage
     * @example
     * // Get one PageImage
     * const pageImage = await prisma.pageImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PageImageFindFirstOrThrowArgs>(args?: SelectSubset<T, PageImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PageImageClient<$Result.GetResult<Prisma.$PageImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PageImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PageImages
     * const pageImages = await prisma.pageImage.findMany()
     * 
     * // Get first 10 PageImages
     * const pageImages = await prisma.pageImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pageImageWithIdOnly = await prisma.pageImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PageImageFindManyArgs>(args?: SelectSubset<T, PageImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PageImage.
     * @param {PageImageCreateArgs} args - Arguments to create a PageImage.
     * @example
     * // Create one PageImage
     * const PageImage = await prisma.pageImage.create({
     *   data: {
     *     // ... data to create a PageImage
     *   }
     * })
     * 
     */
    create<T extends PageImageCreateArgs>(args: SelectSubset<T, PageImageCreateArgs<ExtArgs>>): Prisma__PageImageClient<$Result.GetResult<Prisma.$PageImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PageImages.
     * @param {PageImageCreateManyArgs} args - Arguments to create many PageImages.
     * @example
     * // Create many PageImages
     * const pageImage = await prisma.pageImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PageImageCreateManyArgs>(args?: SelectSubset<T, PageImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PageImages and returns the data saved in the database.
     * @param {PageImageCreateManyAndReturnArgs} args - Arguments to create many PageImages.
     * @example
     * // Create many PageImages
     * const pageImage = await prisma.pageImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PageImages and only return the `id`
     * const pageImageWithIdOnly = await prisma.pageImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PageImageCreateManyAndReturnArgs>(args?: SelectSubset<T, PageImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PageImage.
     * @param {PageImageDeleteArgs} args - Arguments to delete one PageImage.
     * @example
     * // Delete one PageImage
     * const PageImage = await prisma.pageImage.delete({
     *   where: {
     *     // ... filter to delete one PageImage
     *   }
     * })
     * 
     */
    delete<T extends PageImageDeleteArgs>(args: SelectSubset<T, PageImageDeleteArgs<ExtArgs>>): Prisma__PageImageClient<$Result.GetResult<Prisma.$PageImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PageImage.
     * @param {PageImageUpdateArgs} args - Arguments to update one PageImage.
     * @example
     * // Update one PageImage
     * const pageImage = await prisma.pageImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PageImageUpdateArgs>(args: SelectSubset<T, PageImageUpdateArgs<ExtArgs>>): Prisma__PageImageClient<$Result.GetResult<Prisma.$PageImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PageImages.
     * @param {PageImageDeleteManyArgs} args - Arguments to filter PageImages to delete.
     * @example
     * // Delete a few PageImages
     * const { count } = await prisma.pageImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PageImageDeleteManyArgs>(args?: SelectSubset<T, PageImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PageImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PageImages
     * const pageImage = await prisma.pageImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PageImageUpdateManyArgs>(args: SelectSubset<T, PageImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PageImages and returns the data updated in the database.
     * @param {PageImageUpdateManyAndReturnArgs} args - Arguments to update many PageImages.
     * @example
     * // Update many PageImages
     * const pageImage = await prisma.pageImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PageImages and only return the `id`
     * const pageImageWithIdOnly = await prisma.pageImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PageImageUpdateManyAndReturnArgs>(args: SelectSubset<T, PageImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PageImage.
     * @param {PageImageUpsertArgs} args - Arguments to update or create a PageImage.
     * @example
     * // Update or create a PageImage
     * const pageImage = await prisma.pageImage.upsert({
     *   create: {
     *     // ... data to create a PageImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PageImage we want to update
     *   }
     * })
     */
    upsert<T extends PageImageUpsertArgs>(args: SelectSubset<T, PageImageUpsertArgs<ExtArgs>>): Prisma__PageImageClient<$Result.GetResult<Prisma.$PageImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PageImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageImageCountArgs} args - Arguments to filter PageImages to count.
     * @example
     * // Count the number of PageImages
     * const count = await prisma.pageImage.count({
     *   where: {
     *     // ... the filter for the PageImages we want to count
     *   }
     * })
    **/
    count<T extends PageImageCountArgs>(
      args?: Subset<T, PageImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PageImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PageImageAggregateArgs>(args: Subset<T, PageImageAggregateArgs>): Prisma.PrismaPromise<GetPageImageAggregateType<T>>

    /**
     * Group by PageImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PageImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageImageGroupByArgs['orderBy'] }
        : { orderBy?: PageImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PageImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPageImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PageImage model
   */
  readonly fields: PageImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PageImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    page<T extends VolumePageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VolumePageDefaultArgs<ExtArgs>>): Prisma__VolumePageClient<$Result.GetResult<Prisma.$VolumePagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    storageFile<T extends StorageFileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StorageFileDefaultArgs<ExtArgs>>): Prisma__StorageFileClient<$Result.GetResult<Prisma.$StorageFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PageImage model
   */
  interface PageImageFieldRefs {
    readonly id: FieldRef<"PageImage", 'String'>
    readonly pageId: FieldRef<"PageImage", 'String'>
    readonly storageFileId: FieldRef<"PageImage", 'String'>
    readonly useType: FieldRef<"PageImage", 'ImageUseType'>
    readonly createdAt: FieldRef<"PageImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PageImage findUnique
   */
  export type PageImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageImage
     */
    select?: PageImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageImage
     */
    omit?: PageImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageImageInclude<ExtArgs> | null
    /**
     * Filter, which PageImage to fetch.
     */
    where: PageImageWhereUniqueInput
  }

  /**
   * PageImage findUniqueOrThrow
   */
  export type PageImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageImage
     */
    select?: PageImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageImage
     */
    omit?: PageImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageImageInclude<ExtArgs> | null
    /**
     * Filter, which PageImage to fetch.
     */
    where: PageImageWhereUniqueInput
  }

  /**
   * PageImage findFirst
   */
  export type PageImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageImage
     */
    select?: PageImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageImage
     */
    omit?: PageImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageImageInclude<ExtArgs> | null
    /**
     * Filter, which PageImage to fetch.
     */
    where?: PageImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageImages to fetch.
     */
    orderBy?: PageImageOrderByWithRelationInput | PageImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PageImages.
     */
    cursor?: PageImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PageImages.
     */
    distinct?: PageImageScalarFieldEnum | PageImageScalarFieldEnum[]
  }

  /**
   * PageImage findFirstOrThrow
   */
  export type PageImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageImage
     */
    select?: PageImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageImage
     */
    omit?: PageImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageImageInclude<ExtArgs> | null
    /**
     * Filter, which PageImage to fetch.
     */
    where?: PageImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageImages to fetch.
     */
    orderBy?: PageImageOrderByWithRelationInput | PageImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PageImages.
     */
    cursor?: PageImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PageImages.
     */
    distinct?: PageImageScalarFieldEnum | PageImageScalarFieldEnum[]
  }

  /**
   * PageImage findMany
   */
  export type PageImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageImage
     */
    select?: PageImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageImage
     */
    omit?: PageImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageImageInclude<ExtArgs> | null
    /**
     * Filter, which PageImages to fetch.
     */
    where?: PageImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PageImages to fetch.
     */
    orderBy?: PageImageOrderByWithRelationInput | PageImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PageImages.
     */
    cursor?: PageImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PageImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PageImages.
     */
    skip?: number
    distinct?: PageImageScalarFieldEnum | PageImageScalarFieldEnum[]
  }

  /**
   * PageImage create
   */
  export type PageImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageImage
     */
    select?: PageImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageImage
     */
    omit?: PageImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageImageInclude<ExtArgs> | null
    /**
     * The data needed to create a PageImage.
     */
    data: XOR<PageImageCreateInput, PageImageUncheckedCreateInput>
  }

  /**
   * PageImage createMany
   */
  export type PageImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PageImages.
     */
    data: PageImageCreateManyInput | PageImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PageImage createManyAndReturn
   */
  export type PageImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageImage
     */
    select?: PageImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PageImage
     */
    omit?: PageImageOmit<ExtArgs> | null
    /**
     * The data used to create many PageImages.
     */
    data: PageImageCreateManyInput | PageImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PageImage update
   */
  export type PageImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageImage
     */
    select?: PageImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageImage
     */
    omit?: PageImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageImageInclude<ExtArgs> | null
    /**
     * The data needed to update a PageImage.
     */
    data: XOR<PageImageUpdateInput, PageImageUncheckedUpdateInput>
    /**
     * Choose, which PageImage to update.
     */
    where: PageImageWhereUniqueInput
  }

  /**
   * PageImage updateMany
   */
  export type PageImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PageImages.
     */
    data: XOR<PageImageUpdateManyMutationInput, PageImageUncheckedUpdateManyInput>
    /**
     * Filter which PageImages to update
     */
    where?: PageImageWhereInput
    /**
     * Limit how many PageImages to update.
     */
    limit?: number
  }

  /**
   * PageImage updateManyAndReturn
   */
  export type PageImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageImage
     */
    select?: PageImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PageImage
     */
    omit?: PageImageOmit<ExtArgs> | null
    /**
     * The data used to update PageImages.
     */
    data: XOR<PageImageUpdateManyMutationInput, PageImageUncheckedUpdateManyInput>
    /**
     * Filter which PageImages to update
     */
    where?: PageImageWhereInput
    /**
     * Limit how many PageImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PageImage upsert
   */
  export type PageImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageImage
     */
    select?: PageImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageImage
     */
    omit?: PageImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageImageInclude<ExtArgs> | null
    /**
     * The filter to search for the PageImage to update in case it exists.
     */
    where: PageImageWhereUniqueInput
    /**
     * In case the PageImage found by the `where` argument doesn't exist, create a new PageImage with this data.
     */
    create: XOR<PageImageCreateInput, PageImageUncheckedCreateInput>
    /**
     * In case the PageImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageImageUpdateInput, PageImageUncheckedUpdateInput>
  }

  /**
   * PageImage delete
   */
  export type PageImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageImage
     */
    select?: PageImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageImage
     */
    omit?: PageImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageImageInclude<ExtArgs> | null
    /**
     * Filter which PageImage to delete.
     */
    where: PageImageWhereUniqueInput
  }

  /**
   * PageImage deleteMany
   */
  export type PageImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PageImages to delete
     */
    where?: PageImageWhereInput
    /**
     * Limit how many PageImages to delete.
     */
    limit?: number
  }

  /**
   * PageImage without action
   */
  export type PageImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageImage
     */
    select?: PageImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageImage
     */
    omit?: PageImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageImageInclude<ExtArgs> | null
  }


  /**
   * Model StorageFile
   */

  export type AggregateStorageFile = {
    _count: StorageFileCountAggregateOutputType | null
    _avg: StorageFileAvgAggregateOutputType | null
    _sum: StorageFileSumAggregateOutputType | null
    _min: StorageFileMinAggregateOutputType | null
    _max: StorageFileMaxAggregateOutputType | null
  }

  export type StorageFileAvgAggregateOutputType = {
    sizeBytes: number | null
    width: number | null
    height: number | null
  }

  export type StorageFileSumAggregateOutputType = {
    sizeBytes: number | null
    width: number | null
    height: number | null
  }

  export type StorageFileMinAggregateOutputType = {
    id: string | null
    bucketName: string | null
    storageKey: string | null
    filename: string | null
    mimeType: string | null
    sizeBytes: number | null
    hashEtag: string | null
    publicUrl: string | null
    isPublic: boolean | null
    width: number | null
    height: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StorageFileMaxAggregateOutputType = {
    id: string | null
    bucketName: string | null
    storageKey: string | null
    filename: string | null
    mimeType: string | null
    sizeBytes: number | null
    hashEtag: string | null
    publicUrl: string | null
    isPublic: boolean | null
    width: number | null
    height: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StorageFileCountAggregateOutputType = {
    id: number
    bucketName: number
    storageKey: number
    filename: number
    mimeType: number
    sizeBytes: number
    hashEtag: number
    publicUrl: number
    isPublic: number
    width: number
    height: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StorageFileAvgAggregateInputType = {
    sizeBytes?: true
    width?: true
    height?: true
  }

  export type StorageFileSumAggregateInputType = {
    sizeBytes?: true
    width?: true
    height?: true
  }

  export type StorageFileMinAggregateInputType = {
    id?: true
    bucketName?: true
    storageKey?: true
    filename?: true
    mimeType?: true
    sizeBytes?: true
    hashEtag?: true
    publicUrl?: true
    isPublic?: true
    width?: true
    height?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StorageFileMaxAggregateInputType = {
    id?: true
    bucketName?: true
    storageKey?: true
    filename?: true
    mimeType?: true
    sizeBytes?: true
    hashEtag?: true
    publicUrl?: true
    isPublic?: true
    width?: true
    height?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StorageFileCountAggregateInputType = {
    id?: true
    bucketName?: true
    storageKey?: true
    filename?: true
    mimeType?: true
    sizeBytes?: true
    hashEtag?: true
    publicUrl?: true
    isPublic?: true
    width?: true
    height?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StorageFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorageFile to aggregate.
     */
    where?: StorageFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageFiles to fetch.
     */
    orderBy?: StorageFileOrderByWithRelationInput | StorageFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StorageFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StorageFiles
    **/
    _count?: true | StorageFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StorageFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StorageFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StorageFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StorageFileMaxAggregateInputType
  }

  export type GetStorageFileAggregateType<T extends StorageFileAggregateArgs> = {
        [P in keyof T & keyof AggregateStorageFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorageFile[P]>
      : GetScalarType<T[P], AggregateStorageFile[P]>
  }




  export type StorageFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageFileWhereInput
    orderBy?: StorageFileOrderByWithAggregationInput | StorageFileOrderByWithAggregationInput[]
    by: StorageFileScalarFieldEnum[] | StorageFileScalarFieldEnum
    having?: StorageFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StorageFileCountAggregateInputType | true
    _avg?: StorageFileAvgAggregateInputType
    _sum?: StorageFileSumAggregateInputType
    _min?: StorageFileMinAggregateInputType
    _max?: StorageFileMaxAggregateInputType
  }

  export type StorageFileGroupByOutputType = {
    id: string
    bucketName: string
    storageKey: string
    filename: string
    mimeType: string | null
    sizeBytes: number | null
    hashEtag: string | null
    publicUrl: string | null
    isPublic: boolean
    width: number | null
    height: number | null
    createdAt: Date
    updatedAt: Date
    _count: StorageFileCountAggregateOutputType | null
    _avg: StorageFileAvgAggregateOutputType | null
    _sum: StorageFileSumAggregateOutputType | null
    _min: StorageFileMinAggregateOutputType | null
    _max: StorageFileMaxAggregateOutputType | null
  }

  type GetStorageFileGroupByPayload<T extends StorageFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StorageFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StorageFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StorageFileGroupByOutputType[P]>
            : GetScalarType<T[P], StorageFileGroupByOutputType[P]>
        }
      >
    >


  export type StorageFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bucketName?: boolean
    storageKey?: boolean
    filename?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    hashEtag?: boolean
    publicUrl?: boolean
    isPublic?: boolean
    width?: boolean
    height?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    media?: boolean | StorageFile$mediaArgs<ExtArgs>
    pageImages?: boolean | StorageFile$pageImagesArgs<ExtArgs>
    _count?: boolean | StorageFileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storageFile"]>

  export type StorageFileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bucketName?: boolean
    storageKey?: boolean
    filename?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    hashEtag?: boolean
    publicUrl?: boolean
    isPublic?: boolean
    width?: boolean
    height?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["storageFile"]>

  export type StorageFileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bucketName?: boolean
    storageKey?: boolean
    filename?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    hashEtag?: boolean
    publicUrl?: boolean
    isPublic?: boolean
    width?: boolean
    height?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["storageFile"]>

  export type StorageFileSelectScalar = {
    id?: boolean
    bucketName?: boolean
    storageKey?: boolean
    filename?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    hashEtag?: boolean
    publicUrl?: boolean
    isPublic?: boolean
    width?: boolean
    height?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StorageFileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bucketName" | "storageKey" | "filename" | "mimeType" | "sizeBytes" | "hashEtag" | "publicUrl" | "isPublic" | "width" | "height" | "createdAt" | "updatedAt", ExtArgs["result"]["storageFile"]>
  export type StorageFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | StorageFile$mediaArgs<ExtArgs>
    pageImages?: boolean | StorageFile$pageImagesArgs<ExtArgs>
    _count?: boolean | StorageFileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StorageFileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StorageFileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StorageFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StorageFile"
    objects: {
      media: Prisma.$MediaPayload<ExtArgs>[]
      pageImages: Prisma.$PageImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bucketName: string
      storageKey: string
      filename: string
      mimeType: string | null
      sizeBytes: number | null
      hashEtag: string | null
      publicUrl: string | null
      isPublic: boolean
      width: number | null
      height: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["storageFile"]>
    composites: {}
  }

  type StorageFileGetPayload<S extends boolean | null | undefined | StorageFileDefaultArgs> = $Result.GetResult<Prisma.$StorageFilePayload, S>

  type StorageFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StorageFileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StorageFileCountAggregateInputType | true
    }

  export interface StorageFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StorageFile'], meta: { name: 'StorageFile' } }
    /**
     * Find zero or one StorageFile that matches the filter.
     * @param {StorageFileFindUniqueArgs} args - Arguments to find a StorageFile
     * @example
     * // Get one StorageFile
     * const storageFile = await prisma.storageFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StorageFileFindUniqueArgs>(args: SelectSubset<T, StorageFileFindUniqueArgs<ExtArgs>>): Prisma__StorageFileClient<$Result.GetResult<Prisma.$StorageFilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StorageFile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StorageFileFindUniqueOrThrowArgs} args - Arguments to find a StorageFile
     * @example
     * // Get one StorageFile
     * const storageFile = await prisma.storageFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StorageFileFindUniqueOrThrowArgs>(args: SelectSubset<T, StorageFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StorageFileClient<$Result.GetResult<Prisma.$StorageFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StorageFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageFileFindFirstArgs} args - Arguments to find a StorageFile
     * @example
     * // Get one StorageFile
     * const storageFile = await prisma.storageFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StorageFileFindFirstArgs>(args?: SelectSubset<T, StorageFileFindFirstArgs<ExtArgs>>): Prisma__StorageFileClient<$Result.GetResult<Prisma.$StorageFilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StorageFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageFileFindFirstOrThrowArgs} args - Arguments to find a StorageFile
     * @example
     * // Get one StorageFile
     * const storageFile = await prisma.storageFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StorageFileFindFirstOrThrowArgs>(args?: SelectSubset<T, StorageFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__StorageFileClient<$Result.GetResult<Prisma.$StorageFilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StorageFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StorageFiles
     * const storageFiles = await prisma.storageFile.findMany()
     * 
     * // Get first 10 StorageFiles
     * const storageFiles = await prisma.storageFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storageFileWithIdOnly = await prisma.storageFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StorageFileFindManyArgs>(args?: SelectSubset<T, StorageFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorageFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StorageFile.
     * @param {StorageFileCreateArgs} args - Arguments to create a StorageFile.
     * @example
     * // Create one StorageFile
     * const StorageFile = await prisma.storageFile.create({
     *   data: {
     *     // ... data to create a StorageFile
     *   }
     * })
     * 
     */
    create<T extends StorageFileCreateArgs>(args: SelectSubset<T, StorageFileCreateArgs<ExtArgs>>): Prisma__StorageFileClient<$Result.GetResult<Prisma.$StorageFilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StorageFiles.
     * @param {StorageFileCreateManyArgs} args - Arguments to create many StorageFiles.
     * @example
     * // Create many StorageFiles
     * const storageFile = await prisma.storageFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StorageFileCreateManyArgs>(args?: SelectSubset<T, StorageFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StorageFiles and returns the data saved in the database.
     * @param {StorageFileCreateManyAndReturnArgs} args - Arguments to create many StorageFiles.
     * @example
     * // Create many StorageFiles
     * const storageFile = await prisma.storageFile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StorageFiles and only return the `id`
     * const storageFileWithIdOnly = await prisma.storageFile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StorageFileCreateManyAndReturnArgs>(args?: SelectSubset<T, StorageFileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorageFilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StorageFile.
     * @param {StorageFileDeleteArgs} args - Arguments to delete one StorageFile.
     * @example
     * // Delete one StorageFile
     * const StorageFile = await prisma.storageFile.delete({
     *   where: {
     *     // ... filter to delete one StorageFile
     *   }
     * })
     * 
     */
    delete<T extends StorageFileDeleteArgs>(args: SelectSubset<T, StorageFileDeleteArgs<ExtArgs>>): Prisma__StorageFileClient<$Result.GetResult<Prisma.$StorageFilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StorageFile.
     * @param {StorageFileUpdateArgs} args - Arguments to update one StorageFile.
     * @example
     * // Update one StorageFile
     * const storageFile = await prisma.storageFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StorageFileUpdateArgs>(args: SelectSubset<T, StorageFileUpdateArgs<ExtArgs>>): Prisma__StorageFileClient<$Result.GetResult<Prisma.$StorageFilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StorageFiles.
     * @param {StorageFileDeleteManyArgs} args - Arguments to filter StorageFiles to delete.
     * @example
     * // Delete a few StorageFiles
     * const { count } = await prisma.storageFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StorageFileDeleteManyArgs>(args?: SelectSubset<T, StorageFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StorageFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StorageFiles
     * const storageFile = await prisma.storageFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StorageFileUpdateManyArgs>(args: SelectSubset<T, StorageFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StorageFiles and returns the data updated in the database.
     * @param {StorageFileUpdateManyAndReturnArgs} args - Arguments to update many StorageFiles.
     * @example
     * // Update many StorageFiles
     * const storageFile = await prisma.storageFile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StorageFiles and only return the `id`
     * const storageFileWithIdOnly = await prisma.storageFile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StorageFileUpdateManyAndReturnArgs>(args: SelectSubset<T, StorageFileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorageFilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StorageFile.
     * @param {StorageFileUpsertArgs} args - Arguments to update or create a StorageFile.
     * @example
     * // Update or create a StorageFile
     * const storageFile = await prisma.storageFile.upsert({
     *   create: {
     *     // ... data to create a StorageFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StorageFile we want to update
     *   }
     * })
     */
    upsert<T extends StorageFileUpsertArgs>(args: SelectSubset<T, StorageFileUpsertArgs<ExtArgs>>): Prisma__StorageFileClient<$Result.GetResult<Prisma.$StorageFilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StorageFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageFileCountArgs} args - Arguments to filter StorageFiles to count.
     * @example
     * // Count the number of StorageFiles
     * const count = await prisma.storageFile.count({
     *   where: {
     *     // ... the filter for the StorageFiles we want to count
     *   }
     * })
    **/
    count<T extends StorageFileCountArgs>(
      args?: Subset<T, StorageFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StorageFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StorageFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StorageFileAggregateArgs>(args: Subset<T, StorageFileAggregateArgs>): Prisma.PrismaPromise<GetStorageFileAggregateType<T>>

    /**
     * Group by StorageFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StorageFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StorageFileGroupByArgs['orderBy'] }
        : { orderBy?: StorageFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StorageFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorageFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StorageFile model
   */
  readonly fields: StorageFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StorageFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StorageFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    media<T extends StorageFile$mediaArgs<ExtArgs> = {}>(args?: Subset<T, StorageFile$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pageImages<T extends StorageFile$pageImagesArgs<ExtArgs> = {}>(args?: Subset<T, StorageFile$pageImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PageImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StorageFile model
   */
  interface StorageFileFieldRefs {
    readonly id: FieldRef<"StorageFile", 'String'>
    readonly bucketName: FieldRef<"StorageFile", 'String'>
    readonly storageKey: FieldRef<"StorageFile", 'String'>
    readonly filename: FieldRef<"StorageFile", 'String'>
    readonly mimeType: FieldRef<"StorageFile", 'String'>
    readonly sizeBytes: FieldRef<"StorageFile", 'Float'>
    readonly hashEtag: FieldRef<"StorageFile", 'String'>
    readonly publicUrl: FieldRef<"StorageFile", 'String'>
    readonly isPublic: FieldRef<"StorageFile", 'Boolean'>
    readonly width: FieldRef<"StorageFile", 'Int'>
    readonly height: FieldRef<"StorageFile", 'Int'>
    readonly createdAt: FieldRef<"StorageFile", 'DateTime'>
    readonly updatedAt: FieldRef<"StorageFile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StorageFile findUnique
   */
  export type StorageFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageFile
     */
    select?: StorageFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageFile
     */
    omit?: StorageFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageFileInclude<ExtArgs> | null
    /**
     * Filter, which StorageFile to fetch.
     */
    where: StorageFileWhereUniqueInput
  }

  /**
   * StorageFile findUniqueOrThrow
   */
  export type StorageFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageFile
     */
    select?: StorageFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageFile
     */
    omit?: StorageFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageFileInclude<ExtArgs> | null
    /**
     * Filter, which StorageFile to fetch.
     */
    where: StorageFileWhereUniqueInput
  }

  /**
   * StorageFile findFirst
   */
  export type StorageFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageFile
     */
    select?: StorageFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageFile
     */
    omit?: StorageFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageFileInclude<ExtArgs> | null
    /**
     * Filter, which StorageFile to fetch.
     */
    where?: StorageFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageFiles to fetch.
     */
    orderBy?: StorageFileOrderByWithRelationInput | StorageFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorageFiles.
     */
    cursor?: StorageFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorageFiles.
     */
    distinct?: StorageFileScalarFieldEnum | StorageFileScalarFieldEnum[]
  }

  /**
   * StorageFile findFirstOrThrow
   */
  export type StorageFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageFile
     */
    select?: StorageFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageFile
     */
    omit?: StorageFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageFileInclude<ExtArgs> | null
    /**
     * Filter, which StorageFile to fetch.
     */
    where?: StorageFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageFiles to fetch.
     */
    orderBy?: StorageFileOrderByWithRelationInput | StorageFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorageFiles.
     */
    cursor?: StorageFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorageFiles.
     */
    distinct?: StorageFileScalarFieldEnum | StorageFileScalarFieldEnum[]
  }

  /**
   * StorageFile findMany
   */
  export type StorageFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageFile
     */
    select?: StorageFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageFile
     */
    omit?: StorageFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageFileInclude<ExtArgs> | null
    /**
     * Filter, which StorageFiles to fetch.
     */
    where?: StorageFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageFiles to fetch.
     */
    orderBy?: StorageFileOrderByWithRelationInput | StorageFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StorageFiles.
     */
    cursor?: StorageFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageFiles.
     */
    skip?: number
    distinct?: StorageFileScalarFieldEnum | StorageFileScalarFieldEnum[]
  }

  /**
   * StorageFile create
   */
  export type StorageFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageFile
     */
    select?: StorageFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageFile
     */
    omit?: StorageFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageFileInclude<ExtArgs> | null
    /**
     * The data needed to create a StorageFile.
     */
    data: XOR<StorageFileCreateInput, StorageFileUncheckedCreateInput>
  }

  /**
   * StorageFile createMany
   */
  export type StorageFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StorageFiles.
     */
    data: StorageFileCreateManyInput | StorageFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StorageFile createManyAndReturn
   */
  export type StorageFileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageFile
     */
    select?: StorageFileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StorageFile
     */
    omit?: StorageFileOmit<ExtArgs> | null
    /**
     * The data used to create many StorageFiles.
     */
    data: StorageFileCreateManyInput | StorageFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StorageFile update
   */
  export type StorageFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageFile
     */
    select?: StorageFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageFile
     */
    omit?: StorageFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageFileInclude<ExtArgs> | null
    /**
     * The data needed to update a StorageFile.
     */
    data: XOR<StorageFileUpdateInput, StorageFileUncheckedUpdateInput>
    /**
     * Choose, which StorageFile to update.
     */
    where: StorageFileWhereUniqueInput
  }

  /**
   * StorageFile updateMany
   */
  export type StorageFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StorageFiles.
     */
    data: XOR<StorageFileUpdateManyMutationInput, StorageFileUncheckedUpdateManyInput>
    /**
     * Filter which StorageFiles to update
     */
    where?: StorageFileWhereInput
    /**
     * Limit how many StorageFiles to update.
     */
    limit?: number
  }

  /**
   * StorageFile updateManyAndReturn
   */
  export type StorageFileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageFile
     */
    select?: StorageFileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StorageFile
     */
    omit?: StorageFileOmit<ExtArgs> | null
    /**
     * The data used to update StorageFiles.
     */
    data: XOR<StorageFileUpdateManyMutationInput, StorageFileUncheckedUpdateManyInput>
    /**
     * Filter which StorageFiles to update
     */
    where?: StorageFileWhereInput
    /**
     * Limit how many StorageFiles to update.
     */
    limit?: number
  }

  /**
   * StorageFile upsert
   */
  export type StorageFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageFile
     */
    select?: StorageFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageFile
     */
    omit?: StorageFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageFileInclude<ExtArgs> | null
    /**
     * The filter to search for the StorageFile to update in case it exists.
     */
    where: StorageFileWhereUniqueInput
    /**
     * In case the StorageFile found by the `where` argument doesn't exist, create a new StorageFile with this data.
     */
    create: XOR<StorageFileCreateInput, StorageFileUncheckedCreateInput>
    /**
     * In case the StorageFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StorageFileUpdateInput, StorageFileUncheckedUpdateInput>
  }

  /**
   * StorageFile delete
   */
  export type StorageFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageFile
     */
    select?: StorageFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageFile
     */
    omit?: StorageFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageFileInclude<ExtArgs> | null
    /**
     * Filter which StorageFile to delete.
     */
    where: StorageFileWhereUniqueInput
  }

  /**
   * StorageFile deleteMany
   */
  export type StorageFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorageFiles to delete
     */
    where?: StorageFileWhereInput
    /**
     * Limit how many StorageFiles to delete.
     */
    limit?: number
  }

  /**
   * StorageFile.media
   */
  export type StorageFile$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * StorageFile.pageImages
   */
  export type StorageFile$pageImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PageImage
     */
    select?: PageImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PageImage
     */
    omit?: PageImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageImageInclude<ExtArgs> | null
    where?: PageImageWhereInput
    orderBy?: PageImageOrderByWithRelationInput | PageImageOrderByWithRelationInput[]
    cursor?: PageImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageImageScalarFieldEnum | PageImageScalarFieldEnum[]
  }

  /**
   * StorageFile without action
   */
  export type StorageFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageFile
     */
    select?: StorageFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageFile
     */
    omit?: StorageFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageFileInclude<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaMinAggregateOutputType = {
    id: string | null
    filename: string | null
    url: string | null
    storageFileId: string | null
    createdAt: Date | null
  }

  export type MediaMaxAggregateOutputType = {
    id: string | null
    filename: string | null
    url: string | null
    storageFileId: string | null
    createdAt: Date | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    filename: number
    url: number
    storageFileId: number
    altTextI18n: number
    createdAt: number
    _all: number
  }


  export type MediaMinAggregateInputType = {
    id?: true
    filename?: true
    url?: true
    storageFileId?: true
    createdAt?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    filename?: true
    url?: true
    storageFileId?: true
    createdAt?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    filename?: true
    url?: true
    storageFileId?: true
    altTextI18n?: true
    createdAt?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: string
    filename: string
    url: string
    storageFileId: string | null
    altTextI18n: JsonValue | null
    createdAt: Date
    _count: MediaCountAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    url?: boolean
    storageFileId?: boolean
    altTextI18n?: boolean
    createdAt?: boolean
    thumbnailForCategory?: boolean | Media$thumbnailForCategoryArgs<ExtArgs>
    thumbnailForCollections?: boolean | Media$thumbnailForCollectionsArgs<ExtArgs>
    thumbnailForMaps?: boolean | Media$thumbnailForMapsArgs<ExtArgs>
    storageFile?: boolean | Media$storageFileArgs<ExtArgs>
    thumbnailForPages?: boolean | Media$thumbnailForPagesArgs<ExtArgs>
    thumbnailForPosts?: boolean | Media$thumbnailForPostsArgs<ExtArgs>
    thumbnailForDataset?: boolean | Media$thumbnailForDatasetArgs<ExtArgs>
    thumbnailForSeries?: boolean | Media$thumbnailForSeriesArgs<ExtArgs>
    thumbnailForVolumes?: boolean | Media$thumbnailForVolumesArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    url?: boolean
    storageFileId?: boolean
    altTextI18n?: boolean
    createdAt?: boolean
    storageFile?: boolean | Media$storageFileArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    url?: boolean
    storageFileId?: boolean
    altTextI18n?: boolean
    createdAt?: boolean
    storageFile?: boolean | Media$storageFileArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectScalar = {
    id?: boolean
    filename?: boolean
    url?: boolean
    storageFileId?: boolean
    altTextI18n?: boolean
    createdAt?: boolean
  }

  export type MediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filename" | "url" | "storageFileId" | "altTextI18n" | "createdAt", ExtArgs["result"]["media"]>
  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thumbnailForCategory?: boolean | Media$thumbnailForCategoryArgs<ExtArgs>
    thumbnailForCollections?: boolean | Media$thumbnailForCollectionsArgs<ExtArgs>
    thumbnailForMaps?: boolean | Media$thumbnailForMapsArgs<ExtArgs>
    storageFile?: boolean | Media$storageFileArgs<ExtArgs>
    thumbnailForPages?: boolean | Media$thumbnailForPagesArgs<ExtArgs>
    thumbnailForPosts?: boolean | Media$thumbnailForPostsArgs<ExtArgs>
    thumbnailForDataset?: boolean | Media$thumbnailForDatasetArgs<ExtArgs>
    thumbnailForSeries?: boolean | Media$thumbnailForSeriesArgs<ExtArgs>
    thumbnailForVolumes?: boolean | Media$thumbnailForVolumesArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    storageFile?: boolean | Media$storageFileArgs<ExtArgs>
  }
  export type MediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    storageFile?: boolean | Media$storageFileArgs<ExtArgs>
  }

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      thumbnailForCategory: Prisma.$CategoryPayload<ExtArgs>[]
      thumbnailForCollections: Prisma.$CollectionPayload<ExtArgs>[]
      thumbnailForMaps: Prisma.$MapPayload<ExtArgs>[]
      storageFile: Prisma.$StorageFilePayload<ExtArgs> | null
      thumbnailForPages: Prisma.$PagePayload<ExtArgs>[]
      thumbnailForPosts: Prisma.$PostPayload<ExtArgs>[]
      thumbnailForDataset: Prisma.$ResearchDatasetPayload<ExtArgs>[]
      thumbnailForSeries: Prisma.$SeriesPayload<ExtArgs>[]
      thumbnailForVolumes: Prisma.$VolumePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      filename: string
      url: string
      storageFileId: string | null
      altTextI18n: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Media and returns the data saved in the database.
     * @param {MediaCreateManyAndReturnArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media and returns the data updated in the database.
     * @param {MediaUpdateManyAndReturnArgs} args - Arguments to update many Media.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MediaUpdateManyAndReturnArgs>(args: SelectSubset<T, MediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    thumbnailForCategory<T extends Media$thumbnailForCategoryArgs<ExtArgs> = {}>(args?: Subset<T, Media$thumbnailForCategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    thumbnailForCollections<T extends Media$thumbnailForCollectionsArgs<ExtArgs> = {}>(args?: Subset<T, Media$thumbnailForCollectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    thumbnailForMaps<T extends Media$thumbnailForMapsArgs<ExtArgs> = {}>(args?: Subset<T, Media$thumbnailForMapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    storageFile<T extends Media$storageFileArgs<ExtArgs> = {}>(args?: Subset<T, Media$storageFileArgs<ExtArgs>>): Prisma__StorageFileClient<$Result.GetResult<Prisma.$StorageFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    thumbnailForPages<T extends Media$thumbnailForPagesArgs<ExtArgs> = {}>(args?: Subset<T, Media$thumbnailForPagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    thumbnailForPosts<T extends Media$thumbnailForPostsArgs<ExtArgs> = {}>(args?: Subset<T, Media$thumbnailForPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    thumbnailForDataset<T extends Media$thumbnailForDatasetArgs<ExtArgs> = {}>(args?: Subset<T, Media$thumbnailForDatasetArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchDatasetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    thumbnailForSeries<T extends Media$thumbnailForSeriesArgs<ExtArgs> = {}>(args?: Subset<T, Media$thumbnailForSeriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    thumbnailForVolumes<T extends Media$thumbnailForVolumesArgs<ExtArgs> = {}>(args?: Subset<T, Media$thumbnailForVolumesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'String'>
    readonly filename: FieldRef<"Media", 'String'>
    readonly url: FieldRef<"Media", 'String'>
    readonly storageFileId: FieldRef<"Media", 'String'>
    readonly altTextI18n: FieldRef<"Media", 'Json'>
    readonly createdAt: FieldRef<"Media", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media createManyAndReturn
   */
  export type MediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
  }

  /**
   * Media updateManyAndReturn
   */
  export type MediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to delete.
     */
    limit?: number
  }

  /**
   * Media.thumbnailForCategory
   */
  export type Media$thumbnailForCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Media.thumbnailForCollections
   */
  export type Media$thumbnailForCollectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    where?: CollectionWhereInput
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    cursor?: CollectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * Media.thumbnailForMaps
   */
  export type Media$thumbnailForMapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    where?: MapWhereInput
    orderBy?: MapOrderByWithRelationInput | MapOrderByWithRelationInput[]
    cursor?: MapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MapScalarFieldEnum | MapScalarFieldEnum[]
  }

  /**
   * Media.storageFile
   */
  export type Media$storageFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageFile
     */
    select?: StorageFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageFile
     */
    omit?: StorageFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageFileInclude<ExtArgs> | null
    where?: StorageFileWhereInput
  }

  /**
   * Media.thumbnailForPages
   */
  export type Media$thumbnailForPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    where?: PageWhereInput
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    cursor?: PageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Media.thumbnailForPosts
   */
  export type Media$thumbnailForPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Media.thumbnailForDataset
   */
  export type Media$thumbnailForDatasetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDataset
     */
    select?: ResearchDatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchDataset
     */
    omit?: ResearchDatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDatasetInclude<ExtArgs> | null
    where?: ResearchDatasetWhereInput
    orderBy?: ResearchDatasetOrderByWithRelationInput | ResearchDatasetOrderByWithRelationInput[]
    cursor?: ResearchDatasetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchDatasetScalarFieldEnum | ResearchDatasetScalarFieldEnum[]
  }

  /**
   * Media.thumbnailForSeries
   */
  export type Media$thumbnailForSeriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    where?: SeriesWhereInput
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    cursor?: SeriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Media.thumbnailForVolumes
   */
  export type Media$thumbnailForVolumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volume
     */
    select?: VolumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volume
     */
    omit?: VolumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeInclude<ExtArgs> | null
    where?: VolumeWhereInput
    orderBy?: VolumeOrderByWithRelationInput | VolumeOrderByWithRelationInput[]
    cursor?: VolumeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VolumeScalarFieldEnum | VolumeScalarFieldEnum[]
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Model Place
   */

  export type AggregatePlace = {
    _count: PlaceCountAggregateOutputType | null
    _avg: PlaceAvgAggregateOutputType | null
    _sum: PlaceSumAggregateOutputType | null
    _min: PlaceMinAggregateOutputType | null
    _max: PlaceMaxAggregateOutputType | null
  }

  export type PlaceAvgAggregateOutputType = {
    lat: number | null
    lon: number | null
  }

  export type PlaceSumAggregateOutputType = {
    lat: number | null
    lon: number | null
  }

  export type PlaceMinAggregateOutputType = {
    id: string | null
    geoname: string | null
    geocode: string | null
    lat: number | null
    lon: number | null
    countryCode: string | null
    admin1: string | null
    admin2: string | null
  }

  export type PlaceMaxAggregateOutputType = {
    id: string | null
    geoname: string | null
    geocode: string | null
    lat: number | null
    lon: number | null
    countryCode: string | null
    admin1: string | null
    admin2: string | null
  }

  export type PlaceCountAggregateOutputType = {
    id: number
    geoname: number
    geocode: number
    lat: number
    lon: number
    countryCode: number
    admin1: number
    admin2: number
    _all: number
  }


  export type PlaceAvgAggregateInputType = {
    lat?: true
    lon?: true
  }

  export type PlaceSumAggregateInputType = {
    lat?: true
    lon?: true
  }

  export type PlaceMinAggregateInputType = {
    id?: true
    geoname?: true
    geocode?: true
    lat?: true
    lon?: true
    countryCode?: true
    admin1?: true
    admin2?: true
  }

  export type PlaceMaxAggregateInputType = {
    id?: true
    geoname?: true
    geocode?: true
    lat?: true
    lon?: true
    countryCode?: true
    admin1?: true
    admin2?: true
  }

  export type PlaceCountAggregateInputType = {
    id?: true
    geoname?: true
    geocode?: true
    lat?: true
    lon?: true
    countryCode?: true
    admin1?: true
    admin2?: true
    _all?: true
  }

  export type PlaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Place to aggregate.
     */
    where?: PlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Places to fetch.
     */
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Places from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Places.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Places
    **/
    _count?: true | PlaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaceMaxAggregateInputType
  }

  export type GetPlaceAggregateType<T extends PlaceAggregateArgs> = {
        [P in keyof T & keyof AggregatePlace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlace[P]>
      : GetScalarType<T[P], AggregatePlace[P]>
  }




  export type PlaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaceWhereInput
    orderBy?: PlaceOrderByWithAggregationInput | PlaceOrderByWithAggregationInput[]
    by: PlaceScalarFieldEnum[] | PlaceScalarFieldEnum
    having?: PlaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaceCountAggregateInputType | true
    _avg?: PlaceAvgAggregateInputType
    _sum?: PlaceSumAggregateInputType
    _min?: PlaceMinAggregateInputType
    _max?: PlaceMaxAggregateInputType
  }

  export type PlaceGroupByOutputType = {
    id: string
    geoname: string
    geocode: string
    lat: number | null
    lon: number | null
    countryCode: string
    admin1: string | null
    admin2: string | null
    _count: PlaceCountAggregateOutputType | null
    _avg: PlaceAvgAggregateOutputType | null
    _sum: PlaceSumAggregateOutputType | null
    _min: PlaceMinAggregateOutputType | null
    _max: PlaceMaxAggregateOutputType | null
  }

  type GetPlaceGroupByPayload<T extends PlaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaceGroupByOutputType[P]>
            : GetScalarType<T[P], PlaceGroupByOutputType[P]>
        }
      >
    >


  export type PlaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    geoname?: boolean
    geocode?: boolean
    lat?: boolean
    lon?: boolean
    countryCode?: boolean
    admin1?: boolean
    admin2?: boolean
    administrativePlaces?: boolean | Place$administrativePlacesArgs<ExtArgs>
    artifacts?: boolean | Place$artifactsArgs<ExtArgs>
    _count?: boolean | PlaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["place"]>

  export type PlaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    geoname?: boolean
    geocode?: boolean
    lat?: boolean
    lon?: boolean
    countryCode?: boolean
    admin1?: boolean
    admin2?: boolean
  }, ExtArgs["result"]["place"]>

  export type PlaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    geoname?: boolean
    geocode?: boolean
    lat?: boolean
    lon?: boolean
    countryCode?: boolean
    admin1?: boolean
    admin2?: boolean
  }, ExtArgs["result"]["place"]>

  export type PlaceSelectScalar = {
    id?: boolean
    geoname?: boolean
    geocode?: boolean
    lat?: boolean
    lon?: boolean
    countryCode?: boolean
    admin1?: boolean
    admin2?: boolean
  }

  export type PlaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "geoname" | "geocode" | "lat" | "lon" | "countryCode" | "admin1" | "admin2", ExtArgs["result"]["place"]>
  export type PlaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    administrativePlaces?: boolean | Place$administrativePlacesArgs<ExtArgs>
    artifacts?: boolean | Place$artifactsArgs<ExtArgs>
    _count?: boolean | PlaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PlaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Place"
    objects: {
      administrativePlaces: Prisma.$AdministrativePlacePayload<ExtArgs>[]
      artifacts: Prisma.$ArtifactPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      geoname: string
      geocode: string
      lat: number | null
      lon: number | null
      countryCode: string
      admin1: string | null
      admin2: string | null
    }, ExtArgs["result"]["place"]>
    composites: {}
  }

  type PlaceGetPayload<S extends boolean | null | undefined | PlaceDefaultArgs> = $Result.GetResult<Prisma.$PlacePayload, S>

  type PlaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaceCountAggregateInputType | true
    }

  export interface PlaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Place'], meta: { name: 'Place' } }
    /**
     * Find zero or one Place that matches the filter.
     * @param {PlaceFindUniqueArgs} args - Arguments to find a Place
     * @example
     * // Get one Place
     * const place = await prisma.place.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaceFindUniqueArgs>(args: SelectSubset<T, PlaceFindUniqueArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Place that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaceFindUniqueOrThrowArgs} args - Arguments to find a Place
     * @example
     * // Get one Place
     * const place = await prisma.place.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaceFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Place that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceFindFirstArgs} args - Arguments to find a Place
     * @example
     * // Get one Place
     * const place = await prisma.place.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaceFindFirstArgs>(args?: SelectSubset<T, PlaceFindFirstArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Place that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceFindFirstOrThrowArgs} args - Arguments to find a Place
     * @example
     * // Get one Place
     * const place = await prisma.place.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaceFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Places that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Places
     * const places = await prisma.place.findMany()
     * 
     * // Get first 10 Places
     * const places = await prisma.place.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const placeWithIdOnly = await prisma.place.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlaceFindManyArgs>(args?: SelectSubset<T, PlaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Place.
     * @param {PlaceCreateArgs} args - Arguments to create a Place.
     * @example
     * // Create one Place
     * const Place = await prisma.place.create({
     *   data: {
     *     // ... data to create a Place
     *   }
     * })
     * 
     */
    create<T extends PlaceCreateArgs>(args: SelectSubset<T, PlaceCreateArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Places.
     * @param {PlaceCreateManyArgs} args - Arguments to create many Places.
     * @example
     * // Create many Places
     * const place = await prisma.place.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaceCreateManyArgs>(args?: SelectSubset<T, PlaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Places and returns the data saved in the database.
     * @param {PlaceCreateManyAndReturnArgs} args - Arguments to create many Places.
     * @example
     * // Create many Places
     * const place = await prisma.place.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Places and only return the `id`
     * const placeWithIdOnly = await prisma.place.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlaceCreateManyAndReturnArgs>(args?: SelectSubset<T, PlaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Place.
     * @param {PlaceDeleteArgs} args - Arguments to delete one Place.
     * @example
     * // Delete one Place
     * const Place = await prisma.place.delete({
     *   where: {
     *     // ... filter to delete one Place
     *   }
     * })
     * 
     */
    delete<T extends PlaceDeleteArgs>(args: SelectSubset<T, PlaceDeleteArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Place.
     * @param {PlaceUpdateArgs} args - Arguments to update one Place.
     * @example
     * // Update one Place
     * const place = await prisma.place.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaceUpdateArgs>(args: SelectSubset<T, PlaceUpdateArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Places.
     * @param {PlaceDeleteManyArgs} args - Arguments to filter Places to delete.
     * @example
     * // Delete a few Places
     * const { count } = await prisma.place.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaceDeleteManyArgs>(args?: SelectSubset<T, PlaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Places.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Places
     * const place = await prisma.place.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaceUpdateManyArgs>(args: SelectSubset<T, PlaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Places and returns the data updated in the database.
     * @param {PlaceUpdateManyAndReturnArgs} args - Arguments to update many Places.
     * @example
     * // Update many Places
     * const place = await prisma.place.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Places and only return the `id`
     * const placeWithIdOnly = await prisma.place.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlaceUpdateManyAndReturnArgs>(args: SelectSubset<T, PlaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Place.
     * @param {PlaceUpsertArgs} args - Arguments to update or create a Place.
     * @example
     * // Update or create a Place
     * const place = await prisma.place.upsert({
     *   create: {
     *     // ... data to create a Place
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Place we want to update
     *   }
     * })
     */
    upsert<T extends PlaceUpsertArgs>(args: SelectSubset<T, PlaceUpsertArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Places.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceCountArgs} args - Arguments to filter Places to count.
     * @example
     * // Count the number of Places
     * const count = await prisma.place.count({
     *   where: {
     *     // ... the filter for the Places we want to count
     *   }
     * })
    **/
    count<T extends PlaceCountArgs>(
      args?: Subset<T, PlaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Place.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaceAggregateArgs>(args: Subset<T, PlaceAggregateArgs>): Prisma.PrismaPromise<GetPlaceAggregateType<T>>

    /**
     * Group by Place.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaceGroupByArgs['orderBy'] }
        : { orderBy?: PlaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Place model
   */
  readonly fields: PlaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Place.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    administrativePlaces<T extends Place$administrativePlacesArgs<ExtArgs> = {}>(args?: Subset<T, Place$administrativePlacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdministrativePlacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    artifacts<T extends Place$artifactsArgs<ExtArgs> = {}>(args?: Subset<T, Place$artifactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Place model
   */
  interface PlaceFieldRefs {
    readonly id: FieldRef<"Place", 'String'>
    readonly geoname: FieldRef<"Place", 'String'>
    readonly geocode: FieldRef<"Place", 'String'>
    readonly lat: FieldRef<"Place", 'Float'>
    readonly lon: FieldRef<"Place", 'Float'>
    readonly countryCode: FieldRef<"Place", 'String'>
    readonly admin1: FieldRef<"Place", 'String'>
    readonly admin2: FieldRef<"Place", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Place findUnique
   */
  export type PlaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Place to fetch.
     */
    where: PlaceWhereUniqueInput
  }

  /**
   * Place findUniqueOrThrow
   */
  export type PlaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Place to fetch.
     */
    where: PlaceWhereUniqueInput
  }

  /**
   * Place findFirst
   */
  export type PlaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Place to fetch.
     */
    where?: PlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Places to fetch.
     */
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Places.
     */
    cursor?: PlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Places from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Places.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Places.
     */
    distinct?: PlaceScalarFieldEnum | PlaceScalarFieldEnum[]
  }

  /**
   * Place findFirstOrThrow
   */
  export type PlaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Place to fetch.
     */
    where?: PlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Places to fetch.
     */
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Places.
     */
    cursor?: PlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Places from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Places.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Places.
     */
    distinct?: PlaceScalarFieldEnum | PlaceScalarFieldEnum[]
  }

  /**
   * Place findMany
   */
  export type PlaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter, which Places to fetch.
     */
    where?: PlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Places to fetch.
     */
    orderBy?: PlaceOrderByWithRelationInput | PlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Places.
     */
    cursor?: PlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Places from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Places.
     */
    skip?: number
    distinct?: PlaceScalarFieldEnum | PlaceScalarFieldEnum[]
  }

  /**
   * Place create
   */
  export type PlaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Place.
     */
    data: XOR<PlaceCreateInput, PlaceUncheckedCreateInput>
  }

  /**
   * Place createMany
   */
  export type PlaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Places.
     */
    data: PlaceCreateManyInput | PlaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Place createManyAndReturn
   */
  export type PlaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * The data used to create many Places.
     */
    data: PlaceCreateManyInput | PlaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Place update
   */
  export type PlaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Place.
     */
    data: XOR<PlaceUpdateInput, PlaceUncheckedUpdateInput>
    /**
     * Choose, which Place to update.
     */
    where: PlaceWhereUniqueInput
  }

  /**
   * Place updateMany
   */
  export type PlaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Places.
     */
    data: XOR<PlaceUpdateManyMutationInput, PlaceUncheckedUpdateManyInput>
    /**
     * Filter which Places to update
     */
    where?: PlaceWhereInput
    /**
     * Limit how many Places to update.
     */
    limit?: number
  }

  /**
   * Place updateManyAndReturn
   */
  export type PlaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * The data used to update Places.
     */
    data: XOR<PlaceUpdateManyMutationInput, PlaceUncheckedUpdateManyInput>
    /**
     * Filter which Places to update
     */
    where?: PlaceWhereInput
    /**
     * Limit how many Places to update.
     */
    limit?: number
  }

  /**
   * Place upsert
   */
  export type PlaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Place to update in case it exists.
     */
    where: PlaceWhereUniqueInput
    /**
     * In case the Place found by the `where` argument doesn't exist, create a new Place with this data.
     */
    create: XOR<PlaceCreateInput, PlaceUncheckedCreateInput>
    /**
     * In case the Place was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaceUpdateInput, PlaceUncheckedUpdateInput>
  }

  /**
   * Place delete
   */
  export type PlaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    /**
     * Filter which Place to delete.
     */
    where: PlaceWhereUniqueInput
  }

  /**
   * Place deleteMany
   */
  export type PlaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Places to delete
     */
    where?: PlaceWhereInput
    /**
     * Limit how many Places to delete.
     */
    limit?: number
  }

  /**
   * Place.administrativePlaces
   */
  export type Place$administrativePlacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativePlace
     */
    select?: AdministrativePlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativePlace
     */
    omit?: AdministrativePlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativePlaceInclude<ExtArgs> | null
    where?: AdministrativePlaceWhereInput
    orderBy?: AdministrativePlaceOrderByWithRelationInput | AdministrativePlaceOrderByWithRelationInput[]
    cursor?: AdministrativePlaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdministrativePlaceScalarFieldEnum | AdministrativePlaceScalarFieldEnum[]
  }

  /**
   * Place.artifacts
   */
  export type Place$artifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    where?: ArtifactWhereInput
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    cursor?: ArtifactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * Place without action
   */
  export type PlaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
  }


  /**
   * Model AdministrativePlace
   */

  export type AggregateAdministrativePlace = {
    _count: AdministrativePlaceCountAggregateOutputType | null
    _avg: AdministrativePlaceAvgAggregateOutputType | null
    _sum: AdministrativePlaceSumAggregateOutputType | null
    _min: AdministrativePlaceMinAggregateOutputType | null
    _max: AdministrativePlaceMaxAggregateOutputType | null
  }

  export type AdministrativePlaceAvgAggregateOutputType = {
    jewishPop: number | null
    totalPop: number | null
  }

  export type AdministrativePlaceSumAggregateOutputType = {
    jewishPop: number | null
    totalPop: number | null
  }

  export type AdministrativePlaceMinAggregateOutputType = {
    id: string | null
    name: string | null
    year: string | null
    source: string | null
    admin1: string | null
    admin2: string | null
    jewishPop: number | null
    totalPop: number | null
    placeId: string | null
  }

  export type AdministrativePlaceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    year: string | null
    source: string | null
    admin1: string | null
    admin2: string | null
    jewishPop: number | null
    totalPop: number | null
    placeId: string | null
  }

  export type AdministrativePlaceCountAggregateOutputType = {
    id: number
    name: number
    year: number
    source: number
    admin1: number
    admin2: number
    jewishPop: number
    totalPop: number
    placeId: number
    _all: number
  }


  export type AdministrativePlaceAvgAggregateInputType = {
    jewishPop?: true
    totalPop?: true
  }

  export type AdministrativePlaceSumAggregateInputType = {
    jewishPop?: true
    totalPop?: true
  }

  export type AdministrativePlaceMinAggregateInputType = {
    id?: true
    name?: true
    year?: true
    source?: true
    admin1?: true
    admin2?: true
    jewishPop?: true
    totalPop?: true
    placeId?: true
  }

  export type AdministrativePlaceMaxAggregateInputType = {
    id?: true
    name?: true
    year?: true
    source?: true
    admin1?: true
    admin2?: true
    jewishPop?: true
    totalPop?: true
    placeId?: true
  }

  export type AdministrativePlaceCountAggregateInputType = {
    id?: true
    name?: true
    year?: true
    source?: true
    admin1?: true
    admin2?: true
    jewishPop?: true
    totalPop?: true
    placeId?: true
    _all?: true
  }

  export type AdministrativePlaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdministrativePlace to aggregate.
     */
    where?: AdministrativePlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdministrativePlaces to fetch.
     */
    orderBy?: AdministrativePlaceOrderByWithRelationInput | AdministrativePlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdministrativePlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdministrativePlaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdministrativePlaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdministrativePlaces
    **/
    _count?: true | AdministrativePlaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdministrativePlaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdministrativePlaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdministrativePlaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdministrativePlaceMaxAggregateInputType
  }

  export type GetAdministrativePlaceAggregateType<T extends AdministrativePlaceAggregateArgs> = {
        [P in keyof T & keyof AggregateAdministrativePlace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdministrativePlace[P]>
      : GetScalarType<T[P], AggregateAdministrativePlace[P]>
  }




  export type AdministrativePlaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdministrativePlaceWhereInput
    orderBy?: AdministrativePlaceOrderByWithAggregationInput | AdministrativePlaceOrderByWithAggregationInput[]
    by: AdministrativePlaceScalarFieldEnum[] | AdministrativePlaceScalarFieldEnum
    having?: AdministrativePlaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdministrativePlaceCountAggregateInputType | true
    _avg?: AdministrativePlaceAvgAggregateInputType
    _sum?: AdministrativePlaceSumAggregateInputType
    _min?: AdministrativePlaceMinAggregateInputType
    _max?: AdministrativePlaceMaxAggregateInputType
  }

  export type AdministrativePlaceGroupByOutputType = {
    id: string
    name: string
    year: string | null
    source: string | null
    admin1: string | null
    admin2: string | null
    jewishPop: number | null
    totalPop: number | null
    placeId: string | null
    _count: AdministrativePlaceCountAggregateOutputType | null
    _avg: AdministrativePlaceAvgAggregateOutputType | null
    _sum: AdministrativePlaceSumAggregateOutputType | null
    _min: AdministrativePlaceMinAggregateOutputType | null
    _max: AdministrativePlaceMaxAggregateOutputType | null
  }

  type GetAdministrativePlaceGroupByPayload<T extends AdministrativePlaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdministrativePlaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdministrativePlaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdministrativePlaceGroupByOutputType[P]>
            : GetScalarType<T[P], AdministrativePlaceGroupByOutputType[P]>
        }
      >
    >


  export type AdministrativePlaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    year?: boolean
    source?: boolean
    admin1?: boolean
    admin2?: boolean
    jewishPop?: boolean
    totalPop?: boolean
    placeId?: boolean
    place?: boolean | AdministrativePlace$placeArgs<ExtArgs>
  }, ExtArgs["result"]["administrativePlace"]>

  export type AdministrativePlaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    year?: boolean
    source?: boolean
    admin1?: boolean
    admin2?: boolean
    jewishPop?: boolean
    totalPop?: boolean
    placeId?: boolean
    place?: boolean | AdministrativePlace$placeArgs<ExtArgs>
  }, ExtArgs["result"]["administrativePlace"]>

  export type AdministrativePlaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    year?: boolean
    source?: boolean
    admin1?: boolean
    admin2?: boolean
    jewishPop?: boolean
    totalPop?: boolean
    placeId?: boolean
    place?: boolean | AdministrativePlace$placeArgs<ExtArgs>
  }, ExtArgs["result"]["administrativePlace"]>

  export type AdministrativePlaceSelectScalar = {
    id?: boolean
    name?: boolean
    year?: boolean
    source?: boolean
    admin1?: boolean
    admin2?: boolean
    jewishPop?: boolean
    totalPop?: boolean
    placeId?: boolean
  }

  export type AdministrativePlaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "year" | "source" | "admin1" | "admin2" | "jewishPop" | "totalPop" | "placeId", ExtArgs["result"]["administrativePlace"]>
  export type AdministrativePlaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | AdministrativePlace$placeArgs<ExtArgs>
  }
  export type AdministrativePlaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | AdministrativePlace$placeArgs<ExtArgs>
  }
  export type AdministrativePlaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    place?: boolean | AdministrativePlace$placeArgs<ExtArgs>
  }

  export type $AdministrativePlacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdministrativePlace"
    objects: {
      place: Prisma.$PlacePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      year: string | null
      source: string | null
      admin1: string | null
      admin2: string | null
      jewishPop: number | null
      totalPop: number | null
      placeId: string | null
    }, ExtArgs["result"]["administrativePlace"]>
    composites: {}
  }

  type AdministrativePlaceGetPayload<S extends boolean | null | undefined | AdministrativePlaceDefaultArgs> = $Result.GetResult<Prisma.$AdministrativePlacePayload, S>

  type AdministrativePlaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdministrativePlaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdministrativePlaceCountAggregateInputType | true
    }

  export interface AdministrativePlaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdministrativePlace'], meta: { name: 'AdministrativePlace' } }
    /**
     * Find zero or one AdministrativePlace that matches the filter.
     * @param {AdministrativePlaceFindUniqueArgs} args - Arguments to find a AdministrativePlace
     * @example
     * // Get one AdministrativePlace
     * const administrativePlace = await prisma.administrativePlace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdministrativePlaceFindUniqueArgs>(args: SelectSubset<T, AdministrativePlaceFindUniqueArgs<ExtArgs>>): Prisma__AdministrativePlaceClient<$Result.GetResult<Prisma.$AdministrativePlacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdministrativePlace that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdministrativePlaceFindUniqueOrThrowArgs} args - Arguments to find a AdministrativePlace
     * @example
     * // Get one AdministrativePlace
     * const administrativePlace = await prisma.administrativePlace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdministrativePlaceFindUniqueOrThrowArgs>(args: SelectSubset<T, AdministrativePlaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdministrativePlaceClient<$Result.GetResult<Prisma.$AdministrativePlacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdministrativePlace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministrativePlaceFindFirstArgs} args - Arguments to find a AdministrativePlace
     * @example
     * // Get one AdministrativePlace
     * const administrativePlace = await prisma.administrativePlace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdministrativePlaceFindFirstArgs>(args?: SelectSubset<T, AdministrativePlaceFindFirstArgs<ExtArgs>>): Prisma__AdministrativePlaceClient<$Result.GetResult<Prisma.$AdministrativePlacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdministrativePlace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministrativePlaceFindFirstOrThrowArgs} args - Arguments to find a AdministrativePlace
     * @example
     * // Get one AdministrativePlace
     * const administrativePlace = await prisma.administrativePlace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdministrativePlaceFindFirstOrThrowArgs>(args?: SelectSubset<T, AdministrativePlaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdministrativePlaceClient<$Result.GetResult<Prisma.$AdministrativePlacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdministrativePlaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministrativePlaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdministrativePlaces
     * const administrativePlaces = await prisma.administrativePlace.findMany()
     * 
     * // Get first 10 AdministrativePlaces
     * const administrativePlaces = await prisma.administrativePlace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const administrativePlaceWithIdOnly = await prisma.administrativePlace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdministrativePlaceFindManyArgs>(args?: SelectSubset<T, AdministrativePlaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdministrativePlacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdministrativePlace.
     * @param {AdministrativePlaceCreateArgs} args - Arguments to create a AdministrativePlace.
     * @example
     * // Create one AdministrativePlace
     * const AdministrativePlace = await prisma.administrativePlace.create({
     *   data: {
     *     // ... data to create a AdministrativePlace
     *   }
     * })
     * 
     */
    create<T extends AdministrativePlaceCreateArgs>(args: SelectSubset<T, AdministrativePlaceCreateArgs<ExtArgs>>): Prisma__AdministrativePlaceClient<$Result.GetResult<Prisma.$AdministrativePlacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdministrativePlaces.
     * @param {AdministrativePlaceCreateManyArgs} args - Arguments to create many AdministrativePlaces.
     * @example
     * // Create many AdministrativePlaces
     * const administrativePlace = await prisma.administrativePlace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdministrativePlaceCreateManyArgs>(args?: SelectSubset<T, AdministrativePlaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdministrativePlaces and returns the data saved in the database.
     * @param {AdministrativePlaceCreateManyAndReturnArgs} args - Arguments to create many AdministrativePlaces.
     * @example
     * // Create many AdministrativePlaces
     * const administrativePlace = await prisma.administrativePlace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdministrativePlaces and only return the `id`
     * const administrativePlaceWithIdOnly = await prisma.administrativePlace.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdministrativePlaceCreateManyAndReturnArgs>(args?: SelectSubset<T, AdministrativePlaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdministrativePlacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdministrativePlace.
     * @param {AdministrativePlaceDeleteArgs} args - Arguments to delete one AdministrativePlace.
     * @example
     * // Delete one AdministrativePlace
     * const AdministrativePlace = await prisma.administrativePlace.delete({
     *   where: {
     *     // ... filter to delete one AdministrativePlace
     *   }
     * })
     * 
     */
    delete<T extends AdministrativePlaceDeleteArgs>(args: SelectSubset<T, AdministrativePlaceDeleteArgs<ExtArgs>>): Prisma__AdministrativePlaceClient<$Result.GetResult<Prisma.$AdministrativePlacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdministrativePlace.
     * @param {AdministrativePlaceUpdateArgs} args - Arguments to update one AdministrativePlace.
     * @example
     * // Update one AdministrativePlace
     * const administrativePlace = await prisma.administrativePlace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdministrativePlaceUpdateArgs>(args: SelectSubset<T, AdministrativePlaceUpdateArgs<ExtArgs>>): Prisma__AdministrativePlaceClient<$Result.GetResult<Prisma.$AdministrativePlacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdministrativePlaces.
     * @param {AdministrativePlaceDeleteManyArgs} args - Arguments to filter AdministrativePlaces to delete.
     * @example
     * // Delete a few AdministrativePlaces
     * const { count } = await prisma.administrativePlace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdministrativePlaceDeleteManyArgs>(args?: SelectSubset<T, AdministrativePlaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdministrativePlaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministrativePlaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdministrativePlaces
     * const administrativePlace = await prisma.administrativePlace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdministrativePlaceUpdateManyArgs>(args: SelectSubset<T, AdministrativePlaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdministrativePlaces and returns the data updated in the database.
     * @param {AdministrativePlaceUpdateManyAndReturnArgs} args - Arguments to update many AdministrativePlaces.
     * @example
     * // Update many AdministrativePlaces
     * const administrativePlace = await prisma.administrativePlace.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdministrativePlaces and only return the `id`
     * const administrativePlaceWithIdOnly = await prisma.administrativePlace.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdministrativePlaceUpdateManyAndReturnArgs>(args: SelectSubset<T, AdministrativePlaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdministrativePlacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdministrativePlace.
     * @param {AdministrativePlaceUpsertArgs} args - Arguments to update or create a AdministrativePlace.
     * @example
     * // Update or create a AdministrativePlace
     * const administrativePlace = await prisma.administrativePlace.upsert({
     *   create: {
     *     // ... data to create a AdministrativePlace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdministrativePlace we want to update
     *   }
     * })
     */
    upsert<T extends AdministrativePlaceUpsertArgs>(args: SelectSubset<T, AdministrativePlaceUpsertArgs<ExtArgs>>): Prisma__AdministrativePlaceClient<$Result.GetResult<Prisma.$AdministrativePlacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdministrativePlaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministrativePlaceCountArgs} args - Arguments to filter AdministrativePlaces to count.
     * @example
     * // Count the number of AdministrativePlaces
     * const count = await prisma.administrativePlace.count({
     *   where: {
     *     // ... the filter for the AdministrativePlaces we want to count
     *   }
     * })
    **/
    count<T extends AdministrativePlaceCountArgs>(
      args?: Subset<T, AdministrativePlaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdministrativePlaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdministrativePlace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministrativePlaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdministrativePlaceAggregateArgs>(args: Subset<T, AdministrativePlaceAggregateArgs>): Prisma.PrismaPromise<GetAdministrativePlaceAggregateType<T>>

    /**
     * Group by AdministrativePlace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministrativePlaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdministrativePlaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdministrativePlaceGroupByArgs['orderBy'] }
        : { orderBy?: AdministrativePlaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdministrativePlaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdministrativePlaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdministrativePlace model
   */
  readonly fields: AdministrativePlaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdministrativePlace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdministrativePlaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    place<T extends AdministrativePlace$placeArgs<ExtArgs> = {}>(args?: Subset<T, AdministrativePlace$placeArgs<ExtArgs>>): Prisma__PlaceClient<$Result.GetResult<Prisma.$PlacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdministrativePlace model
   */
  interface AdministrativePlaceFieldRefs {
    readonly id: FieldRef<"AdministrativePlace", 'String'>
    readonly name: FieldRef<"AdministrativePlace", 'String'>
    readonly year: FieldRef<"AdministrativePlace", 'String'>
    readonly source: FieldRef<"AdministrativePlace", 'String'>
    readonly admin1: FieldRef<"AdministrativePlace", 'String'>
    readonly admin2: FieldRef<"AdministrativePlace", 'String'>
    readonly jewishPop: FieldRef<"AdministrativePlace", 'Int'>
    readonly totalPop: FieldRef<"AdministrativePlace", 'Int'>
    readonly placeId: FieldRef<"AdministrativePlace", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdministrativePlace findUnique
   */
  export type AdministrativePlaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativePlace
     */
    select?: AdministrativePlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativePlace
     */
    omit?: AdministrativePlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativePlaceInclude<ExtArgs> | null
    /**
     * Filter, which AdministrativePlace to fetch.
     */
    where: AdministrativePlaceWhereUniqueInput
  }

  /**
   * AdministrativePlace findUniqueOrThrow
   */
  export type AdministrativePlaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativePlace
     */
    select?: AdministrativePlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativePlace
     */
    omit?: AdministrativePlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativePlaceInclude<ExtArgs> | null
    /**
     * Filter, which AdministrativePlace to fetch.
     */
    where: AdministrativePlaceWhereUniqueInput
  }

  /**
   * AdministrativePlace findFirst
   */
  export type AdministrativePlaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativePlace
     */
    select?: AdministrativePlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativePlace
     */
    omit?: AdministrativePlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativePlaceInclude<ExtArgs> | null
    /**
     * Filter, which AdministrativePlace to fetch.
     */
    where?: AdministrativePlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdministrativePlaces to fetch.
     */
    orderBy?: AdministrativePlaceOrderByWithRelationInput | AdministrativePlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdministrativePlaces.
     */
    cursor?: AdministrativePlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdministrativePlaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdministrativePlaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdministrativePlaces.
     */
    distinct?: AdministrativePlaceScalarFieldEnum | AdministrativePlaceScalarFieldEnum[]
  }

  /**
   * AdministrativePlace findFirstOrThrow
   */
  export type AdministrativePlaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativePlace
     */
    select?: AdministrativePlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativePlace
     */
    omit?: AdministrativePlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativePlaceInclude<ExtArgs> | null
    /**
     * Filter, which AdministrativePlace to fetch.
     */
    where?: AdministrativePlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdministrativePlaces to fetch.
     */
    orderBy?: AdministrativePlaceOrderByWithRelationInput | AdministrativePlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdministrativePlaces.
     */
    cursor?: AdministrativePlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdministrativePlaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdministrativePlaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdministrativePlaces.
     */
    distinct?: AdministrativePlaceScalarFieldEnum | AdministrativePlaceScalarFieldEnum[]
  }

  /**
   * AdministrativePlace findMany
   */
  export type AdministrativePlaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativePlace
     */
    select?: AdministrativePlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativePlace
     */
    omit?: AdministrativePlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativePlaceInclude<ExtArgs> | null
    /**
     * Filter, which AdministrativePlaces to fetch.
     */
    where?: AdministrativePlaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdministrativePlaces to fetch.
     */
    orderBy?: AdministrativePlaceOrderByWithRelationInput | AdministrativePlaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdministrativePlaces.
     */
    cursor?: AdministrativePlaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdministrativePlaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdministrativePlaces.
     */
    skip?: number
    distinct?: AdministrativePlaceScalarFieldEnum | AdministrativePlaceScalarFieldEnum[]
  }

  /**
   * AdministrativePlace create
   */
  export type AdministrativePlaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativePlace
     */
    select?: AdministrativePlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativePlace
     */
    omit?: AdministrativePlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativePlaceInclude<ExtArgs> | null
    /**
     * The data needed to create a AdministrativePlace.
     */
    data: XOR<AdministrativePlaceCreateInput, AdministrativePlaceUncheckedCreateInput>
  }

  /**
   * AdministrativePlace createMany
   */
  export type AdministrativePlaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdministrativePlaces.
     */
    data: AdministrativePlaceCreateManyInput | AdministrativePlaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdministrativePlace createManyAndReturn
   */
  export type AdministrativePlaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativePlace
     */
    select?: AdministrativePlaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativePlace
     */
    omit?: AdministrativePlaceOmit<ExtArgs> | null
    /**
     * The data used to create many AdministrativePlaces.
     */
    data: AdministrativePlaceCreateManyInput | AdministrativePlaceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativePlaceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdministrativePlace update
   */
  export type AdministrativePlaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativePlace
     */
    select?: AdministrativePlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativePlace
     */
    omit?: AdministrativePlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativePlaceInclude<ExtArgs> | null
    /**
     * The data needed to update a AdministrativePlace.
     */
    data: XOR<AdministrativePlaceUpdateInput, AdministrativePlaceUncheckedUpdateInput>
    /**
     * Choose, which AdministrativePlace to update.
     */
    where: AdministrativePlaceWhereUniqueInput
  }

  /**
   * AdministrativePlace updateMany
   */
  export type AdministrativePlaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdministrativePlaces.
     */
    data: XOR<AdministrativePlaceUpdateManyMutationInput, AdministrativePlaceUncheckedUpdateManyInput>
    /**
     * Filter which AdministrativePlaces to update
     */
    where?: AdministrativePlaceWhereInput
    /**
     * Limit how many AdministrativePlaces to update.
     */
    limit?: number
  }

  /**
   * AdministrativePlace updateManyAndReturn
   */
  export type AdministrativePlaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativePlace
     */
    select?: AdministrativePlaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativePlace
     */
    omit?: AdministrativePlaceOmit<ExtArgs> | null
    /**
     * The data used to update AdministrativePlaces.
     */
    data: XOR<AdministrativePlaceUpdateManyMutationInput, AdministrativePlaceUncheckedUpdateManyInput>
    /**
     * Filter which AdministrativePlaces to update
     */
    where?: AdministrativePlaceWhereInput
    /**
     * Limit how many AdministrativePlaces to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativePlaceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdministrativePlace upsert
   */
  export type AdministrativePlaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativePlace
     */
    select?: AdministrativePlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativePlace
     */
    omit?: AdministrativePlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativePlaceInclude<ExtArgs> | null
    /**
     * The filter to search for the AdministrativePlace to update in case it exists.
     */
    where: AdministrativePlaceWhereUniqueInput
    /**
     * In case the AdministrativePlace found by the `where` argument doesn't exist, create a new AdministrativePlace with this data.
     */
    create: XOR<AdministrativePlaceCreateInput, AdministrativePlaceUncheckedCreateInput>
    /**
     * In case the AdministrativePlace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdministrativePlaceUpdateInput, AdministrativePlaceUncheckedUpdateInput>
  }

  /**
   * AdministrativePlace delete
   */
  export type AdministrativePlaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativePlace
     */
    select?: AdministrativePlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativePlace
     */
    omit?: AdministrativePlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativePlaceInclude<ExtArgs> | null
    /**
     * Filter which AdministrativePlace to delete.
     */
    where: AdministrativePlaceWhereUniqueInput
  }

  /**
   * AdministrativePlace deleteMany
   */
  export type AdministrativePlaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdministrativePlaces to delete
     */
    where?: AdministrativePlaceWhereInput
    /**
     * Limit how many AdministrativePlaces to delete.
     */
    limit?: number
  }

  /**
   * AdministrativePlace.place
   */
  export type AdministrativePlace$placeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Place
     */
    select?: PlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Place
     */
    omit?: PlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaceInclude<ExtArgs> | null
    where?: PlaceWhereInput
  }

  /**
   * AdministrativePlace without action
   */
  export type AdministrativePlaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrativePlace
     */
    select?: AdministrativePlaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdministrativePlace
     */
    omit?: AdministrativePlaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdministrativePlaceInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    slug: string | null
    createdAt: Date | null
    name: string | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    createdAt: Date | null
    name: string | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    slug: number
    nameI18n: number
    createdAt: number
    name: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    slug?: true
    createdAt?: true
    name?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    slug?: true
    createdAt?: true
    name?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    slug?: true
    nameI18n?: true
    createdAt?: true
    name?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    slug: string
    nameI18n: JsonValue
    createdAt: Date
    name: string
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    nameI18n?: boolean
    createdAt?: boolean
    name?: boolean
    posts?: boolean | Tag$postsArgs<ExtArgs>
    artifacts?: boolean | Tag$artifactsArgs<ExtArgs>
    collections?: boolean | Tag$collectionsArgs<ExtArgs>
    layers?: boolean | Tag$layersArgs<ExtArgs>
    maps?: boolean | Tag$mapsArgs<ExtArgs>
    pages?: boolean | Tag$pagesArgs<ExtArgs>
    series?: boolean | Tag$seriesArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    nameI18n?: boolean
    createdAt?: boolean
    name?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    nameI18n?: boolean
    createdAt?: boolean
    name?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    slug?: boolean
    nameI18n?: boolean
    createdAt?: boolean
    name?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "nameI18n" | "createdAt" | "name", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Tag$postsArgs<ExtArgs>
    artifacts?: boolean | Tag$artifactsArgs<ExtArgs>
    collections?: boolean | Tag$collectionsArgs<ExtArgs>
    layers?: boolean | Tag$layersArgs<ExtArgs>
    maps?: boolean | Tag$mapsArgs<ExtArgs>
    pages?: boolean | Tag$pagesArgs<ExtArgs>
    series?: boolean | Tag$seriesArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      posts: Prisma.$PostTagPayload<ExtArgs>[]
      artifacts: Prisma.$ArtifactPayload<ExtArgs>[]
      collections: Prisma.$CollectionPayload<ExtArgs>[]
      layers: Prisma.$LayerPayload<ExtArgs>[]
      maps: Prisma.$MapPayload<ExtArgs>[]
      pages: Prisma.$PagePayload<ExtArgs>[]
      series: Prisma.$SeriesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      nameI18n: Prisma.JsonValue
      createdAt: Date
      name: string
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends Tag$postsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    artifacts<T extends Tag$artifactsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$artifactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    collections<T extends Tag$collectionsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$collectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    layers<T extends Tag$layersArgs<ExtArgs> = {}>(args?: Subset<T, Tag$layersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    maps<T extends Tag$mapsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$mapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pages<T extends Tag$pagesArgs<ExtArgs> = {}>(args?: Subset<T, Tag$pagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    series<T extends Tag$seriesArgs<ExtArgs> = {}>(args?: Subset<T, Tag$seriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly slug: FieldRef<"Tag", 'String'>
    readonly nameI18n: FieldRef<"Tag", 'Json'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly name: FieldRef<"Tag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.posts
   */
  export type Tag$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    where?: PostTagWhereInput
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    cursor?: PostTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * Tag.artifacts
   */
  export type Tag$artifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    where?: ArtifactWhereInput
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    cursor?: ArtifactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * Tag.collections
   */
  export type Tag$collectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    where?: CollectionWhereInput
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    cursor?: CollectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * Tag.layers
   */
  export type Tag$layersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layer
     */
    select?: LayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layer
     */
    omit?: LayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayerInclude<ExtArgs> | null
    where?: LayerWhereInput
    orderBy?: LayerOrderByWithRelationInput | LayerOrderByWithRelationInput[]
    cursor?: LayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LayerScalarFieldEnum | LayerScalarFieldEnum[]
  }

  /**
   * Tag.maps
   */
  export type Tag$mapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    where?: MapWhereInput
    orderBy?: MapOrderByWithRelationInput | MapOrderByWithRelationInput[]
    cursor?: MapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MapScalarFieldEnum | MapScalarFieldEnum[]
  }

  /**
   * Tag.pages
   */
  export type Tag$pagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    where?: PageWhereInput
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    cursor?: PageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Tag.series
   */
  export type Tag$seriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    where?: SeriesWhereInput
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    cursor?: SeriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model Region
   */

  export type AggregateRegion = {
    _count: RegionCountAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  export type RegionMinAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    createdAt: Date | null
  }

  export type RegionMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    createdAt: Date | null
  }

  export type RegionCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    nameI18n: number
    createdAt: number
    _all: number
  }


  export type RegionMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    createdAt?: true
  }

  export type RegionMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    createdAt?: true
  }

  export type RegionCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    nameI18n?: true
    createdAt?: true
    _all?: true
  }

  export type RegionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Region to aggregate.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Regions
    **/
    _count?: true | RegionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionMaxAggregateInputType
  }

  export type GetRegionAggregateType<T extends RegionAggregateArgs> = {
        [P in keyof T & keyof AggregateRegion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegion[P]>
      : GetScalarType<T[P], AggregateRegion[P]>
  }




  export type RegionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithAggregationInput | RegionOrderByWithAggregationInput[]
    by: RegionScalarFieldEnum[] | RegionScalarFieldEnum
    having?: RegionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionCountAggregateInputType | true
    _min?: RegionMinAggregateInputType
    _max?: RegionMaxAggregateInputType
  }

  export type RegionGroupByOutputType = {
    id: string
    slug: string
    name: string
    nameI18n: JsonValue
    createdAt: Date
    _count: RegionCountAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  type GetRegionGroupByPayload<T extends RegionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionGroupByOutputType[P]>
            : GetScalarType<T[P], RegionGroupByOutputType[P]>
        }
      >
    >


  export type RegionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    nameI18n?: boolean
    createdAt?: boolean
    artifacts?: boolean | Region$artifactsArgs<ExtArgs>
    collections?: boolean | Region$collectionsArgs<ExtArgs>
    layers?: boolean | Region$layersArgs<ExtArgs>
    maps?: boolean | Region$mapsArgs<ExtArgs>
    pages?: boolean | Region$pagesArgs<ExtArgs>
    posts?: boolean | Region$postsArgs<ExtArgs>
    datasets?: boolean | Region$datasetsArgs<ExtArgs>
    series?: boolean | Region$seriesArgs<ExtArgs>
    volumes?: boolean | Region$volumesArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["region"]>

  export type RegionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    nameI18n?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["region"]>

  export type RegionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    nameI18n?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["region"]>

  export type RegionSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    nameI18n?: boolean
    createdAt?: boolean
  }

  export type RegionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "name" | "nameI18n" | "createdAt", ExtArgs["result"]["region"]>
  export type RegionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifacts?: boolean | Region$artifactsArgs<ExtArgs>
    collections?: boolean | Region$collectionsArgs<ExtArgs>
    layers?: boolean | Region$layersArgs<ExtArgs>
    maps?: boolean | Region$mapsArgs<ExtArgs>
    pages?: boolean | Region$pagesArgs<ExtArgs>
    posts?: boolean | Region$postsArgs<ExtArgs>
    datasets?: boolean | Region$datasetsArgs<ExtArgs>
    series?: boolean | Region$seriesArgs<ExtArgs>
    volumes?: boolean | Region$volumesArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RegionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RegionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RegionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Region"
    objects: {
      artifacts: Prisma.$ArtifactPayload<ExtArgs>[]
      collections: Prisma.$CollectionPayload<ExtArgs>[]
      layers: Prisma.$LayerPayload<ExtArgs>[]
      maps: Prisma.$MapPayload<ExtArgs>[]
      pages: Prisma.$PagePayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      datasets: Prisma.$ResearchDatasetPayload<ExtArgs>[]
      series: Prisma.$SeriesPayload<ExtArgs>[]
      volumes: Prisma.$VolumePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      name: string
      nameI18n: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["region"]>
    composites: {}
  }

  type RegionGetPayload<S extends boolean | null | undefined | RegionDefaultArgs> = $Result.GetResult<Prisma.$RegionPayload, S>

  type RegionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegionCountAggregateInputType | true
    }

  export interface RegionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Region'], meta: { name: 'Region' } }
    /**
     * Find zero or one Region that matches the filter.
     * @param {RegionFindUniqueArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegionFindUniqueArgs>(args: SelectSubset<T, RegionFindUniqueArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Region that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegionFindUniqueOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegionFindUniqueOrThrowArgs>(args: SelectSubset<T, RegionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Region that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegionFindFirstArgs>(args?: SelectSubset<T, RegionFindFirstArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Region that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegionFindFirstOrThrowArgs>(args?: SelectSubset<T, RegionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regions
     * const regions = await prisma.region.findMany()
     * 
     * // Get first 10 Regions
     * const regions = await prisma.region.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionWithIdOnly = await prisma.region.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegionFindManyArgs>(args?: SelectSubset<T, RegionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Region.
     * @param {RegionCreateArgs} args - Arguments to create a Region.
     * @example
     * // Create one Region
     * const Region = await prisma.region.create({
     *   data: {
     *     // ... data to create a Region
     *   }
     * })
     * 
     */
    create<T extends RegionCreateArgs>(args: SelectSubset<T, RegionCreateArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Regions.
     * @param {RegionCreateManyArgs} args - Arguments to create many Regions.
     * @example
     * // Create many Regions
     * const region = await prisma.region.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegionCreateManyArgs>(args?: SelectSubset<T, RegionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Regions and returns the data saved in the database.
     * @param {RegionCreateManyAndReturnArgs} args - Arguments to create many Regions.
     * @example
     * // Create many Regions
     * const region = await prisma.region.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Regions and only return the `id`
     * const regionWithIdOnly = await prisma.region.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegionCreateManyAndReturnArgs>(args?: SelectSubset<T, RegionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Region.
     * @param {RegionDeleteArgs} args - Arguments to delete one Region.
     * @example
     * // Delete one Region
     * const Region = await prisma.region.delete({
     *   where: {
     *     // ... filter to delete one Region
     *   }
     * })
     * 
     */
    delete<T extends RegionDeleteArgs>(args: SelectSubset<T, RegionDeleteArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Region.
     * @param {RegionUpdateArgs} args - Arguments to update one Region.
     * @example
     * // Update one Region
     * const region = await prisma.region.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegionUpdateArgs>(args: SelectSubset<T, RegionUpdateArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Regions.
     * @param {RegionDeleteManyArgs} args - Arguments to filter Regions to delete.
     * @example
     * // Delete a few Regions
     * const { count } = await prisma.region.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegionDeleteManyArgs>(args?: SelectSubset<T, RegionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegionUpdateManyArgs>(args: SelectSubset<T, RegionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions and returns the data updated in the database.
     * @param {RegionUpdateManyAndReturnArgs} args - Arguments to update many Regions.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Regions and only return the `id`
     * const regionWithIdOnly = await prisma.region.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RegionUpdateManyAndReturnArgs>(args: SelectSubset<T, RegionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Region.
     * @param {RegionUpsertArgs} args - Arguments to update or create a Region.
     * @example
     * // Update or create a Region
     * const region = await prisma.region.upsert({
     *   create: {
     *     // ... data to create a Region
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Region we want to update
     *   }
     * })
     */
    upsert<T extends RegionUpsertArgs>(args: SelectSubset<T, RegionUpsertArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCountArgs} args - Arguments to filter Regions to count.
     * @example
     * // Count the number of Regions
     * const count = await prisma.region.count({
     *   where: {
     *     // ... the filter for the Regions we want to count
     *   }
     * })
    **/
    count<T extends RegionCountArgs>(
      args?: Subset<T, RegionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionAggregateArgs>(args: Subset<T, RegionAggregateArgs>): Prisma.PrismaPromise<GetRegionAggregateType<T>>

    /**
     * Group by Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionGroupByArgs['orderBy'] }
        : { orderBy?: RegionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Region model
   */
  readonly fields: RegionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Region.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artifacts<T extends Region$artifactsArgs<ExtArgs> = {}>(args?: Subset<T, Region$artifactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    collections<T extends Region$collectionsArgs<ExtArgs> = {}>(args?: Subset<T, Region$collectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CollectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    layers<T extends Region$layersArgs<ExtArgs> = {}>(args?: Subset<T, Region$layersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    maps<T extends Region$mapsArgs<ExtArgs> = {}>(args?: Subset<T, Region$mapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pages<T extends Region$pagesArgs<ExtArgs> = {}>(args?: Subset<T, Region$pagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends Region$postsArgs<ExtArgs> = {}>(args?: Subset<T, Region$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    datasets<T extends Region$datasetsArgs<ExtArgs> = {}>(args?: Subset<T, Region$datasetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchDatasetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    series<T extends Region$seriesArgs<ExtArgs> = {}>(args?: Subset<T, Region$seriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    volumes<T extends Region$volumesArgs<ExtArgs> = {}>(args?: Subset<T, Region$volumesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Region model
   */
  interface RegionFieldRefs {
    readonly id: FieldRef<"Region", 'String'>
    readonly slug: FieldRef<"Region", 'String'>
    readonly name: FieldRef<"Region", 'String'>
    readonly nameI18n: FieldRef<"Region", 'Json'>
    readonly createdAt: FieldRef<"Region", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Region findUnique
   */
  export type RegionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region findUniqueOrThrow
   */
  export type RegionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region findFirst
   */
  export type RegionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region findFirstOrThrow
   */
  export type RegionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region findMany
   */
  export type RegionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Regions to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region create
   */
  export type RegionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to create a Region.
     */
    data: XOR<RegionCreateInput, RegionUncheckedCreateInput>
  }

  /**
   * Region createMany
   */
  export type RegionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Regions.
     */
    data: RegionCreateManyInput | RegionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Region createManyAndReturn
   */
  export type RegionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * The data used to create many Regions.
     */
    data: RegionCreateManyInput | RegionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Region update
   */
  export type RegionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to update a Region.
     */
    data: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
    /**
     * Choose, which Region to update.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region updateMany
   */
  export type RegionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Regions.
     */
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     */
    where?: RegionWhereInput
    /**
     * Limit how many Regions to update.
     */
    limit?: number
  }

  /**
   * Region updateManyAndReturn
   */
  export type RegionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * The data used to update Regions.
     */
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     */
    where?: RegionWhereInput
    /**
     * Limit how many Regions to update.
     */
    limit?: number
  }

  /**
   * Region upsert
   */
  export type RegionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The filter to search for the Region to update in case it exists.
     */
    where: RegionWhereUniqueInput
    /**
     * In case the Region found by the `where` argument doesn't exist, create a new Region with this data.
     */
    create: XOR<RegionCreateInput, RegionUncheckedCreateInput>
    /**
     * In case the Region was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
  }

  /**
   * Region delete
   */
  export type RegionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter which Region to delete.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region deleteMany
   */
  export type RegionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Regions to delete
     */
    where?: RegionWhereInput
    /**
     * Limit how many Regions to delete.
     */
    limit?: number
  }

  /**
   * Region.artifacts
   */
  export type Region$artifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    where?: ArtifactWhereInput
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    cursor?: ArtifactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * Region.collections
   */
  export type Region$collectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Collection
     */
    select?: CollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Collection
     */
    omit?: CollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CollectionInclude<ExtArgs> | null
    where?: CollectionWhereInput
    orderBy?: CollectionOrderByWithRelationInput | CollectionOrderByWithRelationInput[]
    cursor?: CollectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CollectionScalarFieldEnum | CollectionScalarFieldEnum[]
  }

  /**
   * Region.layers
   */
  export type Region$layersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layer
     */
    select?: LayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layer
     */
    omit?: LayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayerInclude<ExtArgs> | null
    where?: LayerWhereInput
    orderBy?: LayerOrderByWithRelationInput | LayerOrderByWithRelationInput[]
    cursor?: LayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LayerScalarFieldEnum | LayerScalarFieldEnum[]
  }

  /**
   * Region.maps
   */
  export type Region$mapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    where?: MapWhereInput
    orderBy?: MapOrderByWithRelationInput | MapOrderByWithRelationInput[]
    cursor?: MapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MapScalarFieldEnum | MapScalarFieldEnum[]
  }

  /**
   * Region.pages
   */
  export type Region$pagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    where?: PageWhereInput
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    cursor?: PageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Region.posts
   */
  export type Region$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Region.datasets
   */
  export type Region$datasetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDataset
     */
    select?: ResearchDatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchDataset
     */
    omit?: ResearchDatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDatasetInclude<ExtArgs> | null
    where?: ResearchDatasetWhereInput
    orderBy?: ResearchDatasetOrderByWithRelationInput | ResearchDatasetOrderByWithRelationInput[]
    cursor?: ResearchDatasetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchDatasetScalarFieldEnum | ResearchDatasetScalarFieldEnum[]
  }

  /**
   * Region.series
   */
  export type Region$seriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    where?: SeriesWhereInput
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    cursor?: SeriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Region.volumes
   */
  export type Region$volumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Volume
     */
    select?: VolumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Volume
     */
    omit?: VolumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeInclude<ExtArgs> | null
    where?: VolumeWhereInput
    orderBy?: VolumeOrderByWithRelationInput | VolumeOrderByWithRelationInput[]
    cursor?: VolumeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VolumeScalarFieldEnum | VolumeScalarFieldEnum[]
  }

  /**
   * Region without action
   */
  export type RegionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    thumbnailId: string | null
    createdAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    thumbnailId: string | null
    createdAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    thumbnailId: number
    createdAt: number
    titleI18n: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    thumbnailId?: true
    createdAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    thumbnailId?: true
    createdAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    thumbnailId?: true
    createdAt?: true
    titleI18n?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    title: string
    slug: string
    thumbnailId: string | null
    createdAt: Date
    titleI18n: JsonValue
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    thumbnailId?: boolean
    createdAt?: boolean
    titleI18n?: boolean
    thumbnail?: boolean | Category$thumbnailArgs<ExtArgs>
    layers?: boolean | Category$layersArgs<ExtArgs>
    maps?: boolean | Category$mapsArgs<ExtArgs>
    datasets?: boolean | Category$datasetsArgs<ExtArgs>
    posts?: boolean | Category$postsArgs<ExtArgs>
    series?: boolean | Category$seriesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    thumbnailId?: boolean
    createdAt?: boolean
    titleI18n?: boolean
    thumbnail?: boolean | Category$thumbnailArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    thumbnailId?: boolean
    createdAt?: boolean
    titleI18n?: boolean
    thumbnail?: boolean | Category$thumbnailArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    thumbnailId?: boolean
    createdAt?: boolean
    titleI18n?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "thumbnailId" | "createdAt" | "titleI18n", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thumbnail?: boolean | Category$thumbnailArgs<ExtArgs>
    layers?: boolean | Category$layersArgs<ExtArgs>
    maps?: boolean | Category$mapsArgs<ExtArgs>
    datasets?: boolean | Category$datasetsArgs<ExtArgs>
    posts?: boolean | Category$postsArgs<ExtArgs>
    series?: boolean | Category$seriesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thumbnail?: boolean | Category$thumbnailArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thumbnail?: boolean | Category$thumbnailArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      thumbnail: Prisma.$MediaPayload<ExtArgs> | null
      layers: Prisma.$LayerPayload<ExtArgs>[]
      maps: Prisma.$MapPayload<ExtArgs>[]
      datasets: Prisma.$ResearchDatasetPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      series: Prisma.$SeriesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      thumbnailId: string | null
      createdAt: Date
      titleI18n: Prisma.JsonValue
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    thumbnail<T extends Category$thumbnailArgs<ExtArgs> = {}>(args?: Subset<T, Category$thumbnailArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    layers<T extends Category$layersArgs<ExtArgs> = {}>(args?: Subset<T, Category$layersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    maps<T extends Category$mapsArgs<ExtArgs> = {}>(args?: Subset<T, Category$mapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    datasets<T extends Category$datasetsArgs<ExtArgs> = {}>(args?: Subset<T, Category$datasetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResearchDatasetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends Category$postsArgs<ExtArgs> = {}>(args?: Subset<T, Category$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    series<T extends Category$seriesArgs<ExtArgs> = {}>(args?: Subset<T, Category$seriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly title: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly thumbnailId: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly titleI18n: FieldRef<"Category", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.thumbnail
   */
  export type Category$thumbnailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Category.layers
   */
  export type Category$layersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Layer
     */
    select?: LayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Layer
     */
    omit?: LayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LayerInclude<ExtArgs> | null
    where?: LayerWhereInput
    orderBy?: LayerOrderByWithRelationInput | LayerOrderByWithRelationInput[]
    cursor?: LayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LayerScalarFieldEnum | LayerScalarFieldEnum[]
  }

  /**
   * Category.maps
   */
  export type Category$mapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Map
     */
    select?: MapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Map
     */
    omit?: MapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MapInclude<ExtArgs> | null
    where?: MapWhereInput
    orderBy?: MapOrderByWithRelationInput | MapOrderByWithRelationInput[]
    cursor?: MapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MapScalarFieldEnum | MapScalarFieldEnum[]
  }

  /**
   * Category.datasets
   */
  export type Category$datasetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResearchDataset
     */
    select?: ResearchDatasetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResearchDataset
     */
    omit?: ResearchDatasetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResearchDatasetInclude<ExtArgs> | null
    where?: ResearchDatasetWhereInput
    orderBy?: ResearchDatasetOrderByWithRelationInput | ResearchDatasetOrderByWithRelationInput[]
    cursor?: ResearchDatasetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResearchDatasetScalarFieldEnum | ResearchDatasetScalarFieldEnum[]
  }

  /**
   * Category.posts
   */
  export type Category$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Category.series
   */
  export type Category$seriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    where?: SeriesWhereInput
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    cursor?: SeriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model ArtifactCategory
   */

  export type AggregateArtifactCategory = {
    _count: ArtifactCategoryCountAggregateOutputType | null
    _min: ArtifactCategoryMinAggregateOutputType | null
    _max: ArtifactCategoryMaxAggregateOutputType | null
  }

  export type ArtifactCategoryMinAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    createdAt: Date | null
  }

  export type ArtifactCategoryMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    createdAt: Date | null
  }

  export type ArtifactCategoryCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    titleI18n: number
    createdAt: number
    _all: number
  }


  export type ArtifactCategoryMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    createdAt?: true
  }

  export type ArtifactCategoryMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    createdAt?: true
  }

  export type ArtifactCategoryCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    titleI18n?: true
    createdAt?: true
    _all?: true
  }

  export type ArtifactCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArtifactCategory to aggregate.
     */
    where?: ArtifactCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtifactCategories to fetch.
     */
    orderBy?: ArtifactCategoryOrderByWithRelationInput | ArtifactCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArtifactCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtifactCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtifactCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArtifactCategories
    **/
    _count?: true | ArtifactCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArtifactCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArtifactCategoryMaxAggregateInputType
  }

  export type GetArtifactCategoryAggregateType<T extends ArtifactCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateArtifactCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArtifactCategory[P]>
      : GetScalarType<T[P], AggregateArtifactCategory[P]>
  }




  export type ArtifactCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtifactCategoryWhereInput
    orderBy?: ArtifactCategoryOrderByWithAggregationInput | ArtifactCategoryOrderByWithAggregationInput[]
    by: ArtifactCategoryScalarFieldEnum[] | ArtifactCategoryScalarFieldEnum
    having?: ArtifactCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArtifactCategoryCountAggregateInputType | true
    _min?: ArtifactCategoryMinAggregateInputType
    _max?: ArtifactCategoryMaxAggregateInputType
  }

  export type ArtifactCategoryGroupByOutputType = {
    id: string
    slug: string
    title: string
    titleI18n: JsonValue
    createdAt: Date
    _count: ArtifactCategoryCountAggregateOutputType | null
    _min: ArtifactCategoryMinAggregateOutputType | null
    _max: ArtifactCategoryMaxAggregateOutputType | null
  }

  type GetArtifactCategoryGroupByPayload<T extends ArtifactCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArtifactCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArtifactCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArtifactCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ArtifactCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ArtifactCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    titleI18n?: boolean
    createdAt?: boolean
    artifacts?: boolean | ArtifactCategory$artifactsArgs<ExtArgs>
    _count?: boolean | ArtifactCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artifactCategory"]>

  export type ArtifactCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    titleI18n?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["artifactCategory"]>

  export type ArtifactCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    titleI18n?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["artifactCategory"]>

  export type ArtifactCategorySelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
    titleI18n?: boolean
    createdAt?: boolean
  }

  export type ArtifactCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "title" | "titleI18n" | "createdAt", ExtArgs["result"]["artifactCategory"]>
  export type ArtifactCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifacts?: boolean | ArtifactCategory$artifactsArgs<ExtArgs>
    _count?: boolean | ArtifactCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ArtifactCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ArtifactCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ArtifactCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArtifactCategory"
    objects: {
      artifacts: Prisma.$ArtifactPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      title: string
      titleI18n: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["artifactCategory"]>
    composites: {}
  }

  type ArtifactCategoryGetPayload<S extends boolean | null | undefined | ArtifactCategoryDefaultArgs> = $Result.GetResult<Prisma.$ArtifactCategoryPayload, S>

  type ArtifactCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArtifactCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArtifactCategoryCountAggregateInputType | true
    }

  export interface ArtifactCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArtifactCategory'], meta: { name: 'ArtifactCategory' } }
    /**
     * Find zero or one ArtifactCategory that matches the filter.
     * @param {ArtifactCategoryFindUniqueArgs} args - Arguments to find a ArtifactCategory
     * @example
     * // Get one ArtifactCategory
     * const artifactCategory = await prisma.artifactCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArtifactCategoryFindUniqueArgs>(args: SelectSubset<T, ArtifactCategoryFindUniqueArgs<ExtArgs>>): Prisma__ArtifactCategoryClient<$Result.GetResult<Prisma.$ArtifactCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ArtifactCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArtifactCategoryFindUniqueOrThrowArgs} args - Arguments to find a ArtifactCategory
     * @example
     * // Get one ArtifactCategory
     * const artifactCategory = await prisma.artifactCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArtifactCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ArtifactCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArtifactCategoryClient<$Result.GetResult<Prisma.$ArtifactCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArtifactCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactCategoryFindFirstArgs} args - Arguments to find a ArtifactCategory
     * @example
     * // Get one ArtifactCategory
     * const artifactCategory = await prisma.artifactCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArtifactCategoryFindFirstArgs>(args?: SelectSubset<T, ArtifactCategoryFindFirstArgs<ExtArgs>>): Prisma__ArtifactCategoryClient<$Result.GetResult<Prisma.$ArtifactCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArtifactCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactCategoryFindFirstOrThrowArgs} args - Arguments to find a ArtifactCategory
     * @example
     * // Get one ArtifactCategory
     * const artifactCategory = await prisma.artifactCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArtifactCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ArtifactCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArtifactCategoryClient<$Result.GetResult<Prisma.$ArtifactCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ArtifactCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArtifactCategories
     * const artifactCategories = await prisma.artifactCategory.findMany()
     * 
     * // Get first 10 ArtifactCategories
     * const artifactCategories = await prisma.artifactCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const artifactCategoryWithIdOnly = await prisma.artifactCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArtifactCategoryFindManyArgs>(args?: SelectSubset<T, ArtifactCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ArtifactCategory.
     * @param {ArtifactCategoryCreateArgs} args - Arguments to create a ArtifactCategory.
     * @example
     * // Create one ArtifactCategory
     * const ArtifactCategory = await prisma.artifactCategory.create({
     *   data: {
     *     // ... data to create a ArtifactCategory
     *   }
     * })
     * 
     */
    create<T extends ArtifactCategoryCreateArgs>(args: SelectSubset<T, ArtifactCategoryCreateArgs<ExtArgs>>): Prisma__ArtifactCategoryClient<$Result.GetResult<Prisma.$ArtifactCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ArtifactCategories.
     * @param {ArtifactCategoryCreateManyArgs} args - Arguments to create many ArtifactCategories.
     * @example
     * // Create many ArtifactCategories
     * const artifactCategory = await prisma.artifactCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArtifactCategoryCreateManyArgs>(args?: SelectSubset<T, ArtifactCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ArtifactCategories and returns the data saved in the database.
     * @param {ArtifactCategoryCreateManyAndReturnArgs} args - Arguments to create many ArtifactCategories.
     * @example
     * // Create many ArtifactCategories
     * const artifactCategory = await prisma.artifactCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ArtifactCategories and only return the `id`
     * const artifactCategoryWithIdOnly = await prisma.artifactCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArtifactCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ArtifactCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ArtifactCategory.
     * @param {ArtifactCategoryDeleteArgs} args - Arguments to delete one ArtifactCategory.
     * @example
     * // Delete one ArtifactCategory
     * const ArtifactCategory = await prisma.artifactCategory.delete({
     *   where: {
     *     // ... filter to delete one ArtifactCategory
     *   }
     * })
     * 
     */
    delete<T extends ArtifactCategoryDeleteArgs>(args: SelectSubset<T, ArtifactCategoryDeleteArgs<ExtArgs>>): Prisma__ArtifactCategoryClient<$Result.GetResult<Prisma.$ArtifactCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ArtifactCategory.
     * @param {ArtifactCategoryUpdateArgs} args - Arguments to update one ArtifactCategory.
     * @example
     * // Update one ArtifactCategory
     * const artifactCategory = await prisma.artifactCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArtifactCategoryUpdateArgs>(args: SelectSubset<T, ArtifactCategoryUpdateArgs<ExtArgs>>): Prisma__ArtifactCategoryClient<$Result.GetResult<Prisma.$ArtifactCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ArtifactCategories.
     * @param {ArtifactCategoryDeleteManyArgs} args - Arguments to filter ArtifactCategories to delete.
     * @example
     * // Delete a few ArtifactCategories
     * const { count } = await prisma.artifactCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArtifactCategoryDeleteManyArgs>(args?: SelectSubset<T, ArtifactCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArtifactCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArtifactCategories
     * const artifactCategory = await prisma.artifactCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArtifactCategoryUpdateManyArgs>(args: SelectSubset<T, ArtifactCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArtifactCategories and returns the data updated in the database.
     * @param {ArtifactCategoryUpdateManyAndReturnArgs} args - Arguments to update many ArtifactCategories.
     * @example
     * // Update many ArtifactCategories
     * const artifactCategory = await prisma.artifactCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ArtifactCategories and only return the `id`
     * const artifactCategoryWithIdOnly = await prisma.artifactCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArtifactCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ArtifactCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ArtifactCategory.
     * @param {ArtifactCategoryUpsertArgs} args - Arguments to update or create a ArtifactCategory.
     * @example
     * // Update or create a ArtifactCategory
     * const artifactCategory = await prisma.artifactCategory.upsert({
     *   create: {
     *     // ... data to create a ArtifactCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArtifactCategory we want to update
     *   }
     * })
     */
    upsert<T extends ArtifactCategoryUpsertArgs>(args: SelectSubset<T, ArtifactCategoryUpsertArgs<ExtArgs>>): Prisma__ArtifactCategoryClient<$Result.GetResult<Prisma.$ArtifactCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ArtifactCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactCategoryCountArgs} args - Arguments to filter ArtifactCategories to count.
     * @example
     * // Count the number of ArtifactCategories
     * const count = await prisma.artifactCategory.count({
     *   where: {
     *     // ... the filter for the ArtifactCategories we want to count
     *   }
     * })
    **/
    count<T extends ArtifactCategoryCountArgs>(
      args?: Subset<T, ArtifactCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArtifactCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArtifactCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArtifactCategoryAggregateArgs>(args: Subset<T, ArtifactCategoryAggregateArgs>): Prisma.PrismaPromise<GetArtifactCategoryAggregateType<T>>

    /**
     * Group by ArtifactCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArtifactCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArtifactCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ArtifactCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArtifactCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArtifactCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArtifactCategory model
   */
  readonly fields: ArtifactCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArtifactCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArtifactCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artifacts<T extends ArtifactCategory$artifactsArgs<ExtArgs> = {}>(args?: Subset<T, ArtifactCategory$artifactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ArtifactCategory model
   */
  interface ArtifactCategoryFieldRefs {
    readonly id: FieldRef<"ArtifactCategory", 'String'>
    readonly slug: FieldRef<"ArtifactCategory", 'String'>
    readonly title: FieldRef<"ArtifactCategory", 'String'>
    readonly titleI18n: FieldRef<"ArtifactCategory", 'Json'>
    readonly createdAt: FieldRef<"ArtifactCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ArtifactCategory findUnique
   */
  export type ArtifactCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactCategory
     */
    select?: ArtifactCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactCategory
     */
    omit?: ArtifactCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ArtifactCategory to fetch.
     */
    where: ArtifactCategoryWhereUniqueInput
  }

  /**
   * ArtifactCategory findUniqueOrThrow
   */
  export type ArtifactCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactCategory
     */
    select?: ArtifactCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactCategory
     */
    omit?: ArtifactCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ArtifactCategory to fetch.
     */
    where: ArtifactCategoryWhereUniqueInput
  }

  /**
   * ArtifactCategory findFirst
   */
  export type ArtifactCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactCategory
     */
    select?: ArtifactCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactCategory
     */
    omit?: ArtifactCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ArtifactCategory to fetch.
     */
    where?: ArtifactCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtifactCategories to fetch.
     */
    orderBy?: ArtifactCategoryOrderByWithRelationInput | ArtifactCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArtifactCategories.
     */
    cursor?: ArtifactCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtifactCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtifactCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArtifactCategories.
     */
    distinct?: ArtifactCategoryScalarFieldEnum | ArtifactCategoryScalarFieldEnum[]
  }

  /**
   * ArtifactCategory findFirstOrThrow
   */
  export type ArtifactCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactCategory
     */
    select?: ArtifactCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactCategory
     */
    omit?: ArtifactCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ArtifactCategory to fetch.
     */
    where?: ArtifactCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtifactCategories to fetch.
     */
    orderBy?: ArtifactCategoryOrderByWithRelationInput | ArtifactCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArtifactCategories.
     */
    cursor?: ArtifactCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtifactCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtifactCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArtifactCategories.
     */
    distinct?: ArtifactCategoryScalarFieldEnum | ArtifactCategoryScalarFieldEnum[]
  }

  /**
   * ArtifactCategory findMany
   */
  export type ArtifactCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactCategory
     */
    select?: ArtifactCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactCategory
     */
    omit?: ArtifactCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ArtifactCategories to fetch.
     */
    where?: ArtifactCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtifactCategories to fetch.
     */
    orderBy?: ArtifactCategoryOrderByWithRelationInput | ArtifactCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArtifactCategories.
     */
    cursor?: ArtifactCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtifactCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtifactCategories.
     */
    skip?: number
    distinct?: ArtifactCategoryScalarFieldEnum | ArtifactCategoryScalarFieldEnum[]
  }

  /**
   * ArtifactCategory create
   */
  export type ArtifactCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactCategory
     */
    select?: ArtifactCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactCategory
     */
    omit?: ArtifactCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ArtifactCategory.
     */
    data: XOR<ArtifactCategoryCreateInput, ArtifactCategoryUncheckedCreateInput>
  }

  /**
   * ArtifactCategory createMany
   */
  export type ArtifactCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArtifactCategories.
     */
    data: ArtifactCategoryCreateManyInput | ArtifactCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArtifactCategory createManyAndReturn
   */
  export type ArtifactCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactCategory
     */
    select?: ArtifactCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactCategory
     */
    omit?: ArtifactCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ArtifactCategories.
     */
    data: ArtifactCategoryCreateManyInput | ArtifactCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArtifactCategory update
   */
  export type ArtifactCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactCategory
     */
    select?: ArtifactCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactCategory
     */
    omit?: ArtifactCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ArtifactCategory.
     */
    data: XOR<ArtifactCategoryUpdateInput, ArtifactCategoryUncheckedUpdateInput>
    /**
     * Choose, which ArtifactCategory to update.
     */
    where: ArtifactCategoryWhereUniqueInput
  }

  /**
   * ArtifactCategory updateMany
   */
  export type ArtifactCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArtifactCategories.
     */
    data: XOR<ArtifactCategoryUpdateManyMutationInput, ArtifactCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ArtifactCategories to update
     */
    where?: ArtifactCategoryWhereInput
    /**
     * Limit how many ArtifactCategories to update.
     */
    limit?: number
  }

  /**
   * ArtifactCategory updateManyAndReturn
   */
  export type ArtifactCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactCategory
     */
    select?: ArtifactCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactCategory
     */
    omit?: ArtifactCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ArtifactCategories.
     */
    data: XOR<ArtifactCategoryUpdateManyMutationInput, ArtifactCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ArtifactCategories to update
     */
    where?: ArtifactCategoryWhereInput
    /**
     * Limit how many ArtifactCategories to update.
     */
    limit?: number
  }

  /**
   * ArtifactCategory upsert
   */
  export type ArtifactCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactCategory
     */
    select?: ArtifactCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactCategory
     */
    omit?: ArtifactCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ArtifactCategory to update in case it exists.
     */
    where: ArtifactCategoryWhereUniqueInput
    /**
     * In case the ArtifactCategory found by the `where` argument doesn't exist, create a new ArtifactCategory with this data.
     */
    create: XOR<ArtifactCategoryCreateInput, ArtifactCategoryUncheckedCreateInput>
    /**
     * In case the ArtifactCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArtifactCategoryUpdateInput, ArtifactCategoryUncheckedUpdateInput>
  }

  /**
   * ArtifactCategory delete
   */
  export type ArtifactCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactCategory
     */
    select?: ArtifactCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactCategory
     */
    omit?: ArtifactCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactCategoryInclude<ExtArgs> | null
    /**
     * Filter which ArtifactCategory to delete.
     */
    where: ArtifactCategoryWhereUniqueInput
  }

  /**
   * ArtifactCategory deleteMany
   */
  export type ArtifactCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArtifactCategories to delete
     */
    where?: ArtifactCategoryWhereInput
    /**
     * Limit how many ArtifactCategories to delete.
     */
    limit?: number
  }

  /**
   * ArtifactCategory.artifacts
   */
  export type ArtifactCategory$artifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    where?: ArtifactWhereInput
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    cursor?: ArtifactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * ArtifactCategory without action
   */
  export type ArtifactCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactCategory
     */
    select?: ArtifactCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactCategory
     */
    omit?: ArtifactCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Period
   */

  export type AggregatePeriod = {
    _count: PeriodCountAggregateOutputType | null
    _min: PeriodMinAggregateOutputType | null
    _max: PeriodMaxAggregateOutputType | null
  }

  export type PeriodMinAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    dateStart: Date | null
    dateEnd: Date | null
    createdAt: Date | null
  }

  export type PeriodMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    dateStart: Date | null
    dateEnd: Date | null
    createdAt: Date | null
  }

  export type PeriodCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    nameI18n: number
    dateStart: number
    dateEnd: number
    createdAt: number
    _all: number
  }


  export type PeriodMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    dateStart?: true
    dateEnd?: true
    createdAt?: true
  }

  export type PeriodMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    dateStart?: true
    dateEnd?: true
    createdAt?: true
  }

  export type PeriodCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    nameI18n?: true
    dateStart?: true
    dateEnd?: true
    createdAt?: true
    _all?: true
  }

  export type PeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Period to aggregate.
     */
    where?: PeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Periods to fetch.
     */
    orderBy?: PeriodOrderByWithRelationInput | PeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Periods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Periods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Periods
    **/
    _count?: true | PeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PeriodMaxAggregateInputType
  }

  export type GetPeriodAggregateType<T extends PeriodAggregateArgs> = {
        [P in keyof T & keyof AggregatePeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePeriod[P]>
      : GetScalarType<T[P], AggregatePeriod[P]>
  }




  export type PeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PeriodWhereInput
    orderBy?: PeriodOrderByWithAggregationInput | PeriodOrderByWithAggregationInput[]
    by: PeriodScalarFieldEnum[] | PeriodScalarFieldEnum
    having?: PeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PeriodCountAggregateInputType | true
    _min?: PeriodMinAggregateInputType
    _max?: PeriodMaxAggregateInputType
  }

  export type PeriodGroupByOutputType = {
    id: string
    slug: string
    name: string
    nameI18n: JsonValue
    dateStart: Date | null
    dateEnd: Date | null
    createdAt: Date
    _count: PeriodCountAggregateOutputType | null
    _min: PeriodMinAggregateOutputType | null
    _max: PeriodMaxAggregateOutputType | null
  }

  type GetPeriodGroupByPayload<T extends PeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PeriodGroupByOutputType[P]>
            : GetScalarType<T[P], PeriodGroupByOutputType[P]>
        }
      >
    >


  export type PeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    nameI18n?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    createdAt?: boolean
    artifacts?: boolean | Period$artifactsArgs<ExtArgs>
    _count?: boolean | PeriodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["period"]>

  export type PeriodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    nameI18n?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["period"]>

  export type PeriodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    nameI18n?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["period"]>

  export type PeriodSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    nameI18n?: boolean
    dateStart?: boolean
    dateEnd?: boolean
    createdAt?: boolean
  }

  export type PeriodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "name" | "nameI18n" | "dateStart" | "dateEnd" | "createdAt", ExtArgs["result"]["period"]>
  export type PeriodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifacts?: boolean | Period$artifactsArgs<ExtArgs>
    _count?: boolean | PeriodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PeriodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PeriodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Period"
    objects: {
      artifacts: Prisma.$ArtifactPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      name: string
      nameI18n: Prisma.JsonValue
      dateStart: Date | null
      dateEnd: Date | null
      createdAt: Date
    }, ExtArgs["result"]["period"]>
    composites: {}
  }

  type PeriodGetPayload<S extends boolean | null | undefined | PeriodDefaultArgs> = $Result.GetResult<Prisma.$PeriodPayload, S>

  type PeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PeriodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PeriodCountAggregateInputType | true
    }

  export interface PeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Period'], meta: { name: 'Period' } }
    /**
     * Find zero or one Period that matches the filter.
     * @param {PeriodFindUniqueArgs} args - Arguments to find a Period
     * @example
     * // Get one Period
     * const period = await prisma.period.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PeriodFindUniqueArgs>(args: SelectSubset<T, PeriodFindUniqueArgs<ExtArgs>>): Prisma__PeriodClient<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Period that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PeriodFindUniqueOrThrowArgs} args - Arguments to find a Period
     * @example
     * // Get one Period
     * const period = await prisma.period.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, PeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PeriodClient<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Period that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodFindFirstArgs} args - Arguments to find a Period
     * @example
     * // Get one Period
     * const period = await prisma.period.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PeriodFindFirstArgs>(args?: SelectSubset<T, PeriodFindFirstArgs<ExtArgs>>): Prisma__PeriodClient<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Period that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodFindFirstOrThrowArgs} args - Arguments to find a Period
     * @example
     * // Get one Period
     * const period = await prisma.period.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, PeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__PeriodClient<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Periods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Periods
     * const periods = await prisma.period.findMany()
     * 
     * // Get first 10 Periods
     * const periods = await prisma.period.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const periodWithIdOnly = await prisma.period.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PeriodFindManyArgs>(args?: SelectSubset<T, PeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Period.
     * @param {PeriodCreateArgs} args - Arguments to create a Period.
     * @example
     * // Create one Period
     * const Period = await prisma.period.create({
     *   data: {
     *     // ... data to create a Period
     *   }
     * })
     * 
     */
    create<T extends PeriodCreateArgs>(args: SelectSubset<T, PeriodCreateArgs<ExtArgs>>): Prisma__PeriodClient<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Periods.
     * @param {PeriodCreateManyArgs} args - Arguments to create many Periods.
     * @example
     * // Create many Periods
     * const period = await prisma.period.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PeriodCreateManyArgs>(args?: SelectSubset<T, PeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Periods and returns the data saved in the database.
     * @param {PeriodCreateManyAndReturnArgs} args - Arguments to create many Periods.
     * @example
     * // Create many Periods
     * const period = await prisma.period.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Periods and only return the `id`
     * const periodWithIdOnly = await prisma.period.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PeriodCreateManyAndReturnArgs>(args?: SelectSubset<T, PeriodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Period.
     * @param {PeriodDeleteArgs} args - Arguments to delete one Period.
     * @example
     * // Delete one Period
     * const Period = await prisma.period.delete({
     *   where: {
     *     // ... filter to delete one Period
     *   }
     * })
     * 
     */
    delete<T extends PeriodDeleteArgs>(args: SelectSubset<T, PeriodDeleteArgs<ExtArgs>>): Prisma__PeriodClient<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Period.
     * @param {PeriodUpdateArgs} args - Arguments to update one Period.
     * @example
     * // Update one Period
     * const period = await prisma.period.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PeriodUpdateArgs>(args: SelectSubset<T, PeriodUpdateArgs<ExtArgs>>): Prisma__PeriodClient<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Periods.
     * @param {PeriodDeleteManyArgs} args - Arguments to filter Periods to delete.
     * @example
     * // Delete a few Periods
     * const { count } = await prisma.period.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PeriodDeleteManyArgs>(args?: SelectSubset<T, PeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Periods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Periods
     * const period = await prisma.period.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PeriodUpdateManyArgs>(args: SelectSubset<T, PeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Periods and returns the data updated in the database.
     * @param {PeriodUpdateManyAndReturnArgs} args - Arguments to update many Periods.
     * @example
     * // Update many Periods
     * const period = await prisma.period.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Periods and only return the `id`
     * const periodWithIdOnly = await prisma.period.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PeriodUpdateManyAndReturnArgs>(args: SelectSubset<T, PeriodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Period.
     * @param {PeriodUpsertArgs} args - Arguments to update or create a Period.
     * @example
     * // Update or create a Period
     * const period = await prisma.period.upsert({
     *   create: {
     *     // ... data to create a Period
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Period we want to update
     *   }
     * })
     */
    upsert<T extends PeriodUpsertArgs>(args: SelectSubset<T, PeriodUpsertArgs<ExtArgs>>): Prisma__PeriodClient<$Result.GetResult<Prisma.$PeriodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Periods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodCountArgs} args - Arguments to filter Periods to count.
     * @example
     * // Count the number of Periods
     * const count = await prisma.period.count({
     *   where: {
     *     // ... the filter for the Periods we want to count
     *   }
     * })
    **/
    count<T extends PeriodCountArgs>(
      args?: Subset<T, PeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Period.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PeriodAggregateArgs>(args: Subset<T, PeriodAggregateArgs>): Prisma.PrismaPromise<GetPeriodAggregateType<T>>

    /**
     * Group by Period.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PeriodGroupByArgs['orderBy'] }
        : { orderBy?: PeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Period model
   */
  readonly fields: PeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Period.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artifacts<T extends Period$artifactsArgs<ExtArgs> = {}>(args?: Subset<T, Period$artifactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Period model
   */
  interface PeriodFieldRefs {
    readonly id: FieldRef<"Period", 'String'>
    readonly slug: FieldRef<"Period", 'String'>
    readonly name: FieldRef<"Period", 'String'>
    readonly nameI18n: FieldRef<"Period", 'Json'>
    readonly dateStart: FieldRef<"Period", 'DateTime'>
    readonly dateEnd: FieldRef<"Period", 'DateTime'>
    readonly createdAt: FieldRef<"Period", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Period findUnique
   */
  export type PeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodInclude<ExtArgs> | null
    /**
     * Filter, which Period to fetch.
     */
    where: PeriodWhereUniqueInput
  }

  /**
   * Period findUniqueOrThrow
   */
  export type PeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodInclude<ExtArgs> | null
    /**
     * Filter, which Period to fetch.
     */
    where: PeriodWhereUniqueInput
  }

  /**
   * Period findFirst
   */
  export type PeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodInclude<ExtArgs> | null
    /**
     * Filter, which Period to fetch.
     */
    where?: PeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Periods to fetch.
     */
    orderBy?: PeriodOrderByWithRelationInput | PeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Periods.
     */
    cursor?: PeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Periods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Periods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Periods.
     */
    distinct?: PeriodScalarFieldEnum | PeriodScalarFieldEnum[]
  }

  /**
   * Period findFirstOrThrow
   */
  export type PeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodInclude<ExtArgs> | null
    /**
     * Filter, which Period to fetch.
     */
    where?: PeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Periods to fetch.
     */
    orderBy?: PeriodOrderByWithRelationInput | PeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Periods.
     */
    cursor?: PeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Periods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Periods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Periods.
     */
    distinct?: PeriodScalarFieldEnum | PeriodScalarFieldEnum[]
  }

  /**
   * Period findMany
   */
  export type PeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodInclude<ExtArgs> | null
    /**
     * Filter, which Periods to fetch.
     */
    where?: PeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Periods to fetch.
     */
    orderBy?: PeriodOrderByWithRelationInput | PeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Periods.
     */
    cursor?: PeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Periods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Periods.
     */
    skip?: number
    distinct?: PeriodScalarFieldEnum | PeriodScalarFieldEnum[]
  }

  /**
   * Period create
   */
  export type PeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a Period.
     */
    data: XOR<PeriodCreateInput, PeriodUncheckedCreateInput>
  }

  /**
   * Period createMany
   */
  export type PeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Periods.
     */
    data: PeriodCreateManyInput | PeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Period createManyAndReturn
   */
  export type PeriodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * The data used to create many Periods.
     */
    data: PeriodCreateManyInput | PeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Period update
   */
  export type PeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a Period.
     */
    data: XOR<PeriodUpdateInput, PeriodUncheckedUpdateInput>
    /**
     * Choose, which Period to update.
     */
    where: PeriodWhereUniqueInput
  }

  /**
   * Period updateMany
   */
  export type PeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Periods.
     */
    data: XOR<PeriodUpdateManyMutationInput, PeriodUncheckedUpdateManyInput>
    /**
     * Filter which Periods to update
     */
    where?: PeriodWhereInput
    /**
     * Limit how many Periods to update.
     */
    limit?: number
  }

  /**
   * Period updateManyAndReturn
   */
  export type PeriodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * The data used to update Periods.
     */
    data: XOR<PeriodUpdateManyMutationInput, PeriodUncheckedUpdateManyInput>
    /**
     * Filter which Periods to update
     */
    where?: PeriodWhereInput
    /**
     * Limit how many Periods to update.
     */
    limit?: number
  }

  /**
   * Period upsert
   */
  export type PeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the Period to update in case it exists.
     */
    where: PeriodWhereUniqueInput
    /**
     * In case the Period found by the `where` argument doesn't exist, create a new Period with this data.
     */
    create: XOR<PeriodCreateInput, PeriodUncheckedCreateInput>
    /**
     * In case the Period was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PeriodUpdateInput, PeriodUncheckedUpdateInput>
  }

  /**
   * Period delete
   */
  export type PeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodInclude<ExtArgs> | null
    /**
     * Filter which Period to delete.
     */
    where: PeriodWhereUniqueInput
  }

  /**
   * Period deleteMany
   */
  export type PeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Periods to delete
     */
    where?: PeriodWhereInput
    /**
     * Limit how many Periods to delete.
     */
    limit?: number
  }

  /**
   * Period.artifacts
   */
  export type Period$artifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Artifact
     */
    select?: ArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Artifact
     */
    omit?: ArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactInclude<ExtArgs> | null
    where?: ArtifactWhereInput
    orderBy?: ArtifactOrderByWithRelationInput | ArtifactOrderByWithRelationInput[]
    cursor?: ArtifactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtifactScalarFieldEnum | ArtifactScalarFieldEnum[]
  }

  /**
   * Period without action
   */
  export type PeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Period
     */
    select?: PeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Period
     */
    omit?: PeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodInclude<ExtArgs> | null
  }


  /**
   * Model Menu
   */

  export type AggregateMenu = {
    _count: MenuCountAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  export type MenuMinAggregateOutputType = {
    id: string | null
    location: $Enums.MenuLocation | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuMaxAggregateOutputType = {
    id: string | null
    location: $Enums.MenuLocation | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuCountAggregateOutputType = {
    id: number
    location: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MenuMinAggregateInputType = {
    id?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuMaxAggregateInputType = {
    id?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuCountAggregateInputType = {
    id?: true
    location?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MenuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Menu to aggregate.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Menus
    **/
    _count?: true | MenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuMaxAggregateInputType
  }

  export type GetMenuAggregateType<T extends MenuAggregateArgs> = {
        [P in keyof T & keyof AggregateMenu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenu[P]>
      : GetScalarType<T[P], AggregateMenu[P]>
  }




  export type MenuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuWhereInput
    orderBy?: MenuOrderByWithAggregationInput | MenuOrderByWithAggregationInput[]
    by: MenuScalarFieldEnum[] | MenuScalarFieldEnum
    having?: MenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuCountAggregateInputType | true
    _min?: MenuMinAggregateInputType
    _max?: MenuMaxAggregateInputType
  }

  export type MenuGroupByOutputType = {
    id: string
    location: $Enums.MenuLocation
    createdAt: Date
    updatedAt: Date
    _count: MenuCountAggregateOutputType | null
    _min: MenuMinAggregateOutputType | null
    _max: MenuMaxAggregateOutputType | null
  }

  type GetMenuGroupByPayload<T extends MenuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuGroupByOutputType[P]>
            : GetScalarType<T[P], MenuGroupByOutputType[P]>
        }
      >
    >


  export type MenuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | Menu$itemsArgs<ExtArgs>
    _count?: boolean | MenuCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menu"]>

  export type MenuSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["menu"]>

  export type MenuSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["menu"]>

  export type MenuSelectScalar = {
    id?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MenuOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "location" | "createdAt" | "updatedAt", ExtArgs["result"]["menu"]>
  export type MenuInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Menu$itemsArgs<ExtArgs>
    _count?: boolean | MenuCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MenuIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MenuIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MenuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Menu"
    objects: {
      items: Prisma.$MenuItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      location: $Enums.MenuLocation
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["menu"]>
    composites: {}
  }

  type MenuGetPayload<S extends boolean | null | undefined | MenuDefaultArgs> = $Result.GetResult<Prisma.$MenuPayload, S>

  type MenuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MenuFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenuCountAggregateInputType | true
    }

  export interface MenuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Menu'], meta: { name: 'Menu' } }
    /**
     * Find zero or one Menu that matches the filter.
     * @param {MenuFindUniqueArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenuFindUniqueArgs>(args: SelectSubset<T, MenuFindUniqueArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Menu that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenuFindUniqueOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenuFindUniqueOrThrowArgs>(args: SelectSubset<T, MenuFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Menu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenuFindFirstArgs>(args?: SelectSubset<T, MenuFindFirstArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Menu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindFirstOrThrowArgs} args - Arguments to find a Menu
     * @example
     * // Get one Menu
     * const menu = await prisma.menu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenuFindFirstOrThrowArgs>(args?: SelectSubset<T, MenuFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Menus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Menus
     * const menus = await prisma.menu.findMany()
     * 
     * // Get first 10 Menus
     * const menus = await prisma.menu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuWithIdOnly = await prisma.menu.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MenuFindManyArgs>(args?: SelectSubset<T, MenuFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Menu.
     * @param {MenuCreateArgs} args - Arguments to create a Menu.
     * @example
     * // Create one Menu
     * const Menu = await prisma.menu.create({
     *   data: {
     *     // ... data to create a Menu
     *   }
     * })
     * 
     */
    create<T extends MenuCreateArgs>(args: SelectSubset<T, MenuCreateArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Menus.
     * @param {MenuCreateManyArgs} args - Arguments to create many Menus.
     * @example
     * // Create many Menus
     * const menu = await prisma.menu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenuCreateManyArgs>(args?: SelectSubset<T, MenuCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Menus and returns the data saved in the database.
     * @param {MenuCreateManyAndReturnArgs} args - Arguments to create many Menus.
     * @example
     * // Create many Menus
     * const menu = await prisma.menu.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Menus and only return the `id`
     * const menuWithIdOnly = await prisma.menu.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenuCreateManyAndReturnArgs>(args?: SelectSubset<T, MenuCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Menu.
     * @param {MenuDeleteArgs} args - Arguments to delete one Menu.
     * @example
     * // Delete one Menu
     * const Menu = await prisma.menu.delete({
     *   where: {
     *     // ... filter to delete one Menu
     *   }
     * })
     * 
     */
    delete<T extends MenuDeleteArgs>(args: SelectSubset<T, MenuDeleteArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Menu.
     * @param {MenuUpdateArgs} args - Arguments to update one Menu.
     * @example
     * // Update one Menu
     * const menu = await prisma.menu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenuUpdateArgs>(args: SelectSubset<T, MenuUpdateArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Menus.
     * @param {MenuDeleteManyArgs} args - Arguments to filter Menus to delete.
     * @example
     * // Delete a few Menus
     * const { count } = await prisma.menu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenuDeleteManyArgs>(args?: SelectSubset<T, MenuDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Menus
     * const menu = await prisma.menu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenuUpdateManyArgs>(args: SelectSubset<T, MenuUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menus and returns the data updated in the database.
     * @param {MenuUpdateManyAndReturnArgs} args - Arguments to update many Menus.
     * @example
     * // Update many Menus
     * const menu = await prisma.menu.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Menus and only return the `id`
     * const menuWithIdOnly = await prisma.menu.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MenuUpdateManyAndReturnArgs>(args: SelectSubset<T, MenuUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Menu.
     * @param {MenuUpsertArgs} args - Arguments to update or create a Menu.
     * @example
     * // Update or create a Menu
     * const menu = await prisma.menu.upsert({
     *   create: {
     *     // ... data to create a Menu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Menu we want to update
     *   }
     * })
     */
    upsert<T extends MenuUpsertArgs>(args: SelectSubset<T, MenuUpsertArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuCountArgs} args - Arguments to filter Menus to count.
     * @example
     * // Count the number of Menus
     * const count = await prisma.menu.count({
     *   where: {
     *     // ... the filter for the Menus we want to count
     *   }
     * })
    **/
    count<T extends MenuCountArgs>(
      args?: Subset<T, MenuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuAggregateArgs>(args: Subset<T, MenuAggregateArgs>): Prisma.PrismaPromise<GetMenuAggregateType<T>>

    /**
     * Group by Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuGroupByArgs['orderBy'] }
        : { orderBy?: MenuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Menu model
   */
  readonly fields: MenuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Menu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends Menu$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Menu$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Menu model
   */
  interface MenuFieldRefs {
    readonly id: FieldRef<"Menu", 'String'>
    readonly location: FieldRef<"Menu", 'MenuLocation'>
    readonly createdAt: FieldRef<"Menu", 'DateTime'>
    readonly updatedAt: FieldRef<"Menu", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Menu findUnique
   */
  export type MenuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu findUniqueOrThrow
   */
  export type MenuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu findFirst
   */
  export type MenuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Menu findFirstOrThrow
   */
  export type MenuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menu to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Menus.
     */
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Menu findMany
   */
  export type MenuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter, which Menus to fetch.
     */
    where?: MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Menus to fetch.
     */
    orderBy?: MenuOrderByWithRelationInput | MenuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Menus.
     */
    cursor?: MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Menus.
     */
    skip?: number
    distinct?: MenuScalarFieldEnum | MenuScalarFieldEnum[]
  }

  /**
   * Menu create
   */
  export type MenuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The data needed to create a Menu.
     */
    data: XOR<MenuCreateInput, MenuUncheckedCreateInput>
  }

  /**
   * Menu createMany
   */
  export type MenuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Menus.
     */
    data: MenuCreateManyInput | MenuCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Menu createManyAndReturn
   */
  export type MenuCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * The data used to create many Menus.
     */
    data: MenuCreateManyInput | MenuCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Menu update
   */
  export type MenuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The data needed to update a Menu.
     */
    data: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
    /**
     * Choose, which Menu to update.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu updateMany
   */
  export type MenuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Menus.
     */
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyInput>
    /**
     * Filter which Menus to update
     */
    where?: MenuWhereInput
    /**
     * Limit how many Menus to update.
     */
    limit?: number
  }

  /**
   * Menu updateManyAndReturn
   */
  export type MenuUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * The data used to update Menus.
     */
    data: XOR<MenuUpdateManyMutationInput, MenuUncheckedUpdateManyInput>
    /**
     * Filter which Menus to update
     */
    where?: MenuWhereInput
    /**
     * Limit how many Menus to update.
     */
    limit?: number
  }

  /**
   * Menu upsert
   */
  export type MenuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * The filter to search for the Menu to update in case it exists.
     */
    where: MenuWhereUniqueInput
    /**
     * In case the Menu found by the `where` argument doesn't exist, create a new Menu with this data.
     */
    create: XOR<MenuCreateInput, MenuUncheckedCreateInput>
    /**
     * In case the Menu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuUpdateInput, MenuUncheckedUpdateInput>
  }

  /**
   * Menu delete
   */
  export type MenuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
    /**
     * Filter which Menu to delete.
     */
    where: MenuWhereUniqueInput
  }

  /**
   * Menu deleteMany
   */
  export type MenuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Menus to delete
     */
    where?: MenuWhereInput
    /**
     * Limit how many Menus to delete.
     */
    limit?: number
  }

  /**
   * Menu.items
   */
  export type Menu$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    where?: MenuItemWhereInput
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    cursor?: MenuItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * Menu without action
   */
  export type MenuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Menu
     */
    select?: MenuSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Menu
     */
    omit?: MenuOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuInclude<ExtArgs> | null
  }


  /**
   * Model MenuItem
   */

  export type AggregateMenuItem = {
    _count: MenuItemCountAggregateOutputType | null
    _avg: MenuItemAvgAggregateOutputType | null
    _sum: MenuItemSumAggregateOutputType | null
    _min: MenuItemMinAggregateOutputType | null
    _max: MenuItemMaxAggregateOutputType | null
  }

  export type MenuItemAvgAggregateOutputType = {
    order: number | null
  }

  export type MenuItemSumAggregateOutputType = {
    order: number | null
  }

  export type MenuItemMinAggregateOutputType = {
    id: string | null
    menuId: string | null
    parentId: string | null
    label: string | null
    icon: string | null
    variant: $Enums.ItemVariant | null
    order: number | null
    pageId: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuItemMaxAggregateOutputType = {
    id: string | null
    menuId: string | null
    parentId: string | null
    label: string | null
    icon: string | null
    variant: $Enums.ItemVariant | null
    order: number | null
    pageId: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MenuItemCountAggregateOutputType = {
    id: number
    menuId: number
    parentId: number
    label: number
    labelI18n: number
    icon: number
    variant: number
    order: number
    pageId: number
    url: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MenuItemAvgAggregateInputType = {
    order?: true
  }

  export type MenuItemSumAggregateInputType = {
    order?: true
  }

  export type MenuItemMinAggregateInputType = {
    id?: true
    menuId?: true
    parentId?: true
    label?: true
    icon?: true
    variant?: true
    order?: true
    pageId?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuItemMaxAggregateInputType = {
    id?: true
    menuId?: true
    parentId?: true
    label?: true
    icon?: true
    variant?: true
    order?: true
    pageId?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MenuItemCountAggregateInputType = {
    id?: true
    menuId?: true
    parentId?: true
    label?: true
    labelI18n?: true
    icon?: true
    variant?: true
    order?: true
    pageId?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MenuItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuItem to aggregate.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MenuItems
    **/
    _count?: true | MenuItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenuItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenuItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenuItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenuItemMaxAggregateInputType
  }

  export type GetMenuItemAggregateType<T extends MenuItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMenuItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenuItem[P]>
      : GetScalarType<T[P], AggregateMenuItem[P]>
  }




  export type MenuItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MenuItemWhereInput
    orderBy?: MenuItemOrderByWithAggregationInput | MenuItemOrderByWithAggregationInput[]
    by: MenuItemScalarFieldEnum[] | MenuItemScalarFieldEnum
    having?: MenuItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenuItemCountAggregateInputType | true
    _avg?: MenuItemAvgAggregateInputType
    _sum?: MenuItemSumAggregateInputType
    _min?: MenuItemMinAggregateInputType
    _max?: MenuItemMaxAggregateInputType
  }

  export type MenuItemGroupByOutputType = {
    id: string
    menuId: string
    parentId: string | null
    label: string
    labelI18n: JsonValue
    icon: string | null
    variant: $Enums.ItemVariant
    order: number
    pageId: string | null
    url: string | null
    createdAt: Date
    updatedAt: Date
    _count: MenuItemCountAggregateOutputType | null
    _avg: MenuItemAvgAggregateOutputType | null
    _sum: MenuItemSumAggregateOutputType | null
    _min: MenuItemMinAggregateOutputType | null
    _max: MenuItemMaxAggregateOutputType | null
  }

  type GetMenuItemGroupByPayload<T extends MenuItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenuItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenuItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenuItemGroupByOutputType[P]>
            : GetScalarType<T[P], MenuItemGroupByOutputType[P]>
        }
      >
    >


  export type MenuItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuId?: boolean
    parentId?: boolean
    label?: boolean
    labelI18n?: boolean
    icon?: boolean
    variant?: boolean
    order?: boolean
    pageId?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    parent?: boolean | MenuItem$parentArgs<ExtArgs>
    children?: boolean | MenuItem$childrenArgs<ExtArgs>
    page?: boolean | MenuItem$pageArgs<ExtArgs>
    _count?: boolean | MenuItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menuItem"]>

  export type MenuItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuId?: boolean
    parentId?: boolean
    label?: boolean
    labelI18n?: boolean
    icon?: boolean
    variant?: boolean
    order?: boolean
    pageId?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    parent?: boolean | MenuItem$parentArgs<ExtArgs>
    page?: boolean | MenuItem$pageArgs<ExtArgs>
  }, ExtArgs["result"]["menuItem"]>

  export type MenuItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    menuId?: boolean
    parentId?: boolean
    label?: boolean
    labelI18n?: boolean
    icon?: boolean
    variant?: boolean
    order?: boolean
    pageId?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    parent?: boolean | MenuItem$parentArgs<ExtArgs>
    page?: boolean | MenuItem$pageArgs<ExtArgs>
  }, ExtArgs["result"]["menuItem"]>

  export type MenuItemSelectScalar = {
    id?: boolean
    menuId?: boolean
    parentId?: boolean
    label?: boolean
    labelI18n?: boolean
    icon?: boolean
    variant?: boolean
    order?: boolean
    pageId?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MenuItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "menuId" | "parentId" | "label" | "labelI18n" | "icon" | "variant" | "order" | "pageId" | "url" | "createdAt" | "updatedAt", ExtArgs["result"]["menuItem"]>
  export type MenuItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    parent?: boolean | MenuItem$parentArgs<ExtArgs>
    children?: boolean | MenuItem$childrenArgs<ExtArgs>
    page?: boolean | MenuItem$pageArgs<ExtArgs>
    _count?: boolean | MenuItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MenuItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    parent?: boolean | MenuItem$parentArgs<ExtArgs>
    page?: boolean | MenuItem$pageArgs<ExtArgs>
  }
  export type MenuItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menu?: boolean | MenuDefaultArgs<ExtArgs>
    parent?: boolean | MenuItem$parentArgs<ExtArgs>
    page?: boolean | MenuItem$pageArgs<ExtArgs>
  }

  export type $MenuItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MenuItem"
    objects: {
      menu: Prisma.$MenuPayload<ExtArgs>
      parent: Prisma.$MenuItemPayload<ExtArgs> | null
      children: Prisma.$MenuItemPayload<ExtArgs>[]
      page: Prisma.$PagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      menuId: string
      parentId: string | null
      label: string
      labelI18n: Prisma.JsonValue
      icon: string | null
      variant: $Enums.ItemVariant
      order: number
      pageId: string | null
      url: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["menuItem"]>
    composites: {}
  }

  type MenuItemGetPayload<S extends boolean | null | undefined | MenuItemDefaultArgs> = $Result.GetResult<Prisma.$MenuItemPayload, S>

  type MenuItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MenuItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenuItemCountAggregateInputType | true
    }

  export interface MenuItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MenuItem'], meta: { name: 'MenuItem' } }
    /**
     * Find zero or one MenuItem that matches the filter.
     * @param {MenuItemFindUniqueArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MenuItemFindUniqueArgs>(args: SelectSubset<T, MenuItemFindUniqueArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MenuItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MenuItemFindUniqueOrThrowArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MenuItemFindUniqueOrThrowArgs>(args: SelectSubset<T, MenuItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenuItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemFindFirstArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MenuItemFindFirstArgs>(args?: SelectSubset<T, MenuItemFindFirstArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MenuItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemFindFirstOrThrowArgs} args - Arguments to find a MenuItem
     * @example
     * // Get one MenuItem
     * const menuItem = await prisma.menuItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MenuItemFindFirstOrThrowArgs>(args?: SelectSubset<T, MenuItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MenuItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MenuItems
     * const menuItems = await prisma.menuItem.findMany()
     * 
     * // Get first 10 MenuItems
     * const menuItems = await prisma.menuItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menuItemWithIdOnly = await prisma.menuItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MenuItemFindManyArgs>(args?: SelectSubset<T, MenuItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MenuItem.
     * @param {MenuItemCreateArgs} args - Arguments to create a MenuItem.
     * @example
     * // Create one MenuItem
     * const MenuItem = await prisma.menuItem.create({
     *   data: {
     *     // ... data to create a MenuItem
     *   }
     * })
     * 
     */
    create<T extends MenuItemCreateArgs>(args: SelectSubset<T, MenuItemCreateArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MenuItems.
     * @param {MenuItemCreateManyArgs} args - Arguments to create many MenuItems.
     * @example
     * // Create many MenuItems
     * const menuItem = await prisma.menuItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MenuItemCreateManyArgs>(args?: SelectSubset<T, MenuItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MenuItems and returns the data saved in the database.
     * @param {MenuItemCreateManyAndReturnArgs} args - Arguments to create many MenuItems.
     * @example
     * // Create many MenuItems
     * const menuItem = await prisma.menuItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MenuItems and only return the `id`
     * const menuItemWithIdOnly = await prisma.menuItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MenuItemCreateManyAndReturnArgs>(args?: SelectSubset<T, MenuItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MenuItem.
     * @param {MenuItemDeleteArgs} args - Arguments to delete one MenuItem.
     * @example
     * // Delete one MenuItem
     * const MenuItem = await prisma.menuItem.delete({
     *   where: {
     *     // ... filter to delete one MenuItem
     *   }
     * })
     * 
     */
    delete<T extends MenuItemDeleteArgs>(args: SelectSubset<T, MenuItemDeleteArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MenuItem.
     * @param {MenuItemUpdateArgs} args - Arguments to update one MenuItem.
     * @example
     * // Update one MenuItem
     * const menuItem = await prisma.menuItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MenuItemUpdateArgs>(args: SelectSubset<T, MenuItemUpdateArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MenuItems.
     * @param {MenuItemDeleteManyArgs} args - Arguments to filter MenuItems to delete.
     * @example
     * // Delete a few MenuItems
     * const { count } = await prisma.menuItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MenuItemDeleteManyArgs>(args?: SelectSubset<T, MenuItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MenuItems
     * const menuItem = await prisma.menuItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MenuItemUpdateManyArgs>(args: SelectSubset<T, MenuItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MenuItems and returns the data updated in the database.
     * @param {MenuItemUpdateManyAndReturnArgs} args - Arguments to update many MenuItems.
     * @example
     * // Update many MenuItems
     * const menuItem = await prisma.menuItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MenuItems and only return the `id`
     * const menuItemWithIdOnly = await prisma.menuItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MenuItemUpdateManyAndReturnArgs>(args: SelectSubset<T, MenuItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MenuItem.
     * @param {MenuItemUpsertArgs} args - Arguments to update or create a MenuItem.
     * @example
     * // Update or create a MenuItem
     * const menuItem = await prisma.menuItem.upsert({
     *   create: {
     *     // ... data to create a MenuItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MenuItem we want to update
     *   }
     * })
     */
    upsert<T extends MenuItemUpsertArgs>(args: SelectSubset<T, MenuItemUpsertArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MenuItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemCountArgs} args - Arguments to filter MenuItems to count.
     * @example
     * // Count the number of MenuItems
     * const count = await prisma.menuItem.count({
     *   where: {
     *     // ... the filter for the MenuItems we want to count
     *   }
     * })
    **/
    count<T extends MenuItemCountArgs>(
      args?: Subset<T, MenuItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenuItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MenuItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenuItemAggregateArgs>(args: Subset<T, MenuItemAggregateArgs>): Prisma.PrismaPromise<GetMenuItemAggregateType<T>>

    /**
     * Group by MenuItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenuItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MenuItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MenuItemGroupByArgs['orderBy'] }
        : { orderBy?: MenuItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MenuItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenuItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MenuItem model
   */
  readonly fields: MenuItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MenuItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MenuItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    menu<T extends MenuDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MenuDefaultArgs<ExtArgs>>): Prisma__MenuClient<$Result.GetResult<Prisma.$MenuPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends MenuItem$parentArgs<ExtArgs> = {}>(args?: Subset<T, MenuItem$parentArgs<ExtArgs>>): Prisma__MenuItemClient<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends MenuItem$childrenArgs<ExtArgs> = {}>(args?: Subset<T, MenuItem$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MenuItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    page<T extends MenuItem$pageArgs<ExtArgs> = {}>(args?: Subset<T, MenuItem$pageArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MenuItem model
   */
  interface MenuItemFieldRefs {
    readonly id: FieldRef<"MenuItem", 'String'>
    readonly menuId: FieldRef<"MenuItem", 'String'>
    readonly parentId: FieldRef<"MenuItem", 'String'>
    readonly label: FieldRef<"MenuItem", 'String'>
    readonly labelI18n: FieldRef<"MenuItem", 'Json'>
    readonly icon: FieldRef<"MenuItem", 'String'>
    readonly variant: FieldRef<"MenuItem", 'ItemVariant'>
    readonly order: FieldRef<"MenuItem", 'Int'>
    readonly pageId: FieldRef<"MenuItem", 'String'>
    readonly url: FieldRef<"MenuItem", 'String'>
    readonly createdAt: FieldRef<"MenuItem", 'DateTime'>
    readonly updatedAt: FieldRef<"MenuItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MenuItem findUnique
   */
  export type MenuItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem findUniqueOrThrow
   */
  export type MenuItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem findFirst
   */
  export type MenuItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuItems.
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuItems.
     */
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * MenuItem findFirstOrThrow
   */
  export type MenuItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItem to fetch.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MenuItems.
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MenuItems.
     */
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * MenuItem findMany
   */
  export type MenuItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter, which MenuItems to fetch.
     */
    where?: MenuItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MenuItems to fetch.
     */
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MenuItems.
     */
    cursor?: MenuItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MenuItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MenuItems.
     */
    skip?: number
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * MenuItem create
   */
  export type MenuItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * The data needed to create a MenuItem.
     */
    data: XOR<MenuItemCreateInput, MenuItemUncheckedCreateInput>
  }

  /**
   * MenuItem createMany
   */
  export type MenuItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MenuItems.
     */
    data: MenuItemCreateManyInput | MenuItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MenuItem createManyAndReturn
   */
  export type MenuItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * The data used to create many MenuItems.
     */
    data: MenuItemCreateManyInput | MenuItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenuItem update
   */
  export type MenuItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * The data needed to update a MenuItem.
     */
    data: XOR<MenuItemUpdateInput, MenuItemUncheckedUpdateInput>
    /**
     * Choose, which MenuItem to update.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem updateMany
   */
  export type MenuItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MenuItems.
     */
    data: XOR<MenuItemUpdateManyMutationInput, MenuItemUncheckedUpdateManyInput>
    /**
     * Filter which MenuItems to update
     */
    where?: MenuItemWhereInput
    /**
     * Limit how many MenuItems to update.
     */
    limit?: number
  }

  /**
   * MenuItem updateManyAndReturn
   */
  export type MenuItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * The data used to update MenuItems.
     */
    data: XOR<MenuItemUpdateManyMutationInput, MenuItemUncheckedUpdateManyInput>
    /**
     * Filter which MenuItems to update
     */
    where?: MenuItemWhereInput
    /**
     * Limit how many MenuItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MenuItem upsert
   */
  export type MenuItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * The filter to search for the MenuItem to update in case it exists.
     */
    where: MenuItemWhereUniqueInput
    /**
     * In case the MenuItem found by the `where` argument doesn't exist, create a new MenuItem with this data.
     */
    create: XOR<MenuItemCreateInput, MenuItemUncheckedCreateInput>
    /**
     * In case the MenuItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MenuItemUpdateInput, MenuItemUncheckedUpdateInput>
  }

  /**
   * MenuItem delete
   */
  export type MenuItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    /**
     * Filter which MenuItem to delete.
     */
    where: MenuItemWhereUniqueInput
  }

  /**
   * MenuItem deleteMany
   */
  export type MenuItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MenuItems to delete
     */
    where?: MenuItemWhereInput
    /**
     * Limit how many MenuItems to delete.
     */
    limit?: number
  }

  /**
   * MenuItem.parent
   */
  export type MenuItem$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    where?: MenuItemWhereInput
  }

  /**
   * MenuItem.children
   */
  export type MenuItem$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
    where?: MenuItemWhereInput
    orderBy?: MenuItemOrderByWithRelationInput | MenuItemOrderByWithRelationInput[]
    cursor?: MenuItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenuItemScalarFieldEnum | MenuItemScalarFieldEnum[]
  }

  /**
   * MenuItem.page
   */
  export type MenuItem$pageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    where?: PageWhereInput
  }

  /**
   * MenuItem without action
   */
  export type MenuItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenuItem
     */
    select?: MenuItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MenuItem
     */
    omit?: MenuItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MenuItemInclude<ExtArgs> | null
  }


  /**
   * Model FooterColumn
   */

  export type AggregateFooterColumn = {
    _count: FooterColumnCountAggregateOutputType | null
    _avg: FooterColumnAvgAggregateOutputType | null
    _sum: FooterColumnSumAggregateOutputType | null
    _min: FooterColumnMinAggregateOutputType | null
    _max: FooterColumnMaxAggregateOutputType | null
  }

  export type FooterColumnAvgAggregateOutputType = {
    order: number | null
  }

  export type FooterColumnSumAggregateOutputType = {
    order: number | null
  }

  export type FooterColumnMinAggregateOutputType = {
    id: string | null
    type: $Enums.MenuType | null
    order: number | null
    title: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FooterColumnMaxAggregateOutputType = {
    id: string | null
    type: $Enums.MenuType | null
    order: number | null
    title: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FooterColumnCountAggregateOutputType = {
    id: number
    type: number
    order: number
    title: number
    titleI18n: number
    content: number
    contentI18n: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FooterColumnAvgAggregateInputType = {
    order?: true
  }

  export type FooterColumnSumAggregateInputType = {
    order?: true
  }

  export type FooterColumnMinAggregateInputType = {
    id?: true
    type?: true
    order?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FooterColumnMaxAggregateInputType = {
    id?: true
    type?: true
    order?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FooterColumnCountAggregateInputType = {
    id?: true
    type?: true
    order?: true
    title?: true
    titleI18n?: true
    content?: true
    contentI18n?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FooterColumnAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FooterColumn to aggregate.
     */
    where?: FooterColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FooterColumns to fetch.
     */
    orderBy?: FooterColumnOrderByWithRelationInput | FooterColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FooterColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FooterColumns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FooterColumns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FooterColumns
    **/
    _count?: true | FooterColumnCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FooterColumnAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FooterColumnSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FooterColumnMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FooterColumnMaxAggregateInputType
  }

  export type GetFooterColumnAggregateType<T extends FooterColumnAggregateArgs> = {
        [P in keyof T & keyof AggregateFooterColumn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFooterColumn[P]>
      : GetScalarType<T[P], AggregateFooterColumn[P]>
  }




  export type FooterColumnGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FooterColumnWhereInput
    orderBy?: FooterColumnOrderByWithAggregationInput | FooterColumnOrderByWithAggregationInput[]
    by: FooterColumnScalarFieldEnum[] | FooterColumnScalarFieldEnum
    having?: FooterColumnScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FooterColumnCountAggregateInputType | true
    _avg?: FooterColumnAvgAggregateInputType
    _sum?: FooterColumnSumAggregateInputType
    _min?: FooterColumnMinAggregateInputType
    _max?: FooterColumnMaxAggregateInputType
  }

  export type FooterColumnGroupByOutputType = {
    id: string
    type: $Enums.MenuType
    order: number
    title: string
    titleI18n: JsonValue
    content: string | null
    contentI18n: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: FooterColumnCountAggregateOutputType | null
    _avg: FooterColumnAvgAggregateOutputType | null
    _sum: FooterColumnSumAggregateOutputType | null
    _min: FooterColumnMinAggregateOutputType | null
    _max: FooterColumnMaxAggregateOutputType | null
  }

  type GetFooterColumnGroupByPayload<T extends FooterColumnGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FooterColumnGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FooterColumnGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FooterColumnGroupByOutputType[P]>
            : GetScalarType<T[P], FooterColumnGroupByOutputType[P]>
        }
      >
    >


  export type FooterColumnSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    order?: boolean
    title?: boolean
    titleI18n?: boolean
    content?: boolean
    contentI18n?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | FooterColumn$itemsArgs<ExtArgs>
    _count?: boolean | FooterColumnCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["footerColumn"]>

  export type FooterColumnSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    order?: boolean
    title?: boolean
    titleI18n?: boolean
    content?: boolean
    contentI18n?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["footerColumn"]>

  export type FooterColumnSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    order?: boolean
    title?: boolean
    titleI18n?: boolean
    content?: boolean
    contentI18n?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["footerColumn"]>

  export type FooterColumnSelectScalar = {
    id?: boolean
    type?: boolean
    order?: boolean
    title?: boolean
    titleI18n?: boolean
    content?: boolean
    contentI18n?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FooterColumnOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "order" | "title" | "titleI18n" | "content" | "contentI18n" | "createdAt" | "updatedAt", ExtArgs["result"]["footerColumn"]>
  export type FooterColumnInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | FooterColumn$itemsArgs<ExtArgs>
    _count?: boolean | FooterColumnCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FooterColumnIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FooterColumnIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FooterColumnPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FooterColumn"
    objects: {
      items: Prisma.$FooterColumnItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.MenuType
      order: number
      title: string
      titleI18n: Prisma.JsonValue
      content: string | null
      contentI18n: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["footerColumn"]>
    composites: {}
  }

  type FooterColumnGetPayload<S extends boolean | null | undefined | FooterColumnDefaultArgs> = $Result.GetResult<Prisma.$FooterColumnPayload, S>

  type FooterColumnCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FooterColumnFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FooterColumnCountAggregateInputType | true
    }

  export interface FooterColumnDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FooterColumn'], meta: { name: 'FooterColumn' } }
    /**
     * Find zero or one FooterColumn that matches the filter.
     * @param {FooterColumnFindUniqueArgs} args - Arguments to find a FooterColumn
     * @example
     * // Get one FooterColumn
     * const footerColumn = await prisma.footerColumn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FooterColumnFindUniqueArgs>(args: SelectSubset<T, FooterColumnFindUniqueArgs<ExtArgs>>): Prisma__FooterColumnClient<$Result.GetResult<Prisma.$FooterColumnPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FooterColumn that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FooterColumnFindUniqueOrThrowArgs} args - Arguments to find a FooterColumn
     * @example
     * // Get one FooterColumn
     * const footerColumn = await prisma.footerColumn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FooterColumnFindUniqueOrThrowArgs>(args: SelectSubset<T, FooterColumnFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FooterColumnClient<$Result.GetResult<Prisma.$FooterColumnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FooterColumn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterColumnFindFirstArgs} args - Arguments to find a FooterColumn
     * @example
     * // Get one FooterColumn
     * const footerColumn = await prisma.footerColumn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FooterColumnFindFirstArgs>(args?: SelectSubset<T, FooterColumnFindFirstArgs<ExtArgs>>): Prisma__FooterColumnClient<$Result.GetResult<Prisma.$FooterColumnPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FooterColumn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterColumnFindFirstOrThrowArgs} args - Arguments to find a FooterColumn
     * @example
     * // Get one FooterColumn
     * const footerColumn = await prisma.footerColumn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FooterColumnFindFirstOrThrowArgs>(args?: SelectSubset<T, FooterColumnFindFirstOrThrowArgs<ExtArgs>>): Prisma__FooterColumnClient<$Result.GetResult<Prisma.$FooterColumnPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FooterColumns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterColumnFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FooterColumns
     * const footerColumns = await prisma.footerColumn.findMany()
     * 
     * // Get first 10 FooterColumns
     * const footerColumns = await prisma.footerColumn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const footerColumnWithIdOnly = await prisma.footerColumn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FooterColumnFindManyArgs>(args?: SelectSubset<T, FooterColumnFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FooterColumnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FooterColumn.
     * @param {FooterColumnCreateArgs} args - Arguments to create a FooterColumn.
     * @example
     * // Create one FooterColumn
     * const FooterColumn = await prisma.footerColumn.create({
     *   data: {
     *     // ... data to create a FooterColumn
     *   }
     * })
     * 
     */
    create<T extends FooterColumnCreateArgs>(args: SelectSubset<T, FooterColumnCreateArgs<ExtArgs>>): Prisma__FooterColumnClient<$Result.GetResult<Prisma.$FooterColumnPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FooterColumns.
     * @param {FooterColumnCreateManyArgs} args - Arguments to create many FooterColumns.
     * @example
     * // Create many FooterColumns
     * const footerColumn = await prisma.footerColumn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FooterColumnCreateManyArgs>(args?: SelectSubset<T, FooterColumnCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FooterColumns and returns the data saved in the database.
     * @param {FooterColumnCreateManyAndReturnArgs} args - Arguments to create many FooterColumns.
     * @example
     * // Create many FooterColumns
     * const footerColumn = await prisma.footerColumn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FooterColumns and only return the `id`
     * const footerColumnWithIdOnly = await prisma.footerColumn.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FooterColumnCreateManyAndReturnArgs>(args?: SelectSubset<T, FooterColumnCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FooterColumnPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FooterColumn.
     * @param {FooterColumnDeleteArgs} args - Arguments to delete one FooterColumn.
     * @example
     * // Delete one FooterColumn
     * const FooterColumn = await prisma.footerColumn.delete({
     *   where: {
     *     // ... filter to delete one FooterColumn
     *   }
     * })
     * 
     */
    delete<T extends FooterColumnDeleteArgs>(args: SelectSubset<T, FooterColumnDeleteArgs<ExtArgs>>): Prisma__FooterColumnClient<$Result.GetResult<Prisma.$FooterColumnPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FooterColumn.
     * @param {FooterColumnUpdateArgs} args - Arguments to update one FooterColumn.
     * @example
     * // Update one FooterColumn
     * const footerColumn = await prisma.footerColumn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FooterColumnUpdateArgs>(args: SelectSubset<T, FooterColumnUpdateArgs<ExtArgs>>): Prisma__FooterColumnClient<$Result.GetResult<Prisma.$FooterColumnPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FooterColumns.
     * @param {FooterColumnDeleteManyArgs} args - Arguments to filter FooterColumns to delete.
     * @example
     * // Delete a few FooterColumns
     * const { count } = await prisma.footerColumn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FooterColumnDeleteManyArgs>(args?: SelectSubset<T, FooterColumnDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FooterColumns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterColumnUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FooterColumns
     * const footerColumn = await prisma.footerColumn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FooterColumnUpdateManyArgs>(args: SelectSubset<T, FooterColumnUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FooterColumns and returns the data updated in the database.
     * @param {FooterColumnUpdateManyAndReturnArgs} args - Arguments to update many FooterColumns.
     * @example
     * // Update many FooterColumns
     * const footerColumn = await prisma.footerColumn.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FooterColumns and only return the `id`
     * const footerColumnWithIdOnly = await prisma.footerColumn.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FooterColumnUpdateManyAndReturnArgs>(args: SelectSubset<T, FooterColumnUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FooterColumnPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FooterColumn.
     * @param {FooterColumnUpsertArgs} args - Arguments to update or create a FooterColumn.
     * @example
     * // Update or create a FooterColumn
     * const footerColumn = await prisma.footerColumn.upsert({
     *   create: {
     *     // ... data to create a FooterColumn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FooterColumn we want to update
     *   }
     * })
     */
    upsert<T extends FooterColumnUpsertArgs>(args: SelectSubset<T, FooterColumnUpsertArgs<ExtArgs>>): Prisma__FooterColumnClient<$Result.GetResult<Prisma.$FooterColumnPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FooterColumns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterColumnCountArgs} args - Arguments to filter FooterColumns to count.
     * @example
     * // Count the number of FooterColumns
     * const count = await prisma.footerColumn.count({
     *   where: {
     *     // ... the filter for the FooterColumns we want to count
     *   }
     * })
    **/
    count<T extends FooterColumnCountArgs>(
      args?: Subset<T, FooterColumnCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FooterColumnCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FooterColumn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterColumnAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FooterColumnAggregateArgs>(args: Subset<T, FooterColumnAggregateArgs>): Prisma.PrismaPromise<GetFooterColumnAggregateType<T>>

    /**
     * Group by FooterColumn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterColumnGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FooterColumnGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FooterColumnGroupByArgs['orderBy'] }
        : { orderBy?: FooterColumnGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FooterColumnGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFooterColumnGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FooterColumn model
   */
  readonly fields: FooterColumnFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FooterColumn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FooterColumnClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends FooterColumn$itemsArgs<ExtArgs> = {}>(args?: Subset<T, FooterColumn$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FooterColumnItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FooterColumn model
   */
  interface FooterColumnFieldRefs {
    readonly id: FieldRef<"FooterColumn", 'String'>
    readonly type: FieldRef<"FooterColumn", 'MenuType'>
    readonly order: FieldRef<"FooterColumn", 'Int'>
    readonly title: FieldRef<"FooterColumn", 'String'>
    readonly titleI18n: FieldRef<"FooterColumn", 'Json'>
    readonly content: FieldRef<"FooterColumn", 'String'>
    readonly contentI18n: FieldRef<"FooterColumn", 'Json'>
    readonly createdAt: FieldRef<"FooterColumn", 'DateTime'>
    readonly updatedAt: FieldRef<"FooterColumn", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FooterColumn findUnique
   */
  export type FooterColumnFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumn
     */
    select?: FooterColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumn
     */
    omit?: FooterColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnInclude<ExtArgs> | null
    /**
     * Filter, which FooterColumn to fetch.
     */
    where: FooterColumnWhereUniqueInput
  }

  /**
   * FooterColumn findUniqueOrThrow
   */
  export type FooterColumnFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumn
     */
    select?: FooterColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumn
     */
    omit?: FooterColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnInclude<ExtArgs> | null
    /**
     * Filter, which FooterColumn to fetch.
     */
    where: FooterColumnWhereUniqueInput
  }

  /**
   * FooterColumn findFirst
   */
  export type FooterColumnFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumn
     */
    select?: FooterColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumn
     */
    omit?: FooterColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnInclude<ExtArgs> | null
    /**
     * Filter, which FooterColumn to fetch.
     */
    where?: FooterColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FooterColumns to fetch.
     */
    orderBy?: FooterColumnOrderByWithRelationInput | FooterColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FooterColumns.
     */
    cursor?: FooterColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FooterColumns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FooterColumns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FooterColumns.
     */
    distinct?: FooterColumnScalarFieldEnum | FooterColumnScalarFieldEnum[]
  }

  /**
   * FooterColumn findFirstOrThrow
   */
  export type FooterColumnFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumn
     */
    select?: FooterColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumn
     */
    omit?: FooterColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnInclude<ExtArgs> | null
    /**
     * Filter, which FooterColumn to fetch.
     */
    where?: FooterColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FooterColumns to fetch.
     */
    orderBy?: FooterColumnOrderByWithRelationInput | FooterColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FooterColumns.
     */
    cursor?: FooterColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FooterColumns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FooterColumns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FooterColumns.
     */
    distinct?: FooterColumnScalarFieldEnum | FooterColumnScalarFieldEnum[]
  }

  /**
   * FooterColumn findMany
   */
  export type FooterColumnFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumn
     */
    select?: FooterColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumn
     */
    omit?: FooterColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnInclude<ExtArgs> | null
    /**
     * Filter, which FooterColumns to fetch.
     */
    where?: FooterColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FooterColumns to fetch.
     */
    orderBy?: FooterColumnOrderByWithRelationInput | FooterColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FooterColumns.
     */
    cursor?: FooterColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FooterColumns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FooterColumns.
     */
    skip?: number
    distinct?: FooterColumnScalarFieldEnum | FooterColumnScalarFieldEnum[]
  }

  /**
   * FooterColumn create
   */
  export type FooterColumnCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumn
     */
    select?: FooterColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumn
     */
    omit?: FooterColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnInclude<ExtArgs> | null
    /**
     * The data needed to create a FooterColumn.
     */
    data: XOR<FooterColumnCreateInput, FooterColumnUncheckedCreateInput>
  }

  /**
   * FooterColumn createMany
   */
  export type FooterColumnCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FooterColumns.
     */
    data: FooterColumnCreateManyInput | FooterColumnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FooterColumn createManyAndReturn
   */
  export type FooterColumnCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumn
     */
    select?: FooterColumnSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumn
     */
    omit?: FooterColumnOmit<ExtArgs> | null
    /**
     * The data used to create many FooterColumns.
     */
    data: FooterColumnCreateManyInput | FooterColumnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FooterColumn update
   */
  export type FooterColumnUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumn
     */
    select?: FooterColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumn
     */
    omit?: FooterColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnInclude<ExtArgs> | null
    /**
     * The data needed to update a FooterColumn.
     */
    data: XOR<FooterColumnUpdateInput, FooterColumnUncheckedUpdateInput>
    /**
     * Choose, which FooterColumn to update.
     */
    where: FooterColumnWhereUniqueInput
  }

  /**
   * FooterColumn updateMany
   */
  export type FooterColumnUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FooterColumns.
     */
    data: XOR<FooterColumnUpdateManyMutationInput, FooterColumnUncheckedUpdateManyInput>
    /**
     * Filter which FooterColumns to update
     */
    where?: FooterColumnWhereInput
    /**
     * Limit how many FooterColumns to update.
     */
    limit?: number
  }

  /**
   * FooterColumn updateManyAndReturn
   */
  export type FooterColumnUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumn
     */
    select?: FooterColumnSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumn
     */
    omit?: FooterColumnOmit<ExtArgs> | null
    /**
     * The data used to update FooterColumns.
     */
    data: XOR<FooterColumnUpdateManyMutationInput, FooterColumnUncheckedUpdateManyInput>
    /**
     * Filter which FooterColumns to update
     */
    where?: FooterColumnWhereInput
    /**
     * Limit how many FooterColumns to update.
     */
    limit?: number
  }

  /**
   * FooterColumn upsert
   */
  export type FooterColumnUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumn
     */
    select?: FooterColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumn
     */
    omit?: FooterColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnInclude<ExtArgs> | null
    /**
     * The filter to search for the FooterColumn to update in case it exists.
     */
    where: FooterColumnWhereUniqueInput
    /**
     * In case the FooterColumn found by the `where` argument doesn't exist, create a new FooterColumn with this data.
     */
    create: XOR<FooterColumnCreateInput, FooterColumnUncheckedCreateInput>
    /**
     * In case the FooterColumn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FooterColumnUpdateInput, FooterColumnUncheckedUpdateInput>
  }

  /**
   * FooterColumn delete
   */
  export type FooterColumnDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumn
     */
    select?: FooterColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumn
     */
    omit?: FooterColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnInclude<ExtArgs> | null
    /**
     * Filter which FooterColumn to delete.
     */
    where: FooterColumnWhereUniqueInput
  }

  /**
   * FooterColumn deleteMany
   */
  export type FooterColumnDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FooterColumns to delete
     */
    where?: FooterColumnWhereInput
    /**
     * Limit how many FooterColumns to delete.
     */
    limit?: number
  }

  /**
   * FooterColumn.items
   */
  export type FooterColumn$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumnItem
     */
    select?: FooterColumnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumnItem
     */
    omit?: FooterColumnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnItemInclude<ExtArgs> | null
    where?: FooterColumnItemWhereInput
    orderBy?: FooterColumnItemOrderByWithRelationInput | FooterColumnItemOrderByWithRelationInput[]
    cursor?: FooterColumnItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FooterColumnItemScalarFieldEnum | FooterColumnItemScalarFieldEnum[]
  }

  /**
   * FooterColumn without action
   */
  export type FooterColumnDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumn
     */
    select?: FooterColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumn
     */
    omit?: FooterColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnInclude<ExtArgs> | null
  }


  /**
   * Model FooterColumnItem
   */

  export type AggregateFooterColumnItem = {
    _count: FooterColumnItemCountAggregateOutputType | null
    _avg: FooterColumnItemAvgAggregateOutputType | null
    _sum: FooterColumnItemSumAggregateOutputType | null
    _min: FooterColumnItemMinAggregateOutputType | null
    _max: FooterColumnItemMaxAggregateOutputType | null
  }

  export type FooterColumnItemAvgAggregateOutputType = {
    order: number | null
  }

  export type FooterColumnItemSumAggregateOutputType = {
    order: number | null
  }

  export type FooterColumnItemMinAggregateOutputType = {
    id: string | null
    footerColumnId: string | null
    label: string | null
    icon: string | null
    order: number | null
    pageId: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FooterColumnItemMaxAggregateOutputType = {
    id: string | null
    footerColumnId: string | null
    label: string | null
    icon: string | null
    order: number | null
    pageId: string | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FooterColumnItemCountAggregateOutputType = {
    id: number
    footerColumnId: number
    label: number
    labelI18n: number
    icon: number
    order: number
    pageId: number
    url: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FooterColumnItemAvgAggregateInputType = {
    order?: true
  }

  export type FooterColumnItemSumAggregateInputType = {
    order?: true
  }

  export type FooterColumnItemMinAggregateInputType = {
    id?: true
    footerColumnId?: true
    label?: true
    icon?: true
    order?: true
    pageId?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FooterColumnItemMaxAggregateInputType = {
    id?: true
    footerColumnId?: true
    label?: true
    icon?: true
    order?: true
    pageId?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FooterColumnItemCountAggregateInputType = {
    id?: true
    footerColumnId?: true
    label?: true
    labelI18n?: true
    icon?: true
    order?: true
    pageId?: true
    url?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FooterColumnItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FooterColumnItem to aggregate.
     */
    where?: FooterColumnItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FooterColumnItems to fetch.
     */
    orderBy?: FooterColumnItemOrderByWithRelationInput | FooterColumnItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FooterColumnItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FooterColumnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FooterColumnItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FooterColumnItems
    **/
    _count?: true | FooterColumnItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FooterColumnItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FooterColumnItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FooterColumnItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FooterColumnItemMaxAggregateInputType
  }

  export type GetFooterColumnItemAggregateType<T extends FooterColumnItemAggregateArgs> = {
        [P in keyof T & keyof AggregateFooterColumnItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFooterColumnItem[P]>
      : GetScalarType<T[P], AggregateFooterColumnItem[P]>
  }




  export type FooterColumnItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FooterColumnItemWhereInput
    orderBy?: FooterColumnItemOrderByWithAggregationInput | FooterColumnItemOrderByWithAggregationInput[]
    by: FooterColumnItemScalarFieldEnum[] | FooterColumnItemScalarFieldEnum
    having?: FooterColumnItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FooterColumnItemCountAggregateInputType | true
    _avg?: FooterColumnItemAvgAggregateInputType
    _sum?: FooterColumnItemSumAggregateInputType
    _min?: FooterColumnItemMinAggregateInputType
    _max?: FooterColumnItemMaxAggregateInputType
  }

  export type FooterColumnItemGroupByOutputType = {
    id: string
    footerColumnId: string
    label: string
    labelI18n: JsonValue
    icon: string | null
    order: number
    pageId: string | null
    url: string | null
    createdAt: Date
    updatedAt: Date
    _count: FooterColumnItemCountAggregateOutputType | null
    _avg: FooterColumnItemAvgAggregateOutputType | null
    _sum: FooterColumnItemSumAggregateOutputType | null
    _min: FooterColumnItemMinAggregateOutputType | null
    _max: FooterColumnItemMaxAggregateOutputType | null
  }

  type GetFooterColumnItemGroupByPayload<T extends FooterColumnItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FooterColumnItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FooterColumnItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FooterColumnItemGroupByOutputType[P]>
            : GetScalarType<T[P], FooterColumnItemGroupByOutputType[P]>
        }
      >
    >


  export type FooterColumnItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    footerColumnId?: boolean
    label?: boolean
    labelI18n?: boolean
    icon?: boolean
    order?: boolean
    pageId?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    footerColumn?: boolean | FooterColumnDefaultArgs<ExtArgs>
    page?: boolean | FooterColumnItem$pageArgs<ExtArgs>
  }, ExtArgs["result"]["footerColumnItem"]>

  export type FooterColumnItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    footerColumnId?: boolean
    label?: boolean
    labelI18n?: boolean
    icon?: boolean
    order?: boolean
    pageId?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    footerColumn?: boolean | FooterColumnDefaultArgs<ExtArgs>
    page?: boolean | FooterColumnItem$pageArgs<ExtArgs>
  }, ExtArgs["result"]["footerColumnItem"]>

  export type FooterColumnItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    footerColumnId?: boolean
    label?: boolean
    labelI18n?: boolean
    icon?: boolean
    order?: boolean
    pageId?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    footerColumn?: boolean | FooterColumnDefaultArgs<ExtArgs>
    page?: boolean | FooterColumnItem$pageArgs<ExtArgs>
  }, ExtArgs["result"]["footerColumnItem"]>

  export type FooterColumnItemSelectScalar = {
    id?: boolean
    footerColumnId?: boolean
    label?: boolean
    labelI18n?: boolean
    icon?: boolean
    order?: boolean
    pageId?: boolean
    url?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FooterColumnItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "footerColumnId" | "label" | "labelI18n" | "icon" | "order" | "pageId" | "url" | "createdAt" | "updatedAt", ExtArgs["result"]["footerColumnItem"]>
  export type FooterColumnItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    footerColumn?: boolean | FooterColumnDefaultArgs<ExtArgs>
    page?: boolean | FooterColumnItem$pageArgs<ExtArgs>
  }
  export type FooterColumnItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    footerColumn?: boolean | FooterColumnDefaultArgs<ExtArgs>
    page?: boolean | FooterColumnItem$pageArgs<ExtArgs>
  }
  export type FooterColumnItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    footerColumn?: boolean | FooterColumnDefaultArgs<ExtArgs>
    page?: boolean | FooterColumnItem$pageArgs<ExtArgs>
  }

  export type $FooterColumnItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FooterColumnItem"
    objects: {
      footerColumn: Prisma.$FooterColumnPayload<ExtArgs>
      page: Prisma.$PagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      footerColumnId: string
      label: string
      labelI18n: Prisma.JsonValue
      icon: string | null
      order: number
      pageId: string | null
      url: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["footerColumnItem"]>
    composites: {}
  }

  type FooterColumnItemGetPayload<S extends boolean | null | undefined | FooterColumnItemDefaultArgs> = $Result.GetResult<Prisma.$FooterColumnItemPayload, S>

  type FooterColumnItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FooterColumnItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FooterColumnItemCountAggregateInputType | true
    }

  export interface FooterColumnItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FooterColumnItem'], meta: { name: 'FooterColumnItem' } }
    /**
     * Find zero or one FooterColumnItem that matches the filter.
     * @param {FooterColumnItemFindUniqueArgs} args - Arguments to find a FooterColumnItem
     * @example
     * // Get one FooterColumnItem
     * const footerColumnItem = await prisma.footerColumnItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FooterColumnItemFindUniqueArgs>(args: SelectSubset<T, FooterColumnItemFindUniqueArgs<ExtArgs>>): Prisma__FooterColumnItemClient<$Result.GetResult<Prisma.$FooterColumnItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FooterColumnItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FooterColumnItemFindUniqueOrThrowArgs} args - Arguments to find a FooterColumnItem
     * @example
     * // Get one FooterColumnItem
     * const footerColumnItem = await prisma.footerColumnItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FooterColumnItemFindUniqueOrThrowArgs>(args: SelectSubset<T, FooterColumnItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FooterColumnItemClient<$Result.GetResult<Prisma.$FooterColumnItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FooterColumnItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterColumnItemFindFirstArgs} args - Arguments to find a FooterColumnItem
     * @example
     * // Get one FooterColumnItem
     * const footerColumnItem = await prisma.footerColumnItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FooterColumnItemFindFirstArgs>(args?: SelectSubset<T, FooterColumnItemFindFirstArgs<ExtArgs>>): Prisma__FooterColumnItemClient<$Result.GetResult<Prisma.$FooterColumnItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FooterColumnItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterColumnItemFindFirstOrThrowArgs} args - Arguments to find a FooterColumnItem
     * @example
     * // Get one FooterColumnItem
     * const footerColumnItem = await prisma.footerColumnItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FooterColumnItemFindFirstOrThrowArgs>(args?: SelectSubset<T, FooterColumnItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__FooterColumnItemClient<$Result.GetResult<Prisma.$FooterColumnItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FooterColumnItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterColumnItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FooterColumnItems
     * const footerColumnItems = await prisma.footerColumnItem.findMany()
     * 
     * // Get first 10 FooterColumnItems
     * const footerColumnItems = await prisma.footerColumnItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const footerColumnItemWithIdOnly = await prisma.footerColumnItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FooterColumnItemFindManyArgs>(args?: SelectSubset<T, FooterColumnItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FooterColumnItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FooterColumnItem.
     * @param {FooterColumnItemCreateArgs} args - Arguments to create a FooterColumnItem.
     * @example
     * // Create one FooterColumnItem
     * const FooterColumnItem = await prisma.footerColumnItem.create({
     *   data: {
     *     // ... data to create a FooterColumnItem
     *   }
     * })
     * 
     */
    create<T extends FooterColumnItemCreateArgs>(args: SelectSubset<T, FooterColumnItemCreateArgs<ExtArgs>>): Prisma__FooterColumnItemClient<$Result.GetResult<Prisma.$FooterColumnItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FooterColumnItems.
     * @param {FooterColumnItemCreateManyArgs} args - Arguments to create many FooterColumnItems.
     * @example
     * // Create many FooterColumnItems
     * const footerColumnItem = await prisma.footerColumnItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FooterColumnItemCreateManyArgs>(args?: SelectSubset<T, FooterColumnItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FooterColumnItems and returns the data saved in the database.
     * @param {FooterColumnItemCreateManyAndReturnArgs} args - Arguments to create many FooterColumnItems.
     * @example
     * // Create many FooterColumnItems
     * const footerColumnItem = await prisma.footerColumnItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FooterColumnItems and only return the `id`
     * const footerColumnItemWithIdOnly = await prisma.footerColumnItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FooterColumnItemCreateManyAndReturnArgs>(args?: SelectSubset<T, FooterColumnItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FooterColumnItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FooterColumnItem.
     * @param {FooterColumnItemDeleteArgs} args - Arguments to delete one FooterColumnItem.
     * @example
     * // Delete one FooterColumnItem
     * const FooterColumnItem = await prisma.footerColumnItem.delete({
     *   where: {
     *     // ... filter to delete one FooterColumnItem
     *   }
     * })
     * 
     */
    delete<T extends FooterColumnItemDeleteArgs>(args: SelectSubset<T, FooterColumnItemDeleteArgs<ExtArgs>>): Prisma__FooterColumnItemClient<$Result.GetResult<Prisma.$FooterColumnItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FooterColumnItem.
     * @param {FooterColumnItemUpdateArgs} args - Arguments to update one FooterColumnItem.
     * @example
     * // Update one FooterColumnItem
     * const footerColumnItem = await prisma.footerColumnItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FooterColumnItemUpdateArgs>(args: SelectSubset<T, FooterColumnItemUpdateArgs<ExtArgs>>): Prisma__FooterColumnItemClient<$Result.GetResult<Prisma.$FooterColumnItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FooterColumnItems.
     * @param {FooterColumnItemDeleteManyArgs} args - Arguments to filter FooterColumnItems to delete.
     * @example
     * // Delete a few FooterColumnItems
     * const { count } = await prisma.footerColumnItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FooterColumnItemDeleteManyArgs>(args?: SelectSubset<T, FooterColumnItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FooterColumnItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterColumnItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FooterColumnItems
     * const footerColumnItem = await prisma.footerColumnItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FooterColumnItemUpdateManyArgs>(args: SelectSubset<T, FooterColumnItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FooterColumnItems and returns the data updated in the database.
     * @param {FooterColumnItemUpdateManyAndReturnArgs} args - Arguments to update many FooterColumnItems.
     * @example
     * // Update many FooterColumnItems
     * const footerColumnItem = await prisma.footerColumnItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FooterColumnItems and only return the `id`
     * const footerColumnItemWithIdOnly = await prisma.footerColumnItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FooterColumnItemUpdateManyAndReturnArgs>(args: SelectSubset<T, FooterColumnItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FooterColumnItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FooterColumnItem.
     * @param {FooterColumnItemUpsertArgs} args - Arguments to update or create a FooterColumnItem.
     * @example
     * // Update or create a FooterColumnItem
     * const footerColumnItem = await prisma.footerColumnItem.upsert({
     *   create: {
     *     // ... data to create a FooterColumnItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FooterColumnItem we want to update
     *   }
     * })
     */
    upsert<T extends FooterColumnItemUpsertArgs>(args: SelectSubset<T, FooterColumnItemUpsertArgs<ExtArgs>>): Prisma__FooterColumnItemClient<$Result.GetResult<Prisma.$FooterColumnItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FooterColumnItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterColumnItemCountArgs} args - Arguments to filter FooterColumnItems to count.
     * @example
     * // Count the number of FooterColumnItems
     * const count = await prisma.footerColumnItem.count({
     *   where: {
     *     // ... the filter for the FooterColumnItems we want to count
     *   }
     * })
    **/
    count<T extends FooterColumnItemCountArgs>(
      args?: Subset<T, FooterColumnItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FooterColumnItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FooterColumnItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterColumnItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FooterColumnItemAggregateArgs>(args: Subset<T, FooterColumnItemAggregateArgs>): Prisma.PrismaPromise<GetFooterColumnItemAggregateType<T>>

    /**
     * Group by FooterColumnItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FooterColumnItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FooterColumnItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FooterColumnItemGroupByArgs['orderBy'] }
        : { orderBy?: FooterColumnItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FooterColumnItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFooterColumnItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FooterColumnItem model
   */
  readonly fields: FooterColumnItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FooterColumnItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FooterColumnItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    footerColumn<T extends FooterColumnDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FooterColumnDefaultArgs<ExtArgs>>): Prisma__FooterColumnClient<$Result.GetResult<Prisma.$FooterColumnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    page<T extends FooterColumnItem$pageArgs<ExtArgs> = {}>(args?: Subset<T, FooterColumnItem$pageArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FooterColumnItem model
   */
  interface FooterColumnItemFieldRefs {
    readonly id: FieldRef<"FooterColumnItem", 'String'>
    readonly footerColumnId: FieldRef<"FooterColumnItem", 'String'>
    readonly label: FieldRef<"FooterColumnItem", 'String'>
    readonly labelI18n: FieldRef<"FooterColumnItem", 'Json'>
    readonly icon: FieldRef<"FooterColumnItem", 'String'>
    readonly order: FieldRef<"FooterColumnItem", 'Int'>
    readonly pageId: FieldRef<"FooterColumnItem", 'String'>
    readonly url: FieldRef<"FooterColumnItem", 'String'>
    readonly createdAt: FieldRef<"FooterColumnItem", 'DateTime'>
    readonly updatedAt: FieldRef<"FooterColumnItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FooterColumnItem findUnique
   */
  export type FooterColumnItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumnItem
     */
    select?: FooterColumnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumnItem
     */
    omit?: FooterColumnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnItemInclude<ExtArgs> | null
    /**
     * Filter, which FooterColumnItem to fetch.
     */
    where: FooterColumnItemWhereUniqueInput
  }

  /**
   * FooterColumnItem findUniqueOrThrow
   */
  export type FooterColumnItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumnItem
     */
    select?: FooterColumnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumnItem
     */
    omit?: FooterColumnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnItemInclude<ExtArgs> | null
    /**
     * Filter, which FooterColumnItem to fetch.
     */
    where: FooterColumnItemWhereUniqueInput
  }

  /**
   * FooterColumnItem findFirst
   */
  export type FooterColumnItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumnItem
     */
    select?: FooterColumnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumnItem
     */
    omit?: FooterColumnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnItemInclude<ExtArgs> | null
    /**
     * Filter, which FooterColumnItem to fetch.
     */
    where?: FooterColumnItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FooterColumnItems to fetch.
     */
    orderBy?: FooterColumnItemOrderByWithRelationInput | FooterColumnItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FooterColumnItems.
     */
    cursor?: FooterColumnItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FooterColumnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FooterColumnItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FooterColumnItems.
     */
    distinct?: FooterColumnItemScalarFieldEnum | FooterColumnItemScalarFieldEnum[]
  }

  /**
   * FooterColumnItem findFirstOrThrow
   */
  export type FooterColumnItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumnItem
     */
    select?: FooterColumnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumnItem
     */
    omit?: FooterColumnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnItemInclude<ExtArgs> | null
    /**
     * Filter, which FooterColumnItem to fetch.
     */
    where?: FooterColumnItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FooterColumnItems to fetch.
     */
    orderBy?: FooterColumnItemOrderByWithRelationInput | FooterColumnItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FooterColumnItems.
     */
    cursor?: FooterColumnItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FooterColumnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FooterColumnItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FooterColumnItems.
     */
    distinct?: FooterColumnItemScalarFieldEnum | FooterColumnItemScalarFieldEnum[]
  }

  /**
   * FooterColumnItem findMany
   */
  export type FooterColumnItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumnItem
     */
    select?: FooterColumnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumnItem
     */
    omit?: FooterColumnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnItemInclude<ExtArgs> | null
    /**
     * Filter, which FooterColumnItems to fetch.
     */
    where?: FooterColumnItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FooterColumnItems to fetch.
     */
    orderBy?: FooterColumnItemOrderByWithRelationInput | FooterColumnItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FooterColumnItems.
     */
    cursor?: FooterColumnItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FooterColumnItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FooterColumnItems.
     */
    skip?: number
    distinct?: FooterColumnItemScalarFieldEnum | FooterColumnItemScalarFieldEnum[]
  }

  /**
   * FooterColumnItem create
   */
  export type FooterColumnItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumnItem
     */
    select?: FooterColumnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumnItem
     */
    omit?: FooterColumnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnItemInclude<ExtArgs> | null
    /**
     * The data needed to create a FooterColumnItem.
     */
    data: XOR<FooterColumnItemCreateInput, FooterColumnItemUncheckedCreateInput>
  }

  /**
   * FooterColumnItem createMany
   */
  export type FooterColumnItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FooterColumnItems.
     */
    data: FooterColumnItemCreateManyInput | FooterColumnItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FooterColumnItem createManyAndReturn
   */
  export type FooterColumnItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumnItem
     */
    select?: FooterColumnItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumnItem
     */
    omit?: FooterColumnItemOmit<ExtArgs> | null
    /**
     * The data used to create many FooterColumnItems.
     */
    data: FooterColumnItemCreateManyInput | FooterColumnItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FooterColumnItem update
   */
  export type FooterColumnItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumnItem
     */
    select?: FooterColumnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumnItem
     */
    omit?: FooterColumnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnItemInclude<ExtArgs> | null
    /**
     * The data needed to update a FooterColumnItem.
     */
    data: XOR<FooterColumnItemUpdateInput, FooterColumnItemUncheckedUpdateInput>
    /**
     * Choose, which FooterColumnItem to update.
     */
    where: FooterColumnItemWhereUniqueInput
  }

  /**
   * FooterColumnItem updateMany
   */
  export type FooterColumnItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FooterColumnItems.
     */
    data: XOR<FooterColumnItemUpdateManyMutationInput, FooterColumnItemUncheckedUpdateManyInput>
    /**
     * Filter which FooterColumnItems to update
     */
    where?: FooterColumnItemWhereInput
    /**
     * Limit how many FooterColumnItems to update.
     */
    limit?: number
  }

  /**
   * FooterColumnItem updateManyAndReturn
   */
  export type FooterColumnItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumnItem
     */
    select?: FooterColumnItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumnItem
     */
    omit?: FooterColumnItemOmit<ExtArgs> | null
    /**
     * The data used to update FooterColumnItems.
     */
    data: XOR<FooterColumnItemUpdateManyMutationInput, FooterColumnItemUncheckedUpdateManyInput>
    /**
     * Filter which FooterColumnItems to update
     */
    where?: FooterColumnItemWhereInput
    /**
     * Limit how many FooterColumnItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FooterColumnItem upsert
   */
  export type FooterColumnItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumnItem
     */
    select?: FooterColumnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumnItem
     */
    omit?: FooterColumnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnItemInclude<ExtArgs> | null
    /**
     * The filter to search for the FooterColumnItem to update in case it exists.
     */
    where: FooterColumnItemWhereUniqueInput
    /**
     * In case the FooterColumnItem found by the `where` argument doesn't exist, create a new FooterColumnItem with this data.
     */
    create: XOR<FooterColumnItemCreateInput, FooterColumnItemUncheckedCreateInput>
    /**
     * In case the FooterColumnItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FooterColumnItemUpdateInput, FooterColumnItemUncheckedUpdateInput>
  }

  /**
   * FooterColumnItem delete
   */
  export type FooterColumnItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumnItem
     */
    select?: FooterColumnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumnItem
     */
    omit?: FooterColumnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnItemInclude<ExtArgs> | null
    /**
     * Filter which FooterColumnItem to delete.
     */
    where: FooterColumnItemWhereUniqueInput
  }

  /**
   * FooterColumnItem deleteMany
   */
  export type FooterColumnItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FooterColumnItems to delete
     */
    where?: FooterColumnItemWhereInput
    /**
     * Limit how many FooterColumnItems to delete.
     */
    limit?: number
  }

  /**
   * FooterColumnItem.page
   */
  export type FooterColumnItem$pageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    where?: PageWhereInput
  }

  /**
   * FooterColumnItem without action
   */
  export type FooterColumnItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FooterColumnItem
     */
    select?: FooterColumnItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FooterColumnItem
     */
    omit?: FooterColumnItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FooterColumnItemInclude<ExtArgs> | null
  }


  /**
   * Model SiteSettings
   */

  export type AggregateSiteSettings = {
    _count: SiteSettingsCountAggregateOutputType | null
    _min: SiteSettingsMinAggregateOutputType | null
    _max: SiteSettingsMaxAggregateOutputType | null
  }

  export type SiteSettingsMinAggregateOutputType = {
    id: string | null
    key: string | null
    copyrightText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteSettingsMaxAggregateOutputType = {
    id: string | null
    key: string | null
    copyrightText: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SiteSettingsCountAggregateOutputType = {
    id: number
    key: number
    copyrightText: number
    copyrightI18n: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SiteSettingsMinAggregateInputType = {
    id?: true
    key?: true
    copyrightText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteSettingsMaxAggregateInputType = {
    id?: true
    key?: true
    copyrightText?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SiteSettingsCountAggregateInputType = {
    id?: true
    key?: true
    copyrightText?: true
    copyrightI18n?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SiteSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteSettings to aggregate.
     */
    where?: SiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingsOrderByWithRelationInput | SiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SiteSettings
    **/
    _count?: true | SiteSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SiteSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SiteSettingsMaxAggregateInputType
  }

  export type GetSiteSettingsAggregateType<T extends SiteSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSiteSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSiteSettings[P]>
      : GetScalarType<T[P], AggregateSiteSettings[P]>
  }




  export type SiteSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SiteSettingsWhereInput
    orderBy?: SiteSettingsOrderByWithAggregationInput | SiteSettingsOrderByWithAggregationInput[]
    by: SiteSettingsScalarFieldEnum[] | SiteSettingsScalarFieldEnum
    having?: SiteSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SiteSettingsCountAggregateInputType | true
    _min?: SiteSettingsMinAggregateInputType
    _max?: SiteSettingsMaxAggregateInputType
  }

  export type SiteSettingsGroupByOutputType = {
    id: string
    key: string
    copyrightText: string
    copyrightI18n: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: SiteSettingsCountAggregateOutputType | null
    _min: SiteSettingsMinAggregateOutputType | null
    _max: SiteSettingsMaxAggregateOutputType | null
  }

  type GetSiteSettingsGroupByPayload<T extends SiteSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SiteSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SiteSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SiteSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SiteSettingsGroupByOutputType[P]>
        }
      >
    >


  export type SiteSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    copyrightText?: boolean
    copyrightI18n?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["siteSettings"]>

  export type SiteSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    copyrightText?: boolean
    copyrightI18n?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["siteSettings"]>

  export type SiteSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    copyrightText?: boolean
    copyrightI18n?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["siteSettings"]>

  export type SiteSettingsSelectScalar = {
    id?: boolean
    key?: boolean
    copyrightText?: boolean
    copyrightI18n?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SiteSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "copyrightText" | "copyrightI18n" | "createdAt" | "updatedAt", ExtArgs["result"]["siteSettings"]>

  export type $SiteSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SiteSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      copyrightText: string
      copyrightI18n: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["siteSettings"]>
    composites: {}
  }

  type SiteSettingsGetPayload<S extends boolean | null | undefined | SiteSettingsDefaultArgs> = $Result.GetResult<Prisma.$SiteSettingsPayload, S>

  type SiteSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SiteSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SiteSettingsCountAggregateInputType | true
    }

  export interface SiteSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SiteSettings'], meta: { name: 'SiteSettings' } }
    /**
     * Find zero or one SiteSettings that matches the filter.
     * @param {SiteSettingsFindUniqueArgs} args - Arguments to find a SiteSettings
     * @example
     * // Get one SiteSettings
     * const siteSettings = await prisma.siteSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SiteSettingsFindUniqueArgs>(args: SelectSubset<T, SiteSettingsFindUniqueArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SiteSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SiteSettingsFindUniqueOrThrowArgs} args - Arguments to find a SiteSettings
     * @example
     * // Get one SiteSettings
     * const siteSettings = await prisma.siteSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SiteSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SiteSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsFindFirstArgs} args - Arguments to find a SiteSettings
     * @example
     * // Get one SiteSettings
     * const siteSettings = await prisma.siteSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SiteSettingsFindFirstArgs>(args?: SelectSubset<T, SiteSettingsFindFirstArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SiteSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsFindFirstOrThrowArgs} args - Arguments to find a SiteSettings
     * @example
     * // Get one SiteSettings
     * const siteSettings = await prisma.siteSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SiteSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SiteSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SiteSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SiteSettings
     * const siteSettings = await prisma.siteSettings.findMany()
     * 
     * // Get first 10 SiteSettings
     * const siteSettings = await prisma.siteSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const siteSettingsWithIdOnly = await prisma.siteSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SiteSettingsFindManyArgs>(args?: SelectSubset<T, SiteSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SiteSettings.
     * @param {SiteSettingsCreateArgs} args - Arguments to create a SiteSettings.
     * @example
     * // Create one SiteSettings
     * const SiteSettings = await prisma.siteSettings.create({
     *   data: {
     *     // ... data to create a SiteSettings
     *   }
     * })
     * 
     */
    create<T extends SiteSettingsCreateArgs>(args: SelectSubset<T, SiteSettingsCreateArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SiteSettings.
     * @param {SiteSettingsCreateManyArgs} args - Arguments to create many SiteSettings.
     * @example
     * // Create many SiteSettings
     * const siteSettings = await prisma.siteSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SiteSettingsCreateManyArgs>(args?: SelectSubset<T, SiteSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SiteSettings and returns the data saved in the database.
     * @param {SiteSettingsCreateManyAndReturnArgs} args - Arguments to create many SiteSettings.
     * @example
     * // Create many SiteSettings
     * const siteSettings = await prisma.siteSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SiteSettings and only return the `id`
     * const siteSettingsWithIdOnly = await prisma.siteSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SiteSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SiteSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SiteSettings.
     * @param {SiteSettingsDeleteArgs} args - Arguments to delete one SiteSettings.
     * @example
     * // Delete one SiteSettings
     * const SiteSettings = await prisma.siteSettings.delete({
     *   where: {
     *     // ... filter to delete one SiteSettings
     *   }
     * })
     * 
     */
    delete<T extends SiteSettingsDeleteArgs>(args: SelectSubset<T, SiteSettingsDeleteArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SiteSettings.
     * @param {SiteSettingsUpdateArgs} args - Arguments to update one SiteSettings.
     * @example
     * // Update one SiteSettings
     * const siteSettings = await prisma.siteSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SiteSettingsUpdateArgs>(args: SelectSubset<T, SiteSettingsUpdateArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SiteSettings.
     * @param {SiteSettingsDeleteManyArgs} args - Arguments to filter SiteSettings to delete.
     * @example
     * // Delete a few SiteSettings
     * const { count } = await prisma.siteSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SiteSettingsDeleteManyArgs>(args?: SelectSubset<T, SiteSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SiteSettings
     * const siteSettings = await prisma.siteSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SiteSettingsUpdateManyArgs>(args: SelectSubset<T, SiteSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SiteSettings and returns the data updated in the database.
     * @param {SiteSettingsUpdateManyAndReturnArgs} args - Arguments to update many SiteSettings.
     * @example
     * // Update many SiteSettings
     * const siteSettings = await prisma.siteSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SiteSettings and only return the `id`
     * const siteSettingsWithIdOnly = await prisma.siteSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SiteSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SiteSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SiteSettings.
     * @param {SiteSettingsUpsertArgs} args - Arguments to update or create a SiteSettings.
     * @example
     * // Update or create a SiteSettings
     * const siteSettings = await prisma.siteSettings.upsert({
     *   create: {
     *     // ... data to create a SiteSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SiteSettings we want to update
     *   }
     * })
     */
    upsert<T extends SiteSettingsUpsertArgs>(args: SelectSubset<T, SiteSettingsUpsertArgs<ExtArgs>>): Prisma__SiteSettingsClient<$Result.GetResult<Prisma.$SiteSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsCountArgs} args - Arguments to filter SiteSettings to count.
     * @example
     * // Count the number of SiteSettings
     * const count = await prisma.siteSettings.count({
     *   where: {
     *     // ... the filter for the SiteSettings we want to count
     *   }
     * })
    **/
    count<T extends SiteSettingsCountArgs>(
      args?: Subset<T, SiteSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SiteSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SiteSettingsAggregateArgs>(args: Subset<T, SiteSettingsAggregateArgs>): Prisma.PrismaPromise<GetSiteSettingsAggregateType<T>>

    /**
     * Group by SiteSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SiteSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SiteSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SiteSettingsGroupByArgs['orderBy'] }
        : { orderBy?: SiteSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SiteSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSiteSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SiteSettings model
   */
  readonly fields: SiteSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SiteSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SiteSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SiteSettings model
   */
  interface SiteSettingsFieldRefs {
    readonly id: FieldRef<"SiteSettings", 'String'>
    readonly key: FieldRef<"SiteSettings", 'String'>
    readonly copyrightText: FieldRef<"SiteSettings", 'String'>
    readonly copyrightI18n: FieldRef<"SiteSettings", 'Json'>
    readonly createdAt: FieldRef<"SiteSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"SiteSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SiteSettings findUnique
   */
  export type SiteSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SiteSettings to fetch.
     */
    where: SiteSettingsWhereUniqueInput
  }

  /**
   * SiteSettings findUniqueOrThrow
   */
  export type SiteSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SiteSettings to fetch.
     */
    where: SiteSettingsWhereUniqueInput
  }

  /**
   * SiteSettings findFirst
   */
  export type SiteSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SiteSettings to fetch.
     */
    where?: SiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingsOrderByWithRelationInput | SiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteSettings.
     */
    cursor?: SiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteSettings.
     */
    distinct?: SiteSettingsScalarFieldEnum | SiteSettingsScalarFieldEnum[]
  }

  /**
   * SiteSettings findFirstOrThrow
   */
  export type SiteSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SiteSettings to fetch.
     */
    where?: SiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingsOrderByWithRelationInput | SiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SiteSettings.
     */
    cursor?: SiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SiteSettings.
     */
    distinct?: SiteSettingsScalarFieldEnum | SiteSettingsScalarFieldEnum[]
  }

  /**
   * SiteSettings findMany
   */
  export type SiteSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SiteSettings to fetch.
     */
    where?: SiteSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SiteSettings to fetch.
     */
    orderBy?: SiteSettingsOrderByWithRelationInput | SiteSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SiteSettings.
     */
    cursor?: SiteSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SiteSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SiteSettings.
     */
    skip?: number
    distinct?: SiteSettingsScalarFieldEnum | SiteSettingsScalarFieldEnum[]
  }

  /**
   * SiteSettings create
   */
  export type SiteSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a SiteSettings.
     */
    data: XOR<SiteSettingsCreateInput, SiteSettingsUncheckedCreateInput>
  }

  /**
   * SiteSettings createMany
   */
  export type SiteSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SiteSettings.
     */
    data: SiteSettingsCreateManyInput | SiteSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SiteSettings createManyAndReturn
   */
  export type SiteSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many SiteSettings.
     */
    data: SiteSettingsCreateManyInput | SiteSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SiteSettings update
   */
  export type SiteSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a SiteSettings.
     */
    data: XOR<SiteSettingsUpdateInput, SiteSettingsUncheckedUpdateInput>
    /**
     * Choose, which SiteSettings to update.
     */
    where: SiteSettingsWhereUniqueInput
  }

  /**
   * SiteSettings updateMany
   */
  export type SiteSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SiteSettings.
     */
    data: XOR<SiteSettingsUpdateManyMutationInput, SiteSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SiteSettings to update
     */
    where?: SiteSettingsWhereInput
    /**
     * Limit how many SiteSettings to update.
     */
    limit?: number
  }

  /**
   * SiteSettings updateManyAndReturn
   */
  export type SiteSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * The data used to update SiteSettings.
     */
    data: XOR<SiteSettingsUpdateManyMutationInput, SiteSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SiteSettings to update
     */
    where?: SiteSettingsWhereInput
    /**
     * Limit how many SiteSettings to update.
     */
    limit?: number
  }

  /**
   * SiteSettings upsert
   */
  export type SiteSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the SiteSettings to update in case it exists.
     */
    where: SiteSettingsWhereUniqueInput
    /**
     * In case the SiteSettings found by the `where` argument doesn't exist, create a new SiteSettings with this data.
     */
    create: XOR<SiteSettingsCreateInput, SiteSettingsUncheckedCreateInput>
    /**
     * In case the SiteSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SiteSettingsUpdateInput, SiteSettingsUncheckedUpdateInput>
  }

  /**
   * SiteSettings delete
   */
  export type SiteSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
    /**
     * Filter which SiteSettings to delete.
     */
    where: SiteSettingsWhereUniqueInput
  }

  /**
   * SiteSettings deleteMany
   */
  export type SiteSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SiteSettings to delete
     */
    where?: SiteSettingsWhereInput
    /**
     * Limit how many SiteSettings to delete.
     */
    limit?: number
  }

  /**
   * SiteSettings without action
   */
  export type SiteSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SiteSettings
     */
    select?: SiteSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SiteSettings
     */
    omit?: SiteSettingsOmit<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    year: number | null
  }

  export type DocumentSumAggregateOutputType = {
    year: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    titleEn: string | null
    description: string | null
    descriptionEn: string | null
    category: string | null
    year: number | null
    reference: string | null
    referenceUrl: string | null
    scanUrl: string | null
    scanZip: string | null
    lang: $Enums.ContentLanguage | null
    status: $Enums.ContentStatus | null
    license: string | null
    volume: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    titleEn: string | null
    description: string | null
    descriptionEn: string | null
    category: string | null
    year: number | null
    reference: string | null
    referenceUrl: string | null
    scanUrl: string | null
    scanZip: string | null
    lang: $Enums.ContentLanguage | null
    status: $Enums.ContentStatus | null
    license: string | null
    volume: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    titleEn: number
    description: number
    descriptionEn: number
    category: number
    year: number
    reference: number
    referenceUrl: number
    scanUrl: number
    scanZip: number
    lang: number
    status: number
    license: number
    volume: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    year?: true
  }

  export type DocumentSumAggregateInputType = {
    year?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    titleEn?: true
    description?: true
    descriptionEn?: true
    category?: true
    year?: true
    reference?: true
    referenceUrl?: true
    scanUrl?: true
    scanZip?: true
    lang?: true
    status?: true
    license?: true
    volume?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    titleEn?: true
    description?: true
    descriptionEn?: true
    category?: true
    year?: true
    reference?: true
    referenceUrl?: true
    scanUrl?: true
    scanZip?: true
    lang?: true
    status?: true
    license?: true
    volume?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    titleEn?: true
    description?: true
    descriptionEn?: true
    category?: true
    year?: true
    reference?: true
    referenceUrl?: true
    scanUrl?: true
    scanZip?: true
    lang?: true
    status?: true
    license?: true
    volume?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    slug: string
    title: string
    titleEn: string | null
    description: string | null
    descriptionEn: string | null
    category: string | null
    year: number | null
    reference: string | null
    referenceUrl: string | null
    scanUrl: string | null
    scanZip: string | null
    lang: $Enums.ContentLanguage
    status: $Enums.ContentStatus
    license: string | null
    volume: string | null
    createdAt: Date
    updatedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    titleEn?: boolean
    description?: boolean
    descriptionEn?: boolean
    category?: boolean
    year?: boolean
    reference?: boolean
    referenceUrl?: boolean
    scanUrl?: boolean
    scanZip?: boolean
    lang?: boolean
    status?: boolean
    license?: boolean
    volume?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pages?: boolean | Document$pagesArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    titleEn?: boolean
    description?: boolean
    descriptionEn?: boolean
    category?: boolean
    year?: boolean
    reference?: boolean
    referenceUrl?: boolean
    scanUrl?: boolean
    scanZip?: boolean
    lang?: boolean
    status?: boolean
    license?: boolean
    volume?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    titleEn?: boolean
    description?: boolean
    descriptionEn?: boolean
    category?: boolean
    year?: boolean
    reference?: boolean
    referenceUrl?: boolean
    scanUrl?: boolean
    scanZip?: boolean
    lang?: boolean
    status?: boolean
    license?: boolean
    volume?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
    titleEn?: boolean
    description?: boolean
    descriptionEn?: boolean
    category?: boolean
    year?: boolean
    reference?: boolean
    referenceUrl?: boolean
    scanUrl?: boolean
    scanZip?: boolean
    lang?: boolean
    status?: boolean
    license?: boolean
    volume?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "title" | "titleEn" | "description" | "descriptionEn" | "category" | "year" | "reference" | "referenceUrl" | "scanUrl" | "scanZip" | "lang" | "status" | "license" | "volume" | "createdAt" | "updatedAt", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pages?: boolean | Document$pagesArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      pages: Prisma.$DocumentPagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      title: string
      titleEn: string | null
      description: string | null
      descriptionEn: string | null
      category: string | null
      year: number | null
      reference: string | null
      referenceUrl: string | null
      scanUrl: string | null
      scanZip: string | null
      lang: $Enums.ContentLanguage
      status: $Enums.ContentStatus
      license: string | null
      volume: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pages<T extends Document$pagesArgs<ExtArgs> = {}>(args?: Subset<T, Document$pagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly slug: FieldRef<"Document", 'String'>
    readonly title: FieldRef<"Document", 'String'>
    readonly titleEn: FieldRef<"Document", 'String'>
    readonly description: FieldRef<"Document", 'String'>
    readonly descriptionEn: FieldRef<"Document", 'String'>
    readonly category: FieldRef<"Document", 'String'>
    readonly year: FieldRef<"Document", 'Int'>
    readonly reference: FieldRef<"Document", 'String'>
    readonly referenceUrl: FieldRef<"Document", 'String'>
    readonly scanUrl: FieldRef<"Document", 'String'>
    readonly scanZip: FieldRef<"Document", 'String'>
    readonly lang: FieldRef<"Document", 'ContentLanguage'>
    readonly status: FieldRef<"Document", 'ContentStatus'>
    readonly license: FieldRef<"Document", 'String'>
    readonly volume: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document.pages
   */
  export type Document$pagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageInclude<ExtArgs> | null
    where?: DocumentPageWhereInput
    orderBy?: DocumentPageOrderByWithRelationInput | DocumentPageOrderByWithRelationInput[]
    cursor?: DocumentPageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentPageScalarFieldEnum | DocumentPageScalarFieldEnum[]
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model DocumentPage
   */

  export type AggregateDocumentPage = {
    _count: DocumentPageCountAggregateOutputType | null
    _avg: DocumentPageAvgAggregateOutputType | null
    _sum: DocumentPageSumAggregateOutputType | null
    _min: DocumentPageMinAggregateOutputType | null
    _max: DocumentPageMaxAggregateOutputType | null
  }

  export type DocumentPageAvgAggregateOutputType = {
    index: number | null
  }

  export type DocumentPageSumAggregateOutputType = {
    index: number | null
  }

  export type DocumentPageMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    index: number | null
    content: string | null
    contentHe: string | null
    contentEn: string | null
    filename: string | null
    bookmark: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentPageMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    index: number | null
    content: string | null
    contentHe: string | null
    contentEn: string | null
    filename: string | null
    bookmark: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentPageCountAggregateOutputType = {
    id: number
    documentId: number
    index: number
    content: number
    contentHe: number
    contentEn: number
    filename: number
    bookmark: number
    highlights: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentPageAvgAggregateInputType = {
    index?: true
  }

  export type DocumentPageSumAggregateInputType = {
    index?: true
  }

  export type DocumentPageMinAggregateInputType = {
    id?: true
    documentId?: true
    index?: true
    content?: true
    contentHe?: true
    contentEn?: true
    filename?: true
    bookmark?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentPageMaxAggregateInputType = {
    id?: true
    documentId?: true
    index?: true
    content?: true
    contentHe?: true
    contentEn?: true
    filename?: true
    bookmark?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentPageCountAggregateInputType = {
    id?: true
    documentId?: true
    index?: true
    content?: true
    contentHe?: true
    contentEn?: true
    filename?: true
    bookmark?: true
    highlights?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentPageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentPage to aggregate.
     */
    where?: DocumentPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentPages to fetch.
     */
    orderBy?: DocumentPageOrderByWithRelationInput | DocumentPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentPages
    **/
    _count?: true | DocumentPageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentPageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentPageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentPageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentPageMaxAggregateInputType
  }

  export type GetDocumentPageAggregateType<T extends DocumentPageAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentPage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentPage[P]>
      : GetScalarType<T[P], AggregateDocumentPage[P]>
  }




  export type DocumentPageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentPageWhereInput
    orderBy?: DocumentPageOrderByWithAggregationInput | DocumentPageOrderByWithAggregationInput[]
    by: DocumentPageScalarFieldEnum[] | DocumentPageScalarFieldEnum
    having?: DocumentPageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentPageCountAggregateInputType | true
    _avg?: DocumentPageAvgAggregateInputType
    _sum?: DocumentPageSumAggregateInputType
    _min?: DocumentPageMinAggregateInputType
    _max?: DocumentPageMaxAggregateInputType
  }

  export type DocumentPageGroupByOutputType = {
    id: string
    documentId: string
    index: number
    content: string
    contentHe: string | null
    contentEn: string | null
    filename: string | null
    bookmark: string | null
    highlights: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: DocumentPageCountAggregateOutputType | null
    _avg: DocumentPageAvgAggregateOutputType | null
    _sum: DocumentPageSumAggregateOutputType | null
    _min: DocumentPageMinAggregateOutputType | null
    _max: DocumentPageMaxAggregateOutputType | null
  }

  type GetDocumentPageGroupByPayload<T extends DocumentPageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentPageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentPageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentPageGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentPageGroupByOutputType[P]>
        }
      >
    >


  export type DocumentPageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    index?: boolean
    content?: boolean
    contentHe?: boolean
    contentEn?: boolean
    filename?: boolean
    bookmark?: boolean
    highlights?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentPage"]>

  export type DocumentPageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    index?: boolean
    content?: boolean
    contentHe?: boolean
    contentEn?: boolean
    filename?: boolean
    bookmark?: boolean
    highlights?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentPage"]>

  export type DocumentPageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    index?: boolean
    content?: boolean
    contentHe?: boolean
    contentEn?: boolean
    filename?: boolean
    bookmark?: boolean
    highlights?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentPage"]>

  export type DocumentPageSelectScalar = {
    id?: boolean
    documentId?: boolean
    index?: boolean
    content?: boolean
    contentHe?: boolean
    contentEn?: boolean
    filename?: boolean
    bookmark?: boolean
    highlights?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentPageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentId" | "index" | "content" | "contentHe" | "contentEn" | "filename" | "bookmark" | "highlights" | "createdAt" | "updatedAt", ExtArgs["result"]["documentPage"]>
  export type DocumentPageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }
  export type DocumentPageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }
  export type DocumentPageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }

  export type $DocumentPagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentPage"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      index: number
      content: string
      contentHe: string | null
      contentEn: string | null
      filename: string | null
      bookmark: string | null
      highlights: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["documentPage"]>
    composites: {}
  }

  type DocumentPageGetPayload<S extends boolean | null | undefined | DocumentPageDefaultArgs> = $Result.GetResult<Prisma.$DocumentPagePayload, S>

  type DocumentPageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentPageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentPageCountAggregateInputType | true
    }

  export interface DocumentPageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentPage'], meta: { name: 'DocumentPage' } }
    /**
     * Find zero or one DocumentPage that matches the filter.
     * @param {DocumentPageFindUniqueArgs} args - Arguments to find a DocumentPage
     * @example
     * // Get one DocumentPage
     * const documentPage = await prisma.documentPage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentPageFindUniqueArgs>(args: SelectSubset<T, DocumentPageFindUniqueArgs<ExtArgs>>): Prisma__DocumentPageClient<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentPage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentPageFindUniqueOrThrowArgs} args - Arguments to find a DocumentPage
     * @example
     * // Get one DocumentPage
     * const documentPage = await prisma.documentPage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentPageFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentPageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentPageClient<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentPage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPageFindFirstArgs} args - Arguments to find a DocumentPage
     * @example
     * // Get one DocumentPage
     * const documentPage = await prisma.documentPage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentPageFindFirstArgs>(args?: SelectSubset<T, DocumentPageFindFirstArgs<ExtArgs>>): Prisma__DocumentPageClient<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentPage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPageFindFirstOrThrowArgs} args - Arguments to find a DocumentPage
     * @example
     * // Get one DocumentPage
     * const documentPage = await prisma.documentPage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentPageFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentPageFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentPageClient<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentPages
     * const documentPages = await prisma.documentPage.findMany()
     * 
     * // Get first 10 DocumentPages
     * const documentPages = await prisma.documentPage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentPageWithIdOnly = await prisma.documentPage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentPageFindManyArgs>(args?: SelectSubset<T, DocumentPageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentPage.
     * @param {DocumentPageCreateArgs} args - Arguments to create a DocumentPage.
     * @example
     * // Create one DocumentPage
     * const DocumentPage = await prisma.documentPage.create({
     *   data: {
     *     // ... data to create a DocumentPage
     *   }
     * })
     * 
     */
    create<T extends DocumentPageCreateArgs>(args: SelectSubset<T, DocumentPageCreateArgs<ExtArgs>>): Prisma__DocumentPageClient<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentPages.
     * @param {DocumentPageCreateManyArgs} args - Arguments to create many DocumentPages.
     * @example
     * // Create many DocumentPages
     * const documentPage = await prisma.documentPage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentPageCreateManyArgs>(args?: SelectSubset<T, DocumentPageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentPages and returns the data saved in the database.
     * @param {DocumentPageCreateManyAndReturnArgs} args - Arguments to create many DocumentPages.
     * @example
     * // Create many DocumentPages
     * const documentPage = await prisma.documentPage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentPages and only return the `id`
     * const documentPageWithIdOnly = await prisma.documentPage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentPageCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentPageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentPage.
     * @param {DocumentPageDeleteArgs} args - Arguments to delete one DocumentPage.
     * @example
     * // Delete one DocumentPage
     * const DocumentPage = await prisma.documentPage.delete({
     *   where: {
     *     // ... filter to delete one DocumentPage
     *   }
     * })
     * 
     */
    delete<T extends DocumentPageDeleteArgs>(args: SelectSubset<T, DocumentPageDeleteArgs<ExtArgs>>): Prisma__DocumentPageClient<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentPage.
     * @param {DocumentPageUpdateArgs} args - Arguments to update one DocumentPage.
     * @example
     * // Update one DocumentPage
     * const documentPage = await prisma.documentPage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentPageUpdateArgs>(args: SelectSubset<T, DocumentPageUpdateArgs<ExtArgs>>): Prisma__DocumentPageClient<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentPages.
     * @param {DocumentPageDeleteManyArgs} args - Arguments to filter DocumentPages to delete.
     * @example
     * // Delete a few DocumentPages
     * const { count } = await prisma.documentPage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentPageDeleteManyArgs>(args?: SelectSubset<T, DocumentPageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentPages
     * const documentPage = await prisma.documentPage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentPageUpdateManyArgs>(args: SelectSubset<T, DocumentPageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentPages and returns the data updated in the database.
     * @param {DocumentPageUpdateManyAndReturnArgs} args - Arguments to update many DocumentPages.
     * @example
     * // Update many DocumentPages
     * const documentPage = await prisma.documentPage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentPages and only return the `id`
     * const documentPageWithIdOnly = await prisma.documentPage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentPageUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentPageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentPage.
     * @param {DocumentPageUpsertArgs} args - Arguments to update or create a DocumentPage.
     * @example
     * // Update or create a DocumentPage
     * const documentPage = await prisma.documentPage.upsert({
     *   create: {
     *     // ... data to create a DocumentPage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentPage we want to update
     *   }
     * })
     */
    upsert<T extends DocumentPageUpsertArgs>(args: SelectSubset<T, DocumentPageUpsertArgs<ExtArgs>>): Prisma__DocumentPageClient<$Result.GetResult<Prisma.$DocumentPagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPageCountArgs} args - Arguments to filter DocumentPages to count.
     * @example
     * // Count the number of DocumentPages
     * const count = await prisma.documentPage.count({
     *   where: {
     *     // ... the filter for the DocumentPages we want to count
     *   }
     * })
    **/
    count<T extends DocumentPageCountArgs>(
      args?: Subset<T, DocumentPageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentPageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentPageAggregateArgs>(args: Subset<T, DocumentPageAggregateArgs>): Prisma.PrismaPromise<GetDocumentPageAggregateType<T>>

    /**
     * Group by DocumentPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentPageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentPageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentPageGroupByArgs['orderBy'] }
        : { orderBy?: DocumentPageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentPageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentPage model
   */
  readonly fields: DocumentPageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentPage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentPageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentPage model
   */
  interface DocumentPageFieldRefs {
    readonly id: FieldRef<"DocumentPage", 'String'>
    readonly documentId: FieldRef<"DocumentPage", 'String'>
    readonly index: FieldRef<"DocumentPage", 'Int'>
    readonly content: FieldRef<"DocumentPage", 'String'>
    readonly contentHe: FieldRef<"DocumentPage", 'String'>
    readonly contentEn: FieldRef<"DocumentPage", 'String'>
    readonly filename: FieldRef<"DocumentPage", 'String'>
    readonly bookmark: FieldRef<"DocumentPage", 'String'>
    readonly highlights: FieldRef<"DocumentPage", 'Json'>
    readonly createdAt: FieldRef<"DocumentPage", 'DateTime'>
    readonly updatedAt: FieldRef<"DocumentPage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentPage findUnique
   */
  export type DocumentPageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageInclude<ExtArgs> | null
    /**
     * Filter, which DocumentPage to fetch.
     */
    where: DocumentPageWhereUniqueInput
  }

  /**
   * DocumentPage findUniqueOrThrow
   */
  export type DocumentPageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageInclude<ExtArgs> | null
    /**
     * Filter, which DocumentPage to fetch.
     */
    where: DocumentPageWhereUniqueInput
  }

  /**
   * DocumentPage findFirst
   */
  export type DocumentPageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageInclude<ExtArgs> | null
    /**
     * Filter, which DocumentPage to fetch.
     */
    where?: DocumentPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentPages to fetch.
     */
    orderBy?: DocumentPageOrderByWithRelationInput | DocumentPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentPages.
     */
    cursor?: DocumentPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentPages.
     */
    distinct?: DocumentPageScalarFieldEnum | DocumentPageScalarFieldEnum[]
  }

  /**
   * DocumentPage findFirstOrThrow
   */
  export type DocumentPageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageInclude<ExtArgs> | null
    /**
     * Filter, which DocumentPage to fetch.
     */
    where?: DocumentPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentPages to fetch.
     */
    orderBy?: DocumentPageOrderByWithRelationInput | DocumentPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentPages.
     */
    cursor?: DocumentPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentPages.
     */
    distinct?: DocumentPageScalarFieldEnum | DocumentPageScalarFieldEnum[]
  }

  /**
   * DocumentPage findMany
   */
  export type DocumentPageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageInclude<ExtArgs> | null
    /**
     * Filter, which DocumentPages to fetch.
     */
    where?: DocumentPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentPages to fetch.
     */
    orderBy?: DocumentPageOrderByWithRelationInput | DocumentPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentPages.
     */
    cursor?: DocumentPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentPages.
     */
    skip?: number
    distinct?: DocumentPageScalarFieldEnum | DocumentPageScalarFieldEnum[]
  }

  /**
   * DocumentPage create
   */
  export type DocumentPageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentPage.
     */
    data: XOR<DocumentPageCreateInput, DocumentPageUncheckedCreateInput>
  }

  /**
   * DocumentPage createMany
   */
  export type DocumentPageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentPages.
     */
    data: DocumentPageCreateManyInput | DocumentPageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentPage createManyAndReturn
   */
  export type DocumentPageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentPages.
     */
    data: DocumentPageCreateManyInput | DocumentPageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentPage update
   */
  export type DocumentPageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentPage.
     */
    data: XOR<DocumentPageUpdateInput, DocumentPageUncheckedUpdateInput>
    /**
     * Choose, which DocumentPage to update.
     */
    where: DocumentPageWhereUniqueInput
  }

  /**
   * DocumentPage updateMany
   */
  export type DocumentPageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentPages.
     */
    data: XOR<DocumentPageUpdateManyMutationInput, DocumentPageUncheckedUpdateManyInput>
    /**
     * Filter which DocumentPages to update
     */
    where?: DocumentPageWhereInput
    /**
     * Limit how many DocumentPages to update.
     */
    limit?: number
  }

  /**
   * DocumentPage updateManyAndReturn
   */
  export type DocumentPageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * The data used to update DocumentPages.
     */
    data: XOR<DocumentPageUpdateManyMutationInput, DocumentPageUncheckedUpdateManyInput>
    /**
     * Filter which DocumentPages to update
     */
    where?: DocumentPageWhereInput
    /**
     * Limit how many DocumentPages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentPage upsert
   */
  export type DocumentPageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentPage to update in case it exists.
     */
    where: DocumentPageWhereUniqueInput
    /**
     * In case the DocumentPage found by the `where` argument doesn't exist, create a new DocumentPage with this data.
     */
    create: XOR<DocumentPageCreateInput, DocumentPageUncheckedCreateInput>
    /**
     * In case the DocumentPage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentPageUpdateInput, DocumentPageUncheckedUpdateInput>
  }

  /**
   * DocumentPage delete
   */
  export type DocumentPageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageInclude<ExtArgs> | null
    /**
     * Filter which DocumentPage to delete.
     */
    where: DocumentPageWhereUniqueInput
  }

  /**
   * DocumentPage deleteMany
   */
  export type DocumentPageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentPages to delete
     */
    where?: DocumentPageWhereInput
    /**
     * Limit how many DocumentPages to delete.
     */
    limit?: number
  }

  /**
   * DocumentPage without action
   */
  export type DocumentPageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentPage
     */
    select?: DocumentPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentPage
     */
    omit?: DocumentPageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentPageInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    title: 'title',
    slug: 'slug',
    content: 'content',
    excerpt: 'excerpt',
    sources: 'sources',
    citations: 'citations',
    language: 'language',
    translationGroupId: 'translationGroupId',
    status: 'status',
    authorId: 'authorId',
    parentId: 'parentId',
    metaDescription: 'metaDescription',
    metaKeywords: 'metaKeywords',
    thumbnailId: 'thumbnailId',
    template: 'template',
    menuOrder: 'menuOrder',
    showInMenu: 'showInMenu'
  };

  export type PageScalarFieldEnum = (typeof PageScalarFieldEnum)[keyof typeof PageScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    translationGroupId: 'translationGroupId',
    language: 'language',
    title: 'title',
    slug: 'slug',
    content: 'content',
    sources: 'sources',
    excerpt: 'excerpt',
    status: 'status',
    authorId: 'authorId',
    thumbnailId: 'thumbnailId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const PostTagScalarFieldEnum: {
    postId: 'postId',
    tagId: 'tagId'
  };

  export type PostTagScalarFieldEnum = (typeof PostTagScalarFieldEnum)[keyof typeof PostTagScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    passwordHash: 'passwordHash',
    role: 'role',
    createdAt: 'createdAt',
    emailVerified: 'emailVerified',
    image: 'image'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const ResearchDatasetScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    titleI18n: 'titleI18n',
    codebookTextI18n: 'codebookTextI18n',
    status: 'status',
    maturity: 'maturity',
    version: 'version',
    license: 'license',
    thumbnailId: 'thumbnailId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    description: 'description',
    title: 'title',
    categoryId: 'categoryId',
    citationText: 'citationText',
    codebookText: 'codebookText',
    maxYear: 'maxYear',
    minYear: 'minYear',
    sources: 'sources',
    isVisible: 'isVisible',
    sourcesI18n: 'sourcesI18n',
    descriptionI18n: 'descriptionI18n'
  };

  export type ResearchDatasetScalarFieldEnum = (typeof ResearchDatasetScalarFieldEnum)[keyof typeof ResearchDatasetScalarFieldEnum]


  export const DatasetResourceScalarFieldEnum: {
    id: 'id',
    datasetId: 'datasetId',
    url: 'url',
    isMainFile: 'isMainFile',
    createdAt: 'createdAt',
    name: 'name',
    slug: 'slug',
    format: 'format',
    filename: 'filename',
    mimeType: 'mimeType',
    excerptI18n: 'excerptI18n',
    mapId: 'mapId'
  };

  export type DatasetResourceScalarFieldEnum = (typeof DatasetResourceScalarFieldEnum)[keyof typeof DatasetResourceScalarFieldEnum]


  export const MapScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    titleI18n: 'titleI18n',
    descriptionI18n: 'descriptionI18n',
    year: 'year',
    version: 'version',
    thumbnailId: 'thumbnailId',
    config: 'config',
    globalStyleConfig: 'globalStyleConfig',
    referenceLinks: 'referenceLinks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    description: 'description',
    period: 'period',
    title: 'title',
    yearMax: 'yearMax',
    yearMin: 'yearMin',
    categoryId: 'categoryId',
    status: 'status'
  };

  export type MapScalarFieldEnum = (typeof MapScalarFieldEnum)[keyof typeof MapScalarFieldEnum]


  export const LayerScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    nameI18n: 'nameI18n',
    description: 'description',
    descriptionI18n: 'descriptionI18n',
    filename: 'filename',
    status: 'status',
    version: 'version',
    categoryId: 'categoryId',
    type: 'type',
    citationText: 'citationText',
    citationTextI18n: 'citationTextI18n',
    codebookText: 'codebookText',
    codebookTextI18n: 'codebookTextI18n',
    sources: 'sources',
    sourcesI18n: 'sourcesI18n',
    license: 'license',
    maturity: 'maturity',
    minYear: 'minYear',
    maxYear: 'maxYear',
    sourceType: 'sourceType',
    sourceUrl: 'sourceUrl',
    downloadUrl: 'downloadUrl',
    geoJsonData: 'geoJsonData',
    styleConfig: 'styleConfig',
    thumbnail: 'thumbnail',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LayerScalarFieldEnum = (typeof LayerScalarFieldEnum)[keyof typeof LayerScalarFieldEnum]


  export const MapLayerAssociationScalarFieldEnum: {
    id: 'id',
    mapId: 'mapId',
    layerId: 'layerId',
    zIndex: 'zIndex',
    isVisible: 'isVisible',
    isVisibleByDefault: 'isVisibleByDefault',
    styleOverride: 'styleOverride',
    interactionConfig: 'interactionConfig',
    createdAt: 'createdAt'
  };

  export type MapLayerAssociationScalarFieldEnum = (typeof MapLayerAssociationScalarFieldEnum)[keyof typeof MapLayerAssociationScalarFieldEnum]


  export const CollectionScalarFieldEnum: {
    id: 'id',
    nameI18n: 'nameI18n',
    descriptionI18n: 'descriptionI18n',
    createdAt: 'createdAt',
    thumbnailId: 'thumbnailId',
    name: 'name',
    referenceCode: 'referenceCode',
    yearMax: 'yearMax',
    yearMin: 'yearMin'
  };

  export type CollectionScalarFieldEnum = (typeof CollectionScalarFieldEnum)[keyof typeof CollectionScalarFieldEnum]


  export const SeriesScalarFieldEnum: {
    id: 'id',
    collectionId: 'collectionId',
    nameI18n: 'nameI18n',
    descriptionI18n: 'descriptionI18n',
    indexNumber: 'indexNumber',
    volumeLabelFormat: 'volumeLabelFormat',
    thumbnailId: 'thumbnailId',
    createdAt: 'createdAt',
    slug: 'slug',
    name: 'name',
    description: 'description',
    license: 'license',
    period: 'period',
    sourceLink: 'sourceLink',
    sources: 'sources',
    author: 'author',
    editor: 'editor',
    referenceCode: 'referenceCode',
    yearMax: 'yearMax',
    yearMin: 'yearMin',
    languages: 'languages'
  };

  export type SeriesScalarFieldEnum = (typeof SeriesScalarFieldEnum)[keyof typeof SeriesScalarFieldEnum]


  export const VolumeScalarFieldEnum: {
    id: 'id',
    seriesId: 'seriesId',
    indexNumber: 'indexNumber',
    titleI18n: 'titleI18n',
    descriptionI18n: 'descriptionI18n',
    languageOfContent: 'languageOfContent',
    yearContent: 'yearContent',
    thumbnailId: 'thumbnailId',
    createdAt: 'createdAt',
    slug: 'slug',
    title: 'title',
    description: 'description',
    license: 'license',
    sourceLink: 'sourceLink',
    sources: 'sources',
    year: 'year',
    author: 'author',
    editor: 'editor',
    languages: 'languages',
    yearMax: 'yearMax',
    yearMin: 'yearMin'
  };

  export type VolumeScalarFieldEnum = (typeof VolumeScalarFieldEnum)[keyof typeof VolumeScalarFieldEnum]


  export const VolumePageScalarFieldEnum: {
    id: 'id',
    volumeId: 'volumeId',
    sequenceIndex: 'sequenceIndex',
    label: 'label',
    createdAt: 'createdAt',
    isVisible: 'isVisible'
  };

  export type VolumePageScalarFieldEnum = (typeof VolumePageScalarFieldEnum)[keyof typeof VolumePageScalarFieldEnum]


  export const ArtifactScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    content: 'content',
    contentI18n: 'contentI18n',
    year: 'year',
    dateDisplay: 'dateDisplay',
    dateSort: 'dateSort',
    excerpt: 'excerpt',
    excerptI18n: 'excerptI18n',
    createdAt: 'createdAt',
    description: 'description',
    descriptionI18n: 'descriptionI18n',
    displayScans: 'displayScans',
    displayTexts: 'displayTexts',
    sources: 'sources',
    title: 'title',
    titleI18n: 'titleI18n',
    artifactCategoryId: 'artifactCategoryId'
  };

  export type ArtifactScalarFieldEnum = (typeof ArtifactScalarFieldEnum)[keyof typeof ArtifactScalarFieldEnum]


  export const PageTextScalarFieldEnum: {
    id: 'id',
    pageId: 'pageId',
    content: 'content',
    type: 'type',
    language: 'language',
    textAccuracy: 'textAccuracy',
    contributorId: 'contributorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PageTextScalarFieldEnum = (typeof PageTextScalarFieldEnum)[keyof typeof PageTextScalarFieldEnum]


  export const PageDataScalarFieldEnum: {
    id: 'id',
    pageId: 'pageId',
    ocrData: 'ocrData',
    updatedAt: 'updatedAt'
  };

  export type PageDataScalarFieldEnum = (typeof PageDataScalarFieldEnum)[keyof typeof PageDataScalarFieldEnum]


  export const PageImageScalarFieldEnum: {
    id: 'id',
    pageId: 'pageId',
    storageFileId: 'storageFileId',
    useType: 'useType',
    createdAt: 'createdAt'
  };

  export type PageImageScalarFieldEnum = (typeof PageImageScalarFieldEnum)[keyof typeof PageImageScalarFieldEnum]


  export const StorageFileScalarFieldEnum: {
    id: 'id',
    bucketName: 'bucketName',
    storageKey: 'storageKey',
    filename: 'filename',
    mimeType: 'mimeType',
    sizeBytes: 'sizeBytes',
    hashEtag: 'hashEtag',
    publicUrl: 'publicUrl',
    isPublic: 'isPublic',
    width: 'width',
    height: 'height',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StorageFileScalarFieldEnum = (typeof StorageFileScalarFieldEnum)[keyof typeof StorageFileScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    url: 'url',
    storageFileId: 'storageFileId',
    altTextI18n: 'altTextI18n',
    createdAt: 'createdAt'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const PlaceScalarFieldEnum: {
    id: 'id',
    geoname: 'geoname',
    geocode: 'geocode',
    lat: 'lat',
    lon: 'lon',
    countryCode: 'countryCode',
    admin1: 'admin1',
    admin2: 'admin2'
  };

  export type PlaceScalarFieldEnum = (typeof PlaceScalarFieldEnum)[keyof typeof PlaceScalarFieldEnum]


  export const AdministrativePlaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    year: 'year',
    source: 'source',
    admin1: 'admin1',
    admin2: 'admin2',
    jewishPop: 'jewishPop',
    totalPop: 'totalPop',
    placeId: 'placeId'
  };

  export type AdministrativePlaceScalarFieldEnum = (typeof AdministrativePlaceScalarFieldEnum)[keyof typeof AdministrativePlaceScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    nameI18n: 'nameI18n',
    createdAt: 'createdAt',
    name: 'name'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const RegionScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    nameI18n: 'nameI18n',
    createdAt: 'createdAt'
  };

  export type RegionScalarFieldEnum = (typeof RegionScalarFieldEnum)[keyof typeof RegionScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    thumbnailId: 'thumbnailId',
    createdAt: 'createdAt',
    titleI18n: 'titleI18n'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ArtifactCategoryScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    titleI18n: 'titleI18n',
    createdAt: 'createdAt'
  };

  export type ArtifactCategoryScalarFieldEnum = (typeof ArtifactCategoryScalarFieldEnum)[keyof typeof ArtifactCategoryScalarFieldEnum]


  export const PeriodScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    nameI18n: 'nameI18n',
    dateStart: 'dateStart',
    dateEnd: 'dateEnd',
    createdAt: 'createdAt'
  };

  export type PeriodScalarFieldEnum = (typeof PeriodScalarFieldEnum)[keyof typeof PeriodScalarFieldEnum]


  export const MenuScalarFieldEnum: {
    id: 'id',
    location: 'location',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MenuScalarFieldEnum = (typeof MenuScalarFieldEnum)[keyof typeof MenuScalarFieldEnum]


  export const MenuItemScalarFieldEnum: {
    id: 'id',
    menuId: 'menuId',
    parentId: 'parentId',
    label: 'label',
    labelI18n: 'labelI18n',
    icon: 'icon',
    variant: 'variant',
    order: 'order',
    pageId: 'pageId',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MenuItemScalarFieldEnum = (typeof MenuItemScalarFieldEnum)[keyof typeof MenuItemScalarFieldEnum]


  export const FooterColumnScalarFieldEnum: {
    id: 'id',
    type: 'type',
    order: 'order',
    title: 'title',
    titleI18n: 'titleI18n',
    content: 'content',
    contentI18n: 'contentI18n',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FooterColumnScalarFieldEnum = (typeof FooterColumnScalarFieldEnum)[keyof typeof FooterColumnScalarFieldEnum]


  export const FooterColumnItemScalarFieldEnum: {
    id: 'id',
    footerColumnId: 'footerColumnId',
    label: 'label',
    labelI18n: 'labelI18n',
    icon: 'icon',
    order: 'order',
    pageId: 'pageId',
    url: 'url',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FooterColumnItemScalarFieldEnum = (typeof FooterColumnItemScalarFieldEnum)[keyof typeof FooterColumnItemScalarFieldEnum]


  export const SiteSettingsScalarFieldEnum: {
    id: 'id',
    key: 'key',
    copyrightText: 'copyrightText',
    copyrightI18n: 'copyrightI18n',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SiteSettingsScalarFieldEnum = (typeof SiteSettingsScalarFieldEnum)[keyof typeof SiteSettingsScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    titleEn: 'titleEn',
    description: 'description',
    descriptionEn: 'descriptionEn',
    category: 'category',
    year: 'year',
    reference: 'reference',
    referenceUrl: 'referenceUrl',
    scanUrl: 'scanUrl',
    scanZip: 'scanZip',
    lang: 'lang',
    status: 'status',
    license: 'license',
    volume: 'volume',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const DocumentPageScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    index: 'index',
    content: 'content',
    contentHe: 'contentHe',
    contentEn: 'contentEn',
    filename: 'filename',
    bookmark: 'bookmark',
    highlights: 'highlights',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentPageScalarFieldEnum = (typeof DocumentPageScalarFieldEnum)[keyof typeof DocumentPageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'AppLanguage'
   */
  export type EnumAppLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppLanguage'>
    


  /**
   * Reference to a field of type 'AppLanguage[]'
   */
  export type ListEnumAppLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppLanguage[]'>
    


  /**
   * Reference to a field of type 'ContentStatus'
   */
  export type EnumContentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentStatus'>
    


  /**
   * Reference to a field of type 'ContentStatus[]'
   */
  export type ListEnumContentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DataMaturity'
   */
  export type EnumDataMaturityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataMaturity'>
    


  /**
   * Reference to a field of type 'DataMaturity[]'
   */
  export type ListEnumDataMaturityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DataMaturity[]'>
    


  /**
   * Reference to a field of type 'ResouceType'
   */
  export type EnumResouceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResouceType'>
    


  /**
   * Reference to a field of type 'ResouceType[]'
   */
  export type ListEnumResouceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResouceType[]'>
    


  /**
   * Reference to a field of type 'LayerType'
   */
  export type EnumLayerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LayerType'>
    


  /**
   * Reference to a field of type 'LayerType[]'
   */
  export type ListEnumLayerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LayerType[]'>
    


  /**
   * Reference to a field of type 'LayerSourceType'
   */
  export type EnumLayerSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LayerSourceType'>
    


  /**
   * Reference to a field of type 'LayerSourceType[]'
   */
  export type ListEnumLayerSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LayerSourceType[]'>
    


  /**
   * Reference to a field of type 'ContentLanguage[]'
   */
  export type ListEnumContentLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentLanguage[]'>
    


  /**
   * Reference to a field of type 'ContentLanguage'
   */
  export type EnumContentLanguageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentLanguage'>
    


  /**
   * Reference to a field of type 'TextType'
   */
  export type EnumTextTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TextType'>
    


  /**
   * Reference to a field of type 'TextType[]'
   */
  export type ListEnumTextTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TextType[]'>
    


  /**
   * Reference to a field of type 'ImageUseType'
   */
  export type EnumImageUseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImageUseType'>
    


  /**
   * Reference to a field of type 'ImageUseType[]'
   */
  export type ListEnumImageUseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImageUseType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'MenuLocation'
   */
  export type EnumMenuLocationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MenuLocation'>
    


  /**
   * Reference to a field of type 'MenuLocation[]'
   */
  export type ListEnumMenuLocationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MenuLocation[]'>
    


  /**
   * Reference to a field of type 'ItemVariant'
   */
  export type EnumItemVariantFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemVariant'>
    


  /**
   * Reference to a field of type 'ItemVariant[]'
   */
  export type ListEnumItemVariantFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemVariant[]'>
    


  /**
   * Reference to a field of type 'MenuType'
   */
  export type EnumMenuTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MenuType'>
    


  /**
   * Reference to a field of type 'MenuType[]'
   */
  export type ListEnumMenuTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MenuType[]'>
    
  /**
   * Deep Input Types
   */


  export type PageWhereInput = {
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    id?: UuidFilter<"Page"> | string
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
    title?: StringFilter<"Page"> | string
    slug?: StringFilter<"Page"> | string
    content?: StringNullableFilter<"Page"> | string | null
    excerpt?: StringNullableFilter<"Page"> | string | null
    sources?: StringNullableFilter<"Page"> | string | null
    citations?: StringNullableFilter<"Page"> | string | null
    language?: EnumAppLanguageFilter<"Page"> | $Enums.AppLanguage
    translationGroupId?: UuidNullableFilter<"Page"> | string | null
    status?: EnumContentStatusFilter<"Page"> | $Enums.ContentStatus
    authorId?: UuidNullableFilter<"Page"> | string | null
    parentId?: UuidNullableFilter<"Page"> | string | null
    metaDescription?: StringNullableFilter<"Page"> | string | null
    metaKeywords?: StringNullableFilter<"Page"> | string | null
    thumbnailId?: UuidNullableFilter<"Page"> | string | null
    template?: StringNullableFilter<"Page"> | string | null
    menuOrder?: IntFilter<"Page"> | number
    showInMenu?: BoolFilter<"Page"> | boolean
    author?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    parent?: XOR<PageNullableScalarRelationFilter, PageWhereInput> | null
    children?: PageListRelationFilter
    thumbnail?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    regions?: RegionListRelationFilter
    tags?: TagListRelationFilter
    menuItems?: MenuItemListRelationFilter
    footerItems?: FooterColumnItemListRelationFilter
  }

  export type PageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrderInput | SortOrder
    excerpt?: SortOrderInput | SortOrder
    sources?: SortOrderInput | SortOrder
    citations?: SortOrderInput | SortOrder
    language?: SortOrder
    translationGroupId?: SortOrderInput | SortOrder
    status?: SortOrder
    authorId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrderInput | SortOrder
    thumbnailId?: SortOrderInput | SortOrder
    template?: SortOrderInput | SortOrder
    menuOrder?: SortOrder
    showInMenu?: SortOrder
    author?: UserOrderByWithRelationInput
    parent?: PageOrderByWithRelationInput
    children?: PageOrderByRelationAggregateInput
    thumbnail?: MediaOrderByWithRelationInput
    regions?: RegionOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    menuItems?: MenuItemOrderByRelationAggregateInput
    footerItems?: FooterColumnItemOrderByRelationAggregateInput
  }

  export type PageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
    title?: StringFilter<"Page"> | string
    content?: StringNullableFilter<"Page"> | string | null
    excerpt?: StringNullableFilter<"Page"> | string | null
    sources?: StringNullableFilter<"Page"> | string | null
    citations?: StringNullableFilter<"Page"> | string | null
    language?: EnumAppLanguageFilter<"Page"> | $Enums.AppLanguage
    translationGroupId?: UuidNullableFilter<"Page"> | string | null
    status?: EnumContentStatusFilter<"Page"> | $Enums.ContentStatus
    authorId?: UuidNullableFilter<"Page"> | string | null
    parentId?: UuidNullableFilter<"Page"> | string | null
    metaDescription?: StringNullableFilter<"Page"> | string | null
    metaKeywords?: StringNullableFilter<"Page"> | string | null
    thumbnailId?: UuidNullableFilter<"Page"> | string | null
    template?: StringNullableFilter<"Page"> | string | null
    menuOrder?: IntFilter<"Page"> | number
    showInMenu?: BoolFilter<"Page"> | boolean
    author?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    parent?: XOR<PageNullableScalarRelationFilter, PageWhereInput> | null
    children?: PageListRelationFilter
    thumbnail?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    regions?: RegionListRelationFilter
    tags?: TagListRelationFilter
    menuItems?: MenuItemListRelationFilter
    footerItems?: FooterColumnItemListRelationFilter
  }, "id" | "slug">

  export type PageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrderInput | SortOrder
    excerpt?: SortOrderInput | SortOrder
    sources?: SortOrderInput | SortOrder
    citations?: SortOrderInput | SortOrder
    language?: SortOrder
    translationGroupId?: SortOrderInput | SortOrder
    status?: SortOrder
    authorId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    metaKeywords?: SortOrderInput | SortOrder
    thumbnailId?: SortOrderInput | SortOrder
    template?: SortOrderInput | SortOrder
    menuOrder?: SortOrder
    showInMenu?: SortOrder
    _count?: PageCountOrderByAggregateInput
    _avg?: PageAvgOrderByAggregateInput
    _max?: PageMaxOrderByAggregateInput
    _min?: PageMinOrderByAggregateInput
    _sum?: PageSumOrderByAggregateInput
  }

  export type PageScalarWhereWithAggregatesInput = {
    AND?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    OR?: PageScalarWhereWithAggregatesInput[]
    NOT?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Page"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Page"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Page"> | Date | string
    title?: StringWithAggregatesFilter<"Page"> | string
    slug?: StringWithAggregatesFilter<"Page"> | string
    content?: StringNullableWithAggregatesFilter<"Page"> | string | null
    excerpt?: StringNullableWithAggregatesFilter<"Page"> | string | null
    sources?: StringNullableWithAggregatesFilter<"Page"> | string | null
    citations?: StringNullableWithAggregatesFilter<"Page"> | string | null
    language?: EnumAppLanguageWithAggregatesFilter<"Page"> | $Enums.AppLanguage
    translationGroupId?: UuidNullableWithAggregatesFilter<"Page"> | string | null
    status?: EnumContentStatusWithAggregatesFilter<"Page"> | $Enums.ContentStatus
    authorId?: UuidNullableWithAggregatesFilter<"Page"> | string | null
    parentId?: UuidNullableWithAggregatesFilter<"Page"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"Page"> | string | null
    metaKeywords?: StringNullableWithAggregatesFilter<"Page"> | string | null
    thumbnailId?: UuidNullableWithAggregatesFilter<"Page"> | string | null
    template?: StringNullableWithAggregatesFilter<"Page"> | string | null
    menuOrder?: IntWithAggregatesFilter<"Page"> | number
    showInMenu?: BoolWithAggregatesFilter<"Page"> | boolean
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: UuidFilter<"Post"> | string
    translationGroupId?: UuidFilter<"Post"> | string
    language?: EnumAppLanguageFilter<"Post"> | $Enums.AppLanguage
    title?: StringFilter<"Post"> | string
    slug?: StringFilter<"Post"> | string
    content?: StringNullableFilter<"Post"> | string | null
    sources?: StringNullableFilter<"Post"> | string | null
    excerpt?: StringNullableFilter<"Post"> | string | null
    status?: EnumContentStatusFilter<"Post"> | $Enums.ContentStatus
    authorId?: UuidNullableFilter<"Post"> | string | null
    thumbnailId?: UuidNullableFilter<"Post"> | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    tags?: PostTagListRelationFilter
    author?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    thumbnail?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    categories?: CategoryListRelationFilter
    regions?: RegionListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    translationGroupId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrderInput | SortOrder
    sources?: SortOrderInput | SortOrder
    excerpt?: SortOrderInput | SortOrder
    status?: SortOrder
    authorId?: SortOrderInput | SortOrder
    thumbnailId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tags?: PostTagOrderByRelationAggregateInput
    author?: UserOrderByWithRelationInput
    thumbnail?: MediaOrderByWithRelationInput
    categories?: CategoryOrderByRelationAggregateInput
    regions?: RegionOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    translationGroupId?: UuidFilter<"Post"> | string
    language?: EnumAppLanguageFilter<"Post"> | $Enums.AppLanguage
    title?: StringFilter<"Post"> | string
    content?: StringNullableFilter<"Post"> | string | null
    sources?: StringNullableFilter<"Post"> | string | null
    excerpt?: StringNullableFilter<"Post"> | string | null
    status?: EnumContentStatusFilter<"Post"> | $Enums.ContentStatus
    authorId?: UuidNullableFilter<"Post"> | string | null
    thumbnailId?: UuidNullableFilter<"Post"> | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    tags?: PostTagListRelationFilter
    author?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    thumbnail?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    categories?: CategoryListRelationFilter
    regions?: RegionListRelationFilter
  }, "id" | "slug">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    translationGroupId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrderInput | SortOrder
    sources?: SortOrderInput | SortOrder
    excerpt?: SortOrderInput | SortOrder
    status?: SortOrder
    authorId?: SortOrderInput | SortOrder
    thumbnailId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Post"> | string
    translationGroupId?: UuidWithAggregatesFilter<"Post"> | string
    language?: EnumAppLanguageWithAggregatesFilter<"Post"> | $Enums.AppLanguage
    title?: StringWithAggregatesFilter<"Post"> | string
    slug?: StringWithAggregatesFilter<"Post"> | string
    content?: StringNullableWithAggregatesFilter<"Post"> | string | null
    sources?: StringNullableWithAggregatesFilter<"Post"> | string | null
    excerpt?: StringNullableWithAggregatesFilter<"Post"> | string | null
    status?: EnumContentStatusWithAggregatesFilter<"Post"> | $Enums.ContentStatus
    authorId?: UuidNullableWithAggregatesFilter<"Post"> | string | null
    thumbnailId?: UuidNullableWithAggregatesFilter<"Post"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
  }

  export type PostTagWhereInput = {
    AND?: PostTagWhereInput | PostTagWhereInput[]
    OR?: PostTagWhereInput[]
    NOT?: PostTagWhereInput | PostTagWhereInput[]
    postId?: UuidFilter<"PostTag"> | string
    tagId?: UuidFilter<"PostTag"> | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type PostTagOrderByWithRelationInput = {
    postId?: SortOrder
    tagId?: SortOrder
    post?: PostOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type PostTagWhereUniqueInput = Prisma.AtLeast<{
    postId_tagId?: PostTagPostIdTagIdCompoundUniqueInput
    AND?: PostTagWhereInput | PostTagWhereInput[]
    OR?: PostTagWhereInput[]
    NOT?: PostTagWhereInput | PostTagWhereInput[]
    postId?: UuidFilter<"PostTag"> | string
    tagId?: UuidFilter<"PostTag"> | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "postId_tagId">

  export type PostTagOrderByWithAggregationInput = {
    postId?: SortOrder
    tagId?: SortOrder
    _count?: PostTagCountOrderByAggregateInput
    _max?: PostTagMaxOrderByAggregateInput
    _min?: PostTagMinOrderByAggregateInput
  }

  export type PostTagScalarWhereWithAggregatesInput = {
    AND?: PostTagScalarWhereWithAggregatesInput | PostTagScalarWhereWithAggregatesInput[]
    OR?: PostTagScalarWhereWithAggregatesInput[]
    NOT?: PostTagScalarWhereWithAggregatesInput | PostTagScalarWhereWithAggregatesInput[]
    postId?: UuidWithAggregatesFilter<"PostTag"> | string
    tagId?: UuidWithAggregatesFilter<"PostTag"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    accounts?: AccountListRelationFilter
    pageTexts?: PageTextListRelationFilter
    pages?: PageListRelationFilter
    posts?: PostListRelationFilter
    sessions?: SessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    pageTexts?: PageTextOrderByRelationAggregateInput
    pages?: PageOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    accounts?: AccountListRelationFilter
    pageTexts?: PageTextListRelationFilter
    pages?: PageListRelationFilter
    posts?: PostListRelationFilter
    sessions?: SessionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: UuidFilter<"Account"> | string
    userId?: UuidFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: UuidFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Account"> | string
    userId?: UuidWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: UuidFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: UuidFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: UuidFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: UuidWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type ResearchDatasetWhereInput = {
    AND?: ResearchDatasetWhereInput | ResearchDatasetWhereInput[]
    OR?: ResearchDatasetWhereInput[]
    NOT?: ResearchDatasetWhereInput | ResearchDatasetWhereInput[]
    id?: UuidFilter<"ResearchDataset"> | string
    slug?: StringFilter<"ResearchDataset"> | string
    titleI18n?: JsonNullableFilter<"ResearchDataset">
    codebookTextI18n?: JsonNullableFilter<"ResearchDataset">
    status?: EnumContentStatusFilter<"ResearchDataset"> | $Enums.ContentStatus
    maturity?: EnumDataMaturityFilter<"ResearchDataset"> | $Enums.DataMaturity
    version?: StringNullableFilter<"ResearchDataset"> | string | null
    license?: StringNullableFilter<"ResearchDataset"> | string | null
    thumbnailId?: UuidNullableFilter<"ResearchDataset"> | string | null
    createdAt?: DateTimeFilter<"ResearchDataset"> | Date | string
    updatedAt?: DateTimeFilter<"ResearchDataset"> | Date | string
    description?: StringNullableFilter<"ResearchDataset"> | string | null
    title?: StringFilter<"ResearchDataset"> | string
    categoryId?: UuidNullableFilter<"ResearchDataset"> | string | null
    citationText?: StringNullableFilter<"ResearchDataset"> | string | null
    codebookText?: StringNullableFilter<"ResearchDataset"> | string | null
    maxYear?: IntNullableFilter<"ResearchDataset"> | number | null
    minYear?: IntNullableFilter<"ResearchDataset"> | number | null
    sources?: StringNullableFilter<"ResearchDataset"> | string | null
    isVisible?: BoolFilter<"ResearchDataset"> | boolean
    sourcesI18n?: JsonNullableFilter<"ResearchDataset">
    descriptionI18n?: JsonNullableFilter<"ResearchDataset">
    resources?: DatasetResourceListRelationFilter
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    thumbnail?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    regions?: RegionListRelationFilter
  }

  export type ResearchDatasetOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    titleI18n?: SortOrderInput | SortOrder
    codebookTextI18n?: SortOrderInput | SortOrder
    status?: SortOrder
    maturity?: SortOrder
    version?: SortOrderInput | SortOrder
    license?: SortOrderInput | SortOrder
    thumbnailId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrderInput | SortOrder
    title?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    citationText?: SortOrderInput | SortOrder
    codebookText?: SortOrderInput | SortOrder
    maxYear?: SortOrderInput | SortOrder
    minYear?: SortOrderInput | SortOrder
    sources?: SortOrderInput | SortOrder
    isVisible?: SortOrder
    sourcesI18n?: SortOrderInput | SortOrder
    descriptionI18n?: SortOrderInput | SortOrder
    resources?: DatasetResourceOrderByRelationAggregateInput
    category?: CategoryOrderByWithRelationInput
    thumbnail?: MediaOrderByWithRelationInput
    regions?: RegionOrderByRelationAggregateInput
  }

  export type ResearchDatasetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ResearchDatasetWhereInput | ResearchDatasetWhereInput[]
    OR?: ResearchDatasetWhereInput[]
    NOT?: ResearchDatasetWhereInput | ResearchDatasetWhereInput[]
    titleI18n?: JsonNullableFilter<"ResearchDataset">
    codebookTextI18n?: JsonNullableFilter<"ResearchDataset">
    status?: EnumContentStatusFilter<"ResearchDataset"> | $Enums.ContentStatus
    maturity?: EnumDataMaturityFilter<"ResearchDataset"> | $Enums.DataMaturity
    version?: StringNullableFilter<"ResearchDataset"> | string | null
    license?: StringNullableFilter<"ResearchDataset"> | string | null
    thumbnailId?: UuidNullableFilter<"ResearchDataset"> | string | null
    createdAt?: DateTimeFilter<"ResearchDataset"> | Date | string
    updatedAt?: DateTimeFilter<"ResearchDataset"> | Date | string
    description?: StringNullableFilter<"ResearchDataset"> | string | null
    title?: StringFilter<"ResearchDataset"> | string
    categoryId?: UuidNullableFilter<"ResearchDataset"> | string | null
    citationText?: StringNullableFilter<"ResearchDataset"> | string | null
    codebookText?: StringNullableFilter<"ResearchDataset"> | string | null
    maxYear?: IntNullableFilter<"ResearchDataset"> | number | null
    minYear?: IntNullableFilter<"ResearchDataset"> | number | null
    sources?: StringNullableFilter<"ResearchDataset"> | string | null
    isVisible?: BoolFilter<"ResearchDataset"> | boolean
    sourcesI18n?: JsonNullableFilter<"ResearchDataset">
    descriptionI18n?: JsonNullableFilter<"ResearchDataset">
    resources?: DatasetResourceListRelationFilter
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    thumbnail?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    regions?: RegionListRelationFilter
  }, "id" | "slug">

  export type ResearchDatasetOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    titleI18n?: SortOrderInput | SortOrder
    codebookTextI18n?: SortOrderInput | SortOrder
    status?: SortOrder
    maturity?: SortOrder
    version?: SortOrderInput | SortOrder
    license?: SortOrderInput | SortOrder
    thumbnailId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrderInput | SortOrder
    title?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    citationText?: SortOrderInput | SortOrder
    codebookText?: SortOrderInput | SortOrder
    maxYear?: SortOrderInput | SortOrder
    minYear?: SortOrderInput | SortOrder
    sources?: SortOrderInput | SortOrder
    isVisible?: SortOrder
    sourcesI18n?: SortOrderInput | SortOrder
    descriptionI18n?: SortOrderInput | SortOrder
    _count?: ResearchDatasetCountOrderByAggregateInput
    _avg?: ResearchDatasetAvgOrderByAggregateInput
    _max?: ResearchDatasetMaxOrderByAggregateInput
    _min?: ResearchDatasetMinOrderByAggregateInput
    _sum?: ResearchDatasetSumOrderByAggregateInput
  }

  export type ResearchDatasetScalarWhereWithAggregatesInput = {
    AND?: ResearchDatasetScalarWhereWithAggregatesInput | ResearchDatasetScalarWhereWithAggregatesInput[]
    OR?: ResearchDatasetScalarWhereWithAggregatesInput[]
    NOT?: ResearchDatasetScalarWhereWithAggregatesInput | ResearchDatasetScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ResearchDataset"> | string
    slug?: StringWithAggregatesFilter<"ResearchDataset"> | string
    titleI18n?: JsonNullableWithAggregatesFilter<"ResearchDataset">
    codebookTextI18n?: JsonNullableWithAggregatesFilter<"ResearchDataset">
    status?: EnumContentStatusWithAggregatesFilter<"ResearchDataset"> | $Enums.ContentStatus
    maturity?: EnumDataMaturityWithAggregatesFilter<"ResearchDataset"> | $Enums.DataMaturity
    version?: StringNullableWithAggregatesFilter<"ResearchDataset"> | string | null
    license?: StringNullableWithAggregatesFilter<"ResearchDataset"> | string | null
    thumbnailId?: UuidNullableWithAggregatesFilter<"ResearchDataset"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ResearchDataset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ResearchDataset"> | Date | string
    description?: StringNullableWithAggregatesFilter<"ResearchDataset"> | string | null
    title?: StringWithAggregatesFilter<"ResearchDataset"> | string
    categoryId?: UuidNullableWithAggregatesFilter<"ResearchDataset"> | string | null
    citationText?: StringNullableWithAggregatesFilter<"ResearchDataset"> | string | null
    codebookText?: StringNullableWithAggregatesFilter<"ResearchDataset"> | string | null
    maxYear?: IntNullableWithAggregatesFilter<"ResearchDataset"> | number | null
    minYear?: IntNullableWithAggregatesFilter<"ResearchDataset"> | number | null
    sources?: StringNullableWithAggregatesFilter<"ResearchDataset"> | string | null
    isVisible?: BoolWithAggregatesFilter<"ResearchDataset"> | boolean
    sourcesI18n?: JsonNullableWithAggregatesFilter<"ResearchDataset">
    descriptionI18n?: JsonNullableWithAggregatesFilter<"ResearchDataset">
  }

  export type DatasetResourceWhereInput = {
    AND?: DatasetResourceWhereInput | DatasetResourceWhereInput[]
    OR?: DatasetResourceWhereInput[]
    NOT?: DatasetResourceWhereInput | DatasetResourceWhereInput[]
    id?: UuidFilter<"DatasetResource"> | string
    datasetId?: UuidNullableFilter<"DatasetResource"> | string | null
    url?: StringFilter<"DatasetResource"> | string
    isMainFile?: BoolFilter<"DatasetResource"> | boolean
    createdAt?: DateTimeFilter<"DatasetResource"> | Date | string
    name?: StringFilter<"DatasetResource"> | string
    slug?: StringFilter<"DatasetResource"> | string
    format?: EnumResouceTypeFilter<"DatasetResource"> | $Enums.ResouceType
    filename?: StringNullableFilter<"DatasetResource"> | string | null
    mimeType?: StringNullableFilter<"DatasetResource"> | string | null
    excerptI18n?: JsonNullableFilter<"DatasetResource">
    mapId?: UuidNullableFilter<"DatasetResource"> | string | null
    dataset?: XOR<ResearchDatasetNullableScalarRelationFilter, ResearchDatasetWhereInput> | null
    map?: XOR<MapNullableScalarRelationFilter, MapWhereInput> | null
  }

  export type DatasetResourceOrderByWithRelationInput = {
    id?: SortOrder
    datasetId?: SortOrderInput | SortOrder
    url?: SortOrder
    isMainFile?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    format?: SortOrder
    filename?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    excerptI18n?: SortOrderInput | SortOrder
    mapId?: SortOrderInput | SortOrder
    dataset?: ResearchDatasetOrderByWithRelationInput
    map?: MapOrderByWithRelationInput
  }

  export type DatasetResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: DatasetResourceWhereInput | DatasetResourceWhereInput[]
    OR?: DatasetResourceWhereInput[]
    NOT?: DatasetResourceWhereInput | DatasetResourceWhereInput[]
    datasetId?: UuidNullableFilter<"DatasetResource"> | string | null
    url?: StringFilter<"DatasetResource"> | string
    isMainFile?: BoolFilter<"DatasetResource"> | boolean
    createdAt?: DateTimeFilter<"DatasetResource"> | Date | string
    name?: StringFilter<"DatasetResource"> | string
    format?: EnumResouceTypeFilter<"DatasetResource"> | $Enums.ResouceType
    filename?: StringNullableFilter<"DatasetResource"> | string | null
    mimeType?: StringNullableFilter<"DatasetResource"> | string | null
    excerptI18n?: JsonNullableFilter<"DatasetResource">
    mapId?: UuidNullableFilter<"DatasetResource"> | string | null
    dataset?: XOR<ResearchDatasetNullableScalarRelationFilter, ResearchDatasetWhereInput> | null
    map?: XOR<MapNullableScalarRelationFilter, MapWhereInput> | null
  }, "id" | "slug">

  export type DatasetResourceOrderByWithAggregationInput = {
    id?: SortOrder
    datasetId?: SortOrderInput | SortOrder
    url?: SortOrder
    isMainFile?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    format?: SortOrder
    filename?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    excerptI18n?: SortOrderInput | SortOrder
    mapId?: SortOrderInput | SortOrder
    _count?: DatasetResourceCountOrderByAggregateInput
    _max?: DatasetResourceMaxOrderByAggregateInput
    _min?: DatasetResourceMinOrderByAggregateInput
  }

  export type DatasetResourceScalarWhereWithAggregatesInput = {
    AND?: DatasetResourceScalarWhereWithAggregatesInput | DatasetResourceScalarWhereWithAggregatesInput[]
    OR?: DatasetResourceScalarWhereWithAggregatesInput[]
    NOT?: DatasetResourceScalarWhereWithAggregatesInput | DatasetResourceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"DatasetResource"> | string
    datasetId?: UuidNullableWithAggregatesFilter<"DatasetResource"> | string | null
    url?: StringWithAggregatesFilter<"DatasetResource"> | string
    isMainFile?: BoolWithAggregatesFilter<"DatasetResource"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DatasetResource"> | Date | string
    name?: StringWithAggregatesFilter<"DatasetResource"> | string
    slug?: StringWithAggregatesFilter<"DatasetResource"> | string
    format?: EnumResouceTypeWithAggregatesFilter<"DatasetResource"> | $Enums.ResouceType
    filename?: StringNullableWithAggregatesFilter<"DatasetResource"> | string | null
    mimeType?: StringNullableWithAggregatesFilter<"DatasetResource"> | string | null
    excerptI18n?: JsonNullableWithAggregatesFilter<"DatasetResource">
    mapId?: UuidNullableWithAggregatesFilter<"DatasetResource"> | string | null
  }

  export type MapWhereInput = {
    AND?: MapWhereInput | MapWhereInput[]
    OR?: MapWhereInput[]
    NOT?: MapWhereInput | MapWhereInput[]
    id?: UuidFilter<"Map"> | string
    slug?: StringFilter<"Map"> | string
    titleI18n?: JsonNullableFilter<"Map">
    descriptionI18n?: JsonNullableFilter<"Map">
    year?: IntNullableFilter<"Map"> | number | null
    version?: StringNullableFilter<"Map"> | string | null
    thumbnailId?: UuidNullableFilter<"Map"> | string | null
    config?: JsonNullableFilter<"Map">
    globalStyleConfig?: JsonNullableFilter<"Map">
    referenceLinks?: JsonNullableFilter<"Map">
    createdAt?: DateTimeFilter<"Map"> | Date | string
    updatedAt?: DateTimeFilter<"Map"> | Date | string
    description?: StringNullableFilter<"Map"> | string | null
    period?: StringNullableFilter<"Map"> | string | null
    title?: StringFilter<"Map"> | string
    yearMax?: IntNullableFilter<"Map"> | number | null
    yearMin?: IntNullableFilter<"Map"> | number | null
    categoryId?: UuidNullableFilter<"Map"> | string | null
    status?: EnumContentStatusFilter<"Map"> | $Enums.ContentStatus
    resources?: DatasetResourceListRelationFilter
    layers?: MapLayerAssociationListRelationFilter
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    thumbnail?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    regions?: RegionListRelationFilter
    tags?: TagListRelationFilter
  }

  export type MapOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    titleI18n?: SortOrderInput | SortOrder
    descriptionI18n?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    thumbnailId?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    globalStyleConfig?: SortOrderInput | SortOrder
    referenceLinks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrderInput | SortOrder
    period?: SortOrderInput | SortOrder
    title?: SortOrder
    yearMax?: SortOrderInput | SortOrder
    yearMin?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    status?: SortOrder
    resources?: DatasetResourceOrderByRelationAggregateInput
    layers?: MapLayerAssociationOrderByRelationAggregateInput
    category?: CategoryOrderByWithRelationInput
    thumbnail?: MediaOrderByWithRelationInput
    regions?: RegionOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
  }

  export type MapWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: MapWhereInput | MapWhereInput[]
    OR?: MapWhereInput[]
    NOT?: MapWhereInput | MapWhereInput[]
    titleI18n?: JsonNullableFilter<"Map">
    descriptionI18n?: JsonNullableFilter<"Map">
    year?: IntNullableFilter<"Map"> | number | null
    version?: StringNullableFilter<"Map"> | string | null
    thumbnailId?: UuidNullableFilter<"Map"> | string | null
    config?: JsonNullableFilter<"Map">
    globalStyleConfig?: JsonNullableFilter<"Map">
    referenceLinks?: JsonNullableFilter<"Map">
    createdAt?: DateTimeFilter<"Map"> | Date | string
    updatedAt?: DateTimeFilter<"Map"> | Date | string
    description?: StringNullableFilter<"Map"> | string | null
    period?: StringNullableFilter<"Map"> | string | null
    title?: StringFilter<"Map"> | string
    yearMax?: IntNullableFilter<"Map"> | number | null
    yearMin?: IntNullableFilter<"Map"> | number | null
    categoryId?: UuidNullableFilter<"Map"> | string | null
    status?: EnumContentStatusFilter<"Map"> | $Enums.ContentStatus
    resources?: DatasetResourceListRelationFilter
    layers?: MapLayerAssociationListRelationFilter
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    thumbnail?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    regions?: RegionListRelationFilter
    tags?: TagListRelationFilter
  }, "id" | "slug">

  export type MapOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    titleI18n?: SortOrderInput | SortOrder
    descriptionI18n?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    version?: SortOrderInput | SortOrder
    thumbnailId?: SortOrderInput | SortOrder
    config?: SortOrderInput | SortOrder
    globalStyleConfig?: SortOrderInput | SortOrder
    referenceLinks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrderInput | SortOrder
    period?: SortOrderInput | SortOrder
    title?: SortOrder
    yearMax?: SortOrderInput | SortOrder
    yearMin?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: MapCountOrderByAggregateInput
    _avg?: MapAvgOrderByAggregateInput
    _max?: MapMaxOrderByAggregateInput
    _min?: MapMinOrderByAggregateInput
    _sum?: MapSumOrderByAggregateInput
  }

  export type MapScalarWhereWithAggregatesInput = {
    AND?: MapScalarWhereWithAggregatesInput | MapScalarWhereWithAggregatesInput[]
    OR?: MapScalarWhereWithAggregatesInput[]
    NOT?: MapScalarWhereWithAggregatesInput | MapScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Map"> | string
    slug?: StringWithAggregatesFilter<"Map"> | string
    titleI18n?: JsonNullableWithAggregatesFilter<"Map">
    descriptionI18n?: JsonNullableWithAggregatesFilter<"Map">
    year?: IntNullableWithAggregatesFilter<"Map"> | number | null
    version?: StringNullableWithAggregatesFilter<"Map"> | string | null
    thumbnailId?: UuidNullableWithAggregatesFilter<"Map"> | string | null
    config?: JsonNullableWithAggregatesFilter<"Map">
    globalStyleConfig?: JsonNullableWithAggregatesFilter<"Map">
    referenceLinks?: JsonNullableWithAggregatesFilter<"Map">
    createdAt?: DateTimeWithAggregatesFilter<"Map"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Map"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Map"> | string | null
    period?: StringNullableWithAggregatesFilter<"Map"> | string | null
    title?: StringWithAggregatesFilter<"Map"> | string
    yearMax?: IntNullableWithAggregatesFilter<"Map"> | number | null
    yearMin?: IntNullableWithAggregatesFilter<"Map"> | number | null
    categoryId?: UuidNullableWithAggregatesFilter<"Map"> | string | null
    status?: EnumContentStatusWithAggregatesFilter<"Map"> | $Enums.ContentStatus
  }

  export type LayerWhereInput = {
    AND?: LayerWhereInput | LayerWhereInput[]
    OR?: LayerWhereInput[]
    NOT?: LayerWhereInput | LayerWhereInput[]
    id?: UuidFilter<"Layer"> | string
    slug?: StringFilter<"Layer"> | string
    name?: StringFilter<"Layer"> | string
    nameI18n?: JsonNullableFilter<"Layer">
    description?: StringNullableFilter<"Layer"> | string | null
    descriptionI18n?: JsonNullableFilter<"Layer">
    filename?: StringNullableFilter<"Layer"> | string | null
    status?: EnumContentStatusFilter<"Layer"> | $Enums.ContentStatus
    version?: StringNullableFilter<"Layer"> | string | null
    categoryId?: UuidNullableFilter<"Layer"> | string | null
    type?: EnumLayerTypeFilter<"Layer"> | $Enums.LayerType
    citationText?: StringNullableFilter<"Layer"> | string | null
    citationTextI18n?: JsonNullableFilter<"Layer">
    codebookText?: StringNullableFilter<"Layer"> | string | null
    codebookTextI18n?: JsonNullableFilter<"Layer">
    sources?: StringNullableFilter<"Layer"> | string | null
    sourcesI18n?: JsonNullableFilter<"Layer">
    license?: StringNullableFilter<"Layer"> | string | null
    maturity?: EnumDataMaturityFilter<"Layer"> | $Enums.DataMaturity
    minYear?: IntNullableFilter<"Layer"> | number | null
    maxYear?: IntNullableFilter<"Layer"> | number | null
    sourceType?: EnumLayerSourceTypeFilter<"Layer"> | $Enums.LayerSourceType
    sourceUrl?: StringNullableFilter<"Layer"> | string | null
    downloadUrl?: StringNullableFilter<"Layer"> | string | null
    geoJsonData?: JsonNullableFilter<"Layer">
    styleConfig?: JsonFilter<"Layer">
    thumbnail?: StringNullableFilter<"Layer"> | string | null
    createdAt?: DateTimeFilter<"Layer"> | Date | string
    updatedAt?: DateTimeFilter<"Layer"> | Date | string
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    maps?: MapLayerAssociationListRelationFilter
    regions?: RegionListRelationFilter
    tags?: TagListRelationFilter
  }

  export type LayerOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    nameI18n?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    descriptionI18n?: SortOrderInput | SortOrder
    filename?: SortOrderInput | SortOrder
    status?: SortOrder
    version?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    type?: SortOrder
    citationText?: SortOrderInput | SortOrder
    citationTextI18n?: SortOrderInput | SortOrder
    codebookText?: SortOrderInput | SortOrder
    codebookTextI18n?: SortOrderInput | SortOrder
    sources?: SortOrderInput | SortOrder
    sourcesI18n?: SortOrderInput | SortOrder
    license?: SortOrderInput | SortOrder
    maturity?: SortOrder
    minYear?: SortOrderInput | SortOrder
    maxYear?: SortOrderInput | SortOrder
    sourceType?: SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    downloadUrl?: SortOrderInput | SortOrder
    geoJsonData?: SortOrderInput | SortOrder
    styleConfig?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: CategoryOrderByWithRelationInput
    maps?: MapLayerAssociationOrderByRelationAggregateInput
    regions?: RegionOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
  }

  export type LayerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: LayerWhereInput | LayerWhereInput[]
    OR?: LayerWhereInput[]
    NOT?: LayerWhereInput | LayerWhereInput[]
    name?: StringFilter<"Layer"> | string
    nameI18n?: JsonNullableFilter<"Layer">
    description?: StringNullableFilter<"Layer"> | string | null
    descriptionI18n?: JsonNullableFilter<"Layer">
    filename?: StringNullableFilter<"Layer"> | string | null
    status?: EnumContentStatusFilter<"Layer"> | $Enums.ContentStatus
    version?: StringNullableFilter<"Layer"> | string | null
    categoryId?: UuidNullableFilter<"Layer"> | string | null
    type?: EnumLayerTypeFilter<"Layer"> | $Enums.LayerType
    citationText?: StringNullableFilter<"Layer"> | string | null
    citationTextI18n?: JsonNullableFilter<"Layer">
    codebookText?: StringNullableFilter<"Layer"> | string | null
    codebookTextI18n?: JsonNullableFilter<"Layer">
    sources?: StringNullableFilter<"Layer"> | string | null
    sourcesI18n?: JsonNullableFilter<"Layer">
    license?: StringNullableFilter<"Layer"> | string | null
    maturity?: EnumDataMaturityFilter<"Layer"> | $Enums.DataMaturity
    minYear?: IntNullableFilter<"Layer"> | number | null
    maxYear?: IntNullableFilter<"Layer"> | number | null
    sourceType?: EnumLayerSourceTypeFilter<"Layer"> | $Enums.LayerSourceType
    sourceUrl?: StringNullableFilter<"Layer"> | string | null
    downloadUrl?: StringNullableFilter<"Layer"> | string | null
    geoJsonData?: JsonNullableFilter<"Layer">
    styleConfig?: JsonFilter<"Layer">
    thumbnail?: StringNullableFilter<"Layer"> | string | null
    createdAt?: DateTimeFilter<"Layer"> | Date | string
    updatedAt?: DateTimeFilter<"Layer"> | Date | string
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    maps?: MapLayerAssociationListRelationFilter
    regions?: RegionListRelationFilter
    tags?: TagListRelationFilter
  }, "id" | "slug">

  export type LayerOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    nameI18n?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    descriptionI18n?: SortOrderInput | SortOrder
    filename?: SortOrderInput | SortOrder
    status?: SortOrder
    version?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    type?: SortOrder
    citationText?: SortOrderInput | SortOrder
    citationTextI18n?: SortOrderInput | SortOrder
    codebookText?: SortOrderInput | SortOrder
    codebookTextI18n?: SortOrderInput | SortOrder
    sources?: SortOrderInput | SortOrder
    sourcesI18n?: SortOrderInput | SortOrder
    license?: SortOrderInput | SortOrder
    maturity?: SortOrder
    minYear?: SortOrderInput | SortOrder
    maxYear?: SortOrderInput | SortOrder
    sourceType?: SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    downloadUrl?: SortOrderInput | SortOrder
    geoJsonData?: SortOrderInput | SortOrder
    styleConfig?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LayerCountOrderByAggregateInput
    _avg?: LayerAvgOrderByAggregateInput
    _max?: LayerMaxOrderByAggregateInput
    _min?: LayerMinOrderByAggregateInput
    _sum?: LayerSumOrderByAggregateInput
  }

  export type LayerScalarWhereWithAggregatesInput = {
    AND?: LayerScalarWhereWithAggregatesInput | LayerScalarWhereWithAggregatesInput[]
    OR?: LayerScalarWhereWithAggregatesInput[]
    NOT?: LayerScalarWhereWithAggregatesInput | LayerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Layer"> | string
    slug?: StringWithAggregatesFilter<"Layer"> | string
    name?: StringWithAggregatesFilter<"Layer"> | string
    nameI18n?: JsonNullableWithAggregatesFilter<"Layer">
    description?: StringNullableWithAggregatesFilter<"Layer"> | string | null
    descriptionI18n?: JsonNullableWithAggregatesFilter<"Layer">
    filename?: StringNullableWithAggregatesFilter<"Layer"> | string | null
    status?: EnumContentStatusWithAggregatesFilter<"Layer"> | $Enums.ContentStatus
    version?: StringNullableWithAggregatesFilter<"Layer"> | string | null
    categoryId?: UuidNullableWithAggregatesFilter<"Layer"> | string | null
    type?: EnumLayerTypeWithAggregatesFilter<"Layer"> | $Enums.LayerType
    citationText?: StringNullableWithAggregatesFilter<"Layer"> | string | null
    citationTextI18n?: JsonNullableWithAggregatesFilter<"Layer">
    codebookText?: StringNullableWithAggregatesFilter<"Layer"> | string | null
    codebookTextI18n?: JsonNullableWithAggregatesFilter<"Layer">
    sources?: StringNullableWithAggregatesFilter<"Layer"> | string | null
    sourcesI18n?: JsonNullableWithAggregatesFilter<"Layer">
    license?: StringNullableWithAggregatesFilter<"Layer"> | string | null
    maturity?: EnumDataMaturityWithAggregatesFilter<"Layer"> | $Enums.DataMaturity
    minYear?: IntNullableWithAggregatesFilter<"Layer"> | number | null
    maxYear?: IntNullableWithAggregatesFilter<"Layer"> | number | null
    sourceType?: EnumLayerSourceTypeWithAggregatesFilter<"Layer"> | $Enums.LayerSourceType
    sourceUrl?: StringNullableWithAggregatesFilter<"Layer"> | string | null
    downloadUrl?: StringNullableWithAggregatesFilter<"Layer"> | string | null
    geoJsonData?: JsonNullableWithAggregatesFilter<"Layer">
    styleConfig?: JsonWithAggregatesFilter<"Layer">
    thumbnail?: StringNullableWithAggregatesFilter<"Layer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Layer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Layer"> | Date | string
  }

  export type MapLayerAssociationWhereInput = {
    AND?: MapLayerAssociationWhereInput | MapLayerAssociationWhereInput[]
    OR?: MapLayerAssociationWhereInput[]
    NOT?: MapLayerAssociationWhereInput | MapLayerAssociationWhereInput[]
    id?: UuidFilter<"MapLayerAssociation"> | string
    mapId?: UuidFilter<"MapLayerAssociation"> | string
    layerId?: UuidFilter<"MapLayerAssociation"> | string
    zIndex?: IntFilter<"MapLayerAssociation"> | number
    isVisible?: BoolFilter<"MapLayerAssociation"> | boolean
    isVisibleByDefault?: BoolFilter<"MapLayerAssociation"> | boolean
    styleOverride?: JsonNullableFilter<"MapLayerAssociation">
    interactionConfig?: JsonNullableFilter<"MapLayerAssociation">
    createdAt?: DateTimeFilter<"MapLayerAssociation"> | Date | string
    layer?: XOR<LayerScalarRelationFilter, LayerWhereInput>
    map?: XOR<MapScalarRelationFilter, MapWhereInput>
  }

  export type MapLayerAssociationOrderByWithRelationInput = {
    id?: SortOrder
    mapId?: SortOrder
    layerId?: SortOrder
    zIndex?: SortOrder
    isVisible?: SortOrder
    isVisibleByDefault?: SortOrder
    styleOverride?: SortOrderInput | SortOrder
    interactionConfig?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    layer?: LayerOrderByWithRelationInput
    map?: MapOrderByWithRelationInput
  }

  export type MapLayerAssociationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    mapId_layerId?: MapLayerAssociationMapIdLayerIdCompoundUniqueInput
    AND?: MapLayerAssociationWhereInput | MapLayerAssociationWhereInput[]
    OR?: MapLayerAssociationWhereInput[]
    NOT?: MapLayerAssociationWhereInput | MapLayerAssociationWhereInput[]
    mapId?: UuidFilter<"MapLayerAssociation"> | string
    layerId?: UuidFilter<"MapLayerAssociation"> | string
    zIndex?: IntFilter<"MapLayerAssociation"> | number
    isVisible?: BoolFilter<"MapLayerAssociation"> | boolean
    isVisibleByDefault?: BoolFilter<"MapLayerAssociation"> | boolean
    styleOverride?: JsonNullableFilter<"MapLayerAssociation">
    interactionConfig?: JsonNullableFilter<"MapLayerAssociation">
    createdAt?: DateTimeFilter<"MapLayerAssociation"> | Date | string
    layer?: XOR<LayerScalarRelationFilter, LayerWhereInput>
    map?: XOR<MapScalarRelationFilter, MapWhereInput>
  }, "id" | "mapId_layerId">

  export type MapLayerAssociationOrderByWithAggregationInput = {
    id?: SortOrder
    mapId?: SortOrder
    layerId?: SortOrder
    zIndex?: SortOrder
    isVisible?: SortOrder
    isVisibleByDefault?: SortOrder
    styleOverride?: SortOrderInput | SortOrder
    interactionConfig?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MapLayerAssociationCountOrderByAggregateInput
    _avg?: MapLayerAssociationAvgOrderByAggregateInput
    _max?: MapLayerAssociationMaxOrderByAggregateInput
    _min?: MapLayerAssociationMinOrderByAggregateInput
    _sum?: MapLayerAssociationSumOrderByAggregateInput
  }

  export type MapLayerAssociationScalarWhereWithAggregatesInput = {
    AND?: MapLayerAssociationScalarWhereWithAggregatesInput | MapLayerAssociationScalarWhereWithAggregatesInput[]
    OR?: MapLayerAssociationScalarWhereWithAggregatesInput[]
    NOT?: MapLayerAssociationScalarWhereWithAggregatesInput | MapLayerAssociationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MapLayerAssociation"> | string
    mapId?: UuidWithAggregatesFilter<"MapLayerAssociation"> | string
    layerId?: UuidWithAggregatesFilter<"MapLayerAssociation"> | string
    zIndex?: IntWithAggregatesFilter<"MapLayerAssociation"> | number
    isVisible?: BoolWithAggregatesFilter<"MapLayerAssociation"> | boolean
    isVisibleByDefault?: BoolWithAggregatesFilter<"MapLayerAssociation"> | boolean
    styleOverride?: JsonNullableWithAggregatesFilter<"MapLayerAssociation">
    interactionConfig?: JsonNullableWithAggregatesFilter<"MapLayerAssociation">
    createdAt?: DateTimeWithAggregatesFilter<"MapLayerAssociation"> | Date | string
  }

  export type CollectionWhereInput = {
    AND?: CollectionWhereInput | CollectionWhereInput[]
    OR?: CollectionWhereInput[]
    NOT?: CollectionWhereInput | CollectionWhereInput[]
    id?: UuidFilter<"Collection"> | string
    nameI18n?: JsonFilter<"Collection">
    descriptionI18n?: JsonNullableFilter<"Collection">
    createdAt?: DateTimeFilter<"Collection"> | Date | string
    thumbnailId?: UuidNullableFilter<"Collection"> | string | null
    name?: StringFilter<"Collection"> | string
    referenceCode?: StringNullableFilter<"Collection"> | string | null
    yearMax?: IntNullableFilter<"Collection"> | number | null
    yearMin?: IntNullableFilter<"Collection"> | number | null
    thumbnail?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    series?: SeriesListRelationFilter
    regions?: RegionListRelationFilter
    tags?: TagListRelationFilter
  }

  export type CollectionOrderByWithRelationInput = {
    id?: SortOrder
    nameI18n?: SortOrder
    descriptionI18n?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    thumbnailId?: SortOrderInput | SortOrder
    name?: SortOrder
    referenceCode?: SortOrderInput | SortOrder
    yearMax?: SortOrderInput | SortOrder
    yearMin?: SortOrderInput | SortOrder
    thumbnail?: MediaOrderByWithRelationInput
    series?: SeriesOrderByRelationAggregateInput
    regions?: RegionOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
  }

  export type CollectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CollectionWhereInput | CollectionWhereInput[]
    OR?: CollectionWhereInput[]
    NOT?: CollectionWhereInput | CollectionWhereInput[]
    nameI18n?: JsonFilter<"Collection">
    descriptionI18n?: JsonNullableFilter<"Collection">
    createdAt?: DateTimeFilter<"Collection"> | Date | string
    thumbnailId?: UuidNullableFilter<"Collection"> | string | null
    name?: StringFilter<"Collection"> | string
    referenceCode?: StringNullableFilter<"Collection"> | string | null
    yearMax?: IntNullableFilter<"Collection"> | number | null
    yearMin?: IntNullableFilter<"Collection"> | number | null
    thumbnail?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    series?: SeriesListRelationFilter
    regions?: RegionListRelationFilter
    tags?: TagListRelationFilter
  }, "id">

  export type CollectionOrderByWithAggregationInput = {
    id?: SortOrder
    nameI18n?: SortOrder
    descriptionI18n?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    thumbnailId?: SortOrderInput | SortOrder
    name?: SortOrder
    referenceCode?: SortOrderInput | SortOrder
    yearMax?: SortOrderInput | SortOrder
    yearMin?: SortOrderInput | SortOrder
    _count?: CollectionCountOrderByAggregateInput
    _avg?: CollectionAvgOrderByAggregateInput
    _max?: CollectionMaxOrderByAggregateInput
    _min?: CollectionMinOrderByAggregateInput
    _sum?: CollectionSumOrderByAggregateInput
  }

  export type CollectionScalarWhereWithAggregatesInput = {
    AND?: CollectionScalarWhereWithAggregatesInput | CollectionScalarWhereWithAggregatesInput[]
    OR?: CollectionScalarWhereWithAggregatesInput[]
    NOT?: CollectionScalarWhereWithAggregatesInput | CollectionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Collection"> | string
    nameI18n?: JsonWithAggregatesFilter<"Collection">
    descriptionI18n?: JsonNullableWithAggregatesFilter<"Collection">
    createdAt?: DateTimeWithAggregatesFilter<"Collection"> | Date | string
    thumbnailId?: UuidNullableWithAggregatesFilter<"Collection"> | string | null
    name?: StringWithAggregatesFilter<"Collection"> | string
    referenceCode?: StringNullableWithAggregatesFilter<"Collection"> | string | null
    yearMax?: IntNullableWithAggregatesFilter<"Collection"> | number | null
    yearMin?: IntNullableWithAggregatesFilter<"Collection"> | number | null
  }

  export type SeriesWhereInput = {
    AND?: SeriesWhereInput | SeriesWhereInput[]
    OR?: SeriesWhereInput[]
    NOT?: SeriesWhereInput | SeriesWhereInput[]
    id?: UuidFilter<"Series"> | string
    collectionId?: UuidNullableFilter<"Series"> | string | null
    nameI18n?: JsonFilter<"Series">
    descriptionI18n?: JsonNullableFilter<"Series">
    indexNumber?: IntNullableFilter<"Series"> | number | null
    volumeLabelFormat?: StringNullableFilter<"Series"> | string | null
    thumbnailId?: UuidNullableFilter<"Series"> | string | null
    createdAt?: DateTimeFilter<"Series"> | Date | string
    slug?: StringFilter<"Series"> | string
    name?: StringFilter<"Series"> | string
    description?: StringNullableFilter<"Series"> | string | null
    license?: StringNullableFilter<"Series"> | string | null
    period?: StringNullableFilter<"Series"> | string | null
    sourceLink?: StringNullableFilter<"Series"> | string | null
    sources?: StringNullableFilter<"Series"> | string | null
    author?: StringNullableFilter<"Series"> | string | null
    editor?: StringNullableFilter<"Series"> | string | null
    referenceCode?: StringNullableFilter<"Series"> | string | null
    yearMax?: IntNullableFilter<"Series"> | number | null
    yearMin?: IntNullableFilter<"Series"> | number | null
    languages?: EnumContentLanguageNullableListFilter<"Series">
    collection?: XOR<CollectionNullableScalarRelationFilter, CollectionWhereInput> | null
    thumbnail?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    volumes?: VolumeListRelationFilter
    categories?: CategoryListRelationFilter
    regions?: RegionListRelationFilter
    tags?: TagListRelationFilter
  }

  export type SeriesOrderByWithRelationInput = {
    id?: SortOrder
    collectionId?: SortOrderInput | SortOrder
    nameI18n?: SortOrder
    descriptionI18n?: SortOrderInput | SortOrder
    indexNumber?: SortOrderInput | SortOrder
    volumeLabelFormat?: SortOrderInput | SortOrder
    thumbnailId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    license?: SortOrderInput | SortOrder
    period?: SortOrderInput | SortOrder
    sourceLink?: SortOrderInput | SortOrder
    sources?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    editor?: SortOrderInput | SortOrder
    referenceCode?: SortOrderInput | SortOrder
    yearMax?: SortOrderInput | SortOrder
    yearMin?: SortOrderInput | SortOrder
    languages?: SortOrder
    collection?: CollectionOrderByWithRelationInput
    thumbnail?: MediaOrderByWithRelationInput
    volumes?: VolumeOrderByRelationAggregateInput
    categories?: CategoryOrderByRelationAggregateInput
    regions?: RegionOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
  }

  export type SeriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: SeriesWhereInput | SeriesWhereInput[]
    OR?: SeriesWhereInput[]
    NOT?: SeriesWhereInput | SeriesWhereInput[]
    collectionId?: UuidNullableFilter<"Series"> | string | null
    nameI18n?: JsonFilter<"Series">
    descriptionI18n?: JsonNullableFilter<"Series">
    indexNumber?: IntNullableFilter<"Series"> | number | null
    volumeLabelFormat?: StringNullableFilter<"Series"> | string | null
    thumbnailId?: UuidNullableFilter<"Series"> | string | null
    createdAt?: DateTimeFilter<"Series"> | Date | string
    name?: StringFilter<"Series"> | string
    description?: StringNullableFilter<"Series"> | string | null
    license?: StringNullableFilter<"Series"> | string | null
    period?: StringNullableFilter<"Series"> | string | null
    sourceLink?: StringNullableFilter<"Series"> | string | null
    sources?: StringNullableFilter<"Series"> | string | null
    author?: StringNullableFilter<"Series"> | string | null
    editor?: StringNullableFilter<"Series"> | string | null
    referenceCode?: StringNullableFilter<"Series"> | string | null
    yearMax?: IntNullableFilter<"Series"> | number | null
    yearMin?: IntNullableFilter<"Series"> | number | null
    languages?: EnumContentLanguageNullableListFilter<"Series">
    collection?: XOR<CollectionNullableScalarRelationFilter, CollectionWhereInput> | null
    thumbnail?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    volumes?: VolumeListRelationFilter
    categories?: CategoryListRelationFilter
    regions?: RegionListRelationFilter
    tags?: TagListRelationFilter
  }, "id" | "slug">

  export type SeriesOrderByWithAggregationInput = {
    id?: SortOrder
    collectionId?: SortOrderInput | SortOrder
    nameI18n?: SortOrder
    descriptionI18n?: SortOrderInput | SortOrder
    indexNumber?: SortOrderInput | SortOrder
    volumeLabelFormat?: SortOrderInput | SortOrder
    thumbnailId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    license?: SortOrderInput | SortOrder
    period?: SortOrderInput | SortOrder
    sourceLink?: SortOrderInput | SortOrder
    sources?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    editor?: SortOrderInput | SortOrder
    referenceCode?: SortOrderInput | SortOrder
    yearMax?: SortOrderInput | SortOrder
    yearMin?: SortOrderInput | SortOrder
    languages?: SortOrder
    _count?: SeriesCountOrderByAggregateInput
    _avg?: SeriesAvgOrderByAggregateInput
    _max?: SeriesMaxOrderByAggregateInput
    _min?: SeriesMinOrderByAggregateInput
    _sum?: SeriesSumOrderByAggregateInput
  }

  export type SeriesScalarWhereWithAggregatesInput = {
    AND?: SeriesScalarWhereWithAggregatesInput | SeriesScalarWhereWithAggregatesInput[]
    OR?: SeriesScalarWhereWithAggregatesInput[]
    NOT?: SeriesScalarWhereWithAggregatesInput | SeriesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Series"> | string
    collectionId?: UuidNullableWithAggregatesFilter<"Series"> | string | null
    nameI18n?: JsonWithAggregatesFilter<"Series">
    descriptionI18n?: JsonNullableWithAggregatesFilter<"Series">
    indexNumber?: IntNullableWithAggregatesFilter<"Series"> | number | null
    volumeLabelFormat?: StringNullableWithAggregatesFilter<"Series"> | string | null
    thumbnailId?: UuidNullableWithAggregatesFilter<"Series"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Series"> | Date | string
    slug?: StringWithAggregatesFilter<"Series"> | string
    name?: StringWithAggregatesFilter<"Series"> | string
    description?: StringNullableWithAggregatesFilter<"Series"> | string | null
    license?: StringNullableWithAggregatesFilter<"Series"> | string | null
    period?: StringNullableWithAggregatesFilter<"Series"> | string | null
    sourceLink?: StringNullableWithAggregatesFilter<"Series"> | string | null
    sources?: StringNullableWithAggregatesFilter<"Series"> | string | null
    author?: StringNullableWithAggregatesFilter<"Series"> | string | null
    editor?: StringNullableWithAggregatesFilter<"Series"> | string | null
    referenceCode?: StringNullableWithAggregatesFilter<"Series"> | string | null
    yearMax?: IntNullableWithAggregatesFilter<"Series"> | number | null
    yearMin?: IntNullableWithAggregatesFilter<"Series"> | number | null
    languages?: EnumContentLanguageNullableListFilter<"Series">
  }

  export type VolumeWhereInput = {
    AND?: VolumeWhereInput | VolumeWhereInput[]
    OR?: VolumeWhereInput[]
    NOT?: VolumeWhereInput | VolumeWhereInput[]
    id?: UuidFilter<"Volume"> | string
    seriesId?: UuidNullableFilter<"Volume"> | string | null
    indexNumber?: IntNullableFilter<"Volume"> | number | null
    titleI18n?: JsonFilter<"Volume">
    descriptionI18n?: JsonNullableFilter<"Volume">
    languageOfContent?: StringNullableFilter<"Volume"> | string | null
    yearContent?: IntNullableFilter<"Volume"> | number | null
    thumbnailId?: UuidNullableFilter<"Volume"> | string | null
    createdAt?: DateTimeFilter<"Volume"> | Date | string
    slug?: StringFilter<"Volume"> | string
    title?: StringFilter<"Volume"> | string
    description?: StringNullableFilter<"Volume"> | string | null
    license?: StringNullableFilter<"Volume"> | string | null
    sourceLink?: StringNullableFilter<"Volume"> | string | null
    sources?: StringNullableFilter<"Volume"> | string | null
    year?: IntNullableFilter<"Volume"> | number | null
    author?: StringNullableFilter<"Volume"> | string | null
    editor?: StringNullableFilter<"Volume"> | string | null
    languages?: EnumContentLanguageNullableListFilter<"Volume">
    yearMax?: IntNullableFilter<"Volume"> | number | null
    yearMin?: IntNullableFilter<"Volume"> | number | null
    pages?: VolumePageListRelationFilter
    series?: XOR<SeriesNullableScalarRelationFilter, SeriesWhereInput> | null
    thumbnail?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    regions?: RegionListRelationFilter
  }

  export type VolumeOrderByWithRelationInput = {
    id?: SortOrder
    seriesId?: SortOrderInput | SortOrder
    indexNumber?: SortOrderInput | SortOrder
    titleI18n?: SortOrder
    descriptionI18n?: SortOrderInput | SortOrder
    languageOfContent?: SortOrderInput | SortOrder
    yearContent?: SortOrderInput | SortOrder
    thumbnailId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    license?: SortOrderInput | SortOrder
    sourceLink?: SortOrderInput | SortOrder
    sources?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    editor?: SortOrderInput | SortOrder
    languages?: SortOrder
    yearMax?: SortOrderInput | SortOrder
    yearMin?: SortOrderInput | SortOrder
    pages?: VolumePageOrderByRelationAggregateInput
    series?: SeriesOrderByWithRelationInput
    thumbnail?: MediaOrderByWithRelationInput
    regions?: RegionOrderByRelationAggregateInput
  }

  export type VolumeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: VolumeWhereInput | VolumeWhereInput[]
    OR?: VolumeWhereInput[]
    NOT?: VolumeWhereInput | VolumeWhereInput[]
    seriesId?: UuidNullableFilter<"Volume"> | string | null
    indexNumber?: IntNullableFilter<"Volume"> | number | null
    titleI18n?: JsonFilter<"Volume">
    descriptionI18n?: JsonNullableFilter<"Volume">
    languageOfContent?: StringNullableFilter<"Volume"> | string | null
    yearContent?: IntNullableFilter<"Volume"> | number | null
    thumbnailId?: UuidNullableFilter<"Volume"> | string | null
    createdAt?: DateTimeFilter<"Volume"> | Date | string
    title?: StringFilter<"Volume"> | string
    description?: StringNullableFilter<"Volume"> | string | null
    license?: StringNullableFilter<"Volume"> | string | null
    sourceLink?: StringNullableFilter<"Volume"> | string | null
    sources?: StringNullableFilter<"Volume"> | string | null
    year?: IntNullableFilter<"Volume"> | number | null
    author?: StringNullableFilter<"Volume"> | string | null
    editor?: StringNullableFilter<"Volume"> | string | null
    languages?: EnumContentLanguageNullableListFilter<"Volume">
    yearMax?: IntNullableFilter<"Volume"> | number | null
    yearMin?: IntNullableFilter<"Volume"> | number | null
    pages?: VolumePageListRelationFilter
    series?: XOR<SeriesNullableScalarRelationFilter, SeriesWhereInput> | null
    thumbnail?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    regions?: RegionListRelationFilter
  }, "id" | "slug">

  export type VolumeOrderByWithAggregationInput = {
    id?: SortOrder
    seriesId?: SortOrderInput | SortOrder
    indexNumber?: SortOrderInput | SortOrder
    titleI18n?: SortOrder
    descriptionI18n?: SortOrderInput | SortOrder
    languageOfContent?: SortOrderInput | SortOrder
    yearContent?: SortOrderInput | SortOrder
    thumbnailId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    license?: SortOrderInput | SortOrder
    sourceLink?: SortOrderInput | SortOrder
    sources?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    editor?: SortOrderInput | SortOrder
    languages?: SortOrder
    yearMax?: SortOrderInput | SortOrder
    yearMin?: SortOrderInput | SortOrder
    _count?: VolumeCountOrderByAggregateInput
    _avg?: VolumeAvgOrderByAggregateInput
    _max?: VolumeMaxOrderByAggregateInput
    _min?: VolumeMinOrderByAggregateInput
    _sum?: VolumeSumOrderByAggregateInput
  }

  export type VolumeScalarWhereWithAggregatesInput = {
    AND?: VolumeScalarWhereWithAggregatesInput | VolumeScalarWhereWithAggregatesInput[]
    OR?: VolumeScalarWhereWithAggregatesInput[]
    NOT?: VolumeScalarWhereWithAggregatesInput | VolumeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Volume"> | string
    seriesId?: UuidNullableWithAggregatesFilter<"Volume"> | string | null
    indexNumber?: IntNullableWithAggregatesFilter<"Volume"> | number | null
    titleI18n?: JsonWithAggregatesFilter<"Volume">
    descriptionI18n?: JsonNullableWithAggregatesFilter<"Volume">
    languageOfContent?: StringNullableWithAggregatesFilter<"Volume"> | string | null
    yearContent?: IntNullableWithAggregatesFilter<"Volume"> | number | null
    thumbnailId?: UuidNullableWithAggregatesFilter<"Volume"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Volume"> | Date | string
    slug?: StringWithAggregatesFilter<"Volume"> | string
    title?: StringWithAggregatesFilter<"Volume"> | string
    description?: StringNullableWithAggregatesFilter<"Volume"> | string | null
    license?: StringNullableWithAggregatesFilter<"Volume"> | string | null
    sourceLink?: StringNullableWithAggregatesFilter<"Volume"> | string | null
    sources?: StringNullableWithAggregatesFilter<"Volume"> | string | null
    year?: IntNullableWithAggregatesFilter<"Volume"> | number | null
    author?: StringNullableWithAggregatesFilter<"Volume"> | string | null
    editor?: StringNullableWithAggregatesFilter<"Volume"> | string | null
    languages?: EnumContentLanguageNullableListFilter<"Volume">
    yearMax?: IntNullableWithAggregatesFilter<"Volume"> | number | null
    yearMin?: IntNullableWithAggregatesFilter<"Volume"> | number | null
  }

  export type VolumePageWhereInput = {
    AND?: VolumePageWhereInput | VolumePageWhereInput[]
    OR?: VolumePageWhereInput[]
    NOT?: VolumePageWhereInput | VolumePageWhereInput[]
    id?: UuidFilter<"VolumePage"> | string
    volumeId?: UuidNullableFilter<"VolumePage"> | string | null
    sequenceIndex?: IntFilter<"VolumePage"> | number
    label?: StringFilter<"VolumePage"> | string
    createdAt?: DateTimeFilter<"VolumePage"> | Date | string
    isVisible?: BoolFilter<"VolumePage"> | boolean
    data?: XOR<PageDataNullableScalarRelationFilter, PageDataWhereInput> | null
    images?: PageImageListRelationFilter
    texts?: PageTextListRelationFilter
    volume?: XOR<VolumeNullableScalarRelationFilter, VolumeWhereInput> | null
    artifacts?: ArtifactListRelationFilter
  }

  export type VolumePageOrderByWithRelationInput = {
    id?: SortOrder
    volumeId?: SortOrderInput | SortOrder
    sequenceIndex?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    isVisible?: SortOrder
    data?: PageDataOrderByWithRelationInput
    images?: PageImageOrderByRelationAggregateInput
    texts?: PageTextOrderByRelationAggregateInput
    volume?: VolumeOrderByWithRelationInput
    artifacts?: ArtifactOrderByRelationAggregateInput
  }

  export type VolumePageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VolumePageWhereInput | VolumePageWhereInput[]
    OR?: VolumePageWhereInput[]
    NOT?: VolumePageWhereInput | VolumePageWhereInput[]
    volumeId?: UuidNullableFilter<"VolumePage"> | string | null
    sequenceIndex?: IntFilter<"VolumePage"> | number
    label?: StringFilter<"VolumePage"> | string
    createdAt?: DateTimeFilter<"VolumePage"> | Date | string
    isVisible?: BoolFilter<"VolumePage"> | boolean
    data?: XOR<PageDataNullableScalarRelationFilter, PageDataWhereInput> | null
    images?: PageImageListRelationFilter
    texts?: PageTextListRelationFilter
    volume?: XOR<VolumeNullableScalarRelationFilter, VolumeWhereInput> | null
    artifacts?: ArtifactListRelationFilter
  }, "id">

  export type VolumePageOrderByWithAggregationInput = {
    id?: SortOrder
    volumeId?: SortOrderInput | SortOrder
    sequenceIndex?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    isVisible?: SortOrder
    _count?: VolumePageCountOrderByAggregateInput
    _avg?: VolumePageAvgOrderByAggregateInput
    _max?: VolumePageMaxOrderByAggregateInput
    _min?: VolumePageMinOrderByAggregateInput
    _sum?: VolumePageSumOrderByAggregateInput
  }

  export type VolumePageScalarWhereWithAggregatesInput = {
    AND?: VolumePageScalarWhereWithAggregatesInput | VolumePageScalarWhereWithAggregatesInput[]
    OR?: VolumePageScalarWhereWithAggregatesInput[]
    NOT?: VolumePageScalarWhereWithAggregatesInput | VolumePageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"VolumePage"> | string
    volumeId?: UuidNullableWithAggregatesFilter<"VolumePage"> | string | null
    sequenceIndex?: IntWithAggregatesFilter<"VolumePage"> | number
    label?: StringWithAggregatesFilter<"VolumePage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VolumePage"> | Date | string
    isVisible?: BoolWithAggregatesFilter<"VolumePage"> | boolean
  }

  export type ArtifactWhereInput = {
    AND?: ArtifactWhereInput | ArtifactWhereInput[]
    OR?: ArtifactWhereInput[]
    NOT?: ArtifactWhereInput | ArtifactWhereInput[]
    id?: UuidFilter<"Artifact"> | string
    slug?: StringFilter<"Artifact"> | string
    content?: StringFilter<"Artifact"> | string
    contentI18n?: JsonFilter<"Artifact">
    year?: IntNullableFilter<"Artifact"> | number | null
    dateDisplay?: StringNullableFilter<"Artifact"> | string | null
    dateSort?: DateTimeNullableFilter<"Artifact"> | Date | string | null
    excerpt?: StringNullableFilter<"Artifact"> | string | null
    excerptI18n?: JsonNullableFilter<"Artifact">
    createdAt?: DateTimeFilter<"Artifact"> | Date | string
    description?: StringNullableFilter<"Artifact"> | string | null
    descriptionI18n?: JsonNullableFilter<"Artifact">
    displayScans?: BoolFilter<"Artifact"> | boolean
    displayTexts?: BoolFilter<"Artifact"> | boolean
    sources?: JsonFilter<"Artifact">
    title?: StringFilter<"Artifact"> | string
    titleI18n?: JsonFilter<"Artifact">
    artifactCategoryId?: UuidNullableFilter<"Artifact"> | string | null
    artifactCategory?: XOR<ArtifactCategoryNullableScalarRelationFilter, ArtifactCategoryWhereInput> | null
    periods?: PeriodListRelationFilter
    places?: PlaceListRelationFilter
    regions?: RegionListRelationFilter
    tags?: TagListRelationFilter
    pages?: VolumePageListRelationFilter
  }

  export type ArtifactOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    contentI18n?: SortOrder
    year?: SortOrderInput | SortOrder
    dateDisplay?: SortOrderInput | SortOrder
    dateSort?: SortOrderInput | SortOrder
    excerpt?: SortOrderInput | SortOrder
    excerptI18n?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    description?: SortOrderInput | SortOrder
    descriptionI18n?: SortOrderInput | SortOrder
    displayScans?: SortOrder
    displayTexts?: SortOrder
    sources?: SortOrder
    title?: SortOrder
    titleI18n?: SortOrder
    artifactCategoryId?: SortOrderInput | SortOrder
    artifactCategory?: ArtifactCategoryOrderByWithRelationInput
    periods?: PeriodOrderByRelationAggregateInput
    places?: PlaceOrderByRelationAggregateInput
    regions?: RegionOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
    pages?: VolumePageOrderByRelationAggregateInput
  }

  export type ArtifactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ArtifactWhereInput | ArtifactWhereInput[]
    OR?: ArtifactWhereInput[]
    NOT?: ArtifactWhereInput | ArtifactWhereInput[]
    content?: StringFilter<"Artifact"> | string
    contentI18n?: JsonFilter<"Artifact">
    year?: IntNullableFilter<"Artifact"> | number | null
    dateDisplay?: StringNullableFilter<"Artifact"> | string | null
    dateSort?: DateTimeNullableFilter<"Artifact"> | Date | string | null
    excerpt?: StringNullableFilter<"Artifact"> | string | null
    excerptI18n?: JsonNullableFilter<"Artifact">
    createdAt?: DateTimeFilter<"Artifact"> | Date | string
    description?: StringNullableFilter<"Artifact"> | string | null
    descriptionI18n?: JsonNullableFilter<"Artifact">
    displayScans?: BoolFilter<"Artifact"> | boolean
    displayTexts?: BoolFilter<"Artifact"> | boolean
    sources?: JsonFilter<"Artifact">
    title?: StringFilter<"Artifact"> | string
    titleI18n?: JsonFilter<"Artifact">
    artifactCategoryId?: UuidNullableFilter<"Artifact"> | string | null
    artifactCategory?: XOR<ArtifactCategoryNullableScalarRelationFilter, ArtifactCategoryWhereInput> | null
    periods?: PeriodListRelationFilter
    places?: PlaceListRelationFilter
    regions?: RegionListRelationFilter
    tags?: TagListRelationFilter
    pages?: VolumePageListRelationFilter
  }, "id" | "slug">

  export type ArtifactOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    contentI18n?: SortOrder
    year?: SortOrderInput | SortOrder
    dateDisplay?: SortOrderInput | SortOrder
    dateSort?: SortOrderInput | SortOrder
    excerpt?: SortOrderInput | SortOrder
    excerptI18n?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    description?: SortOrderInput | SortOrder
    descriptionI18n?: SortOrderInput | SortOrder
    displayScans?: SortOrder
    displayTexts?: SortOrder
    sources?: SortOrder
    title?: SortOrder
    titleI18n?: SortOrder
    artifactCategoryId?: SortOrderInput | SortOrder
    _count?: ArtifactCountOrderByAggregateInput
    _avg?: ArtifactAvgOrderByAggregateInput
    _max?: ArtifactMaxOrderByAggregateInput
    _min?: ArtifactMinOrderByAggregateInput
    _sum?: ArtifactSumOrderByAggregateInput
  }

  export type ArtifactScalarWhereWithAggregatesInput = {
    AND?: ArtifactScalarWhereWithAggregatesInput | ArtifactScalarWhereWithAggregatesInput[]
    OR?: ArtifactScalarWhereWithAggregatesInput[]
    NOT?: ArtifactScalarWhereWithAggregatesInput | ArtifactScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Artifact"> | string
    slug?: StringWithAggregatesFilter<"Artifact"> | string
    content?: StringWithAggregatesFilter<"Artifact"> | string
    contentI18n?: JsonWithAggregatesFilter<"Artifact">
    year?: IntNullableWithAggregatesFilter<"Artifact"> | number | null
    dateDisplay?: StringNullableWithAggregatesFilter<"Artifact"> | string | null
    dateSort?: DateTimeNullableWithAggregatesFilter<"Artifact"> | Date | string | null
    excerpt?: StringNullableWithAggregatesFilter<"Artifact"> | string | null
    excerptI18n?: JsonNullableWithAggregatesFilter<"Artifact">
    createdAt?: DateTimeWithAggregatesFilter<"Artifact"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Artifact"> | string | null
    descriptionI18n?: JsonNullableWithAggregatesFilter<"Artifact">
    displayScans?: BoolWithAggregatesFilter<"Artifact"> | boolean
    displayTexts?: BoolWithAggregatesFilter<"Artifact"> | boolean
    sources?: JsonWithAggregatesFilter<"Artifact">
    title?: StringWithAggregatesFilter<"Artifact"> | string
    titleI18n?: JsonWithAggregatesFilter<"Artifact">
    artifactCategoryId?: UuidNullableWithAggregatesFilter<"Artifact"> | string | null
  }

  export type PageTextWhereInput = {
    AND?: PageTextWhereInput | PageTextWhereInput[]
    OR?: PageTextWhereInput[]
    NOT?: PageTextWhereInput | PageTextWhereInput[]
    id?: UuidFilter<"PageText"> | string
    pageId?: UuidFilter<"PageText"> | string
    content?: StringFilter<"PageText"> | string
    type?: EnumTextTypeFilter<"PageText"> | $Enums.TextType
    language?: EnumAppLanguageFilter<"PageText"> | $Enums.AppLanguage
    textAccuracy?: IntNullableFilter<"PageText"> | number | null
    contributorId?: UuidNullableFilter<"PageText"> | string | null
    createdAt?: DateTimeFilter<"PageText"> | Date | string
    updatedAt?: DateTimeFilter<"PageText"> | Date | string
    contributor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    page?: XOR<VolumePageScalarRelationFilter, VolumePageWhereInput>
  }

  export type PageTextOrderByWithRelationInput = {
    id?: SortOrder
    pageId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    language?: SortOrder
    textAccuracy?: SortOrderInput | SortOrder
    contributorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contributor?: UserOrderByWithRelationInput
    page?: VolumePageOrderByWithRelationInput
  }

  export type PageTextWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PageTextWhereInput | PageTextWhereInput[]
    OR?: PageTextWhereInput[]
    NOT?: PageTextWhereInput | PageTextWhereInput[]
    pageId?: UuidFilter<"PageText"> | string
    content?: StringFilter<"PageText"> | string
    type?: EnumTextTypeFilter<"PageText"> | $Enums.TextType
    language?: EnumAppLanguageFilter<"PageText"> | $Enums.AppLanguage
    textAccuracy?: IntNullableFilter<"PageText"> | number | null
    contributorId?: UuidNullableFilter<"PageText"> | string | null
    createdAt?: DateTimeFilter<"PageText"> | Date | string
    updatedAt?: DateTimeFilter<"PageText"> | Date | string
    contributor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    page?: XOR<VolumePageScalarRelationFilter, VolumePageWhereInput>
  }, "id">

  export type PageTextOrderByWithAggregationInput = {
    id?: SortOrder
    pageId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    language?: SortOrder
    textAccuracy?: SortOrderInput | SortOrder
    contributorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PageTextCountOrderByAggregateInput
    _avg?: PageTextAvgOrderByAggregateInput
    _max?: PageTextMaxOrderByAggregateInput
    _min?: PageTextMinOrderByAggregateInput
    _sum?: PageTextSumOrderByAggregateInput
  }

  export type PageTextScalarWhereWithAggregatesInput = {
    AND?: PageTextScalarWhereWithAggregatesInput | PageTextScalarWhereWithAggregatesInput[]
    OR?: PageTextScalarWhereWithAggregatesInput[]
    NOT?: PageTextScalarWhereWithAggregatesInput | PageTextScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PageText"> | string
    pageId?: UuidWithAggregatesFilter<"PageText"> | string
    content?: StringWithAggregatesFilter<"PageText"> | string
    type?: EnumTextTypeWithAggregatesFilter<"PageText"> | $Enums.TextType
    language?: EnumAppLanguageWithAggregatesFilter<"PageText"> | $Enums.AppLanguage
    textAccuracy?: IntNullableWithAggregatesFilter<"PageText"> | number | null
    contributorId?: UuidNullableWithAggregatesFilter<"PageText"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PageText"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PageText"> | Date | string
  }

  export type PageDataWhereInput = {
    AND?: PageDataWhereInput | PageDataWhereInput[]
    OR?: PageDataWhereInput[]
    NOT?: PageDataWhereInput | PageDataWhereInput[]
    id?: UuidFilter<"PageData"> | string
    pageId?: UuidFilter<"PageData"> | string
    ocrData?: JsonFilter<"PageData">
    updatedAt?: DateTimeFilter<"PageData"> | Date | string
    page?: XOR<VolumePageScalarRelationFilter, VolumePageWhereInput>
  }

  export type PageDataOrderByWithRelationInput = {
    id?: SortOrder
    pageId?: SortOrder
    ocrData?: SortOrder
    updatedAt?: SortOrder
    page?: VolumePageOrderByWithRelationInput
  }

  export type PageDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    pageId?: string
    AND?: PageDataWhereInput | PageDataWhereInput[]
    OR?: PageDataWhereInput[]
    NOT?: PageDataWhereInput | PageDataWhereInput[]
    ocrData?: JsonFilter<"PageData">
    updatedAt?: DateTimeFilter<"PageData"> | Date | string
    page?: XOR<VolumePageScalarRelationFilter, VolumePageWhereInput>
  }, "id" | "pageId">

  export type PageDataOrderByWithAggregationInput = {
    id?: SortOrder
    pageId?: SortOrder
    ocrData?: SortOrder
    updatedAt?: SortOrder
    _count?: PageDataCountOrderByAggregateInput
    _max?: PageDataMaxOrderByAggregateInput
    _min?: PageDataMinOrderByAggregateInput
  }

  export type PageDataScalarWhereWithAggregatesInput = {
    AND?: PageDataScalarWhereWithAggregatesInput | PageDataScalarWhereWithAggregatesInput[]
    OR?: PageDataScalarWhereWithAggregatesInput[]
    NOT?: PageDataScalarWhereWithAggregatesInput | PageDataScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PageData"> | string
    pageId?: UuidWithAggregatesFilter<"PageData"> | string
    ocrData?: JsonWithAggregatesFilter<"PageData">
    updatedAt?: DateTimeWithAggregatesFilter<"PageData"> | Date | string
  }

  export type PageImageWhereInput = {
    AND?: PageImageWhereInput | PageImageWhereInput[]
    OR?: PageImageWhereInput[]
    NOT?: PageImageWhereInput | PageImageWhereInput[]
    id?: UuidFilter<"PageImage"> | string
    pageId?: UuidFilter<"PageImage"> | string
    storageFileId?: UuidFilter<"PageImage"> | string
    useType?: EnumImageUseTypeFilter<"PageImage"> | $Enums.ImageUseType
    createdAt?: DateTimeFilter<"PageImage"> | Date | string
    page?: XOR<VolumePageScalarRelationFilter, VolumePageWhereInput>
    storageFile?: XOR<StorageFileScalarRelationFilter, StorageFileWhereInput>
  }

  export type PageImageOrderByWithRelationInput = {
    id?: SortOrder
    pageId?: SortOrder
    storageFileId?: SortOrder
    useType?: SortOrder
    createdAt?: SortOrder
    page?: VolumePageOrderByWithRelationInput
    storageFile?: StorageFileOrderByWithRelationInput
  }

  export type PageImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PageImageWhereInput | PageImageWhereInput[]
    OR?: PageImageWhereInput[]
    NOT?: PageImageWhereInput | PageImageWhereInput[]
    pageId?: UuidFilter<"PageImage"> | string
    storageFileId?: UuidFilter<"PageImage"> | string
    useType?: EnumImageUseTypeFilter<"PageImage"> | $Enums.ImageUseType
    createdAt?: DateTimeFilter<"PageImage"> | Date | string
    page?: XOR<VolumePageScalarRelationFilter, VolumePageWhereInput>
    storageFile?: XOR<StorageFileScalarRelationFilter, StorageFileWhereInput>
  }, "id">

  export type PageImageOrderByWithAggregationInput = {
    id?: SortOrder
    pageId?: SortOrder
    storageFileId?: SortOrder
    useType?: SortOrder
    createdAt?: SortOrder
    _count?: PageImageCountOrderByAggregateInput
    _max?: PageImageMaxOrderByAggregateInput
    _min?: PageImageMinOrderByAggregateInput
  }

  export type PageImageScalarWhereWithAggregatesInput = {
    AND?: PageImageScalarWhereWithAggregatesInput | PageImageScalarWhereWithAggregatesInput[]
    OR?: PageImageScalarWhereWithAggregatesInput[]
    NOT?: PageImageScalarWhereWithAggregatesInput | PageImageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PageImage"> | string
    pageId?: UuidWithAggregatesFilter<"PageImage"> | string
    storageFileId?: UuidWithAggregatesFilter<"PageImage"> | string
    useType?: EnumImageUseTypeWithAggregatesFilter<"PageImage"> | $Enums.ImageUseType
    createdAt?: DateTimeWithAggregatesFilter<"PageImage"> | Date | string
  }

  export type StorageFileWhereInput = {
    AND?: StorageFileWhereInput | StorageFileWhereInput[]
    OR?: StorageFileWhereInput[]
    NOT?: StorageFileWhereInput | StorageFileWhereInput[]
    id?: UuidFilter<"StorageFile"> | string
    bucketName?: StringFilter<"StorageFile"> | string
    storageKey?: StringFilter<"StorageFile"> | string
    filename?: StringFilter<"StorageFile"> | string
    mimeType?: StringNullableFilter<"StorageFile"> | string | null
    sizeBytes?: FloatNullableFilter<"StorageFile"> | number | null
    hashEtag?: StringNullableFilter<"StorageFile"> | string | null
    publicUrl?: StringNullableFilter<"StorageFile"> | string | null
    isPublic?: BoolFilter<"StorageFile"> | boolean
    width?: IntNullableFilter<"StorageFile"> | number | null
    height?: IntNullableFilter<"StorageFile"> | number | null
    createdAt?: DateTimeFilter<"StorageFile"> | Date | string
    updatedAt?: DateTimeFilter<"StorageFile"> | Date | string
    media?: MediaListRelationFilter
    pageImages?: PageImageListRelationFilter
  }

  export type StorageFileOrderByWithRelationInput = {
    id?: SortOrder
    bucketName?: SortOrder
    storageKey?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    hashEtag?: SortOrderInput | SortOrder
    publicUrl?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    media?: MediaOrderByRelationAggregateInput
    pageImages?: PageImageOrderByRelationAggregateInput
  }

  export type StorageFileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storageKey?: string
    AND?: StorageFileWhereInput | StorageFileWhereInput[]
    OR?: StorageFileWhereInput[]
    NOT?: StorageFileWhereInput | StorageFileWhereInput[]
    bucketName?: StringFilter<"StorageFile"> | string
    filename?: StringFilter<"StorageFile"> | string
    mimeType?: StringNullableFilter<"StorageFile"> | string | null
    sizeBytes?: FloatNullableFilter<"StorageFile"> | number | null
    hashEtag?: StringNullableFilter<"StorageFile"> | string | null
    publicUrl?: StringNullableFilter<"StorageFile"> | string | null
    isPublic?: BoolFilter<"StorageFile"> | boolean
    width?: IntNullableFilter<"StorageFile"> | number | null
    height?: IntNullableFilter<"StorageFile"> | number | null
    createdAt?: DateTimeFilter<"StorageFile"> | Date | string
    updatedAt?: DateTimeFilter<"StorageFile"> | Date | string
    media?: MediaListRelationFilter
    pageImages?: PageImageListRelationFilter
  }, "id" | "storageKey">

  export type StorageFileOrderByWithAggregationInput = {
    id?: SortOrder
    bucketName?: SortOrder
    storageKey?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    sizeBytes?: SortOrderInput | SortOrder
    hashEtag?: SortOrderInput | SortOrder
    publicUrl?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StorageFileCountOrderByAggregateInput
    _avg?: StorageFileAvgOrderByAggregateInput
    _max?: StorageFileMaxOrderByAggregateInput
    _min?: StorageFileMinOrderByAggregateInput
    _sum?: StorageFileSumOrderByAggregateInput
  }

  export type StorageFileScalarWhereWithAggregatesInput = {
    AND?: StorageFileScalarWhereWithAggregatesInput | StorageFileScalarWhereWithAggregatesInput[]
    OR?: StorageFileScalarWhereWithAggregatesInput[]
    NOT?: StorageFileScalarWhereWithAggregatesInput | StorageFileScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"StorageFile"> | string
    bucketName?: StringWithAggregatesFilter<"StorageFile"> | string
    storageKey?: StringWithAggregatesFilter<"StorageFile"> | string
    filename?: StringWithAggregatesFilter<"StorageFile"> | string
    mimeType?: StringNullableWithAggregatesFilter<"StorageFile"> | string | null
    sizeBytes?: FloatNullableWithAggregatesFilter<"StorageFile"> | number | null
    hashEtag?: StringNullableWithAggregatesFilter<"StorageFile"> | string | null
    publicUrl?: StringNullableWithAggregatesFilter<"StorageFile"> | string | null
    isPublic?: BoolWithAggregatesFilter<"StorageFile"> | boolean
    width?: IntNullableWithAggregatesFilter<"StorageFile"> | number | null
    height?: IntNullableWithAggregatesFilter<"StorageFile"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"StorageFile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StorageFile"> | Date | string
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: UuidFilter<"Media"> | string
    filename?: StringFilter<"Media"> | string
    url?: StringFilter<"Media"> | string
    storageFileId?: UuidNullableFilter<"Media"> | string | null
    altTextI18n?: JsonNullableFilter<"Media">
    createdAt?: DateTimeFilter<"Media"> | Date | string
    thumbnailForCategory?: CategoryListRelationFilter
    thumbnailForCollections?: CollectionListRelationFilter
    thumbnailForMaps?: MapListRelationFilter
    storageFile?: XOR<StorageFileNullableScalarRelationFilter, StorageFileWhereInput> | null
    thumbnailForPages?: PageListRelationFilter
    thumbnailForPosts?: PostListRelationFilter
    thumbnailForDataset?: ResearchDatasetListRelationFilter
    thumbnailForSeries?: SeriesListRelationFilter
    thumbnailForVolumes?: VolumeListRelationFilter
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    storageFileId?: SortOrderInput | SortOrder
    altTextI18n?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    thumbnailForCategory?: CategoryOrderByRelationAggregateInput
    thumbnailForCollections?: CollectionOrderByRelationAggregateInput
    thumbnailForMaps?: MapOrderByRelationAggregateInput
    storageFile?: StorageFileOrderByWithRelationInput
    thumbnailForPages?: PageOrderByRelationAggregateInput
    thumbnailForPosts?: PostOrderByRelationAggregateInput
    thumbnailForDataset?: ResearchDatasetOrderByRelationAggregateInput
    thumbnailForSeries?: SeriesOrderByRelationAggregateInput
    thumbnailForVolumes?: VolumeOrderByRelationAggregateInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    filename?: StringFilter<"Media"> | string
    url?: StringFilter<"Media"> | string
    storageFileId?: UuidNullableFilter<"Media"> | string | null
    altTextI18n?: JsonNullableFilter<"Media">
    createdAt?: DateTimeFilter<"Media"> | Date | string
    thumbnailForCategory?: CategoryListRelationFilter
    thumbnailForCollections?: CollectionListRelationFilter
    thumbnailForMaps?: MapListRelationFilter
    storageFile?: XOR<StorageFileNullableScalarRelationFilter, StorageFileWhereInput> | null
    thumbnailForPages?: PageListRelationFilter
    thumbnailForPosts?: PostListRelationFilter
    thumbnailForDataset?: ResearchDatasetListRelationFilter
    thumbnailForSeries?: SeriesListRelationFilter
    thumbnailForVolumes?: VolumeListRelationFilter
  }, "id">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    storageFileId?: SortOrderInput | SortOrder
    altTextI18n?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Media"> | string
    filename?: StringWithAggregatesFilter<"Media"> | string
    url?: StringWithAggregatesFilter<"Media"> | string
    storageFileId?: UuidNullableWithAggregatesFilter<"Media"> | string | null
    altTextI18n?: JsonNullableWithAggregatesFilter<"Media">
    createdAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
  }

  export type PlaceWhereInput = {
    AND?: PlaceWhereInput | PlaceWhereInput[]
    OR?: PlaceWhereInput[]
    NOT?: PlaceWhereInput | PlaceWhereInput[]
    id?: UuidFilter<"Place"> | string
    geoname?: StringFilter<"Place"> | string
    geocode?: StringFilter<"Place"> | string
    lat?: FloatNullableFilter<"Place"> | number | null
    lon?: FloatNullableFilter<"Place"> | number | null
    countryCode?: StringFilter<"Place"> | string
    admin1?: StringNullableFilter<"Place"> | string | null
    admin2?: StringNullableFilter<"Place"> | string | null
    administrativePlaces?: AdministrativePlaceListRelationFilter
    artifacts?: ArtifactListRelationFilter
  }

  export type PlaceOrderByWithRelationInput = {
    id?: SortOrder
    geoname?: SortOrder
    geocode?: SortOrder
    lat?: SortOrderInput | SortOrder
    lon?: SortOrderInput | SortOrder
    countryCode?: SortOrder
    admin1?: SortOrderInput | SortOrder
    admin2?: SortOrderInput | SortOrder
    administrativePlaces?: AdministrativePlaceOrderByRelationAggregateInput
    artifacts?: ArtifactOrderByRelationAggregateInput
  }

  export type PlaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    geoname?: string
    geocode?: string
    AND?: PlaceWhereInput | PlaceWhereInput[]
    OR?: PlaceWhereInput[]
    NOT?: PlaceWhereInput | PlaceWhereInput[]
    lat?: FloatNullableFilter<"Place"> | number | null
    lon?: FloatNullableFilter<"Place"> | number | null
    countryCode?: StringFilter<"Place"> | string
    admin1?: StringNullableFilter<"Place"> | string | null
    admin2?: StringNullableFilter<"Place"> | string | null
    administrativePlaces?: AdministrativePlaceListRelationFilter
    artifacts?: ArtifactListRelationFilter
  }, "id" | "geoname" | "geocode">

  export type PlaceOrderByWithAggregationInput = {
    id?: SortOrder
    geoname?: SortOrder
    geocode?: SortOrder
    lat?: SortOrderInput | SortOrder
    lon?: SortOrderInput | SortOrder
    countryCode?: SortOrder
    admin1?: SortOrderInput | SortOrder
    admin2?: SortOrderInput | SortOrder
    _count?: PlaceCountOrderByAggregateInput
    _avg?: PlaceAvgOrderByAggregateInput
    _max?: PlaceMaxOrderByAggregateInput
    _min?: PlaceMinOrderByAggregateInput
    _sum?: PlaceSumOrderByAggregateInput
  }

  export type PlaceScalarWhereWithAggregatesInput = {
    AND?: PlaceScalarWhereWithAggregatesInput | PlaceScalarWhereWithAggregatesInput[]
    OR?: PlaceScalarWhereWithAggregatesInput[]
    NOT?: PlaceScalarWhereWithAggregatesInput | PlaceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Place"> | string
    geoname?: StringWithAggregatesFilter<"Place"> | string
    geocode?: StringWithAggregatesFilter<"Place"> | string
    lat?: FloatNullableWithAggregatesFilter<"Place"> | number | null
    lon?: FloatNullableWithAggregatesFilter<"Place"> | number | null
    countryCode?: StringWithAggregatesFilter<"Place"> | string
    admin1?: StringNullableWithAggregatesFilter<"Place"> | string | null
    admin2?: StringNullableWithAggregatesFilter<"Place"> | string | null
  }

  export type AdministrativePlaceWhereInput = {
    AND?: AdministrativePlaceWhereInput | AdministrativePlaceWhereInput[]
    OR?: AdministrativePlaceWhereInput[]
    NOT?: AdministrativePlaceWhereInput | AdministrativePlaceWhereInput[]
    id?: UuidFilter<"AdministrativePlace"> | string
    name?: StringFilter<"AdministrativePlace"> | string
    year?: StringNullableFilter<"AdministrativePlace"> | string | null
    source?: StringNullableFilter<"AdministrativePlace"> | string | null
    admin1?: StringNullableFilter<"AdministrativePlace"> | string | null
    admin2?: StringNullableFilter<"AdministrativePlace"> | string | null
    jewishPop?: IntNullableFilter<"AdministrativePlace"> | number | null
    totalPop?: IntNullableFilter<"AdministrativePlace"> | number | null
    placeId?: UuidNullableFilter<"AdministrativePlace"> | string | null
    place?: XOR<PlaceNullableScalarRelationFilter, PlaceWhereInput> | null
  }

  export type AdministrativePlaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    year?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    admin1?: SortOrderInput | SortOrder
    admin2?: SortOrderInput | SortOrder
    jewishPop?: SortOrderInput | SortOrder
    totalPop?: SortOrderInput | SortOrder
    placeId?: SortOrderInput | SortOrder
    place?: PlaceOrderByWithRelationInput
  }

  export type AdministrativePlaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdministrativePlaceWhereInput | AdministrativePlaceWhereInput[]
    OR?: AdministrativePlaceWhereInput[]
    NOT?: AdministrativePlaceWhereInput | AdministrativePlaceWhereInput[]
    name?: StringFilter<"AdministrativePlace"> | string
    year?: StringNullableFilter<"AdministrativePlace"> | string | null
    source?: StringNullableFilter<"AdministrativePlace"> | string | null
    admin1?: StringNullableFilter<"AdministrativePlace"> | string | null
    admin2?: StringNullableFilter<"AdministrativePlace"> | string | null
    jewishPop?: IntNullableFilter<"AdministrativePlace"> | number | null
    totalPop?: IntNullableFilter<"AdministrativePlace"> | number | null
    placeId?: UuidNullableFilter<"AdministrativePlace"> | string | null
    place?: XOR<PlaceNullableScalarRelationFilter, PlaceWhereInput> | null
  }, "id">

  export type AdministrativePlaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    year?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    admin1?: SortOrderInput | SortOrder
    admin2?: SortOrderInput | SortOrder
    jewishPop?: SortOrderInput | SortOrder
    totalPop?: SortOrderInput | SortOrder
    placeId?: SortOrderInput | SortOrder
    _count?: AdministrativePlaceCountOrderByAggregateInput
    _avg?: AdministrativePlaceAvgOrderByAggregateInput
    _max?: AdministrativePlaceMaxOrderByAggregateInput
    _min?: AdministrativePlaceMinOrderByAggregateInput
    _sum?: AdministrativePlaceSumOrderByAggregateInput
  }

  export type AdministrativePlaceScalarWhereWithAggregatesInput = {
    AND?: AdministrativePlaceScalarWhereWithAggregatesInput | AdministrativePlaceScalarWhereWithAggregatesInput[]
    OR?: AdministrativePlaceScalarWhereWithAggregatesInput[]
    NOT?: AdministrativePlaceScalarWhereWithAggregatesInput | AdministrativePlaceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AdministrativePlace"> | string
    name?: StringWithAggregatesFilter<"AdministrativePlace"> | string
    year?: StringNullableWithAggregatesFilter<"AdministrativePlace"> | string | null
    source?: StringNullableWithAggregatesFilter<"AdministrativePlace"> | string | null
    admin1?: StringNullableWithAggregatesFilter<"AdministrativePlace"> | string | null
    admin2?: StringNullableWithAggregatesFilter<"AdministrativePlace"> | string | null
    jewishPop?: IntNullableWithAggregatesFilter<"AdministrativePlace"> | number | null
    totalPop?: IntNullableWithAggregatesFilter<"AdministrativePlace"> | number | null
    placeId?: UuidNullableWithAggregatesFilter<"AdministrativePlace"> | string | null
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: UuidFilter<"Tag"> | string
    slug?: StringFilter<"Tag"> | string
    nameI18n?: JsonFilter<"Tag">
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    name?: StringFilter<"Tag"> | string
    posts?: PostTagListRelationFilter
    artifacts?: ArtifactListRelationFilter
    collections?: CollectionListRelationFilter
    layers?: LayerListRelationFilter
    maps?: MapListRelationFilter
    pages?: PageListRelationFilter
    series?: SeriesListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    nameI18n?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    posts?: PostTagOrderByRelationAggregateInput
    artifacts?: ArtifactOrderByRelationAggregateInput
    collections?: CollectionOrderByRelationAggregateInput
    layers?: LayerOrderByRelationAggregateInput
    maps?: MapOrderByRelationAggregateInput
    pages?: PageOrderByRelationAggregateInput
    series?: SeriesOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    nameI18n?: JsonFilter<"Tag">
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    name?: StringFilter<"Tag"> | string
    posts?: PostTagListRelationFilter
    artifacts?: ArtifactListRelationFilter
    collections?: CollectionListRelationFilter
    layers?: LayerListRelationFilter
    maps?: MapListRelationFilter
    pages?: PageListRelationFilter
    series?: SeriesListRelationFilter
  }, "id" | "slug">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    nameI18n?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Tag"> | string
    slug?: StringWithAggregatesFilter<"Tag"> | string
    nameI18n?: JsonWithAggregatesFilter<"Tag">
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    name?: StringWithAggregatesFilter<"Tag"> | string
  }

  export type RegionWhereInput = {
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    id?: UuidFilter<"Region"> | string
    slug?: StringFilter<"Region"> | string
    name?: StringFilter<"Region"> | string
    nameI18n?: JsonFilter<"Region">
    createdAt?: DateTimeFilter<"Region"> | Date | string
    artifacts?: ArtifactListRelationFilter
    collections?: CollectionListRelationFilter
    layers?: LayerListRelationFilter
    maps?: MapListRelationFilter
    pages?: PageListRelationFilter
    posts?: PostListRelationFilter
    datasets?: ResearchDatasetListRelationFilter
    series?: SeriesListRelationFilter
    volumes?: VolumeListRelationFilter
  }

  export type RegionOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    nameI18n?: SortOrder
    createdAt?: SortOrder
    artifacts?: ArtifactOrderByRelationAggregateInput
    collections?: CollectionOrderByRelationAggregateInput
    layers?: LayerOrderByRelationAggregateInput
    maps?: MapOrderByRelationAggregateInput
    pages?: PageOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    datasets?: ResearchDatasetOrderByRelationAggregateInput
    series?: SeriesOrderByRelationAggregateInput
    volumes?: VolumeOrderByRelationAggregateInput
  }

  export type RegionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    name?: StringFilter<"Region"> | string
    nameI18n?: JsonFilter<"Region">
    createdAt?: DateTimeFilter<"Region"> | Date | string
    artifacts?: ArtifactListRelationFilter
    collections?: CollectionListRelationFilter
    layers?: LayerListRelationFilter
    maps?: MapListRelationFilter
    pages?: PageListRelationFilter
    posts?: PostListRelationFilter
    datasets?: ResearchDatasetListRelationFilter
    series?: SeriesListRelationFilter
    volumes?: VolumeListRelationFilter
  }, "id" | "slug">

  export type RegionOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    nameI18n?: SortOrder
    createdAt?: SortOrder
    _count?: RegionCountOrderByAggregateInput
    _max?: RegionMaxOrderByAggregateInput
    _min?: RegionMinOrderByAggregateInput
  }

  export type RegionScalarWhereWithAggregatesInput = {
    AND?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    OR?: RegionScalarWhereWithAggregatesInput[]
    NOT?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Region"> | string
    slug?: StringWithAggregatesFilter<"Region"> | string
    name?: StringWithAggregatesFilter<"Region"> | string
    nameI18n?: JsonWithAggregatesFilter<"Region">
    createdAt?: DateTimeWithAggregatesFilter<"Region"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: UuidFilter<"Category"> | string
    title?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    thumbnailId?: UuidNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    titleI18n?: JsonFilter<"Category">
    thumbnail?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    layers?: LayerListRelationFilter
    maps?: MapListRelationFilter
    datasets?: ResearchDatasetListRelationFilter
    posts?: PostListRelationFilter
    series?: SeriesListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    thumbnailId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    titleI18n?: SortOrder
    thumbnail?: MediaOrderByWithRelationInput
    layers?: LayerOrderByRelationAggregateInput
    maps?: MapOrderByRelationAggregateInput
    datasets?: ResearchDatasetOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    series?: SeriesOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    title?: StringFilter<"Category"> | string
    thumbnailId?: UuidNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    titleI18n?: JsonFilter<"Category">
    thumbnail?: XOR<MediaNullableScalarRelationFilter, MediaWhereInput> | null
    layers?: LayerListRelationFilter
    maps?: MapListRelationFilter
    datasets?: ResearchDatasetListRelationFilter
    posts?: PostListRelationFilter
    series?: SeriesListRelationFilter
  }, "id" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    thumbnailId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    titleI18n?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Category"> | string
    title?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    thumbnailId?: UuidNullableWithAggregatesFilter<"Category"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    titleI18n?: JsonWithAggregatesFilter<"Category">
  }

  export type ArtifactCategoryWhereInput = {
    AND?: ArtifactCategoryWhereInput | ArtifactCategoryWhereInput[]
    OR?: ArtifactCategoryWhereInput[]
    NOT?: ArtifactCategoryWhereInput | ArtifactCategoryWhereInput[]
    id?: UuidFilter<"ArtifactCategory"> | string
    slug?: StringFilter<"ArtifactCategory"> | string
    title?: StringFilter<"ArtifactCategory"> | string
    titleI18n?: JsonFilter<"ArtifactCategory">
    createdAt?: DateTimeFilter<"ArtifactCategory"> | Date | string
    artifacts?: ArtifactListRelationFilter
  }

  export type ArtifactCategoryOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    titleI18n?: SortOrder
    createdAt?: SortOrder
    artifacts?: ArtifactOrderByRelationAggregateInput
  }

  export type ArtifactCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ArtifactCategoryWhereInput | ArtifactCategoryWhereInput[]
    OR?: ArtifactCategoryWhereInput[]
    NOT?: ArtifactCategoryWhereInput | ArtifactCategoryWhereInput[]
    title?: StringFilter<"ArtifactCategory"> | string
    titleI18n?: JsonFilter<"ArtifactCategory">
    createdAt?: DateTimeFilter<"ArtifactCategory"> | Date | string
    artifacts?: ArtifactListRelationFilter
  }, "id" | "slug">

  export type ArtifactCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    titleI18n?: SortOrder
    createdAt?: SortOrder
    _count?: ArtifactCategoryCountOrderByAggregateInput
    _max?: ArtifactCategoryMaxOrderByAggregateInput
    _min?: ArtifactCategoryMinOrderByAggregateInput
  }

  export type ArtifactCategoryScalarWhereWithAggregatesInput = {
    AND?: ArtifactCategoryScalarWhereWithAggregatesInput | ArtifactCategoryScalarWhereWithAggregatesInput[]
    OR?: ArtifactCategoryScalarWhereWithAggregatesInput[]
    NOT?: ArtifactCategoryScalarWhereWithAggregatesInput | ArtifactCategoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ArtifactCategory"> | string
    slug?: StringWithAggregatesFilter<"ArtifactCategory"> | string
    title?: StringWithAggregatesFilter<"ArtifactCategory"> | string
    titleI18n?: JsonWithAggregatesFilter<"ArtifactCategory">
    createdAt?: DateTimeWithAggregatesFilter<"ArtifactCategory"> | Date | string
  }

  export type PeriodWhereInput = {
    AND?: PeriodWhereInput | PeriodWhereInput[]
    OR?: PeriodWhereInput[]
    NOT?: PeriodWhereInput | PeriodWhereInput[]
    id?: UuidFilter<"Period"> | string
    slug?: StringFilter<"Period"> | string
    name?: StringFilter<"Period"> | string
    nameI18n?: JsonFilter<"Period">
    dateStart?: DateTimeNullableFilter<"Period"> | Date | string | null
    dateEnd?: DateTimeNullableFilter<"Period"> | Date | string | null
    createdAt?: DateTimeFilter<"Period"> | Date | string
    artifacts?: ArtifactListRelationFilter
  }

  export type PeriodOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    nameI18n?: SortOrder
    dateStart?: SortOrderInput | SortOrder
    dateEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    artifacts?: ArtifactOrderByRelationAggregateInput
  }

  export type PeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: PeriodWhereInput | PeriodWhereInput[]
    OR?: PeriodWhereInput[]
    NOT?: PeriodWhereInput | PeriodWhereInput[]
    name?: StringFilter<"Period"> | string
    nameI18n?: JsonFilter<"Period">
    dateStart?: DateTimeNullableFilter<"Period"> | Date | string | null
    dateEnd?: DateTimeNullableFilter<"Period"> | Date | string | null
    createdAt?: DateTimeFilter<"Period"> | Date | string
    artifacts?: ArtifactListRelationFilter
  }, "id" | "slug">

  export type PeriodOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    nameI18n?: SortOrder
    dateStart?: SortOrderInput | SortOrder
    dateEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PeriodCountOrderByAggregateInput
    _max?: PeriodMaxOrderByAggregateInput
    _min?: PeriodMinOrderByAggregateInput
  }

  export type PeriodScalarWhereWithAggregatesInput = {
    AND?: PeriodScalarWhereWithAggregatesInput | PeriodScalarWhereWithAggregatesInput[]
    OR?: PeriodScalarWhereWithAggregatesInput[]
    NOT?: PeriodScalarWhereWithAggregatesInput | PeriodScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Period"> | string
    slug?: StringWithAggregatesFilter<"Period"> | string
    name?: StringWithAggregatesFilter<"Period"> | string
    nameI18n?: JsonWithAggregatesFilter<"Period">
    dateStart?: DateTimeNullableWithAggregatesFilter<"Period"> | Date | string | null
    dateEnd?: DateTimeNullableWithAggregatesFilter<"Period"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Period"> | Date | string
  }

  export type MenuWhereInput = {
    AND?: MenuWhereInput | MenuWhereInput[]
    OR?: MenuWhereInput[]
    NOT?: MenuWhereInput | MenuWhereInput[]
    id?: UuidFilter<"Menu"> | string
    location?: EnumMenuLocationFilter<"Menu"> | $Enums.MenuLocation
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
    items?: MenuItemListRelationFilter
  }

  export type MenuOrderByWithRelationInput = {
    id?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: MenuItemOrderByRelationAggregateInput
  }

  export type MenuWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    location?: $Enums.MenuLocation
    AND?: MenuWhereInput | MenuWhereInput[]
    OR?: MenuWhereInput[]
    NOT?: MenuWhereInput | MenuWhereInput[]
    createdAt?: DateTimeFilter<"Menu"> | Date | string
    updatedAt?: DateTimeFilter<"Menu"> | Date | string
    items?: MenuItemListRelationFilter
  }, "id" | "location">

  export type MenuOrderByWithAggregationInput = {
    id?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MenuCountOrderByAggregateInput
    _max?: MenuMaxOrderByAggregateInput
    _min?: MenuMinOrderByAggregateInput
  }

  export type MenuScalarWhereWithAggregatesInput = {
    AND?: MenuScalarWhereWithAggregatesInput | MenuScalarWhereWithAggregatesInput[]
    OR?: MenuScalarWhereWithAggregatesInput[]
    NOT?: MenuScalarWhereWithAggregatesInput | MenuScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Menu"> | string
    location?: EnumMenuLocationWithAggregatesFilter<"Menu"> | $Enums.MenuLocation
    createdAt?: DateTimeWithAggregatesFilter<"Menu"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Menu"> | Date | string
  }

  export type MenuItemWhereInput = {
    AND?: MenuItemWhereInput | MenuItemWhereInput[]
    OR?: MenuItemWhereInput[]
    NOT?: MenuItemWhereInput | MenuItemWhereInput[]
    id?: UuidFilter<"MenuItem"> | string
    menuId?: UuidFilter<"MenuItem"> | string
    parentId?: UuidNullableFilter<"MenuItem"> | string | null
    label?: StringFilter<"MenuItem"> | string
    labelI18n?: JsonFilter<"MenuItem">
    icon?: StringNullableFilter<"MenuItem"> | string | null
    variant?: EnumItemVariantFilter<"MenuItem"> | $Enums.ItemVariant
    order?: IntFilter<"MenuItem"> | number
    pageId?: UuidNullableFilter<"MenuItem"> | string | null
    url?: StringNullableFilter<"MenuItem"> | string | null
    createdAt?: DateTimeFilter<"MenuItem"> | Date | string
    updatedAt?: DateTimeFilter<"MenuItem"> | Date | string
    menu?: XOR<MenuScalarRelationFilter, MenuWhereInput>
    parent?: XOR<MenuItemNullableScalarRelationFilter, MenuItemWhereInput> | null
    children?: MenuItemListRelationFilter
    page?: XOR<PageNullableScalarRelationFilter, PageWhereInput> | null
  }

  export type MenuItemOrderByWithRelationInput = {
    id?: SortOrder
    menuId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    label?: SortOrder
    labelI18n?: SortOrder
    icon?: SortOrderInput | SortOrder
    variant?: SortOrder
    order?: SortOrder
    pageId?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    menu?: MenuOrderByWithRelationInput
    parent?: MenuItemOrderByWithRelationInput
    children?: MenuItemOrderByRelationAggregateInput
    page?: PageOrderByWithRelationInput
  }

  export type MenuItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MenuItemWhereInput | MenuItemWhereInput[]
    OR?: MenuItemWhereInput[]
    NOT?: MenuItemWhereInput | MenuItemWhereInput[]
    menuId?: UuidFilter<"MenuItem"> | string
    parentId?: UuidNullableFilter<"MenuItem"> | string | null
    label?: StringFilter<"MenuItem"> | string
    labelI18n?: JsonFilter<"MenuItem">
    icon?: StringNullableFilter<"MenuItem"> | string | null
    variant?: EnumItemVariantFilter<"MenuItem"> | $Enums.ItemVariant
    order?: IntFilter<"MenuItem"> | number
    pageId?: UuidNullableFilter<"MenuItem"> | string | null
    url?: StringNullableFilter<"MenuItem"> | string | null
    createdAt?: DateTimeFilter<"MenuItem"> | Date | string
    updatedAt?: DateTimeFilter<"MenuItem"> | Date | string
    menu?: XOR<MenuScalarRelationFilter, MenuWhereInput>
    parent?: XOR<MenuItemNullableScalarRelationFilter, MenuItemWhereInput> | null
    children?: MenuItemListRelationFilter
    page?: XOR<PageNullableScalarRelationFilter, PageWhereInput> | null
  }, "id">

  export type MenuItemOrderByWithAggregationInput = {
    id?: SortOrder
    menuId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    label?: SortOrder
    labelI18n?: SortOrder
    icon?: SortOrderInput | SortOrder
    variant?: SortOrder
    order?: SortOrder
    pageId?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MenuItemCountOrderByAggregateInput
    _avg?: MenuItemAvgOrderByAggregateInput
    _max?: MenuItemMaxOrderByAggregateInput
    _min?: MenuItemMinOrderByAggregateInput
    _sum?: MenuItemSumOrderByAggregateInput
  }

  export type MenuItemScalarWhereWithAggregatesInput = {
    AND?: MenuItemScalarWhereWithAggregatesInput | MenuItemScalarWhereWithAggregatesInput[]
    OR?: MenuItemScalarWhereWithAggregatesInput[]
    NOT?: MenuItemScalarWhereWithAggregatesInput | MenuItemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MenuItem"> | string
    menuId?: UuidWithAggregatesFilter<"MenuItem"> | string
    parentId?: UuidNullableWithAggregatesFilter<"MenuItem"> | string | null
    label?: StringWithAggregatesFilter<"MenuItem"> | string
    labelI18n?: JsonWithAggregatesFilter<"MenuItem">
    icon?: StringNullableWithAggregatesFilter<"MenuItem"> | string | null
    variant?: EnumItemVariantWithAggregatesFilter<"MenuItem"> | $Enums.ItemVariant
    order?: IntWithAggregatesFilter<"MenuItem"> | number
    pageId?: UuidNullableWithAggregatesFilter<"MenuItem"> | string | null
    url?: StringNullableWithAggregatesFilter<"MenuItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MenuItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MenuItem"> | Date | string
  }

  export type FooterColumnWhereInput = {
    AND?: FooterColumnWhereInput | FooterColumnWhereInput[]
    OR?: FooterColumnWhereInput[]
    NOT?: FooterColumnWhereInput | FooterColumnWhereInput[]
    id?: UuidFilter<"FooterColumn"> | string
    type?: EnumMenuTypeFilter<"FooterColumn"> | $Enums.MenuType
    order?: IntFilter<"FooterColumn"> | number
    title?: StringFilter<"FooterColumn"> | string
    titleI18n?: JsonFilter<"FooterColumn">
    content?: StringNullableFilter<"FooterColumn"> | string | null
    contentI18n?: JsonNullableFilter<"FooterColumn">
    createdAt?: DateTimeFilter<"FooterColumn"> | Date | string
    updatedAt?: DateTimeFilter<"FooterColumn"> | Date | string
    items?: FooterColumnItemListRelationFilter
  }

  export type FooterColumnOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    order?: SortOrder
    title?: SortOrder
    titleI18n?: SortOrder
    content?: SortOrderInput | SortOrder
    contentI18n?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: FooterColumnItemOrderByRelationAggregateInput
  }

  export type FooterColumnWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FooterColumnWhereInput | FooterColumnWhereInput[]
    OR?: FooterColumnWhereInput[]
    NOT?: FooterColumnWhereInput | FooterColumnWhereInput[]
    type?: EnumMenuTypeFilter<"FooterColumn"> | $Enums.MenuType
    order?: IntFilter<"FooterColumn"> | number
    title?: StringFilter<"FooterColumn"> | string
    titleI18n?: JsonFilter<"FooterColumn">
    content?: StringNullableFilter<"FooterColumn"> | string | null
    contentI18n?: JsonNullableFilter<"FooterColumn">
    createdAt?: DateTimeFilter<"FooterColumn"> | Date | string
    updatedAt?: DateTimeFilter<"FooterColumn"> | Date | string
    items?: FooterColumnItemListRelationFilter
  }, "id">

  export type FooterColumnOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    order?: SortOrder
    title?: SortOrder
    titleI18n?: SortOrder
    content?: SortOrderInput | SortOrder
    contentI18n?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FooterColumnCountOrderByAggregateInput
    _avg?: FooterColumnAvgOrderByAggregateInput
    _max?: FooterColumnMaxOrderByAggregateInput
    _min?: FooterColumnMinOrderByAggregateInput
    _sum?: FooterColumnSumOrderByAggregateInput
  }

  export type FooterColumnScalarWhereWithAggregatesInput = {
    AND?: FooterColumnScalarWhereWithAggregatesInput | FooterColumnScalarWhereWithAggregatesInput[]
    OR?: FooterColumnScalarWhereWithAggregatesInput[]
    NOT?: FooterColumnScalarWhereWithAggregatesInput | FooterColumnScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FooterColumn"> | string
    type?: EnumMenuTypeWithAggregatesFilter<"FooterColumn"> | $Enums.MenuType
    order?: IntWithAggregatesFilter<"FooterColumn"> | number
    title?: StringWithAggregatesFilter<"FooterColumn"> | string
    titleI18n?: JsonWithAggregatesFilter<"FooterColumn">
    content?: StringNullableWithAggregatesFilter<"FooterColumn"> | string | null
    contentI18n?: JsonNullableWithAggregatesFilter<"FooterColumn">
    createdAt?: DateTimeWithAggregatesFilter<"FooterColumn"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FooterColumn"> | Date | string
  }

  export type FooterColumnItemWhereInput = {
    AND?: FooterColumnItemWhereInput | FooterColumnItemWhereInput[]
    OR?: FooterColumnItemWhereInput[]
    NOT?: FooterColumnItemWhereInput | FooterColumnItemWhereInput[]
    id?: UuidFilter<"FooterColumnItem"> | string
    footerColumnId?: UuidFilter<"FooterColumnItem"> | string
    label?: StringFilter<"FooterColumnItem"> | string
    labelI18n?: JsonFilter<"FooterColumnItem">
    icon?: StringNullableFilter<"FooterColumnItem"> | string | null
    order?: IntFilter<"FooterColumnItem"> | number
    pageId?: UuidNullableFilter<"FooterColumnItem"> | string | null
    url?: StringNullableFilter<"FooterColumnItem"> | string | null
    createdAt?: DateTimeFilter<"FooterColumnItem"> | Date | string
    updatedAt?: DateTimeFilter<"FooterColumnItem"> | Date | string
    footerColumn?: XOR<FooterColumnScalarRelationFilter, FooterColumnWhereInput>
    page?: XOR<PageNullableScalarRelationFilter, PageWhereInput> | null
  }

  export type FooterColumnItemOrderByWithRelationInput = {
    id?: SortOrder
    footerColumnId?: SortOrder
    label?: SortOrder
    labelI18n?: SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    pageId?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    footerColumn?: FooterColumnOrderByWithRelationInput
    page?: PageOrderByWithRelationInput
  }

  export type FooterColumnItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FooterColumnItemWhereInput | FooterColumnItemWhereInput[]
    OR?: FooterColumnItemWhereInput[]
    NOT?: FooterColumnItemWhereInput | FooterColumnItemWhereInput[]
    footerColumnId?: UuidFilter<"FooterColumnItem"> | string
    label?: StringFilter<"FooterColumnItem"> | string
    labelI18n?: JsonFilter<"FooterColumnItem">
    icon?: StringNullableFilter<"FooterColumnItem"> | string | null
    order?: IntFilter<"FooterColumnItem"> | number
    pageId?: UuidNullableFilter<"FooterColumnItem"> | string | null
    url?: StringNullableFilter<"FooterColumnItem"> | string | null
    createdAt?: DateTimeFilter<"FooterColumnItem"> | Date | string
    updatedAt?: DateTimeFilter<"FooterColumnItem"> | Date | string
    footerColumn?: XOR<FooterColumnScalarRelationFilter, FooterColumnWhereInput>
    page?: XOR<PageNullableScalarRelationFilter, PageWhereInput> | null
  }, "id">

  export type FooterColumnItemOrderByWithAggregationInput = {
    id?: SortOrder
    footerColumnId?: SortOrder
    label?: SortOrder
    labelI18n?: SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    pageId?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FooterColumnItemCountOrderByAggregateInput
    _avg?: FooterColumnItemAvgOrderByAggregateInput
    _max?: FooterColumnItemMaxOrderByAggregateInput
    _min?: FooterColumnItemMinOrderByAggregateInput
    _sum?: FooterColumnItemSumOrderByAggregateInput
  }

  export type FooterColumnItemScalarWhereWithAggregatesInput = {
    AND?: FooterColumnItemScalarWhereWithAggregatesInput | FooterColumnItemScalarWhereWithAggregatesInput[]
    OR?: FooterColumnItemScalarWhereWithAggregatesInput[]
    NOT?: FooterColumnItemScalarWhereWithAggregatesInput | FooterColumnItemScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FooterColumnItem"> | string
    footerColumnId?: UuidWithAggregatesFilter<"FooterColumnItem"> | string
    label?: StringWithAggregatesFilter<"FooterColumnItem"> | string
    labelI18n?: JsonWithAggregatesFilter<"FooterColumnItem">
    icon?: StringNullableWithAggregatesFilter<"FooterColumnItem"> | string | null
    order?: IntWithAggregatesFilter<"FooterColumnItem"> | number
    pageId?: UuidNullableWithAggregatesFilter<"FooterColumnItem"> | string | null
    url?: StringNullableWithAggregatesFilter<"FooterColumnItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FooterColumnItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FooterColumnItem"> | Date | string
  }

  export type SiteSettingsWhereInput = {
    AND?: SiteSettingsWhereInput | SiteSettingsWhereInput[]
    OR?: SiteSettingsWhereInput[]
    NOT?: SiteSettingsWhereInput | SiteSettingsWhereInput[]
    id?: UuidFilter<"SiteSettings"> | string
    key?: StringFilter<"SiteSettings"> | string
    copyrightText?: StringFilter<"SiteSettings"> | string
    copyrightI18n?: JsonFilter<"SiteSettings">
    createdAt?: DateTimeFilter<"SiteSettings"> | Date | string
    updatedAt?: DateTimeFilter<"SiteSettings"> | Date | string
  }

  export type SiteSettingsOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    copyrightText?: SortOrder
    copyrightI18n?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SiteSettingsWhereInput | SiteSettingsWhereInput[]
    OR?: SiteSettingsWhereInput[]
    NOT?: SiteSettingsWhereInput | SiteSettingsWhereInput[]
    copyrightText?: StringFilter<"SiteSettings"> | string
    copyrightI18n?: JsonFilter<"SiteSettings">
    createdAt?: DateTimeFilter<"SiteSettings"> | Date | string
    updatedAt?: DateTimeFilter<"SiteSettings"> | Date | string
  }, "id" | "key">

  export type SiteSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    copyrightText?: SortOrder
    copyrightI18n?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SiteSettingsCountOrderByAggregateInput
    _max?: SiteSettingsMaxOrderByAggregateInput
    _min?: SiteSettingsMinOrderByAggregateInput
  }

  export type SiteSettingsScalarWhereWithAggregatesInput = {
    AND?: SiteSettingsScalarWhereWithAggregatesInput | SiteSettingsScalarWhereWithAggregatesInput[]
    OR?: SiteSettingsScalarWhereWithAggregatesInput[]
    NOT?: SiteSettingsScalarWhereWithAggregatesInput | SiteSettingsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SiteSettings"> | string
    key?: StringWithAggregatesFilter<"SiteSettings"> | string
    copyrightText?: StringWithAggregatesFilter<"SiteSettings"> | string
    copyrightI18n?: JsonWithAggregatesFilter<"SiteSettings">
    createdAt?: DateTimeWithAggregatesFilter<"SiteSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SiteSettings"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: UuidFilter<"Document"> | string
    slug?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    titleEn?: StringNullableFilter<"Document"> | string | null
    description?: StringNullableFilter<"Document"> | string | null
    descriptionEn?: StringNullableFilter<"Document"> | string | null
    category?: StringNullableFilter<"Document"> | string | null
    year?: IntNullableFilter<"Document"> | number | null
    reference?: StringNullableFilter<"Document"> | string | null
    referenceUrl?: StringNullableFilter<"Document"> | string | null
    scanUrl?: StringNullableFilter<"Document"> | string | null
    scanZip?: StringNullableFilter<"Document"> | string | null
    lang?: EnumContentLanguageFilter<"Document"> | $Enums.ContentLanguage
    status?: EnumContentStatusFilter<"Document"> | $Enums.ContentStatus
    license?: StringNullableFilter<"Document"> | string | null
    volume?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    pages?: DocumentPageListRelationFilter
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    titleEn?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    descriptionEn?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    referenceUrl?: SortOrderInput | SortOrder
    scanUrl?: SortOrderInput | SortOrder
    scanZip?: SortOrderInput | SortOrder
    lang?: SortOrder
    status?: SortOrder
    license?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pages?: DocumentPageOrderByRelationAggregateInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    title?: StringFilter<"Document"> | string
    titleEn?: StringNullableFilter<"Document"> | string | null
    description?: StringNullableFilter<"Document"> | string | null
    descriptionEn?: StringNullableFilter<"Document"> | string | null
    category?: StringNullableFilter<"Document"> | string | null
    year?: IntNullableFilter<"Document"> | number | null
    reference?: StringNullableFilter<"Document"> | string | null
    referenceUrl?: StringNullableFilter<"Document"> | string | null
    scanUrl?: StringNullableFilter<"Document"> | string | null
    scanZip?: StringNullableFilter<"Document"> | string | null
    lang?: EnumContentLanguageFilter<"Document"> | $Enums.ContentLanguage
    status?: EnumContentStatusFilter<"Document"> | $Enums.ContentStatus
    license?: StringNullableFilter<"Document"> | string | null
    volume?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    pages?: DocumentPageListRelationFilter
  }, "id" | "slug">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    titleEn?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    descriptionEn?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    referenceUrl?: SortOrderInput | SortOrder
    scanUrl?: SortOrderInput | SortOrder
    scanZip?: SortOrderInput | SortOrder
    lang?: SortOrder
    status?: SortOrder
    license?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Document"> | string
    slug?: StringWithAggregatesFilter<"Document"> | string
    title?: StringWithAggregatesFilter<"Document"> | string
    titleEn?: StringNullableWithAggregatesFilter<"Document"> | string | null
    description?: StringNullableWithAggregatesFilter<"Document"> | string | null
    descriptionEn?: StringNullableWithAggregatesFilter<"Document"> | string | null
    category?: StringNullableWithAggregatesFilter<"Document"> | string | null
    year?: IntNullableWithAggregatesFilter<"Document"> | number | null
    reference?: StringNullableWithAggregatesFilter<"Document"> | string | null
    referenceUrl?: StringNullableWithAggregatesFilter<"Document"> | string | null
    scanUrl?: StringNullableWithAggregatesFilter<"Document"> | string | null
    scanZip?: StringNullableWithAggregatesFilter<"Document"> | string | null
    lang?: EnumContentLanguageWithAggregatesFilter<"Document"> | $Enums.ContentLanguage
    status?: EnumContentStatusWithAggregatesFilter<"Document"> | $Enums.ContentStatus
    license?: StringNullableWithAggregatesFilter<"Document"> | string | null
    volume?: StringNullableWithAggregatesFilter<"Document"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type DocumentPageWhereInput = {
    AND?: DocumentPageWhereInput | DocumentPageWhereInput[]
    OR?: DocumentPageWhereInput[]
    NOT?: DocumentPageWhereInput | DocumentPageWhereInput[]
    id?: UuidFilter<"DocumentPage"> | string
    documentId?: UuidFilter<"DocumentPage"> | string
    index?: IntFilter<"DocumentPage"> | number
    content?: StringFilter<"DocumentPage"> | string
    contentHe?: StringNullableFilter<"DocumentPage"> | string | null
    contentEn?: StringNullableFilter<"DocumentPage"> | string | null
    filename?: StringNullableFilter<"DocumentPage"> | string | null
    bookmark?: StringNullableFilter<"DocumentPage"> | string | null
    highlights?: JsonNullableFilter<"DocumentPage">
    createdAt?: DateTimeFilter<"DocumentPage"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentPage"> | Date | string
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
  }

  export type DocumentPageOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    index?: SortOrder
    content?: SortOrder
    contentHe?: SortOrderInput | SortOrder
    contentEn?: SortOrderInput | SortOrder
    filename?: SortOrderInput | SortOrder
    bookmark?: SortOrderInput | SortOrder
    highlights?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    document?: DocumentOrderByWithRelationInput
  }

  export type DocumentPageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    documentId_index?: DocumentPageDocumentIdIndexCompoundUniqueInput
    AND?: DocumentPageWhereInput | DocumentPageWhereInput[]
    OR?: DocumentPageWhereInput[]
    NOT?: DocumentPageWhereInput | DocumentPageWhereInput[]
    documentId?: UuidFilter<"DocumentPage"> | string
    index?: IntFilter<"DocumentPage"> | number
    content?: StringFilter<"DocumentPage"> | string
    contentHe?: StringNullableFilter<"DocumentPage"> | string | null
    contentEn?: StringNullableFilter<"DocumentPage"> | string | null
    filename?: StringNullableFilter<"DocumentPage"> | string | null
    bookmark?: StringNullableFilter<"DocumentPage"> | string | null
    highlights?: JsonNullableFilter<"DocumentPage">
    createdAt?: DateTimeFilter<"DocumentPage"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentPage"> | Date | string
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
  }, "id" | "documentId_index">

  export type DocumentPageOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    index?: SortOrder
    content?: SortOrder
    contentHe?: SortOrderInput | SortOrder
    contentEn?: SortOrderInput | SortOrder
    filename?: SortOrderInput | SortOrder
    bookmark?: SortOrderInput | SortOrder
    highlights?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentPageCountOrderByAggregateInput
    _avg?: DocumentPageAvgOrderByAggregateInput
    _max?: DocumentPageMaxOrderByAggregateInput
    _min?: DocumentPageMinOrderByAggregateInput
    _sum?: DocumentPageSumOrderByAggregateInput
  }

  export type DocumentPageScalarWhereWithAggregatesInput = {
    AND?: DocumentPageScalarWhereWithAggregatesInput | DocumentPageScalarWhereWithAggregatesInput[]
    OR?: DocumentPageScalarWhereWithAggregatesInput[]
    NOT?: DocumentPageScalarWhereWithAggregatesInput | DocumentPageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"DocumentPage"> | string
    documentId?: UuidWithAggregatesFilter<"DocumentPage"> | string
    index?: IntWithAggregatesFilter<"DocumentPage"> | number
    content?: StringWithAggregatesFilter<"DocumentPage"> | string
    contentHe?: StringNullableWithAggregatesFilter<"DocumentPage"> | string | null
    contentEn?: StringNullableWithAggregatesFilter<"DocumentPage"> | string | null
    filename?: StringNullableWithAggregatesFilter<"DocumentPage"> | string | null
    bookmark?: StringNullableWithAggregatesFilter<"DocumentPage"> | string | null
    highlights?: JsonNullableWithAggregatesFilter<"DocumentPage">
    createdAt?: DateTimeWithAggregatesFilter<"DocumentPage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DocumentPage"> | Date | string
  }

  export type PageCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content?: string | null
    excerpt?: string | null
    sources?: string | null
    citations?: string | null
    language?: $Enums.AppLanguage
    translationGroupId?: string | null
    status?: $Enums.ContentStatus
    metaDescription?: string | null
    metaKeywords?: string | null
    template?: string | null
    menuOrder?: number
    showInMenu?: boolean
    author?: UserCreateNestedOneWithoutPagesInput
    parent?: PageCreateNestedOneWithoutChildrenInput
    children?: PageCreateNestedManyWithoutParentInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForPagesInput
    regions?: RegionCreateNestedManyWithoutPagesInput
    tags?: TagCreateNestedManyWithoutPagesInput
    menuItems?: MenuItemCreateNestedManyWithoutPageInput
    footerItems?: FooterColumnItemCreateNestedManyWithoutPageInput
  }

  export type PageUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content?: string | null
    excerpt?: string | null
    sources?: string | null
    citations?: string | null
    language?: $Enums.AppLanguage
    translationGroupId?: string | null
    status?: $Enums.ContentStatus
    authorId?: string | null
    parentId?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    thumbnailId?: string | null
    template?: string | null
    menuOrder?: number
    showInMenu?: boolean
    children?: PageUncheckedCreateNestedManyWithoutParentInput
    regions?: RegionUncheckedCreateNestedManyWithoutPagesInput
    tags?: TagUncheckedCreateNestedManyWithoutPagesInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutPageInput
    footerItems?: FooterColumnItemUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
    author?: UserUpdateOneWithoutPagesNestedInput
    parent?: PageUpdateOneWithoutChildrenNestedInput
    children?: PageUpdateManyWithoutParentNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForPagesNestedInput
    regions?: RegionUpdateManyWithoutPagesNestedInput
    tags?: TagUpdateManyWithoutPagesNestedInput
    menuItems?: MenuItemUpdateManyWithoutPageNestedInput
    footerItems?: FooterColumnItemUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
    children?: PageUncheckedUpdateManyWithoutParentNestedInput
    regions?: RegionUncheckedUpdateManyWithoutPagesNestedInput
    tags?: TagUncheckedUpdateManyWithoutPagesNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutPageNestedInput
    footerItems?: FooterColumnItemUncheckedUpdateManyWithoutPageNestedInput
  }

  export type PageCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content?: string | null
    excerpt?: string | null
    sources?: string | null
    citations?: string | null
    language?: $Enums.AppLanguage
    translationGroupId?: string | null
    status?: $Enums.ContentStatus
    authorId?: string | null
    parentId?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    thumbnailId?: string | null
    template?: string | null
    menuOrder?: number
    showInMenu?: boolean
  }

  export type PageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PostCreateInput = {
    id?: string
    translationGroupId?: string
    language?: $Enums.AppLanguage
    title: string
    slug: string
    content?: string | null
    sources?: string | null
    excerpt?: string | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: PostTagCreateNestedManyWithoutPostInput
    author?: UserCreateNestedOneWithoutPostsInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForPostsInput
    categories?: CategoryCreateNestedManyWithoutPostsInput
    regions?: RegionCreateNestedManyWithoutPostsInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    translationGroupId?: string
    language?: $Enums.AppLanguage
    title: string
    slug: string
    content?: string | null
    sources?: string | null
    excerpt?: string | null
    status?: $Enums.ContentStatus
    authorId?: string | null
    thumbnailId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    categories?: CategoryUncheckedCreateNestedManyWithoutPostsInput
    regions?: RegionUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationGroupId?: StringFieldUpdateOperationsInput | string
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: PostTagUpdateManyWithoutPostNestedInput
    author?: UserUpdateOneWithoutPostsNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForPostsNestedInput
    categories?: CategoryUpdateManyWithoutPostsNestedInput
    regions?: RegionUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationGroupId?: StringFieldUpdateOperationsInput | string
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutPostsNestedInput
    regions?: RegionUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostCreateManyInput = {
    id?: string
    translationGroupId?: string
    language?: $Enums.AppLanguage
    title: string
    slug: string
    content?: string | null
    sources?: string | null
    excerpt?: string | null
    status?: $Enums.ContentStatus
    authorId?: string | null
    thumbnailId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationGroupId?: StringFieldUpdateOperationsInput | string
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationGroupId?: StringFieldUpdateOperationsInput | string
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostTagCreateInput = {
    post: PostCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutPostsInput
  }

  export type PostTagUncheckedCreateInput = {
    postId: string
    tagId: string
  }

  export type PostTagUpdateInput = {
    post?: PostUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostTagUncheckedUpdateInput = {
    postId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type PostTagCreateManyInput = {
    postId: string
    tagId: string
  }

  export type PostTagUpdateManyMutationInput = {

  }

  export type PostTagUncheckedUpdateManyInput = {
    postId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    pageTexts?: PageTextCreateNestedManyWithoutContributorInput
    pages?: PageCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    pageTexts?: PageTextUncheckedCreateNestedManyWithoutContributorInput
    pages?: PageUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    pageTexts?: PageTextUpdateManyWithoutContributorNestedInput
    pages?: PageUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    pageTexts?: PageTextUncheckedUpdateManyWithoutContributorNestedInput
    pages?: PageUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchDatasetCreateInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ContentStatus
    maturity?: $Enums.DataMaturity
    version?: string | null
    license?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    title?: string
    citationText?: string | null
    codebookText?: string | null
    maxYear?: number | null
    minYear?: number | null
    sources?: string | null
    isVisible?: boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    resources?: DatasetResourceCreateNestedManyWithoutDatasetInput
    category?: CategoryCreateNestedOneWithoutDatasetsInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForDatasetInput
    regions?: RegionCreateNestedManyWithoutDatasetsInput
  }

  export type ResearchDatasetUncheckedCreateInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ContentStatus
    maturity?: $Enums.DataMaturity
    version?: string | null
    license?: string | null
    thumbnailId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    title?: string
    categoryId?: string | null
    citationText?: string | null
    codebookText?: string | null
    maxYear?: number | null
    minYear?: number | null
    sources?: string | null
    isVisible?: boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    resources?: DatasetResourceUncheckedCreateNestedManyWithoutDatasetInput
    regions?: RegionUncheckedCreateNestedManyWithoutDatasetsInput
  }

  export type ResearchDatasetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    version?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    resources?: DatasetResourceUpdateManyWithoutDatasetNestedInput
    category?: CategoryUpdateOneWithoutDatasetsNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForDatasetNestedInput
    regions?: RegionUpdateManyWithoutDatasetsNestedInput
  }

  export type ResearchDatasetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    version?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    resources?: DatasetResourceUncheckedUpdateManyWithoutDatasetNestedInput
    regions?: RegionUncheckedUpdateManyWithoutDatasetsNestedInput
  }

  export type ResearchDatasetCreateManyInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ContentStatus
    maturity?: $Enums.DataMaturity
    version?: string | null
    license?: string | null
    thumbnailId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    title?: string
    categoryId?: string | null
    citationText?: string | null
    codebookText?: string | null
    maxYear?: number | null
    minYear?: number | null
    sources?: string | null
    isVisible?: boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ResearchDatasetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    version?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ResearchDatasetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    version?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DatasetResourceCreateInput = {
    id?: string
    url: string
    isMainFile?: boolean
    createdAt?: Date | string
    name: string
    slug: string
    format?: $Enums.ResouceType
    filename?: string | null
    mimeType?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    dataset?: ResearchDatasetCreateNestedOneWithoutResourcesInput
    map?: MapCreateNestedOneWithoutResourcesInput
  }

  export type DatasetResourceUncheckedCreateInput = {
    id?: string
    datasetId?: string | null
    url: string
    isMainFile?: boolean
    createdAt?: Date | string
    name: string
    slug: string
    format?: $Enums.ResouceType
    filename?: string | null
    mimeType?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    mapId?: string | null
  }

  export type DatasetResourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    isMainFile?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    format?: EnumResouceTypeFieldUpdateOperationsInput | $Enums.ResouceType
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    dataset?: ResearchDatasetUpdateOneWithoutResourcesNestedInput
    map?: MapUpdateOneWithoutResourcesNestedInput
  }

  export type DatasetResourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    datasetId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    isMainFile?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    format?: EnumResouceTypeFieldUpdateOperationsInput | $Enums.ResouceType
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    mapId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DatasetResourceCreateManyInput = {
    id?: string
    datasetId?: string | null
    url: string
    isMainFile?: boolean
    createdAt?: Date | string
    name: string
    slug: string
    format?: $Enums.ResouceType
    filename?: string | null
    mimeType?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    mapId?: string | null
  }

  export type DatasetResourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    isMainFile?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    format?: EnumResouceTypeFieldUpdateOperationsInput | $Enums.ResouceType
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DatasetResourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    datasetId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    isMainFile?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    format?: EnumResouceTypeFieldUpdateOperationsInput | $Enums.ResouceType
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    mapId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MapCreateInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: number | null
    version?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    period?: string | null
    title?: string
    yearMax?: number | null
    yearMin?: number | null
    status?: $Enums.ContentStatus
    resources?: DatasetResourceCreateNestedManyWithoutMapInput
    layers?: MapLayerAssociationCreateNestedManyWithoutMapInput
    category?: CategoryCreateNestedOneWithoutMapsInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForMapsInput
    regions?: RegionCreateNestedManyWithoutMapsInput
    tags?: TagCreateNestedManyWithoutMapsInput
  }

  export type MapUncheckedCreateInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: number | null
    version?: string | null
    thumbnailId?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    period?: string | null
    title?: string
    yearMax?: number | null
    yearMin?: number | null
    categoryId?: string | null
    status?: $Enums.ContentStatus
    resources?: DatasetResourceUncheckedCreateNestedManyWithoutMapInput
    layers?: MapLayerAssociationUncheckedCreateNestedManyWithoutMapInput
    regions?: RegionUncheckedCreateNestedManyWithoutMapsInput
    tags?: TagUncheckedCreateNestedManyWithoutMapsInput
  }

  export type MapUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    resources?: DatasetResourceUpdateManyWithoutMapNestedInput
    layers?: MapLayerAssociationUpdateManyWithoutMapNestedInput
    category?: CategoryUpdateOneWithoutMapsNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForMapsNestedInput
    regions?: RegionUpdateManyWithoutMapsNestedInput
    tags?: TagUpdateManyWithoutMapsNestedInput
  }

  export type MapUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    resources?: DatasetResourceUncheckedUpdateManyWithoutMapNestedInput
    layers?: MapLayerAssociationUncheckedUpdateManyWithoutMapNestedInput
    regions?: RegionUncheckedUpdateManyWithoutMapsNestedInput
    tags?: TagUncheckedUpdateManyWithoutMapsNestedInput
  }

  export type MapCreateManyInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: number | null
    version?: string | null
    thumbnailId?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    period?: string | null
    title?: string
    yearMax?: number | null
    yearMin?: number | null
    categoryId?: string | null
    status?: $Enums.ContentStatus
  }

  export type MapUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
  }

  export type MapUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
  }

  export type LayerCreateInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: string | null
    status?: $Enums.ContentStatus
    version?: string | null
    type?: $Enums.LayerType
    citationText?: string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: string | null
    maturity?: $Enums.DataMaturity
    minYear?: number | null
    maxYear?: number | null
    sourceType?: $Enums.LayerSourceType
    sourceUrl?: string | null
    downloadUrl?: string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutLayersInput
    maps?: MapLayerAssociationCreateNestedManyWithoutLayerInput
    regions?: RegionCreateNestedManyWithoutLayersInput
    tags?: TagCreateNestedManyWithoutLayersInput
  }

  export type LayerUncheckedCreateInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: string | null
    status?: $Enums.ContentStatus
    version?: string | null
    categoryId?: string | null
    type?: $Enums.LayerType
    citationText?: string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: string | null
    maturity?: $Enums.DataMaturity
    minYear?: number | null
    maxYear?: number | null
    sourceType?: $Enums.LayerSourceType
    sourceUrl?: string | null
    downloadUrl?: string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    maps?: MapLayerAssociationUncheckedCreateNestedManyWithoutLayerInput
    regions?: RegionUncheckedCreateNestedManyWithoutLayersInput
    tags?: TagUncheckedCreateNestedManyWithoutLayersInput
  }

  export type LayerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    version?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLayerTypeFieldUpdateOperationsInput | $Enums.LayerType
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: NullableStringFieldUpdateOperationsInput | string | null
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumLayerSourceTypeFieldUpdateOperationsInput | $Enums.LayerSourceType
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutLayersNestedInput
    maps?: MapLayerAssociationUpdateManyWithoutLayerNestedInput
    regions?: RegionUpdateManyWithoutLayersNestedInput
    tags?: TagUpdateManyWithoutLayersNestedInput
  }

  export type LayerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    version?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLayerTypeFieldUpdateOperationsInput | $Enums.LayerType
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: NullableStringFieldUpdateOperationsInput | string | null
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumLayerSourceTypeFieldUpdateOperationsInput | $Enums.LayerSourceType
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maps?: MapLayerAssociationUncheckedUpdateManyWithoutLayerNestedInput
    regions?: RegionUncheckedUpdateManyWithoutLayersNestedInput
    tags?: TagUncheckedUpdateManyWithoutLayersNestedInput
  }

  export type LayerCreateManyInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: string | null
    status?: $Enums.ContentStatus
    version?: string | null
    categoryId?: string | null
    type?: $Enums.LayerType
    citationText?: string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: string | null
    maturity?: $Enums.DataMaturity
    minYear?: number | null
    maxYear?: number | null
    sourceType?: $Enums.LayerSourceType
    sourceUrl?: string | null
    downloadUrl?: string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LayerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    version?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLayerTypeFieldUpdateOperationsInput | $Enums.LayerType
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: NullableStringFieldUpdateOperationsInput | string | null
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumLayerSourceTypeFieldUpdateOperationsInput | $Enums.LayerSourceType
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LayerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    version?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLayerTypeFieldUpdateOperationsInput | $Enums.LayerType
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: NullableStringFieldUpdateOperationsInput | string | null
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumLayerSourceTypeFieldUpdateOperationsInput | $Enums.LayerSourceType
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapLayerAssociationCreateInput = {
    id?: string
    zIndex?: number
    isVisible?: boolean
    isVisibleByDefault?: boolean
    styleOverride?: NullableJsonNullValueInput | InputJsonValue
    interactionConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    layer: LayerCreateNestedOneWithoutMapsInput
    map: MapCreateNestedOneWithoutLayersInput
  }

  export type MapLayerAssociationUncheckedCreateInput = {
    id?: string
    mapId: string
    layerId: string
    zIndex?: number
    isVisible?: boolean
    isVisibleByDefault?: boolean
    styleOverride?: NullableJsonNullValueInput | InputJsonValue
    interactionConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MapLayerAssociationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    zIndex?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    isVisibleByDefault?: BoolFieldUpdateOperationsInput | boolean
    styleOverride?: NullableJsonNullValueInput | InputJsonValue
    interactionConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    layer?: LayerUpdateOneRequiredWithoutMapsNestedInput
    map?: MapUpdateOneRequiredWithoutLayersNestedInput
  }

  export type MapLayerAssociationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    layerId?: StringFieldUpdateOperationsInput | string
    zIndex?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    isVisibleByDefault?: BoolFieldUpdateOperationsInput | boolean
    styleOverride?: NullableJsonNullValueInput | InputJsonValue
    interactionConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapLayerAssociationCreateManyInput = {
    id?: string
    mapId: string
    layerId: string
    zIndex?: number
    isVisible?: boolean
    isVisibleByDefault?: boolean
    styleOverride?: NullableJsonNullValueInput | InputJsonValue
    interactionConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MapLayerAssociationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    zIndex?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    isVisibleByDefault?: BoolFieldUpdateOperationsInput | boolean
    styleOverride?: NullableJsonNullValueInput | InputJsonValue
    interactionConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapLayerAssociationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    layerId?: StringFieldUpdateOperationsInput | string
    zIndex?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    isVisibleByDefault?: BoolFieldUpdateOperationsInput | boolean
    styleOverride?: NullableJsonNullValueInput | InputJsonValue
    interactionConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CollectionCreateInput = {
    id?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForCollectionsInput
    series?: SeriesCreateNestedManyWithoutCollectionInput
    regions?: RegionCreateNestedManyWithoutCollectionsInput
    tags?: TagCreateNestedManyWithoutCollectionsInput
  }

  export type CollectionUncheckedCreateInput = {
    id?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailId?: string | null
    name?: string
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    series?: SeriesUncheckedCreateNestedManyWithoutCollectionInput
    regions?: RegionUncheckedCreateNestedManyWithoutCollectionsInput
    tags?: TagUncheckedCreateNestedManyWithoutCollectionsInput
  }

  export type CollectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnail?: MediaUpdateOneWithoutThumbnailForCollectionsNestedInput
    series?: SeriesUpdateManyWithoutCollectionNestedInput
    regions?: RegionUpdateManyWithoutCollectionsNestedInput
    tags?: TagUpdateManyWithoutCollectionsNestedInput
  }

  export type CollectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    series?: SeriesUncheckedUpdateManyWithoutCollectionNestedInput
    regions?: RegionUncheckedUpdateManyWithoutCollectionsNestedInput
    tags?: TagUncheckedUpdateManyWithoutCollectionsNestedInput
  }

  export type CollectionCreateManyInput = {
    id?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailId?: string | null
    name?: string
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
  }

  export type CollectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CollectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SeriesCreateInput = {
    id?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: number | null
    volumeLabelFormat?: string | null
    createdAt?: Date | string
    slug: string
    name?: string
    description?: string | null
    license?: string | null
    period?: string | null
    sourceLink?: string | null
    sources?: string | null
    author?: string | null
    editor?: string | null
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    languages?: SeriesCreatelanguagesInput | $Enums.ContentLanguage[]
    collection?: CollectionCreateNestedOneWithoutSeriesInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForSeriesInput
    volumes?: VolumeCreateNestedManyWithoutSeriesInput
    categories?: CategoryCreateNestedManyWithoutSeriesInput
    regions?: RegionCreateNestedManyWithoutSeriesInput
    tags?: TagCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUncheckedCreateInput = {
    id?: string
    collectionId?: string | null
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: number | null
    volumeLabelFormat?: string | null
    thumbnailId?: string | null
    createdAt?: Date | string
    slug: string
    name?: string
    description?: string | null
    license?: string | null
    period?: string | null
    sourceLink?: string | null
    sources?: string | null
    author?: string | null
    editor?: string | null
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    languages?: SeriesCreatelanguagesInput | $Enums.ContentLanguage[]
    volumes?: VolumeUncheckedCreateNestedManyWithoutSeriesInput
    categories?: CategoryUncheckedCreateNestedManyWithoutSeriesInput
    regions?: RegionUncheckedCreateNestedManyWithoutSeriesInput
    tags?: TagUncheckedCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    volumeLabelFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    languages?: SeriesUpdatelanguagesInput | $Enums.ContentLanguage[]
    collection?: CollectionUpdateOneWithoutSeriesNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForSeriesNestedInput
    volumes?: VolumeUpdateManyWithoutSeriesNestedInput
    categories?: CategoryUpdateManyWithoutSeriesNestedInput
    regions?: RegionUpdateManyWithoutSeriesNestedInput
    tags?: TagUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    volumeLabelFormat?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    languages?: SeriesUpdatelanguagesInput | $Enums.ContentLanguage[]
    volumes?: VolumeUncheckedUpdateManyWithoutSeriesNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutSeriesNestedInput
    regions?: RegionUncheckedUpdateManyWithoutSeriesNestedInput
    tags?: TagUncheckedUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesCreateManyInput = {
    id?: string
    collectionId?: string | null
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: number | null
    volumeLabelFormat?: string | null
    thumbnailId?: string | null
    createdAt?: Date | string
    slug: string
    name?: string
    description?: string | null
    license?: string | null
    period?: string | null
    sourceLink?: string | null
    sources?: string | null
    author?: string | null
    editor?: string | null
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    languages?: SeriesCreatelanguagesInput | $Enums.ContentLanguage[]
  }

  export type SeriesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    volumeLabelFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    languages?: SeriesUpdatelanguagesInput | $Enums.ContentLanguage[]
  }

  export type SeriesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    volumeLabelFormat?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    languages?: SeriesUpdatelanguagesInput | $Enums.ContentLanguage[]
  }

  export type VolumeCreateInput = {
    id?: string
    indexNumber?: number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: string | null
    yearContent?: number | null
    createdAt?: Date | string
    slug: string
    title?: string
    description?: string | null
    license?: string | null
    sourceLink?: string | null
    sources?: string | null
    year?: number | null
    author?: string | null
    editor?: string | null
    languages?: VolumeCreatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: number | null
    yearMin?: number | null
    pages?: VolumePageCreateNestedManyWithoutVolumeInput
    series?: SeriesCreateNestedOneWithoutVolumesInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForVolumesInput
    regions?: RegionCreateNestedManyWithoutVolumesInput
  }

  export type VolumeUncheckedCreateInput = {
    id?: string
    seriesId?: string | null
    indexNumber?: number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: string | null
    yearContent?: number | null
    thumbnailId?: string | null
    createdAt?: Date | string
    slug: string
    title?: string
    description?: string | null
    license?: string | null
    sourceLink?: string | null
    sources?: string | null
    year?: number | null
    author?: string | null
    editor?: string | null
    languages?: VolumeCreatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: number | null
    yearMin?: number | null
    pages?: VolumePageUncheckedCreateNestedManyWithoutVolumeInput
    regions?: RegionUncheckedCreateNestedManyWithoutVolumesInput
  }

  export type VolumeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: NullableStringFieldUpdateOperationsInput | string | null
    yearContent?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: VolumeUpdatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    pages?: VolumePageUpdateManyWithoutVolumeNestedInput
    series?: SeriesUpdateOneWithoutVolumesNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForVolumesNestedInput
    regions?: RegionUpdateManyWithoutVolumesNestedInput
  }

  export type VolumeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesId?: NullableStringFieldUpdateOperationsInput | string | null
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: NullableStringFieldUpdateOperationsInput | string | null
    yearContent?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: VolumeUpdatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    pages?: VolumePageUncheckedUpdateManyWithoutVolumeNestedInput
    regions?: RegionUncheckedUpdateManyWithoutVolumesNestedInput
  }

  export type VolumeCreateManyInput = {
    id?: string
    seriesId?: string | null
    indexNumber?: number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: string | null
    yearContent?: number | null
    thumbnailId?: string | null
    createdAt?: Date | string
    slug: string
    title?: string
    description?: string | null
    license?: string | null
    sourceLink?: string | null
    sources?: string | null
    year?: number | null
    author?: string | null
    editor?: string | null
    languages?: VolumeCreatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: number | null
    yearMin?: number | null
  }

  export type VolumeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: NullableStringFieldUpdateOperationsInput | string | null
    yearContent?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: VolumeUpdatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VolumeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesId?: NullableStringFieldUpdateOperationsInput | string | null
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: NullableStringFieldUpdateOperationsInput | string | null
    yearContent?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: VolumeUpdatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VolumePageCreateInput = {
    id?: string
    sequenceIndex: number
    label?: string
    createdAt?: Date | string
    isVisible?: boolean
    data?: PageDataCreateNestedOneWithoutPageInput
    images?: PageImageCreateNestedManyWithoutPageInput
    texts?: PageTextCreateNestedManyWithoutPageInput
    volume?: VolumeCreateNestedOneWithoutPagesInput
    artifacts?: ArtifactCreateNestedManyWithoutPagesInput
  }

  export type VolumePageUncheckedCreateInput = {
    id?: string
    volumeId?: string | null
    sequenceIndex: number
    label?: string
    createdAt?: Date | string
    isVisible?: boolean
    data?: PageDataUncheckedCreateNestedOneWithoutPageInput
    images?: PageImageUncheckedCreateNestedManyWithoutPageInput
    texts?: PageTextUncheckedCreateNestedManyWithoutPageInput
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutPagesInput
  }

  export type VolumePageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequenceIndex?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    data?: PageDataUpdateOneWithoutPageNestedInput
    images?: PageImageUpdateManyWithoutPageNestedInput
    texts?: PageTextUpdateManyWithoutPageNestedInput
    volume?: VolumeUpdateOneWithoutPagesNestedInput
    artifacts?: ArtifactUpdateManyWithoutPagesNestedInput
  }

  export type VolumePageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    volumeId?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceIndex?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    data?: PageDataUncheckedUpdateOneWithoutPageNestedInput
    images?: PageImageUncheckedUpdateManyWithoutPageNestedInput
    texts?: PageTextUncheckedUpdateManyWithoutPageNestedInput
    artifacts?: ArtifactUncheckedUpdateManyWithoutPagesNestedInput
  }

  export type VolumePageCreateManyInput = {
    id?: string
    volumeId?: string | null
    sequenceIndex: number
    label?: string
    createdAt?: Date | string
    isVisible?: boolean
  }

  export type VolumePageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequenceIndex?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VolumePageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    volumeId?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceIndex?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ArtifactCreateInput = {
    id?: string
    slug: string
    content?: string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: number | null
    dateDisplay?: string | null
    dateSort?: Date | string | null
    excerpt?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: boolean
    displayTexts?: boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategory?: ArtifactCategoryCreateNestedOneWithoutArtifactsInput
    periods?: PeriodCreateNestedManyWithoutArtifactsInput
    places?: PlaceCreateNestedManyWithoutArtifactsInput
    regions?: RegionCreateNestedManyWithoutArtifactsInput
    tags?: TagCreateNestedManyWithoutArtifactsInput
    pages?: VolumePageCreateNestedManyWithoutArtifactsInput
  }

  export type ArtifactUncheckedCreateInput = {
    id?: string
    slug: string
    content?: string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: number | null
    dateDisplay?: string | null
    dateSort?: Date | string | null
    excerpt?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: boolean
    displayTexts?: boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategoryId?: string | null
    periods?: PeriodUncheckedCreateNestedManyWithoutArtifactsInput
    places?: PlaceUncheckedCreateNestedManyWithoutArtifactsInput
    regions?: RegionUncheckedCreateNestedManyWithoutArtifactsInput
    tags?: TagUncheckedCreateNestedManyWithoutArtifactsInput
    pages?: VolumePageUncheckedCreateNestedManyWithoutArtifactsInput
  }

  export type ArtifactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    dateDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    dateSort?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: BoolFieldUpdateOperationsInput | boolean
    displayTexts?: BoolFieldUpdateOperationsInput | boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategory?: ArtifactCategoryUpdateOneWithoutArtifactsNestedInput
    periods?: PeriodUpdateManyWithoutArtifactsNestedInput
    places?: PlaceUpdateManyWithoutArtifactsNestedInput
    regions?: RegionUpdateManyWithoutArtifactsNestedInput
    tags?: TagUpdateManyWithoutArtifactsNestedInput
    pages?: VolumePageUpdateManyWithoutArtifactsNestedInput
  }

  export type ArtifactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    dateDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    dateSort?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: BoolFieldUpdateOperationsInput | boolean
    displayTexts?: BoolFieldUpdateOperationsInput | boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    periods?: PeriodUncheckedUpdateManyWithoutArtifactsNestedInput
    places?: PlaceUncheckedUpdateManyWithoutArtifactsNestedInput
    regions?: RegionUncheckedUpdateManyWithoutArtifactsNestedInput
    tags?: TagUncheckedUpdateManyWithoutArtifactsNestedInput
    pages?: VolumePageUncheckedUpdateManyWithoutArtifactsNestedInput
  }

  export type ArtifactCreateManyInput = {
    id?: string
    slug: string
    content?: string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: number | null
    dateDisplay?: string | null
    dateSort?: Date | string | null
    excerpt?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: boolean
    displayTexts?: boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategoryId?: string | null
  }

  export type ArtifactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    dateDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    dateSort?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: BoolFieldUpdateOperationsInput | boolean
    displayTexts?: BoolFieldUpdateOperationsInput | boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
  }

  export type ArtifactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    dateDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    dateSort?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: BoolFieldUpdateOperationsInput | boolean
    displayTexts?: BoolFieldUpdateOperationsInput | boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PageTextCreateInput = {
    id?: string
    content: string
    type?: $Enums.TextType
    language: $Enums.AppLanguage
    textAccuracy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contributor?: UserCreateNestedOneWithoutPageTextsInput
    page: VolumePageCreateNestedOneWithoutTextsInput
  }

  export type PageTextUncheckedCreateInput = {
    id?: string
    pageId: string
    content: string
    type?: $Enums.TextType
    language: $Enums.AppLanguage
    textAccuracy?: number | null
    contributorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageTextUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTextTypeFieldUpdateOperationsInput | $Enums.TextType
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    textAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributor?: UserUpdateOneWithoutPageTextsNestedInput
    page?: VolumePageUpdateOneRequiredWithoutTextsNestedInput
  }

  export type PageTextUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTextTypeFieldUpdateOperationsInput | $Enums.TextType
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    textAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageTextCreateManyInput = {
    id?: string
    pageId: string
    content: string
    type?: $Enums.TextType
    language: $Enums.AppLanguage
    textAccuracy?: number | null
    contributorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageTextUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTextTypeFieldUpdateOperationsInput | $Enums.TextType
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    textAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageTextUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTextTypeFieldUpdateOperationsInput | $Enums.TextType
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    textAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageDataCreateInput = {
    id?: string
    ocrData: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    page: VolumePageCreateNestedOneWithoutDataInput
  }

  export type PageDataUncheckedCreateInput = {
    id?: string
    pageId: string
    ocrData: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type PageDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ocrData?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    page?: VolumePageUpdateOneRequiredWithoutDataNestedInput
  }

  export type PageDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    ocrData?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageDataCreateManyInput = {
    id?: string
    pageId: string
    ocrData: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type PageDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ocrData?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    ocrData?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageImageCreateInput = {
    id?: string
    useType?: $Enums.ImageUseType
    createdAt?: Date | string
    page: VolumePageCreateNestedOneWithoutImagesInput
    storageFile: StorageFileCreateNestedOneWithoutPageImagesInput
  }

  export type PageImageUncheckedCreateInput = {
    id?: string
    pageId: string
    storageFileId: string
    useType?: $Enums.ImageUseType
    createdAt?: Date | string
  }

  export type PageImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    useType?: EnumImageUseTypeFieldUpdateOperationsInput | $Enums.ImageUseType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    page?: VolumePageUpdateOneRequiredWithoutImagesNestedInput
    storageFile?: StorageFileUpdateOneRequiredWithoutPageImagesNestedInput
  }

  export type PageImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    storageFileId?: StringFieldUpdateOperationsInput | string
    useType?: EnumImageUseTypeFieldUpdateOperationsInput | $Enums.ImageUseType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageImageCreateManyInput = {
    id?: string
    pageId: string
    storageFileId: string
    useType?: $Enums.ImageUseType
    createdAt?: Date | string
  }

  export type PageImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    useType?: EnumImageUseTypeFieldUpdateOperationsInput | $Enums.ImageUseType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    storageFileId?: StringFieldUpdateOperationsInput | string
    useType?: EnumImageUseTypeFieldUpdateOperationsInput | $Enums.ImageUseType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageFileCreateInput = {
    id?: string
    bucketName?: string
    storageKey: string
    filename: string
    mimeType?: string | null
    sizeBytes?: number | null
    hashEtag?: string | null
    publicUrl?: string | null
    isPublic?: boolean
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: MediaCreateNestedManyWithoutStorageFileInput
    pageImages?: PageImageCreateNestedManyWithoutStorageFileInput
  }

  export type StorageFileUncheckedCreateInput = {
    id?: string
    bucketName?: string
    storageKey: string
    filename: string
    mimeType?: string | null
    sizeBytes?: number | null
    hashEtag?: string | null
    publicUrl?: string | null
    isPublic?: boolean
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: MediaUncheckedCreateNestedManyWithoutStorageFileInput
    pageImages?: PageImageUncheckedCreateNestedManyWithoutStorageFileInput
  }

  export type StorageFileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableFloatFieldUpdateOperationsInput | number | null
    hashEtag?: NullableStringFieldUpdateOperationsInput | string | null
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: MediaUpdateManyWithoutStorageFileNestedInput
    pageImages?: PageImageUpdateManyWithoutStorageFileNestedInput
  }

  export type StorageFileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableFloatFieldUpdateOperationsInput | number | null
    hashEtag?: NullableStringFieldUpdateOperationsInput | string | null
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: MediaUncheckedUpdateManyWithoutStorageFileNestedInput
    pageImages?: PageImageUncheckedUpdateManyWithoutStorageFileNestedInput
  }

  export type StorageFileCreateManyInput = {
    id?: string
    bucketName?: string
    storageKey: string
    filename: string
    mimeType?: string | null
    sizeBytes?: number | null
    hashEtag?: string | null
    publicUrl?: string | null
    isPublic?: boolean
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorageFileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableFloatFieldUpdateOperationsInput | number | null
    hashEtag?: NullableStringFieldUpdateOperationsInput | string | null
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageFileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableFloatFieldUpdateOperationsInput | number | null
    hashEtag?: NullableStringFieldUpdateOperationsInput | string | null
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateInput = {
    id?: string
    filename: string
    url: string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailForCategory?: CategoryCreateNestedManyWithoutThumbnailInput
    thumbnailForCollections?: CollectionCreateNestedManyWithoutThumbnailInput
    thumbnailForMaps?: MapCreateNestedManyWithoutThumbnailInput
    storageFile?: StorageFileCreateNestedOneWithoutMediaInput
    thumbnailForPages?: PageCreateNestedManyWithoutThumbnailInput
    thumbnailForPosts?: PostCreateNestedManyWithoutThumbnailInput
    thumbnailForDataset?: ResearchDatasetCreateNestedManyWithoutThumbnailInput
    thumbnailForSeries?: SeriesCreateNestedManyWithoutThumbnailInput
    thumbnailForVolumes?: VolumeCreateNestedManyWithoutThumbnailInput
  }

  export type MediaUncheckedCreateInput = {
    id?: string
    filename: string
    url: string
    storageFileId?: string | null
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailForCategory?: CategoryUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForCollections?: CollectionUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForMaps?: MapUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForPages?: PageUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForPosts?: PostUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForDataset?: ResearchDatasetUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForSeries?: SeriesUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForVolumes?: VolumeUncheckedCreateNestedManyWithoutThumbnailInput
  }

  export type MediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailForCategory?: CategoryUpdateManyWithoutThumbnailNestedInput
    thumbnailForCollections?: CollectionUpdateManyWithoutThumbnailNestedInput
    thumbnailForMaps?: MapUpdateManyWithoutThumbnailNestedInput
    storageFile?: StorageFileUpdateOneWithoutMediaNestedInput
    thumbnailForPages?: PageUpdateManyWithoutThumbnailNestedInput
    thumbnailForPosts?: PostUpdateManyWithoutThumbnailNestedInput
    thumbnailForDataset?: ResearchDatasetUpdateManyWithoutThumbnailNestedInput
    thumbnailForSeries?: SeriesUpdateManyWithoutThumbnailNestedInput
    thumbnailForVolumes?: VolumeUpdateManyWithoutThumbnailNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    storageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailForCategory?: CategoryUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForCollections?: CollectionUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForMaps?: MapUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForPages?: PageUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForPosts?: PostUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForDataset?: ResearchDatasetUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForSeries?: SeriesUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForVolumes?: VolumeUncheckedUpdateManyWithoutThumbnailNestedInput
  }

  export type MediaCreateManyInput = {
    id?: string
    filename: string
    url: string
    storageFileId?: string | null
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    storageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaceCreateInput = {
    id?: string
    geoname: string
    geocode: string
    lat?: number | null
    lon?: number | null
    countryCode: string
    admin1?: string | null
    admin2?: string | null
    administrativePlaces?: AdministrativePlaceCreateNestedManyWithoutPlaceInput
    artifacts?: ArtifactCreateNestedManyWithoutPlacesInput
  }

  export type PlaceUncheckedCreateInput = {
    id?: string
    geoname: string
    geocode: string
    lat?: number | null
    lon?: number | null
    countryCode: string
    admin1?: string | null
    admin2?: string | null
    administrativePlaces?: AdministrativePlaceUncheckedCreateNestedManyWithoutPlaceInput
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutPlacesInput
  }

  export type PlaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    geoname?: StringFieldUpdateOperationsInput | string
    geocode?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    countryCode?: StringFieldUpdateOperationsInput | string
    admin1?: NullableStringFieldUpdateOperationsInput | string | null
    admin2?: NullableStringFieldUpdateOperationsInput | string | null
    administrativePlaces?: AdministrativePlaceUpdateManyWithoutPlaceNestedInput
    artifacts?: ArtifactUpdateManyWithoutPlacesNestedInput
  }

  export type PlaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    geoname?: StringFieldUpdateOperationsInput | string
    geocode?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    countryCode?: StringFieldUpdateOperationsInput | string
    admin1?: NullableStringFieldUpdateOperationsInput | string | null
    admin2?: NullableStringFieldUpdateOperationsInput | string | null
    administrativePlaces?: AdministrativePlaceUncheckedUpdateManyWithoutPlaceNestedInput
    artifacts?: ArtifactUncheckedUpdateManyWithoutPlacesNestedInput
  }

  export type PlaceCreateManyInput = {
    id?: string
    geoname: string
    geocode: string
    lat?: number | null
    lon?: number | null
    countryCode: string
    admin1?: string | null
    admin2?: string | null
  }

  export type PlaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    geoname?: StringFieldUpdateOperationsInput | string
    geocode?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    countryCode?: StringFieldUpdateOperationsInput | string
    admin1?: NullableStringFieldUpdateOperationsInput | string | null
    admin2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    geoname?: StringFieldUpdateOperationsInput | string
    geocode?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    countryCode?: StringFieldUpdateOperationsInput | string
    admin1?: NullableStringFieldUpdateOperationsInput | string | null
    admin2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdministrativePlaceCreateInput = {
    id?: string
    name: string
    year?: string | null
    source?: string | null
    admin1?: string | null
    admin2?: string | null
    jewishPop?: number | null
    totalPop?: number | null
    place?: PlaceCreateNestedOneWithoutAdministrativePlacesInput
  }

  export type AdministrativePlaceUncheckedCreateInput = {
    id?: string
    name: string
    year?: string | null
    source?: string | null
    admin1?: string | null
    admin2?: string | null
    jewishPop?: number | null
    totalPop?: number | null
    placeId?: string | null
  }

  export type AdministrativePlaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    year?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    admin1?: NullableStringFieldUpdateOperationsInput | string | null
    admin2?: NullableStringFieldUpdateOperationsInput | string | null
    jewishPop?: NullableIntFieldUpdateOperationsInput | number | null
    totalPop?: NullableIntFieldUpdateOperationsInput | number | null
    place?: PlaceUpdateOneWithoutAdministrativePlacesNestedInput
  }

  export type AdministrativePlaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    year?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    admin1?: NullableStringFieldUpdateOperationsInput | string | null
    admin2?: NullableStringFieldUpdateOperationsInput | string | null
    jewishPop?: NullableIntFieldUpdateOperationsInput | number | null
    totalPop?: NullableIntFieldUpdateOperationsInput | number | null
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdministrativePlaceCreateManyInput = {
    id?: string
    name: string
    year?: string | null
    source?: string | null
    admin1?: string | null
    admin2?: string | null
    jewishPop?: number | null
    totalPop?: number | null
    placeId?: string | null
  }

  export type AdministrativePlaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    year?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    admin1?: NullableStringFieldUpdateOperationsInput | string | null
    admin2?: NullableStringFieldUpdateOperationsInput | string | null
    jewishPop?: NullableIntFieldUpdateOperationsInput | number | null
    totalPop?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AdministrativePlaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    year?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    admin1?: NullableStringFieldUpdateOperationsInput | string | null
    admin2?: NullableStringFieldUpdateOperationsInput | string | null
    jewishPop?: NullableIntFieldUpdateOperationsInput | number | null
    totalPop?: NullableIntFieldUpdateOperationsInput | number | null
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagCreateInput = {
    id?: string
    slug: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    posts?: PostTagCreateNestedManyWithoutTagInput
    artifacts?: ArtifactCreateNestedManyWithoutTagsInput
    collections?: CollectionCreateNestedManyWithoutTagsInput
    layers?: LayerCreateNestedManyWithoutTagsInput
    maps?: MapCreateNestedManyWithoutTagsInput
    pages?: PageCreateNestedManyWithoutTagsInput
    series?: SeriesCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    slug: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    posts?: PostTagUncheckedCreateNestedManyWithoutTagInput
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutTagsInput
    collections?: CollectionUncheckedCreateNestedManyWithoutTagsInput
    layers?: LayerUncheckedCreateNestedManyWithoutTagsInput
    maps?: MapUncheckedCreateNestedManyWithoutTagsInput
    pages?: PageUncheckedCreateNestedManyWithoutTagsInput
    series?: SeriesUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUpdateManyWithoutTagNestedInput
    artifacts?: ArtifactUpdateManyWithoutTagsNestedInput
    collections?: CollectionUpdateManyWithoutTagsNestedInput
    layers?: LayerUpdateManyWithoutTagsNestedInput
    maps?: MapUpdateManyWithoutTagsNestedInput
    pages?: PageUpdateManyWithoutTagsNestedInput
    series?: SeriesUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUncheckedUpdateManyWithoutTagNestedInput
    artifacts?: ArtifactUncheckedUpdateManyWithoutTagsNestedInput
    collections?: CollectionUncheckedUpdateManyWithoutTagsNestedInput
    layers?: LayerUncheckedUpdateManyWithoutTagsNestedInput
    maps?: MapUncheckedUpdateManyWithoutTagsNestedInput
    pages?: PageUncheckedUpdateManyWithoutTagsNestedInput
    series?: SeriesUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    slug: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RegionCreateInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    artifacts?: ArtifactCreateNestedManyWithoutRegionsInput
    collections?: CollectionCreateNestedManyWithoutRegionsInput
    layers?: LayerCreateNestedManyWithoutRegionsInput
    maps?: MapCreateNestedManyWithoutRegionsInput
    pages?: PageCreateNestedManyWithoutRegionsInput
    posts?: PostCreateNestedManyWithoutRegionsInput
    datasets?: ResearchDatasetCreateNestedManyWithoutRegionsInput
    series?: SeriesCreateNestedManyWithoutRegionsInput
    volumes?: VolumeCreateNestedManyWithoutRegionsInput
  }

  export type RegionUncheckedCreateInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutRegionsInput
    collections?: CollectionUncheckedCreateNestedManyWithoutRegionsInput
    layers?: LayerUncheckedCreateNestedManyWithoutRegionsInput
    maps?: MapUncheckedCreateNestedManyWithoutRegionsInput
    pages?: PageUncheckedCreateNestedManyWithoutRegionsInput
    posts?: PostUncheckedCreateNestedManyWithoutRegionsInput
    datasets?: ResearchDatasetUncheckedCreateNestedManyWithoutRegionsInput
    series?: SeriesUncheckedCreateNestedManyWithoutRegionsInput
    volumes?: VolumeUncheckedCreateNestedManyWithoutRegionsInput
  }

  export type RegionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactUpdateManyWithoutRegionsNestedInput
    collections?: CollectionUpdateManyWithoutRegionsNestedInput
    layers?: LayerUpdateManyWithoutRegionsNestedInput
    maps?: MapUpdateManyWithoutRegionsNestedInput
    pages?: PageUpdateManyWithoutRegionsNestedInput
    posts?: PostUpdateManyWithoutRegionsNestedInput
    datasets?: ResearchDatasetUpdateManyWithoutRegionsNestedInput
    series?: SeriesUpdateManyWithoutRegionsNestedInput
    volumes?: VolumeUpdateManyWithoutRegionsNestedInput
  }

  export type RegionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactUncheckedUpdateManyWithoutRegionsNestedInput
    collections?: CollectionUncheckedUpdateManyWithoutRegionsNestedInput
    layers?: LayerUncheckedUpdateManyWithoutRegionsNestedInput
    maps?: MapUncheckedUpdateManyWithoutRegionsNestedInput
    pages?: PageUncheckedUpdateManyWithoutRegionsNestedInput
    posts?: PostUncheckedUpdateManyWithoutRegionsNestedInput
    datasets?: ResearchDatasetUncheckedUpdateManyWithoutRegionsNestedInput
    series?: SeriesUncheckedUpdateManyWithoutRegionsNestedInput
    volumes?: VolumeUncheckedUpdateManyWithoutRegionsNestedInput
  }

  export type RegionCreateManyInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RegionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    title: string
    slug: string
    createdAt?: Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForCategoryInput
    layers?: LayerCreateNestedManyWithoutCategoryInput
    maps?: MapCreateNestedManyWithoutCategoryInput
    datasets?: ResearchDatasetCreateNestedManyWithoutCategoryInput
    posts?: PostCreateNestedManyWithoutCategoriesInput
    series?: SeriesCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    thumbnailId?: string | null
    createdAt?: Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    layers?: LayerUncheckedCreateNestedManyWithoutCategoryInput
    maps?: MapUncheckedCreateNestedManyWithoutCategoryInput
    datasets?: ResearchDatasetUncheckedCreateNestedManyWithoutCategoryInput
    posts?: PostUncheckedCreateNestedManyWithoutCategoriesInput
    series?: SeriesUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    thumbnail?: MediaUpdateOneWithoutThumbnailForCategoryNestedInput
    layers?: LayerUpdateManyWithoutCategoryNestedInput
    maps?: MapUpdateManyWithoutCategoryNestedInput
    datasets?: ResearchDatasetUpdateManyWithoutCategoryNestedInput
    posts?: PostUpdateManyWithoutCategoriesNestedInput
    series?: SeriesUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    layers?: LayerUncheckedUpdateManyWithoutCategoryNestedInput
    maps?: MapUncheckedUpdateManyWithoutCategoryNestedInput
    datasets?: ResearchDatasetUncheckedUpdateManyWithoutCategoryNestedInput
    posts?: PostUncheckedUpdateManyWithoutCategoriesNestedInput
    series?: SeriesUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    title: string
    slug: string
    thumbnailId?: string | null
    createdAt?: Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
  }

  export type ArtifactCategoryCreateInput = {
    id?: string
    slug: string
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    artifacts?: ArtifactCreateNestedManyWithoutArtifactCategoryInput
  }

  export type ArtifactCategoryUncheckedCreateInput = {
    id?: string
    slug: string
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutArtifactCategoryInput
  }

  export type ArtifactCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactUpdateManyWithoutArtifactCategoryNestedInput
  }

  export type ArtifactCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactUncheckedUpdateManyWithoutArtifactCategoryNestedInput
  }

  export type ArtifactCategoryCreateManyInput = {
    id?: string
    slug: string
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ArtifactCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtifactCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PeriodCreateInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    createdAt?: Date | string
    artifacts?: ArtifactCreateNestedManyWithoutPeriodsInput
  }

  export type PeriodUncheckedCreateInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    createdAt?: Date | string
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutPeriodsInput
  }

  export type PeriodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactUpdateManyWithoutPeriodsNestedInput
  }

  export type PeriodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactUncheckedUpdateManyWithoutPeriodsNestedInput
  }

  export type PeriodCreateManyInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    createdAt?: Date | string
  }

  export type PeriodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PeriodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuCreateInput = {
    id?: string
    location: $Enums.MenuLocation
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: MenuItemCreateNestedManyWithoutMenuInput
  }

  export type MenuUncheckedCreateInput = {
    id?: string
    location: $Enums.MenuLocation
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: MenuItemUncheckedCreateNestedManyWithoutMenuInput
  }

  export type MenuUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: EnumMenuLocationFieldUpdateOperationsInput | $Enums.MenuLocation
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: MenuItemUpdateManyWithoutMenuNestedInput
  }

  export type MenuUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: EnumMenuLocationFieldUpdateOperationsInput | $Enums.MenuLocation
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: MenuItemUncheckedUpdateManyWithoutMenuNestedInput
  }

  export type MenuCreateManyInput = {
    id?: string
    location: $Enums.MenuLocation
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: EnumMenuLocationFieldUpdateOperationsInput | $Enums.MenuLocation
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: EnumMenuLocationFieldUpdateOperationsInput | $Enums.MenuLocation
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemCreateInput = {
    id?: string
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    variant?: $Enums.ItemVariant
    order?: number
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    menu: MenuCreateNestedOneWithoutItemsInput
    parent?: MenuItemCreateNestedOneWithoutChildrenInput
    children?: MenuItemCreateNestedManyWithoutParentInput
    page?: PageCreateNestedOneWithoutMenuItemsInput
  }

  export type MenuItemUncheckedCreateInput = {
    id?: string
    menuId: string
    parentId?: string | null
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    variant?: $Enums.ItemVariant
    order?: number
    pageId?: string | null
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: MenuItemUncheckedCreateNestedManyWithoutParentInput
  }

  export type MenuItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    variant?: EnumItemVariantFieldUpdateOperationsInput | $Enums.ItemVariant
    order?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: MenuUpdateOneRequiredWithoutItemsNestedInput
    parent?: MenuItemUpdateOneWithoutChildrenNestedInput
    children?: MenuItemUpdateManyWithoutParentNestedInput
    page?: PageUpdateOneWithoutMenuItemsNestedInput
  }

  export type MenuItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    variant?: EnumItemVariantFieldUpdateOperationsInput | $Enums.ItemVariant
    order?: IntFieldUpdateOperationsInput | number
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: MenuItemUncheckedUpdateManyWithoutParentNestedInput
  }

  export type MenuItemCreateManyInput = {
    id?: string
    menuId: string
    parentId?: string | null
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    variant?: $Enums.ItemVariant
    order?: number
    pageId?: string | null
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    variant?: EnumItemVariantFieldUpdateOperationsInput | $Enums.ItemVariant
    order?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    variant?: EnumItemVariantFieldUpdateOperationsInput | $Enums.ItemVariant
    order?: IntFieldUpdateOperationsInput | number
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FooterColumnCreateInput = {
    id?: string
    type: $Enums.MenuType
    order?: number
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    content?: string | null
    contentI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: FooterColumnItemCreateNestedManyWithoutFooterColumnInput
  }

  export type FooterColumnUncheckedCreateInput = {
    id?: string
    type: $Enums.MenuType
    order?: number
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    content?: string | null
    contentI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: FooterColumnItemUncheckedCreateNestedManyWithoutFooterColumnInput
  }

  export type FooterColumnUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    contentI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: FooterColumnItemUpdateManyWithoutFooterColumnNestedInput
  }

  export type FooterColumnUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    contentI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: FooterColumnItemUncheckedUpdateManyWithoutFooterColumnNestedInput
  }

  export type FooterColumnCreateManyInput = {
    id?: string
    type: $Enums.MenuType
    order?: number
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    content?: string | null
    contentI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FooterColumnUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    contentI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FooterColumnUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    contentI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FooterColumnItemCreateInput = {
    id?: string
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    order?: number
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    footerColumn: FooterColumnCreateNestedOneWithoutItemsInput
    page?: PageCreateNestedOneWithoutFooterItemsInput
  }

  export type FooterColumnItemUncheckedCreateInput = {
    id?: string
    footerColumnId: string
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    order?: number
    pageId?: string | null
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FooterColumnItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    footerColumn?: FooterColumnUpdateOneRequiredWithoutItemsNestedInput
    page?: PageUpdateOneWithoutFooterItemsNestedInput
  }

  export type FooterColumnItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    footerColumnId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FooterColumnItemCreateManyInput = {
    id?: string
    footerColumnId: string
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    order?: number
    pageId?: string | null
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FooterColumnItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FooterColumnItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    footerColumnId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingsCreateInput = {
    id?: string
    key: string
    copyrightText?: string
    copyrightI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteSettingsUncheckedCreateInput = {
    id?: string
    key: string
    copyrightText?: string
    copyrightI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    copyrightText?: StringFieldUpdateOperationsInput | string
    copyrightI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    copyrightText?: StringFieldUpdateOperationsInput | string
    copyrightI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingsCreateManyInput = {
    id?: string
    key: string
    copyrightText?: string
    copyrightI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SiteSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    copyrightText?: StringFieldUpdateOperationsInput | string
    copyrightI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SiteSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    copyrightText?: StringFieldUpdateOperationsInput | string
    copyrightI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    slug: string
    title: string
    titleEn?: string | null
    description?: string | null
    descriptionEn?: string | null
    category?: string | null
    year?: number | null
    reference?: string | null
    referenceUrl?: string | null
    scanUrl?: string | null
    scanZip?: string | null
    lang?: $Enums.ContentLanguage
    status?: $Enums.ContentStatus
    license?: string | null
    volume?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pages?: DocumentPageCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    slug: string
    title: string
    titleEn?: string | null
    description?: string | null
    descriptionEn?: string | null
    category?: string | null
    year?: number | null
    reference?: string | null
    referenceUrl?: string | null
    scanUrl?: string | null
    scanZip?: string | null
    lang?: $Enums.ContentLanguage
    status?: $Enums.ContentStatus
    license?: string | null
    volume?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pages?: DocumentPageUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scanUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scanZip?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: EnumContentLanguageFieldUpdateOperationsInput | $Enums.ContentLanguage
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    license?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pages?: DocumentPageUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scanUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scanZip?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: EnumContentLanguageFieldUpdateOperationsInput | $Enums.ContentLanguage
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    license?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pages?: DocumentPageUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateManyInput = {
    id?: string
    slug: string
    title: string
    titleEn?: string | null
    description?: string | null
    descriptionEn?: string | null
    category?: string | null
    year?: number | null
    reference?: string | null
    referenceUrl?: string | null
    scanUrl?: string | null
    scanZip?: string | null
    lang?: $Enums.ContentLanguage
    status?: $Enums.ContentStatus
    license?: string | null
    volume?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scanUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scanZip?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: EnumContentLanguageFieldUpdateOperationsInput | $Enums.ContentLanguage
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    license?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scanUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scanZip?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: EnumContentLanguageFieldUpdateOperationsInput | $Enums.ContentLanguage
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    license?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentPageCreateInput = {
    id?: string
    index: number
    content: string
    contentHe?: string | null
    contentEn?: string | null
    filename?: string | null
    bookmark?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    document: DocumentCreateNestedOneWithoutPagesInput
  }

  export type DocumentPageUncheckedCreateInput = {
    id?: string
    documentId: string
    index: number
    content: string
    contentHe?: string | null
    contentEn?: string | null
    filename?: string | null
    bookmark?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentPageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentHe?: NullableStringFieldUpdateOperationsInput | string | null
    contentEn?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    bookmark?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutPagesNestedInput
  }

  export type DocumentPageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentHe?: NullableStringFieldUpdateOperationsInput | string | null
    contentEn?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    bookmark?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentPageCreateManyInput = {
    id?: string
    documentId: string
    index: number
    content: string
    contentHe?: string | null
    contentEn?: string | null
    filename?: string | null
    bookmark?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentPageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentHe?: NullableStringFieldUpdateOperationsInput | string | null
    contentEn?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    bookmark?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentPageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentHe?: NullableStringFieldUpdateOperationsInput | string | null
    contentEn?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    bookmark?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumAppLanguageFilter<$PrismaModel = never> = {
    equals?: $Enums.AppLanguage | EnumAppLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.AppLanguage[] | ListEnumAppLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppLanguage[] | ListEnumAppLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumAppLanguageFilter<$PrismaModel> | $Enums.AppLanguage
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type EnumContentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusFilter<$PrismaModel> | $Enums.ContentStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PageNullableScalarRelationFilter = {
    is?: PageWhereInput | null
    isNot?: PageWhereInput | null
  }

  export type PageListRelationFilter = {
    every?: PageWhereInput
    some?: PageWhereInput
    none?: PageWhereInput
  }

  export type MediaNullableScalarRelationFilter = {
    is?: MediaWhereInput | null
    isNot?: MediaWhereInput | null
  }

  export type RegionListRelationFilter = {
    every?: RegionWhereInput
    some?: RegionWhereInput
    none?: RegionWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type MenuItemListRelationFilter = {
    every?: MenuItemWhereInput
    some?: MenuItemWhereInput
    none?: MenuItemWhereInput
  }

  export type FooterColumnItemListRelationFilter = {
    every?: FooterColumnItemWhereInput
    some?: FooterColumnItemWhereInput
    none?: FooterColumnItemWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MenuItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FooterColumnItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    sources?: SortOrder
    citations?: SortOrder
    language?: SortOrder
    translationGroupId?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
    thumbnailId?: SortOrder
    template?: SortOrder
    menuOrder?: SortOrder
    showInMenu?: SortOrder
  }

  export type PageAvgOrderByAggregateInput = {
    menuOrder?: SortOrder
  }

  export type PageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    sources?: SortOrder
    citations?: SortOrder
    language?: SortOrder
    translationGroupId?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
    thumbnailId?: SortOrder
    template?: SortOrder
    menuOrder?: SortOrder
    showInMenu?: SortOrder
  }

  export type PageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    sources?: SortOrder
    citations?: SortOrder
    language?: SortOrder
    translationGroupId?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    metaDescription?: SortOrder
    metaKeywords?: SortOrder
    thumbnailId?: SortOrder
    template?: SortOrder
    menuOrder?: SortOrder
    showInMenu?: SortOrder
  }

  export type PageSumOrderByAggregateInput = {
    menuOrder?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumAppLanguageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppLanguage | EnumAppLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.AppLanguage[] | ListEnumAppLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppLanguage[] | ListEnumAppLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumAppLanguageWithAggregatesFilter<$PrismaModel> | $Enums.AppLanguage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppLanguageFilter<$PrismaModel>
    _max?: NestedEnumAppLanguageFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumContentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentStatusFilter<$PrismaModel>
    _max?: NestedEnumContentStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type PostTagListRelationFilter = {
    every?: PostTagWhereInput
    some?: PostTagWhereInput
    none?: PostTagWhereInput
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type PostTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    translationGroupId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    sources?: SortOrder
    excerpt?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    thumbnailId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    translationGroupId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    sources?: SortOrder
    excerpt?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    thumbnailId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    translationGroupId?: SortOrder
    language?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    sources?: SortOrder
    excerpt?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    thumbnailId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostScalarRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type PostTagPostIdTagIdCompoundUniqueInput = {
    postId: string
    tagId: string
  }

  export type PostTagCountOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
  }

  export type PostTagMaxOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
  }

  export type PostTagMinOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type PageTextListRelationFilter = {
    every?: PageTextWhereInput
    some?: PageTextWhereInput
    none?: PageTextWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PageTextOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumDataMaturityFilter<$PrismaModel = never> = {
    equals?: $Enums.DataMaturity | EnumDataMaturityFieldRefInput<$PrismaModel>
    in?: $Enums.DataMaturity[] | ListEnumDataMaturityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataMaturity[] | ListEnumDataMaturityFieldRefInput<$PrismaModel>
    not?: NestedEnumDataMaturityFilter<$PrismaModel> | $Enums.DataMaturity
  }

  export type DatasetResourceListRelationFilter = {
    every?: DatasetResourceWhereInput
    some?: DatasetResourceWhereInput
    none?: DatasetResourceWhereInput
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type DatasetResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResearchDatasetCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    titleI18n?: SortOrder
    codebookTextI18n?: SortOrder
    status?: SortOrder
    maturity?: SortOrder
    version?: SortOrder
    license?: SortOrder
    thumbnailId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    title?: SortOrder
    categoryId?: SortOrder
    citationText?: SortOrder
    codebookText?: SortOrder
    maxYear?: SortOrder
    minYear?: SortOrder
    sources?: SortOrder
    isVisible?: SortOrder
    sourcesI18n?: SortOrder
    descriptionI18n?: SortOrder
  }

  export type ResearchDatasetAvgOrderByAggregateInput = {
    maxYear?: SortOrder
    minYear?: SortOrder
  }

  export type ResearchDatasetMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    maturity?: SortOrder
    version?: SortOrder
    license?: SortOrder
    thumbnailId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    title?: SortOrder
    categoryId?: SortOrder
    citationText?: SortOrder
    codebookText?: SortOrder
    maxYear?: SortOrder
    minYear?: SortOrder
    sources?: SortOrder
    isVisible?: SortOrder
  }

  export type ResearchDatasetMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    maturity?: SortOrder
    version?: SortOrder
    license?: SortOrder
    thumbnailId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    title?: SortOrder
    categoryId?: SortOrder
    citationText?: SortOrder
    codebookText?: SortOrder
    maxYear?: SortOrder
    minYear?: SortOrder
    sources?: SortOrder
    isVisible?: SortOrder
  }

  export type ResearchDatasetSumOrderByAggregateInput = {
    maxYear?: SortOrder
    minYear?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumDataMaturityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataMaturity | EnumDataMaturityFieldRefInput<$PrismaModel>
    in?: $Enums.DataMaturity[] | ListEnumDataMaturityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataMaturity[] | ListEnumDataMaturityFieldRefInput<$PrismaModel>
    not?: NestedEnumDataMaturityWithAggregatesFilter<$PrismaModel> | $Enums.DataMaturity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataMaturityFilter<$PrismaModel>
    _max?: NestedEnumDataMaturityFilter<$PrismaModel>
  }

  export type EnumResouceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResouceType | EnumResouceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResouceType[] | ListEnumResouceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResouceType[] | ListEnumResouceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResouceTypeFilter<$PrismaModel> | $Enums.ResouceType
  }

  export type ResearchDatasetNullableScalarRelationFilter = {
    is?: ResearchDatasetWhereInput | null
    isNot?: ResearchDatasetWhereInput | null
  }

  export type MapNullableScalarRelationFilter = {
    is?: MapWhereInput | null
    isNot?: MapWhereInput | null
  }

  export type DatasetResourceCountOrderByAggregateInput = {
    id?: SortOrder
    datasetId?: SortOrder
    url?: SortOrder
    isMainFile?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    format?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrder
    excerptI18n?: SortOrder
    mapId?: SortOrder
  }

  export type DatasetResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    datasetId?: SortOrder
    url?: SortOrder
    isMainFile?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    format?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrder
    mapId?: SortOrder
  }

  export type DatasetResourceMinOrderByAggregateInput = {
    id?: SortOrder
    datasetId?: SortOrder
    url?: SortOrder
    isMainFile?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    format?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrder
    mapId?: SortOrder
  }

  export type EnumResouceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResouceType | EnumResouceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResouceType[] | ListEnumResouceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResouceType[] | ListEnumResouceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResouceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ResouceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResouceTypeFilter<$PrismaModel>
    _max?: NestedEnumResouceTypeFilter<$PrismaModel>
  }

  export type MapLayerAssociationListRelationFilter = {
    every?: MapLayerAssociationWhereInput
    some?: MapLayerAssociationWhereInput
    none?: MapLayerAssociationWhereInput
  }

  export type MapLayerAssociationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MapCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    titleI18n?: SortOrder
    descriptionI18n?: SortOrder
    year?: SortOrder
    version?: SortOrder
    thumbnailId?: SortOrder
    config?: SortOrder
    globalStyleConfig?: SortOrder
    referenceLinks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    period?: SortOrder
    title?: SortOrder
    yearMax?: SortOrder
    yearMin?: SortOrder
    categoryId?: SortOrder
    status?: SortOrder
  }

  export type MapAvgOrderByAggregateInput = {
    year?: SortOrder
    yearMax?: SortOrder
    yearMin?: SortOrder
  }

  export type MapMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    year?: SortOrder
    version?: SortOrder
    thumbnailId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    period?: SortOrder
    title?: SortOrder
    yearMax?: SortOrder
    yearMin?: SortOrder
    categoryId?: SortOrder
    status?: SortOrder
  }

  export type MapMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    year?: SortOrder
    version?: SortOrder
    thumbnailId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    period?: SortOrder
    title?: SortOrder
    yearMax?: SortOrder
    yearMin?: SortOrder
    categoryId?: SortOrder
    status?: SortOrder
  }

  export type MapSumOrderByAggregateInput = {
    year?: SortOrder
    yearMax?: SortOrder
    yearMin?: SortOrder
  }

  export type EnumLayerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LayerType | EnumLayerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LayerType[] | ListEnumLayerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LayerType[] | ListEnumLayerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLayerTypeFilter<$PrismaModel> | $Enums.LayerType
  }

  export type EnumLayerSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LayerSourceType | EnumLayerSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LayerSourceType[] | ListEnumLayerSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LayerSourceType[] | ListEnumLayerSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLayerSourceTypeFilter<$PrismaModel> | $Enums.LayerSourceType
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type LayerCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    nameI18n?: SortOrder
    description?: SortOrder
    descriptionI18n?: SortOrder
    filename?: SortOrder
    status?: SortOrder
    version?: SortOrder
    categoryId?: SortOrder
    type?: SortOrder
    citationText?: SortOrder
    citationTextI18n?: SortOrder
    codebookText?: SortOrder
    codebookTextI18n?: SortOrder
    sources?: SortOrder
    sourcesI18n?: SortOrder
    license?: SortOrder
    maturity?: SortOrder
    minYear?: SortOrder
    maxYear?: SortOrder
    sourceType?: SortOrder
    sourceUrl?: SortOrder
    downloadUrl?: SortOrder
    geoJsonData?: SortOrder
    styleConfig?: SortOrder
    thumbnail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LayerAvgOrderByAggregateInput = {
    minYear?: SortOrder
    maxYear?: SortOrder
  }

  export type LayerMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    filename?: SortOrder
    status?: SortOrder
    version?: SortOrder
    categoryId?: SortOrder
    type?: SortOrder
    citationText?: SortOrder
    codebookText?: SortOrder
    sources?: SortOrder
    license?: SortOrder
    maturity?: SortOrder
    minYear?: SortOrder
    maxYear?: SortOrder
    sourceType?: SortOrder
    sourceUrl?: SortOrder
    downloadUrl?: SortOrder
    thumbnail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LayerMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    filename?: SortOrder
    status?: SortOrder
    version?: SortOrder
    categoryId?: SortOrder
    type?: SortOrder
    citationText?: SortOrder
    codebookText?: SortOrder
    sources?: SortOrder
    license?: SortOrder
    maturity?: SortOrder
    minYear?: SortOrder
    maxYear?: SortOrder
    sourceType?: SortOrder
    sourceUrl?: SortOrder
    downloadUrl?: SortOrder
    thumbnail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LayerSumOrderByAggregateInput = {
    minYear?: SortOrder
    maxYear?: SortOrder
  }

  export type EnumLayerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LayerType | EnumLayerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LayerType[] | ListEnumLayerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LayerType[] | ListEnumLayerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLayerTypeWithAggregatesFilter<$PrismaModel> | $Enums.LayerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLayerTypeFilter<$PrismaModel>
    _max?: NestedEnumLayerTypeFilter<$PrismaModel>
  }

  export type EnumLayerSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LayerSourceType | EnumLayerSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LayerSourceType[] | ListEnumLayerSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LayerSourceType[] | ListEnumLayerSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLayerSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.LayerSourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLayerSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumLayerSourceTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type LayerScalarRelationFilter = {
    is?: LayerWhereInput
    isNot?: LayerWhereInput
  }

  export type MapScalarRelationFilter = {
    is?: MapWhereInput
    isNot?: MapWhereInput
  }

  export type MapLayerAssociationMapIdLayerIdCompoundUniqueInput = {
    mapId: string
    layerId: string
  }

  export type MapLayerAssociationCountOrderByAggregateInput = {
    id?: SortOrder
    mapId?: SortOrder
    layerId?: SortOrder
    zIndex?: SortOrder
    isVisible?: SortOrder
    isVisibleByDefault?: SortOrder
    styleOverride?: SortOrder
    interactionConfig?: SortOrder
    createdAt?: SortOrder
  }

  export type MapLayerAssociationAvgOrderByAggregateInput = {
    zIndex?: SortOrder
  }

  export type MapLayerAssociationMaxOrderByAggregateInput = {
    id?: SortOrder
    mapId?: SortOrder
    layerId?: SortOrder
    zIndex?: SortOrder
    isVisible?: SortOrder
    isVisibleByDefault?: SortOrder
    createdAt?: SortOrder
  }

  export type MapLayerAssociationMinOrderByAggregateInput = {
    id?: SortOrder
    mapId?: SortOrder
    layerId?: SortOrder
    zIndex?: SortOrder
    isVisible?: SortOrder
    isVisibleByDefault?: SortOrder
    createdAt?: SortOrder
  }

  export type MapLayerAssociationSumOrderByAggregateInput = {
    zIndex?: SortOrder
  }

  export type SeriesListRelationFilter = {
    every?: SeriesWhereInput
    some?: SeriesWhereInput
    none?: SeriesWhereInput
  }

  export type SeriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CollectionCountOrderByAggregateInput = {
    id?: SortOrder
    nameI18n?: SortOrder
    descriptionI18n?: SortOrder
    createdAt?: SortOrder
    thumbnailId?: SortOrder
    name?: SortOrder
    referenceCode?: SortOrder
    yearMax?: SortOrder
    yearMin?: SortOrder
  }

  export type CollectionAvgOrderByAggregateInput = {
    yearMax?: SortOrder
    yearMin?: SortOrder
  }

  export type CollectionMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    thumbnailId?: SortOrder
    name?: SortOrder
    referenceCode?: SortOrder
    yearMax?: SortOrder
    yearMin?: SortOrder
  }

  export type CollectionMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    thumbnailId?: SortOrder
    name?: SortOrder
    referenceCode?: SortOrder
    yearMax?: SortOrder
    yearMin?: SortOrder
  }

  export type CollectionSumOrderByAggregateInput = {
    yearMax?: SortOrder
    yearMin?: SortOrder
  }

  export type EnumContentLanguageNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentLanguage[] | ListEnumContentLanguageFieldRefInput<$PrismaModel> | null
    has?: $Enums.ContentLanguage | EnumContentLanguageFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.ContentLanguage[] | ListEnumContentLanguageFieldRefInput<$PrismaModel>
    hasSome?: $Enums.ContentLanguage[] | ListEnumContentLanguageFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CollectionNullableScalarRelationFilter = {
    is?: CollectionWhereInput | null
    isNot?: CollectionWhereInput | null
  }

  export type VolumeListRelationFilter = {
    every?: VolumeWhereInput
    some?: VolumeWhereInput
    none?: VolumeWhereInput
  }

  export type VolumeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeriesCountOrderByAggregateInput = {
    id?: SortOrder
    collectionId?: SortOrder
    nameI18n?: SortOrder
    descriptionI18n?: SortOrder
    indexNumber?: SortOrder
    volumeLabelFormat?: SortOrder
    thumbnailId?: SortOrder
    createdAt?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    license?: SortOrder
    period?: SortOrder
    sourceLink?: SortOrder
    sources?: SortOrder
    author?: SortOrder
    editor?: SortOrder
    referenceCode?: SortOrder
    yearMax?: SortOrder
    yearMin?: SortOrder
    languages?: SortOrder
  }

  export type SeriesAvgOrderByAggregateInput = {
    indexNumber?: SortOrder
    yearMax?: SortOrder
    yearMin?: SortOrder
  }

  export type SeriesMaxOrderByAggregateInput = {
    id?: SortOrder
    collectionId?: SortOrder
    indexNumber?: SortOrder
    volumeLabelFormat?: SortOrder
    thumbnailId?: SortOrder
    createdAt?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    license?: SortOrder
    period?: SortOrder
    sourceLink?: SortOrder
    sources?: SortOrder
    author?: SortOrder
    editor?: SortOrder
    referenceCode?: SortOrder
    yearMax?: SortOrder
    yearMin?: SortOrder
  }

  export type SeriesMinOrderByAggregateInput = {
    id?: SortOrder
    collectionId?: SortOrder
    indexNumber?: SortOrder
    volumeLabelFormat?: SortOrder
    thumbnailId?: SortOrder
    createdAt?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    description?: SortOrder
    license?: SortOrder
    period?: SortOrder
    sourceLink?: SortOrder
    sources?: SortOrder
    author?: SortOrder
    editor?: SortOrder
    referenceCode?: SortOrder
    yearMax?: SortOrder
    yearMin?: SortOrder
  }

  export type SeriesSumOrderByAggregateInput = {
    indexNumber?: SortOrder
    yearMax?: SortOrder
    yearMin?: SortOrder
  }

  export type VolumePageListRelationFilter = {
    every?: VolumePageWhereInput
    some?: VolumePageWhereInput
    none?: VolumePageWhereInput
  }

  export type SeriesNullableScalarRelationFilter = {
    is?: SeriesWhereInput | null
    isNot?: SeriesWhereInput | null
  }

  export type VolumePageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VolumeCountOrderByAggregateInput = {
    id?: SortOrder
    seriesId?: SortOrder
    indexNumber?: SortOrder
    titleI18n?: SortOrder
    descriptionI18n?: SortOrder
    languageOfContent?: SortOrder
    yearContent?: SortOrder
    thumbnailId?: SortOrder
    createdAt?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    license?: SortOrder
    sourceLink?: SortOrder
    sources?: SortOrder
    year?: SortOrder
    author?: SortOrder
    editor?: SortOrder
    languages?: SortOrder
    yearMax?: SortOrder
    yearMin?: SortOrder
  }

  export type VolumeAvgOrderByAggregateInput = {
    indexNumber?: SortOrder
    yearContent?: SortOrder
    year?: SortOrder
    yearMax?: SortOrder
    yearMin?: SortOrder
  }

  export type VolumeMaxOrderByAggregateInput = {
    id?: SortOrder
    seriesId?: SortOrder
    indexNumber?: SortOrder
    languageOfContent?: SortOrder
    yearContent?: SortOrder
    thumbnailId?: SortOrder
    createdAt?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    license?: SortOrder
    sourceLink?: SortOrder
    sources?: SortOrder
    year?: SortOrder
    author?: SortOrder
    editor?: SortOrder
    yearMax?: SortOrder
    yearMin?: SortOrder
  }

  export type VolumeMinOrderByAggregateInput = {
    id?: SortOrder
    seriesId?: SortOrder
    indexNumber?: SortOrder
    languageOfContent?: SortOrder
    yearContent?: SortOrder
    thumbnailId?: SortOrder
    createdAt?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    license?: SortOrder
    sourceLink?: SortOrder
    sources?: SortOrder
    year?: SortOrder
    author?: SortOrder
    editor?: SortOrder
    yearMax?: SortOrder
    yearMin?: SortOrder
  }

  export type VolumeSumOrderByAggregateInput = {
    indexNumber?: SortOrder
    yearContent?: SortOrder
    year?: SortOrder
    yearMax?: SortOrder
    yearMin?: SortOrder
  }

  export type PageDataNullableScalarRelationFilter = {
    is?: PageDataWhereInput | null
    isNot?: PageDataWhereInput | null
  }

  export type PageImageListRelationFilter = {
    every?: PageImageWhereInput
    some?: PageImageWhereInput
    none?: PageImageWhereInput
  }

  export type VolumeNullableScalarRelationFilter = {
    is?: VolumeWhereInput | null
    isNot?: VolumeWhereInput | null
  }

  export type ArtifactListRelationFilter = {
    every?: ArtifactWhereInput
    some?: ArtifactWhereInput
    none?: ArtifactWhereInput
  }

  export type PageImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArtifactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VolumePageCountOrderByAggregateInput = {
    id?: SortOrder
    volumeId?: SortOrder
    sequenceIndex?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    isVisible?: SortOrder
  }

  export type VolumePageAvgOrderByAggregateInput = {
    sequenceIndex?: SortOrder
  }

  export type VolumePageMaxOrderByAggregateInput = {
    id?: SortOrder
    volumeId?: SortOrder
    sequenceIndex?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    isVisible?: SortOrder
  }

  export type VolumePageMinOrderByAggregateInput = {
    id?: SortOrder
    volumeId?: SortOrder
    sequenceIndex?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    isVisible?: SortOrder
  }

  export type VolumePageSumOrderByAggregateInput = {
    sequenceIndex?: SortOrder
  }

  export type ArtifactCategoryNullableScalarRelationFilter = {
    is?: ArtifactCategoryWhereInput | null
    isNot?: ArtifactCategoryWhereInput | null
  }

  export type PeriodListRelationFilter = {
    every?: PeriodWhereInput
    some?: PeriodWhereInput
    none?: PeriodWhereInput
  }

  export type PlaceListRelationFilter = {
    every?: PlaceWhereInput
    some?: PlaceWhereInput
    none?: PlaceWhereInput
  }

  export type PeriodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArtifactCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    contentI18n?: SortOrder
    year?: SortOrder
    dateDisplay?: SortOrder
    dateSort?: SortOrder
    excerpt?: SortOrder
    excerptI18n?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    descriptionI18n?: SortOrder
    displayScans?: SortOrder
    displayTexts?: SortOrder
    sources?: SortOrder
    title?: SortOrder
    titleI18n?: SortOrder
    artifactCategoryId?: SortOrder
  }

  export type ArtifactAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type ArtifactMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    year?: SortOrder
    dateDisplay?: SortOrder
    dateSort?: SortOrder
    excerpt?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    displayScans?: SortOrder
    displayTexts?: SortOrder
    title?: SortOrder
    artifactCategoryId?: SortOrder
  }

  export type ArtifactMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    year?: SortOrder
    dateDisplay?: SortOrder
    dateSort?: SortOrder
    excerpt?: SortOrder
    createdAt?: SortOrder
    description?: SortOrder
    displayScans?: SortOrder
    displayTexts?: SortOrder
    title?: SortOrder
    artifactCategoryId?: SortOrder
  }

  export type ArtifactSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type EnumTextTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TextType | EnumTextTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TextType[] | ListEnumTextTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextType[] | ListEnumTextTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTextTypeFilter<$PrismaModel> | $Enums.TextType
  }

  export type VolumePageScalarRelationFilter = {
    is?: VolumePageWhereInput
    isNot?: VolumePageWhereInput
  }

  export type PageTextCountOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    language?: SortOrder
    textAccuracy?: SortOrder
    contributorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageTextAvgOrderByAggregateInput = {
    textAccuracy?: SortOrder
  }

  export type PageTextMaxOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    language?: SortOrder
    textAccuracy?: SortOrder
    contributorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageTextMinOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    language?: SortOrder
    textAccuracy?: SortOrder
    contributorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageTextSumOrderByAggregateInput = {
    textAccuracy?: SortOrder
  }

  export type EnumTextTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TextType | EnumTextTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TextType[] | ListEnumTextTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextType[] | ListEnumTextTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTextTypeWithAggregatesFilter<$PrismaModel> | $Enums.TextType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTextTypeFilter<$PrismaModel>
    _max?: NestedEnumTextTypeFilter<$PrismaModel>
  }

  export type PageDataCountOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    ocrData?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageDataMaxOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageDataMinOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumImageUseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageUseType | EnumImageUseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImageUseType[] | ListEnumImageUseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImageUseType[] | ListEnumImageUseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImageUseTypeFilter<$PrismaModel> | $Enums.ImageUseType
  }

  export type StorageFileScalarRelationFilter = {
    is?: StorageFileWhereInput
    isNot?: StorageFileWhereInput
  }

  export type PageImageCountOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    storageFileId?: SortOrder
    useType?: SortOrder
    createdAt?: SortOrder
  }

  export type PageImageMaxOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    storageFileId?: SortOrder
    useType?: SortOrder
    createdAt?: SortOrder
  }

  export type PageImageMinOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    storageFileId?: SortOrder
    useType?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumImageUseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageUseType | EnumImageUseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImageUseType[] | ListEnumImageUseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImageUseType[] | ListEnumImageUseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImageUseTypeWithAggregatesFilter<$PrismaModel> | $Enums.ImageUseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImageUseTypeFilter<$PrismaModel>
    _max?: NestedEnumImageUseTypeFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type MediaListRelationFilter = {
    every?: MediaWhereInput
    some?: MediaWhereInput
    none?: MediaWhereInput
  }

  export type MediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StorageFileCountOrderByAggregateInput = {
    id?: SortOrder
    bucketName?: SortOrder
    storageKey?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    hashEtag?: SortOrder
    publicUrl?: SortOrder
    isPublic?: SortOrder
    width?: SortOrder
    height?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorageFileAvgOrderByAggregateInput = {
    sizeBytes?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type StorageFileMaxOrderByAggregateInput = {
    id?: SortOrder
    bucketName?: SortOrder
    storageKey?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    hashEtag?: SortOrder
    publicUrl?: SortOrder
    isPublic?: SortOrder
    width?: SortOrder
    height?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorageFileMinOrderByAggregateInput = {
    id?: SortOrder
    bucketName?: SortOrder
    storageKey?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    hashEtag?: SortOrder
    publicUrl?: SortOrder
    isPublic?: SortOrder
    width?: SortOrder
    height?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorageFileSumOrderByAggregateInput = {
    sizeBytes?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type CollectionListRelationFilter = {
    every?: CollectionWhereInput
    some?: CollectionWhereInput
    none?: CollectionWhereInput
  }

  export type MapListRelationFilter = {
    every?: MapWhereInput
    some?: MapWhereInput
    none?: MapWhereInput
  }

  export type StorageFileNullableScalarRelationFilter = {
    is?: StorageFileWhereInput | null
    isNot?: StorageFileWhereInput | null
  }

  export type ResearchDatasetListRelationFilter = {
    every?: ResearchDatasetWhereInput
    some?: ResearchDatasetWhereInput
    none?: ResearchDatasetWhereInput
  }

  export type CollectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResearchDatasetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    storageFileId?: SortOrder
    altTextI18n?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    storageFileId?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    storageFileId?: SortOrder
    createdAt?: SortOrder
  }

  export type AdministrativePlaceListRelationFilter = {
    every?: AdministrativePlaceWhereInput
    some?: AdministrativePlaceWhereInput
    none?: AdministrativePlaceWhereInput
  }

  export type AdministrativePlaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlaceCountOrderByAggregateInput = {
    id?: SortOrder
    geoname?: SortOrder
    geocode?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    countryCode?: SortOrder
    admin1?: SortOrder
    admin2?: SortOrder
  }

  export type PlaceAvgOrderByAggregateInput = {
    lat?: SortOrder
    lon?: SortOrder
  }

  export type PlaceMaxOrderByAggregateInput = {
    id?: SortOrder
    geoname?: SortOrder
    geocode?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    countryCode?: SortOrder
    admin1?: SortOrder
    admin2?: SortOrder
  }

  export type PlaceMinOrderByAggregateInput = {
    id?: SortOrder
    geoname?: SortOrder
    geocode?: SortOrder
    lat?: SortOrder
    lon?: SortOrder
    countryCode?: SortOrder
    admin1?: SortOrder
    admin2?: SortOrder
  }

  export type PlaceSumOrderByAggregateInput = {
    lat?: SortOrder
    lon?: SortOrder
  }

  export type PlaceNullableScalarRelationFilter = {
    is?: PlaceWhereInput | null
    isNot?: PlaceWhereInput | null
  }

  export type AdministrativePlaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    year?: SortOrder
    source?: SortOrder
    admin1?: SortOrder
    admin2?: SortOrder
    jewishPop?: SortOrder
    totalPop?: SortOrder
    placeId?: SortOrder
  }

  export type AdministrativePlaceAvgOrderByAggregateInput = {
    jewishPop?: SortOrder
    totalPop?: SortOrder
  }

  export type AdministrativePlaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    year?: SortOrder
    source?: SortOrder
    admin1?: SortOrder
    admin2?: SortOrder
    jewishPop?: SortOrder
    totalPop?: SortOrder
    placeId?: SortOrder
  }

  export type AdministrativePlaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    year?: SortOrder
    source?: SortOrder
    admin1?: SortOrder
    admin2?: SortOrder
    jewishPop?: SortOrder
    totalPop?: SortOrder
    placeId?: SortOrder
  }

  export type AdministrativePlaceSumOrderByAggregateInput = {
    jewishPop?: SortOrder
    totalPop?: SortOrder
  }

  export type LayerListRelationFilter = {
    every?: LayerWhereInput
    some?: LayerWhereInput
    none?: LayerWhereInput
  }

  export type LayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    nameI18n?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    name?: SortOrder
  }

  export type RegionCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    nameI18n?: SortOrder
    createdAt?: SortOrder
  }

  export type RegionMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type RegionMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    thumbnailId?: SortOrder
    createdAt?: SortOrder
    titleI18n?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    thumbnailId?: SortOrder
    createdAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    thumbnailId?: SortOrder
    createdAt?: SortOrder
  }

  export type ArtifactCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    titleI18n?: SortOrder
    createdAt?: SortOrder
  }

  export type ArtifactCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
  }

  export type ArtifactCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
  }

  export type PeriodCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    nameI18n?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    createdAt?: SortOrder
  }

  export type PeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    createdAt?: SortOrder
  }

  export type PeriodMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    dateStart?: SortOrder
    dateEnd?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumMenuLocationFilter<$PrismaModel = never> = {
    equals?: $Enums.MenuLocation | EnumMenuLocationFieldRefInput<$PrismaModel>
    in?: $Enums.MenuLocation[] | ListEnumMenuLocationFieldRefInput<$PrismaModel>
    notIn?: $Enums.MenuLocation[] | ListEnumMenuLocationFieldRefInput<$PrismaModel>
    not?: NestedEnumMenuLocationFilter<$PrismaModel> | $Enums.MenuLocation
  }

  export type MenuCountOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuMaxOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuMinOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMenuLocationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MenuLocation | EnumMenuLocationFieldRefInput<$PrismaModel>
    in?: $Enums.MenuLocation[] | ListEnumMenuLocationFieldRefInput<$PrismaModel>
    notIn?: $Enums.MenuLocation[] | ListEnumMenuLocationFieldRefInput<$PrismaModel>
    not?: NestedEnumMenuLocationWithAggregatesFilter<$PrismaModel> | $Enums.MenuLocation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMenuLocationFilter<$PrismaModel>
    _max?: NestedEnumMenuLocationFilter<$PrismaModel>
  }

  export type EnumItemVariantFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemVariant | EnumItemVariantFieldRefInput<$PrismaModel>
    in?: $Enums.ItemVariant[] | ListEnumItemVariantFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemVariant[] | ListEnumItemVariantFieldRefInput<$PrismaModel>
    not?: NestedEnumItemVariantFilter<$PrismaModel> | $Enums.ItemVariant
  }

  export type MenuScalarRelationFilter = {
    is?: MenuWhereInput
    isNot?: MenuWhereInput
  }

  export type MenuItemNullableScalarRelationFilter = {
    is?: MenuItemWhereInput | null
    isNot?: MenuItemWhereInput | null
  }

  export type MenuItemCountOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    parentId?: SortOrder
    label?: SortOrder
    labelI18n?: SortOrder
    icon?: SortOrder
    variant?: SortOrder
    order?: SortOrder
    pageId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuItemAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type MenuItemMaxOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    parentId?: SortOrder
    label?: SortOrder
    icon?: SortOrder
    variant?: SortOrder
    order?: SortOrder
    pageId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuItemMinOrderByAggregateInput = {
    id?: SortOrder
    menuId?: SortOrder
    parentId?: SortOrder
    label?: SortOrder
    icon?: SortOrder
    variant?: SortOrder
    order?: SortOrder
    pageId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MenuItemSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumItemVariantWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemVariant | EnumItemVariantFieldRefInput<$PrismaModel>
    in?: $Enums.ItemVariant[] | ListEnumItemVariantFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemVariant[] | ListEnumItemVariantFieldRefInput<$PrismaModel>
    not?: NestedEnumItemVariantWithAggregatesFilter<$PrismaModel> | $Enums.ItemVariant
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemVariantFilter<$PrismaModel>
    _max?: NestedEnumItemVariantFilter<$PrismaModel>
  }

  export type EnumMenuTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MenuType | EnumMenuTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MenuType[] | ListEnumMenuTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MenuType[] | ListEnumMenuTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMenuTypeFilter<$PrismaModel> | $Enums.MenuType
  }

  export type FooterColumnCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    order?: SortOrder
    title?: SortOrder
    titleI18n?: SortOrder
    content?: SortOrder
    contentI18n?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FooterColumnAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type FooterColumnMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    order?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FooterColumnMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    order?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FooterColumnSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumMenuTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MenuType | EnumMenuTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MenuType[] | ListEnumMenuTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MenuType[] | ListEnumMenuTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMenuTypeWithAggregatesFilter<$PrismaModel> | $Enums.MenuType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMenuTypeFilter<$PrismaModel>
    _max?: NestedEnumMenuTypeFilter<$PrismaModel>
  }

  export type FooterColumnScalarRelationFilter = {
    is?: FooterColumnWhereInput
    isNot?: FooterColumnWhereInput
  }

  export type FooterColumnItemCountOrderByAggregateInput = {
    id?: SortOrder
    footerColumnId?: SortOrder
    label?: SortOrder
    labelI18n?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    pageId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FooterColumnItemAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type FooterColumnItemMaxOrderByAggregateInput = {
    id?: SortOrder
    footerColumnId?: SortOrder
    label?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    pageId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FooterColumnItemMinOrderByAggregateInput = {
    id?: SortOrder
    footerColumnId?: SortOrder
    label?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    pageId?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FooterColumnItemSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type SiteSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    copyrightText?: SortOrder
    copyrightI18n?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    copyrightText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SiteSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    copyrightText?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumContentLanguageFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentLanguage | EnumContentLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.ContentLanguage[] | ListEnumContentLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentLanguage[] | ListEnumContentLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumContentLanguageFilter<$PrismaModel> | $Enums.ContentLanguage
  }

  export type DocumentPageListRelationFilter = {
    every?: DocumentPageWhereInput
    some?: DocumentPageWhereInput
    none?: DocumentPageWhereInput
  }

  export type DocumentPageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    description?: SortOrder
    descriptionEn?: SortOrder
    category?: SortOrder
    year?: SortOrder
    reference?: SortOrder
    referenceUrl?: SortOrder
    scanUrl?: SortOrder
    scanZip?: SortOrder
    lang?: SortOrder
    status?: SortOrder
    license?: SortOrder
    volume?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    description?: SortOrder
    descriptionEn?: SortOrder
    category?: SortOrder
    year?: SortOrder
    reference?: SortOrder
    referenceUrl?: SortOrder
    scanUrl?: SortOrder
    scanZip?: SortOrder
    lang?: SortOrder
    status?: SortOrder
    license?: SortOrder
    volume?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    titleEn?: SortOrder
    description?: SortOrder
    descriptionEn?: SortOrder
    category?: SortOrder
    year?: SortOrder
    reference?: SortOrder
    referenceUrl?: SortOrder
    scanUrl?: SortOrder
    scanZip?: SortOrder
    lang?: SortOrder
    status?: SortOrder
    license?: SortOrder
    volume?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type EnumContentLanguageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentLanguage | EnumContentLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.ContentLanguage[] | ListEnumContentLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentLanguage[] | ListEnumContentLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumContentLanguageWithAggregatesFilter<$PrismaModel> | $Enums.ContentLanguage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentLanguageFilter<$PrismaModel>
    _max?: NestedEnumContentLanguageFilter<$PrismaModel>
  }

  export type DocumentScalarRelationFilter = {
    is?: DocumentWhereInput
    isNot?: DocumentWhereInput
  }

  export type DocumentPageDocumentIdIndexCompoundUniqueInput = {
    documentId: string
    index: number
  }

  export type DocumentPageCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    index?: SortOrder
    content?: SortOrder
    contentHe?: SortOrder
    contentEn?: SortOrder
    filename?: SortOrder
    bookmark?: SortOrder
    highlights?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentPageAvgOrderByAggregateInput = {
    index?: SortOrder
  }

  export type DocumentPageMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    index?: SortOrder
    content?: SortOrder
    contentHe?: SortOrder
    contentEn?: SortOrder
    filename?: SortOrder
    bookmark?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentPageMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    index?: SortOrder
    content?: SortOrder
    contentHe?: SortOrder
    contentEn?: SortOrder
    filename?: SortOrder
    bookmark?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentPageSumOrderByAggregateInput = {
    index?: SortOrder
  }

  export type UserCreateNestedOneWithoutPagesInput = {
    create?: XOR<UserCreateWithoutPagesInput, UserUncheckedCreateWithoutPagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPagesInput
    connect?: UserWhereUniqueInput
  }

  export type PageCreateNestedOneWithoutChildrenInput = {
    create?: XOR<PageCreateWithoutChildrenInput, PageUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: PageCreateOrConnectWithoutChildrenInput
    connect?: PageWhereUniqueInput
  }

  export type PageCreateNestedManyWithoutParentInput = {
    create?: XOR<PageCreateWithoutParentInput, PageUncheckedCreateWithoutParentInput> | PageCreateWithoutParentInput[] | PageUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PageCreateOrConnectWithoutParentInput | PageCreateOrConnectWithoutParentInput[]
    createMany?: PageCreateManyParentInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type MediaCreateNestedOneWithoutThumbnailForPagesInput = {
    create?: XOR<MediaCreateWithoutThumbnailForPagesInput, MediaUncheckedCreateWithoutThumbnailForPagesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutThumbnailForPagesInput
    connect?: MediaWhereUniqueInput
  }

  export type RegionCreateNestedManyWithoutPagesInput = {
    create?: XOR<RegionCreateWithoutPagesInput, RegionUncheckedCreateWithoutPagesInput> | RegionCreateWithoutPagesInput[] | RegionUncheckedCreateWithoutPagesInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutPagesInput | RegionCreateOrConnectWithoutPagesInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutPagesInput = {
    create?: XOR<TagCreateWithoutPagesInput, TagUncheckedCreateWithoutPagesInput> | TagCreateWithoutPagesInput[] | TagUncheckedCreateWithoutPagesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutPagesInput | TagCreateOrConnectWithoutPagesInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type MenuItemCreateNestedManyWithoutPageInput = {
    create?: XOR<MenuItemCreateWithoutPageInput, MenuItemUncheckedCreateWithoutPageInput> | MenuItemCreateWithoutPageInput[] | MenuItemUncheckedCreateWithoutPageInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutPageInput | MenuItemCreateOrConnectWithoutPageInput[]
    createMany?: MenuItemCreateManyPageInputEnvelope
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
  }

  export type FooterColumnItemCreateNestedManyWithoutPageInput = {
    create?: XOR<FooterColumnItemCreateWithoutPageInput, FooterColumnItemUncheckedCreateWithoutPageInput> | FooterColumnItemCreateWithoutPageInput[] | FooterColumnItemUncheckedCreateWithoutPageInput[]
    connectOrCreate?: FooterColumnItemCreateOrConnectWithoutPageInput | FooterColumnItemCreateOrConnectWithoutPageInput[]
    createMany?: FooterColumnItemCreateManyPageInputEnvelope
    connect?: FooterColumnItemWhereUniqueInput | FooterColumnItemWhereUniqueInput[]
  }

  export type PageUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<PageCreateWithoutParentInput, PageUncheckedCreateWithoutParentInput> | PageCreateWithoutParentInput[] | PageUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PageCreateOrConnectWithoutParentInput | PageCreateOrConnectWithoutParentInput[]
    createMany?: PageCreateManyParentInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type RegionUncheckedCreateNestedManyWithoutPagesInput = {
    create?: XOR<RegionCreateWithoutPagesInput, RegionUncheckedCreateWithoutPagesInput> | RegionCreateWithoutPagesInput[] | RegionUncheckedCreateWithoutPagesInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutPagesInput | RegionCreateOrConnectWithoutPagesInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutPagesInput = {
    create?: XOR<TagCreateWithoutPagesInput, TagUncheckedCreateWithoutPagesInput> | TagCreateWithoutPagesInput[] | TagUncheckedCreateWithoutPagesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutPagesInput | TagCreateOrConnectWithoutPagesInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type MenuItemUncheckedCreateNestedManyWithoutPageInput = {
    create?: XOR<MenuItemCreateWithoutPageInput, MenuItemUncheckedCreateWithoutPageInput> | MenuItemCreateWithoutPageInput[] | MenuItemUncheckedCreateWithoutPageInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutPageInput | MenuItemCreateOrConnectWithoutPageInput[]
    createMany?: MenuItemCreateManyPageInputEnvelope
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
  }

  export type FooterColumnItemUncheckedCreateNestedManyWithoutPageInput = {
    create?: XOR<FooterColumnItemCreateWithoutPageInput, FooterColumnItemUncheckedCreateWithoutPageInput> | FooterColumnItemCreateWithoutPageInput[] | FooterColumnItemUncheckedCreateWithoutPageInput[]
    connectOrCreate?: FooterColumnItemCreateOrConnectWithoutPageInput | FooterColumnItemCreateOrConnectWithoutPageInput[]
    createMany?: FooterColumnItemCreateManyPageInputEnvelope
    connect?: FooterColumnItemWhereUniqueInput | FooterColumnItemWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumAppLanguageFieldUpdateOperationsInput = {
    set?: $Enums.AppLanguage
  }

  export type EnumContentStatusFieldUpdateOperationsInput = {
    set?: $Enums.ContentStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneWithoutPagesNestedInput = {
    create?: XOR<UserCreateWithoutPagesInput, UserUncheckedCreateWithoutPagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPagesInput
    upsert?: UserUpsertWithoutPagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPagesInput, UserUpdateWithoutPagesInput>, UserUncheckedUpdateWithoutPagesInput>
  }

  export type PageUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<PageCreateWithoutChildrenInput, PageUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: PageCreateOrConnectWithoutChildrenInput
    upsert?: PageUpsertWithoutChildrenInput
    disconnect?: PageWhereInput | boolean
    delete?: PageWhereInput | boolean
    connect?: PageWhereUniqueInput
    update?: XOR<XOR<PageUpdateToOneWithWhereWithoutChildrenInput, PageUpdateWithoutChildrenInput>, PageUncheckedUpdateWithoutChildrenInput>
  }

  export type PageUpdateManyWithoutParentNestedInput = {
    create?: XOR<PageCreateWithoutParentInput, PageUncheckedCreateWithoutParentInput> | PageCreateWithoutParentInput[] | PageUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PageCreateOrConnectWithoutParentInput | PageCreateOrConnectWithoutParentInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutParentInput | PageUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: PageCreateManyParentInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutParentInput | PageUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: PageUpdateManyWithWhereWithoutParentInput | PageUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type MediaUpdateOneWithoutThumbnailForPagesNestedInput = {
    create?: XOR<MediaCreateWithoutThumbnailForPagesInput, MediaUncheckedCreateWithoutThumbnailForPagesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutThumbnailForPagesInput
    upsert?: MediaUpsertWithoutThumbnailForPagesInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutThumbnailForPagesInput, MediaUpdateWithoutThumbnailForPagesInput>, MediaUncheckedUpdateWithoutThumbnailForPagesInput>
  }

  export type RegionUpdateManyWithoutPagesNestedInput = {
    create?: XOR<RegionCreateWithoutPagesInput, RegionUncheckedCreateWithoutPagesInput> | RegionCreateWithoutPagesInput[] | RegionUncheckedCreateWithoutPagesInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutPagesInput | RegionCreateOrConnectWithoutPagesInput[]
    upsert?: RegionUpsertWithWhereUniqueWithoutPagesInput | RegionUpsertWithWhereUniqueWithoutPagesInput[]
    set?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    disconnect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    delete?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    update?: RegionUpdateWithWhereUniqueWithoutPagesInput | RegionUpdateWithWhereUniqueWithoutPagesInput[]
    updateMany?: RegionUpdateManyWithWhereWithoutPagesInput | RegionUpdateManyWithWhereWithoutPagesInput[]
    deleteMany?: RegionScalarWhereInput | RegionScalarWhereInput[]
  }

  export type TagUpdateManyWithoutPagesNestedInput = {
    create?: XOR<TagCreateWithoutPagesInput, TagUncheckedCreateWithoutPagesInput> | TagCreateWithoutPagesInput[] | TagUncheckedCreateWithoutPagesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutPagesInput | TagCreateOrConnectWithoutPagesInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutPagesInput | TagUpsertWithWhereUniqueWithoutPagesInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutPagesInput | TagUpdateWithWhereUniqueWithoutPagesInput[]
    updateMany?: TagUpdateManyWithWhereWithoutPagesInput | TagUpdateManyWithWhereWithoutPagesInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type MenuItemUpdateManyWithoutPageNestedInput = {
    create?: XOR<MenuItemCreateWithoutPageInput, MenuItemUncheckedCreateWithoutPageInput> | MenuItemCreateWithoutPageInput[] | MenuItemUncheckedCreateWithoutPageInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutPageInput | MenuItemCreateOrConnectWithoutPageInput[]
    upsert?: MenuItemUpsertWithWhereUniqueWithoutPageInput | MenuItemUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: MenuItemCreateManyPageInputEnvelope
    set?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    disconnect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    delete?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    update?: MenuItemUpdateWithWhereUniqueWithoutPageInput | MenuItemUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: MenuItemUpdateManyWithWhereWithoutPageInput | MenuItemUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
  }

  export type FooterColumnItemUpdateManyWithoutPageNestedInput = {
    create?: XOR<FooterColumnItemCreateWithoutPageInput, FooterColumnItemUncheckedCreateWithoutPageInput> | FooterColumnItemCreateWithoutPageInput[] | FooterColumnItemUncheckedCreateWithoutPageInput[]
    connectOrCreate?: FooterColumnItemCreateOrConnectWithoutPageInput | FooterColumnItemCreateOrConnectWithoutPageInput[]
    upsert?: FooterColumnItemUpsertWithWhereUniqueWithoutPageInput | FooterColumnItemUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: FooterColumnItemCreateManyPageInputEnvelope
    set?: FooterColumnItemWhereUniqueInput | FooterColumnItemWhereUniqueInput[]
    disconnect?: FooterColumnItemWhereUniqueInput | FooterColumnItemWhereUniqueInput[]
    delete?: FooterColumnItemWhereUniqueInput | FooterColumnItemWhereUniqueInput[]
    connect?: FooterColumnItemWhereUniqueInput | FooterColumnItemWhereUniqueInput[]
    update?: FooterColumnItemUpdateWithWhereUniqueWithoutPageInput | FooterColumnItemUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: FooterColumnItemUpdateManyWithWhereWithoutPageInput | FooterColumnItemUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: FooterColumnItemScalarWhereInput | FooterColumnItemScalarWhereInput[]
  }

  export type PageUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<PageCreateWithoutParentInput, PageUncheckedCreateWithoutParentInput> | PageCreateWithoutParentInput[] | PageUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PageCreateOrConnectWithoutParentInput | PageCreateOrConnectWithoutParentInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutParentInput | PageUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: PageCreateManyParentInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutParentInput | PageUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: PageUpdateManyWithWhereWithoutParentInput | PageUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type RegionUncheckedUpdateManyWithoutPagesNestedInput = {
    create?: XOR<RegionCreateWithoutPagesInput, RegionUncheckedCreateWithoutPagesInput> | RegionCreateWithoutPagesInput[] | RegionUncheckedCreateWithoutPagesInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutPagesInput | RegionCreateOrConnectWithoutPagesInput[]
    upsert?: RegionUpsertWithWhereUniqueWithoutPagesInput | RegionUpsertWithWhereUniqueWithoutPagesInput[]
    set?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    disconnect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    delete?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    update?: RegionUpdateWithWhereUniqueWithoutPagesInput | RegionUpdateWithWhereUniqueWithoutPagesInput[]
    updateMany?: RegionUpdateManyWithWhereWithoutPagesInput | RegionUpdateManyWithWhereWithoutPagesInput[]
    deleteMany?: RegionScalarWhereInput | RegionScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutPagesNestedInput = {
    create?: XOR<TagCreateWithoutPagesInput, TagUncheckedCreateWithoutPagesInput> | TagCreateWithoutPagesInput[] | TagUncheckedCreateWithoutPagesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutPagesInput | TagCreateOrConnectWithoutPagesInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutPagesInput | TagUpsertWithWhereUniqueWithoutPagesInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutPagesInput | TagUpdateWithWhereUniqueWithoutPagesInput[]
    updateMany?: TagUpdateManyWithWhereWithoutPagesInput | TagUpdateManyWithWhereWithoutPagesInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type MenuItemUncheckedUpdateManyWithoutPageNestedInput = {
    create?: XOR<MenuItemCreateWithoutPageInput, MenuItemUncheckedCreateWithoutPageInput> | MenuItemCreateWithoutPageInput[] | MenuItemUncheckedCreateWithoutPageInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutPageInput | MenuItemCreateOrConnectWithoutPageInput[]
    upsert?: MenuItemUpsertWithWhereUniqueWithoutPageInput | MenuItemUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: MenuItemCreateManyPageInputEnvelope
    set?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    disconnect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    delete?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    update?: MenuItemUpdateWithWhereUniqueWithoutPageInput | MenuItemUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: MenuItemUpdateManyWithWhereWithoutPageInput | MenuItemUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
  }

  export type FooterColumnItemUncheckedUpdateManyWithoutPageNestedInput = {
    create?: XOR<FooterColumnItemCreateWithoutPageInput, FooterColumnItemUncheckedCreateWithoutPageInput> | FooterColumnItemCreateWithoutPageInput[] | FooterColumnItemUncheckedCreateWithoutPageInput[]
    connectOrCreate?: FooterColumnItemCreateOrConnectWithoutPageInput | FooterColumnItemCreateOrConnectWithoutPageInput[]
    upsert?: FooterColumnItemUpsertWithWhereUniqueWithoutPageInput | FooterColumnItemUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: FooterColumnItemCreateManyPageInputEnvelope
    set?: FooterColumnItemWhereUniqueInput | FooterColumnItemWhereUniqueInput[]
    disconnect?: FooterColumnItemWhereUniqueInput | FooterColumnItemWhereUniqueInput[]
    delete?: FooterColumnItemWhereUniqueInput | FooterColumnItemWhereUniqueInput[]
    connect?: FooterColumnItemWhereUniqueInput | FooterColumnItemWhereUniqueInput[]
    update?: FooterColumnItemUpdateWithWhereUniqueWithoutPageInput | FooterColumnItemUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: FooterColumnItemUpdateManyWithWhereWithoutPageInput | FooterColumnItemUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: FooterColumnItemScalarWhereInput | FooterColumnItemScalarWhereInput[]
  }

  export type PostTagCreateNestedManyWithoutPostInput = {
    create?: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput> | PostTagCreateWithoutPostInput[] | PostTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostInput | PostTagCreateOrConnectWithoutPostInput[]
    createMany?: PostTagCreateManyPostInputEnvelope
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutThumbnailForPostsInput = {
    create?: XOR<MediaCreateWithoutThumbnailForPostsInput, MediaUncheckedCreateWithoutThumbnailForPostsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutThumbnailForPostsInput
    connect?: MediaWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutPostsInput = {
    create?: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput> | CategoryCreateWithoutPostsInput[] | CategoryUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutPostsInput | CategoryCreateOrConnectWithoutPostsInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type RegionCreateNestedManyWithoutPostsInput = {
    create?: XOR<RegionCreateWithoutPostsInput, RegionUncheckedCreateWithoutPostsInput> | RegionCreateWithoutPostsInput[] | RegionUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutPostsInput | RegionCreateOrConnectWithoutPostsInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
  }

  export type PostTagUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput> | PostTagCreateWithoutPostInput[] | PostTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostInput | PostTagCreateOrConnectWithoutPostInput[]
    createMany?: PostTagCreateManyPostInputEnvelope
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput> | CategoryCreateWithoutPostsInput[] | CategoryUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutPostsInput | CategoryCreateOrConnectWithoutPostsInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type RegionUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<RegionCreateWithoutPostsInput, RegionUncheckedCreateWithoutPostsInput> | RegionCreateWithoutPostsInput[] | RegionUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutPostsInput | RegionCreateOrConnectWithoutPostsInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
  }

  export type PostTagUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput> | PostTagCreateWithoutPostInput[] | PostTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostInput | PostTagCreateOrConnectWithoutPostInput[]
    upsert?: PostTagUpsertWithWhereUniqueWithoutPostInput | PostTagUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostTagCreateManyPostInputEnvelope
    set?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    disconnect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    delete?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    update?: PostTagUpdateWithWhereUniqueWithoutPostInput | PostTagUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostTagUpdateManyWithWhereWithoutPostInput | PostTagUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
  }

  export type UserUpdateOneWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostsInput, UserUpdateWithoutPostsInput>, UserUncheckedUpdateWithoutPostsInput>
  }

  export type MediaUpdateOneWithoutThumbnailForPostsNestedInput = {
    create?: XOR<MediaCreateWithoutThumbnailForPostsInput, MediaUncheckedCreateWithoutThumbnailForPostsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutThumbnailForPostsInput
    upsert?: MediaUpsertWithoutThumbnailForPostsInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutThumbnailForPostsInput, MediaUpdateWithoutThumbnailForPostsInput>, MediaUncheckedUpdateWithoutThumbnailForPostsInput>
  }

  export type CategoryUpdateManyWithoutPostsNestedInput = {
    create?: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput> | CategoryCreateWithoutPostsInput[] | CategoryUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutPostsInput | CategoryCreateOrConnectWithoutPostsInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutPostsInput | CategoryUpsertWithWhereUniqueWithoutPostsInput[]
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutPostsInput | CategoryUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutPostsInput | CategoryUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type RegionUpdateManyWithoutPostsNestedInput = {
    create?: XOR<RegionCreateWithoutPostsInput, RegionUncheckedCreateWithoutPostsInput> | RegionCreateWithoutPostsInput[] | RegionUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutPostsInput | RegionCreateOrConnectWithoutPostsInput[]
    upsert?: RegionUpsertWithWhereUniqueWithoutPostsInput | RegionUpsertWithWhereUniqueWithoutPostsInput[]
    set?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    disconnect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    delete?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    update?: RegionUpdateWithWhereUniqueWithoutPostsInput | RegionUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: RegionUpdateManyWithWhereWithoutPostsInput | RegionUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: RegionScalarWhereInput | RegionScalarWhereInput[]
  }

  export type PostTagUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput> | PostTagCreateWithoutPostInput[] | PostTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostInput | PostTagCreateOrConnectWithoutPostInput[]
    upsert?: PostTagUpsertWithWhereUniqueWithoutPostInput | PostTagUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostTagCreateManyPostInputEnvelope
    set?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    disconnect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    delete?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    update?: PostTagUpdateWithWhereUniqueWithoutPostInput | PostTagUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostTagUpdateManyWithWhereWithoutPostInput | PostTagUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput> | CategoryCreateWithoutPostsInput[] | CategoryUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutPostsInput | CategoryCreateOrConnectWithoutPostsInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutPostsInput | CategoryUpsertWithWhereUniqueWithoutPostsInput[]
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutPostsInput | CategoryUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutPostsInput | CategoryUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type RegionUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<RegionCreateWithoutPostsInput, RegionUncheckedCreateWithoutPostsInput> | RegionCreateWithoutPostsInput[] | RegionUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutPostsInput | RegionCreateOrConnectWithoutPostsInput[]
    upsert?: RegionUpsertWithWhereUniqueWithoutPostsInput | RegionUpsertWithWhereUniqueWithoutPostsInput[]
    set?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    disconnect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    delete?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    update?: RegionUpdateWithWhereUniqueWithoutPostsInput | RegionUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: RegionUpdateManyWithWhereWithoutPostsInput | RegionUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: RegionScalarWhereInput | RegionScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutTagsInput = {
    create?: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput>
    connectOrCreate?: PostCreateOrConnectWithoutTagsInput
    connect?: PostWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutPostsInput = {
    create?: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TagCreateOrConnectWithoutPostsInput
    connect?: TagWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput>
    connectOrCreate?: PostCreateOrConnectWithoutTagsInput
    upsert?: PostUpsertWithoutTagsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutTagsInput, PostUpdateWithoutTagsInput>, PostUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TagCreateOrConnectWithoutPostsInput
    upsert?: TagUpsertWithoutPostsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutPostsInput, TagUpdateWithoutPostsInput>, TagUncheckedUpdateWithoutPostsInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type PageTextCreateNestedManyWithoutContributorInput = {
    create?: XOR<PageTextCreateWithoutContributorInput, PageTextUncheckedCreateWithoutContributorInput> | PageTextCreateWithoutContributorInput[] | PageTextUncheckedCreateWithoutContributorInput[]
    connectOrCreate?: PageTextCreateOrConnectWithoutContributorInput | PageTextCreateOrConnectWithoutContributorInput[]
    createMany?: PageTextCreateManyContributorInputEnvelope
    connect?: PageTextWhereUniqueInput | PageTextWhereUniqueInput[]
  }

  export type PageCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PageCreateWithoutAuthorInput, PageUncheckedCreateWithoutAuthorInput> | PageCreateWithoutAuthorInput[] | PageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PageCreateOrConnectWithoutAuthorInput | PageCreateOrConnectWithoutAuthorInput[]
    createMany?: PageCreateManyAuthorInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type PageTextUncheckedCreateNestedManyWithoutContributorInput = {
    create?: XOR<PageTextCreateWithoutContributorInput, PageTextUncheckedCreateWithoutContributorInput> | PageTextCreateWithoutContributorInput[] | PageTextUncheckedCreateWithoutContributorInput[]
    connectOrCreate?: PageTextCreateOrConnectWithoutContributorInput | PageTextCreateOrConnectWithoutContributorInput[]
    createMany?: PageTextCreateManyContributorInputEnvelope
    connect?: PageTextWhereUniqueInput | PageTextWhereUniqueInput[]
  }

  export type PageUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PageCreateWithoutAuthorInput, PageUncheckedCreateWithoutAuthorInput> | PageCreateWithoutAuthorInput[] | PageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PageCreateOrConnectWithoutAuthorInput | PageCreateOrConnectWithoutAuthorInput[]
    createMany?: PageCreateManyAuthorInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type PageTextUpdateManyWithoutContributorNestedInput = {
    create?: XOR<PageTextCreateWithoutContributorInput, PageTextUncheckedCreateWithoutContributorInput> | PageTextCreateWithoutContributorInput[] | PageTextUncheckedCreateWithoutContributorInput[]
    connectOrCreate?: PageTextCreateOrConnectWithoutContributorInput | PageTextCreateOrConnectWithoutContributorInput[]
    upsert?: PageTextUpsertWithWhereUniqueWithoutContributorInput | PageTextUpsertWithWhereUniqueWithoutContributorInput[]
    createMany?: PageTextCreateManyContributorInputEnvelope
    set?: PageTextWhereUniqueInput | PageTextWhereUniqueInput[]
    disconnect?: PageTextWhereUniqueInput | PageTextWhereUniqueInput[]
    delete?: PageTextWhereUniqueInput | PageTextWhereUniqueInput[]
    connect?: PageTextWhereUniqueInput | PageTextWhereUniqueInput[]
    update?: PageTextUpdateWithWhereUniqueWithoutContributorInput | PageTextUpdateWithWhereUniqueWithoutContributorInput[]
    updateMany?: PageTextUpdateManyWithWhereWithoutContributorInput | PageTextUpdateManyWithWhereWithoutContributorInput[]
    deleteMany?: PageTextScalarWhereInput | PageTextScalarWhereInput[]
  }

  export type PageUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PageCreateWithoutAuthorInput, PageUncheckedCreateWithoutAuthorInput> | PageCreateWithoutAuthorInput[] | PageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PageCreateOrConnectWithoutAuthorInput | PageCreateOrConnectWithoutAuthorInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutAuthorInput | PageUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PageCreateManyAuthorInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutAuthorInput | PageUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PageUpdateManyWithWhereWithoutAuthorInput | PageUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type PostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type PageTextUncheckedUpdateManyWithoutContributorNestedInput = {
    create?: XOR<PageTextCreateWithoutContributorInput, PageTextUncheckedCreateWithoutContributorInput> | PageTextCreateWithoutContributorInput[] | PageTextUncheckedCreateWithoutContributorInput[]
    connectOrCreate?: PageTextCreateOrConnectWithoutContributorInput | PageTextCreateOrConnectWithoutContributorInput[]
    upsert?: PageTextUpsertWithWhereUniqueWithoutContributorInput | PageTextUpsertWithWhereUniqueWithoutContributorInput[]
    createMany?: PageTextCreateManyContributorInputEnvelope
    set?: PageTextWhereUniqueInput | PageTextWhereUniqueInput[]
    disconnect?: PageTextWhereUniqueInput | PageTextWhereUniqueInput[]
    delete?: PageTextWhereUniqueInput | PageTextWhereUniqueInput[]
    connect?: PageTextWhereUniqueInput | PageTextWhereUniqueInput[]
    update?: PageTextUpdateWithWhereUniqueWithoutContributorInput | PageTextUpdateWithWhereUniqueWithoutContributorInput[]
    updateMany?: PageTextUpdateManyWithWhereWithoutContributorInput | PageTextUpdateManyWithWhereWithoutContributorInput[]
    deleteMany?: PageTextScalarWhereInput | PageTextScalarWhereInput[]
  }

  export type PageUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PageCreateWithoutAuthorInput, PageUncheckedCreateWithoutAuthorInput> | PageCreateWithoutAuthorInput[] | PageUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PageCreateOrConnectWithoutAuthorInput | PageCreateOrConnectWithoutAuthorInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutAuthorInput | PageUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PageCreateManyAuthorInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutAuthorInput | PageUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PageUpdateManyWithWhereWithoutAuthorInput | PageUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type DatasetResourceCreateNestedManyWithoutDatasetInput = {
    create?: XOR<DatasetResourceCreateWithoutDatasetInput, DatasetResourceUncheckedCreateWithoutDatasetInput> | DatasetResourceCreateWithoutDatasetInput[] | DatasetResourceUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: DatasetResourceCreateOrConnectWithoutDatasetInput | DatasetResourceCreateOrConnectWithoutDatasetInput[]
    createMany?: DatasetResourceCreateManyDatasetInputEnvelope
    connect?: DatasetResourceWhereUniqueInput | DatasetResourceWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutDatasetsInput = {
    create?: XOR<CategoryCreateWithoutDatasetsInput, CategoryUncheckedCreateWithoutDatasetsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutDatasetsInput
    connect?: CategoryWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutThumbnailForDatasetInput = {
    create?: XOR<MediaCreateWithoutThumbnailForDatasetInput, MediaUncheckedCreateWithoutThumbnailForDatasetInput>
    connectOrCreate?: MediaCreateOrConnectWithoutThumbnailForDatasetInput
    connect?: MediaWhereUniqueInput
  }

  export type RegionCreateNestedManyWithoutDatasetsInput = {
    create?: XOR<RegionCreateWithoutDatasetsInput, RegionUncheckedCreateWithoutDatasetsInput> | RegionCreateWithoutDatasetsInput[] | RegionUncheckedCreateWithoutDatasetsInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutDatasetsInput | RegionCreateOrConnectWithoutDatasetsInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
  }

  export type DatasetResourceUncheckedCreateNestedManyWithoutDatasetInput = {
    create?: XOR<DatasetResourceCreateWithoutDatasetInput, DatasetResourceUncheckedCreateWithoutDatasetInput> | DatasetResourceCreateWithoutDatasetInput[] | DatasetResourceUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: DatasetResourceCreateOrConnectWithoutDatasetInput | DatasetResourceCreateOrConnectWithoutDatasetInput[]
    createMany?: DatasetResourceCreateManyDatasetInputEnvelope
    connect?: DatasetResourceWhereUniqueInput | DatasetResourceWhereUniqueInput[]
  }

  export type RegionUncheckedCreateNestedManyWithoutDatasetsInput = {
    create?: XOR<RegionCreateWithoutDatasetsInput, RegionUncheckedCreateWithoutDatasetsInput> | RegionCreateWithoutDatasetsInput[] | RegionUncheckedCreateWithoutDatasetsInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutDatasetsInput | RegionCreateOrConnectWithoutDatasetsInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
  }

  export type EnumDataMaturityFieldUpdateOperationsInput = {
    set?: $Enums.DataMaturity
  }

  export type DatasetResourceUpdateManyWithoutDatasetNestedInput = {
    create?: XOR<DatasetResourceCreateWithoutDatasetInput, DatasetResourceUncheckedCreateWithoutDatasetInput> | DatasetResourceCreateWithoutDatasetInput[] | DatasetResourceUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: DatasetResourceCreateOrConnectWithoutDatasetInput | DatasetResourceCreateOrConnectWithoutDatasetInput[]
    upsert?: DatasetResourceUpsertWithWhereUniqueWithoutDatasetInput | DatasetResourceUpsertWithWhereUniqueWithoutDatasetInput[]
    createMany?: DatasetResourceCreateManyDatasetInputEnvelope
    set?: DatasetResourceWhereUniqueInput | DatasetResourceWhereUniqueInput[]
    disconnect?: DatasetResourceWhereUniqueInput | DatasetResourceWhereUniqueInput[]
    delete?: DatasetResourceWhereUniqueInput | DatasetResourceWhereUniqueInput[]
    connect?: DatasetResourceWhereUniqueInput | DatasetResourceWhereUniqueInput[]
    update?: DatasetResourceUpdateWithWhereUniqueWithoutDatasetInput | DatasetResourceUpdateWithWhereUniqueWithoutDatasetInput[]
    updateMany?: DatasetResourceUpdateManyWithWhereWithoutDatasetInput | DatasetResourceUpdateManyWithWhereWithoutDatasetInput[]
    deleteMany?: DatasetResourceScalarWhereInput | DatasetResourceScalarWhereInput[]
  }

  export type CategoryUpdateOneWithoutDatasetsNestedInput = {
    create?: XOR<CategoryCreateWithoutDatasetsInput, CategoryUncheckedCreateWithoutDatasetsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutDatasetsInput
    upsert?: CategoryUpsertWithoutDatasetsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutDatasetsInput, CategoryUpdateWithoutDatasetsInput>, CategoryUncheckedUpdateWithoutDatasetsInput>
  }

  export type MediaUpdateOneWithoutThumbnailForDatasetNestedInput = {
    create?: XOR<MediaCreateWithoutThumbnailForDatasetInput, MediaUncheckedCreateWithoutThumbnailForDatasetInput>
    connectOrCreate?: MediaCreateOrConnectWithoutThumbnailForDatasetInput
    upsert?: MediaUpsertWithoutThumbnailForDatasetInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutThumbnailForDatasetInput, MediaUpdateWithoutThumbnailForDatasetInput>, MediaUncheckedUpdateWithoutThumbnailForDatasetInput>
  }

  export type RegionUpdateManyWithoutDatasetsNestedInput = {
    create?: XOR<RegionCreateWithoutDatasetsInput, RegionUncheckedCreateWithoutDatasetsInput> | RegionCreateWithoutDatasetsInput[] | RegionUncheckedCreateWithoutDatasetsInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutDatasetsInput | RegionCreateOrConnectWithoutDatasetsInput[]
    upsert?: RegionUpsertWithWhereUniqueWithoutDatasetsInput | RegionUpsertWithWhereUniqueWithoutDatasetsInput[]
    set?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    disconnect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    delete?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    update?: RegionUpdateWithWhereUniqueWithoutDatasetsInput | RegionUpdateWithWhereUniqueWithoutDatasetsInput[]
    updateMany?: RegionUpdateManyWithWhereWithoutDatasetsInput | RegionUpdateManyWithWhereWithoutDatasetsInput[]
    deleteMany?: RegionScalarWhereInput | RegionScalarWhereInput[]
  }

  export type DatasetResourceUncheckedUpdateManyWithoutDatasetNestedInput = {
    create?: XOR<DatasetResourceCreateWithoutDatasetInput, DatasetResourceUncheckedCreateWithoutDatasetInput> | DatasetResourceCreateWithoutDatasetInput[] | DatasetResourceUncheckedCreateWithoutDatasetInput[]
    connectOrCreate?: DatasetResourceCreateOrConnectWithoutDatasetInput | DatasetResourceCreateOrConnectWithoutDatasetInput[]
    upsert?: DatasetResourceUpsertWithWhereUniqueWithoutDatasetInput | DatasetResourceUpsertWithWhereUniqueWithoutDatasetInput[]
    createMany?: DatasetResourceCreateManyDatasetInputEnvelope
    set?: DatasetResourceWhereUniqueInput | DatasetResourceWhereUniqueInput[]
    disconnect?: DatasetResourceWhereUniqueInput | DatasetResourceWhereUniqueInput[]
    delete?: DatasetResourceWhereUniqueInput | DatasetResourceWhereUniqueInput[]
    connect?: DatasetResourceWhereUniqueInput | DatasetResourceWhereUniqueInput[]
    update?: DatasetResourceUpdateWithWhereUniqueWithoutDatasetInput | DatasetResourceUpdateWithWhereUniqueWithoutDatasetInput[]
    updateMany?: DatasetResourceUpdateManyWithWhereWithoutDatasetInput | DatasetResourceUpdateManyWithWhereWithoutDatasetInput[]
    deleteMany?: DatasetResourceScalarWhereInput | DatasetResourceScalarWhereInput[]
  }

  export type RegionUncheckedUpdateManyWithoutDatasetsNestedInput = {
    create?: XOR<RegionCreateWithoutDatasetsInput, RegionUncheckedCreateWithoutDatasetsInput> | RegionCreateWithoutDatasetsInput[] | RegionUncheckedCreateWithoutDatasetsInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutDatasetsInput | RegionCreateOrConnectWithoutDatasetsInput[]
    upsert?: RegionUpsertWithWhereUniqueWithoutDatasetsInput | RegionUpsertWithWhereUniqueWithoutDatasetsInput[]
    set?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    disconnect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    delete?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    update?: RegionUpdateWithWhereUniqueWithoutDatasetsInput | RegionUpdateWithWhereUniqueWithoutDatasetsInput[]
    updateMany?: RegionUpdateManyWithWhereWithoutDatasetsInput | RegionUpdateManyWithWhereWithoutDatasetsInput[]
    deleteMany?: RegionScalarWhereInput | RegionScalarWhereInput[]
  }

  export type ResearchDatasetCreateNestedOneWithoutResourcesInput = {
    create?: XOR<ResearchDatasetCreateWithoutResourcesInput, ResearchDatasetUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: ResearchDatasetCreateOrConnectWithoutResourcesInput
    connect?: ResearchDatasetWhereUniqueInput
  }

  export type MapCreateNestedOneWithoutResourcesInput = {
    create?: XOR<MapCreateWithoutResourcesInput, MapUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: MapCreateOrConnectWithoutResourcesInput
    connect?: MapWhereUniqueInput
  }

  export type EnumResouceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ResouceType
  }

  export type ResearchDatasetUpdateOneWithoutResourcesNestedInput = {
    create?: XOR<ResearchDatasetCreateWithoutResourcesInput, ResearchDatasetUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: ResearchDatasetCreateOrConnectWithoutResourcesInput
    upsert?: ResearchDatasetUpsertWithoutResourcesInput
    disconnect?: ResearchDatasetWhereInput | boolean
    delete?: ResearchDatasetWhereInput | boolean
    connect?: ResearchDatasetWhereUniqueInput
    update?: XOR<XOR<ResearchDatasetUpdateToOneWithWhereWithoutResourcesInput, ResearchDatasetUpdateWithoutResourcesInput>, ResearchDatasetUncheckedUpdateWithoutResourcesInput>
  }

  export type MapUpdateOneWithoutResourcesNestedInput = {
    create?: XOR<MapCreateWithoutResourcesInput, MapUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: MapCreateOrConnectWithoutResourcesInput
    upsert?: MapUpsertWithoutResourcesInput
    disconnect?: MapWhereInput | boolean
    delete?: MapWhereInput | boolean
    connect?: MapWhereUniqueInput
    update?: XOR<XOR<MapUpdateToOneWithWhereWithoutResourcesInput, MapUpdateWithoutResourcesInput>, MapUncheckedUpdateWithoutResourcesInput>
  }

  export type DatasetResourceCreateNestedManyWithoutMapInput = {
    create?: XOR<DatasetResourceCreateWithoutMapInput, DatasetResourceUncheckedCreateWithoutMapInput> | DatasetResourceCreateWithoutMapInput[] | DatasetResourceUncheckedCreateWithoutMapInput[]
    connectOrCreate?: DatasetResourceCreateOrConnectWithoutMapInput | DatasetResourceCreateOrConnectWithoutMapInput[]
    createMany?: DatasetResourceCreateManyMapInputEnvelope
    connect?: DatasetResourceWhereUniqueInput | DatasetResourceWhereUniqueInput[]
  }

  export type MapLayerAssociationCreateNestedManyWithoutMapInput = {
    create?: XOR<MapLayerAssociationCreateWithoutMapInput, MapLayerAssociationUncheckedCreateWithoutMapInput> | MapLayerAssociationCreateWithoutMapInput[] | MapLayerAssociationUncheckedCreateWithoutMapInput[]
    connectOrCreate?: MapLayerAssociationCreateOrConnectWithoutMapInput | MapLayerAssociationCreateOrConnectWithoutMapInput[]
    createMany?: MapLayerAssociationCreateManyMapInputEnvelope
    connect?: MapLayerAssociationWhereUniqueInput | MapLayerAssociationWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutMapsInput = {
    create?: XOR<CategoryCreateWithoutMapsInput, CategoryUncheckedCreateWithoutMapsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutMapsInput
    connect?: CategoryWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutThumbnailForMapsInput = {
    create?: XOR<MediaCreateWithoutThumbnailForMapsInput, MediaUncheckedCreateWithoutThumbnailForMapsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutThumbnailForMapsInput
    connect?: MediaWhereUniqueInput
  }

  export type RegionCreateNestedManyWithoutMapsInput = {
    create?: XOR<RegionCreateWithoutMapsInput, RegionUncheckedCreateWithoutMapsInput> | RegionCreateWithoutMapsInput[] | RegionUncheckedCreateWithoutMapsInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutMapsInput | RegionCreateOrConnectWithoutMapsInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutMapsInput = {
    create?: XOR<TagCreateWithoutMapsInput, TagUncheckedCreateWithoutMapsInput> | TagCreateWithoutMapsInput[] | TagUncheckedCreateWithoutMapsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutMapsInput | TagCreateOrConnectWithoutMapsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type DatasetResourceUncheckedCreateNestedManyWithoutMapInput = {
    create?: XOR<DatasetResourceCreateWithoutMapInput, DatasetResourceUncheckedCreateWithoutMapInput> | DatasetResourceCreateWithoutMapInput[] | DatasetResourceUncheckedCreateWithoutMapInput[]
    connectOrCreate?: DatasetResourceCreateOrConnectWithoutMapInput | DatasetResourceCreateOrConnectWithoutMapInput[]
    createMany?: DatasetResourceCreateManyMapInputEnvelope
    connect?: DatasetResourceWhereUniqueInput | DatasetResourceWhereUniqueInput[]
  }

  export type MapLayerAssociationUncheckedCreateNestedManyWithoutMapInput = {
    create?: XOR<MapLayerAssociationCreateWithoutMapInput, MapLayerAssociationUncheckedCreateWithoutMapInput> | MapLayerAssociationCreateWithoutMapInput[] | MapLayerAssociationUncheckedCreateWithoutMapInput[]
    connectOrCreate?: MapLayerAssociationCreateOrConnectWithoutMapInput | MapLayerAssociationCreateOrConnectWithoutMapInput[]
    createMany?: MapLayerAssociationCreateManyMapInputEnvelope
    connect?: MapLayerAssociationWhereUniqueInput | MapLayerAssociationWhereUniqueInput[]
  }

  export type RegionUncheckedCreateNestedManyWithoutMapsInput = {
    create?: XOR<RegionCreateWithoutMapsInput, RegionUncheckedCreateWithoutMapsInput> | RegionCreateWithoutMapsInput[] | RegionUncheckedCreateWithoutMapsInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutMapsInput | RegionCreateOrConnectWithoutMapsInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutMapsInput = {
    create?: XOR<TagCreateWithoutMapsInput, TagUncheckedCreateWithoutMapsInput> | TagCreateWithoutMapsInput[] | TagUncheckedCreateWithoutMapsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutMapsInput | TagCreateOrConnectWithoutMapsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type DatasetResourceUpdateManyWithoutMapNestedInput = {
    create?: XOR<DatasetResourceCreateWithoutMapInput, DatasetResourceUncheckedCreateWithoutMapInput> | DatasetResourceCreateWithoutMapInput[] | DatasetResourceUncheckedCreateWithoutMapInput[]
    connectOrCreate?: DatasetResourceCreateOrConnectWithoutMapInput | DatasetResourceCreateOrConnectWithoutMapInput[]
    upsert?: DatasetResourceUpsertWithWhereUniqueWithoutMapInput | DatasetResourceUpsertWithWhereUniqueWithoutMapInput[]
    createMany?: DatasetResourceCreateManyMapInputEnvelope
    set?: DatasetResourceWhereUniqueInput | DatasetResourceWhereUniqueInput[]
    disconnect?: DatasetResourceWhereUniqueInput | DatasetResourceWhereUniqueInput[]
    delete?: DatasetResourceWhereUniqueInput | DatasetResourceWhereUniqueInput[]
    connect?: DatasetResourceWhereUniqueInput | DatasetResourceWhereUniqueInput[]
    update?: DatasetResourceUpdateWithWhereUniqueWithoutMapInput | DatasetResourceUpdateWithWhereUniqueWithoutMapInput[]
    updateMany?: DatasetResourceUpdateManyWithWhereWithoutMapInput | DatasetResourceUpdateManyWithWhereWithoutMapInput[]
    deleteMany?: DatasetResourceScalarWhereInput | DatasetResourceScalarWhereInput[]
  }

  export type MapLayerAssociationUpdateManyWithoutMapNestedInput = {
    create?: XOR<MapLayerAssociationCreateWithoutMapInput, MapLayerAssociationUncheckedCreateWithoutMapInput> | MapLayerAssociationCreateWithoutMapInput[] | MapLayerAssociationUncheckedCreateWithoutMapInput[]
    connectOrCreate?: MapLayerAssociationCreateOrConnectWithoutMapInput | MapLayerAssociationCreateOrConnectWithoutMapInput[]
    upsert?: MapLayerAssociationUpsertWithWhereUniqueWithoutMapInput | MapLayerAssociationUpsertWithWhereUniqueWithoutMapInput[]
    createMany?: MapLayerAssociationCreateManyMapInputEnvelope
    set?: MapLayerAssociationWhereUniqueInput | MapLayerAssociationWhereUniqueInput[]
    disconnect?: MapLayerAssociationWhereUniqueInput | MapLayerAssociationWhereUniqueInput[]
    delete?: MapLayerAssociationWhereUniqueInput | MapLayerAssociationWhereUniqueInput[]
    connect?: MapLayerAssociationWhereUniqueInput | MapLayerAssociationWhereUniqueInput[]
    update?: MapLayerAssociationUpdateWithWhereUniqueWithoutMapInput | MapLayerAssociationUpdateWithWhereUniqueWithoutMapInput[]
    updateMany?: MapLayerAssociationUpdateManyWithWhereWithoutMapInput | MapLayerAssociationUpdateManyWithWhereWithoutMapInput[]
    deleteMany?: MapLayerAssociationScalarWhereInput | MapLayerAssociationScalarWhereInput[]
  }

  export type CategoryUpdateOneWithoutMapsNestedInput = {
    create?: XOR<CategoryCreateWithoutMapsInput, CategoryUncheckedCreateWithoutMapsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutMapsInput
    upsert?: CategoryUpsertWithoutMapsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutMapsInput, CategoryUpdateWithoutMapsInput>, CategoryUncheckedUpdateWithoutMapsInput>
  }

  export type MediaUpdateOneWithoutThumbnailForMapsNestedInput = {
    create?: XOR<MediaCreateWithoutThumbnailForMapsInput, MediaUncheckedCreateWithoutThumbnailForMapsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutThumbnailForMapsInput
    upsert?: MediaUpsertWithoutThumbnailForMapsInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutThumbnailForMapsInput, MediaUpdateWithoutThumbnailForMapsInput>, MediaUncheckedUpdateWithoutThumbnailForMapsInput>
  }

  export type RegionUpdateManyWithoutMapsNestedInput = {
    create?: XOR<RegionCreateWithoutMapsInput, RegionUncheckedCreateWithoutMapsInput> | RegionCreateWithoutMapsInput[] | RegionUncheckedCreateWithoutMapsInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutMapsInput | RegionCreateOrConnectWithoutMapsInput[]
    upsert?: RegionUpsertWithWhereUniqueWithoutMapsInput | RegionUpsertWithWhereUniqueWithoutMapsInput[]
    set?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    disconnect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    delete?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    update?: RegionUpdateWithWhereUniqueWithoutMapsInput | RegionUpdateWithWhereUniqueWithoutMapsInput[]
    updateMany?: RegionUpdateManyWithWhereWithoutMapsInput | RegionUpdateManyWithWhereWithoutMapsInput[]
    deleteMany?: RegionScalarWhereInput | RegionScalarWhereInput[]
  }

  export type TagUpdateManyWithoutMapsNestedInput = {
    create?: XOR<TagCreateWithoutMapsInput, TagUncheckedCreateWithoutMapsInput> | TagCreateWithoutMapsInput[] | TagUncheckedCreateWithoutMapsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutMapsInput | TagCreateOrConnectWithoutMapsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutMapsInput | TagUpsertWithWhereUniqueWithoutMapsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutMapsInput | TagUpdateWithWhereUniqueWithoutMapsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutMapsInput | TagUpdateManyWithWhereWithoutMapsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type DatasetResourceUncheckedUpdateManyWithoutMapNestedInput = {
    create?: XOR<DatasetResourceCreateWithoutMapInput, DatasetResourceUncheckedCreateWithoutMapInput> | DatasetResourceCreateWithoutMapInput[] | DatasetResourceUncheckedCreateWithoutMapInput[]
    connectOrCreate?: DatasetResourceCreateOrConnectWithoutMapInput | DatasetResourceCreateOrConnectWithoutMapInput[]
    upsert?: DatasetResourceUpsertWithWhereUniqueWithoutMapInput | DatasetResourceUpsertWithWhereUniqueWithoutMapInput[]
    createMany?: DatasetResourceCreateManyMapInputEnvelope
    set?: DatasetResourceWhereUniqueInput | DatasetResourceWhereUniqueInput[]
    disconnect?: DatasetResourceWhereUniqueInput | DatasetResourceWhereUniqueInput[]
    delete?: DatasetResourceWhereUniqueInput | DatasetResourceWhereUniqueInput[]
    connect?: DatasetResourceWhereUniqueInput | DatasetResourceWhereUniqueInput[]
    update?: DatasetResourceUpdateWithWhereUniqueWithoutMapInput | DatasetResourceUpdateWithWhereUniqueWithoutMapInput[]
    updateMany?: DatasetResourceUpdateManyWithWhereWithoutMapInput | DatasetResourceUpdateManyWithWhereWithoutMapInput[]
    deleteMany?: DatasetResourceScalarWhereInput | DatasetResourceScalarWhereInput[]
  }

  export type MapLayerAssociationUncheckedUpdateManyWithoutMapNestedInput = {
    create?: XOR<MapLayerAssociationCreateWithoutMapInput, MapLayerAssociationUncheckedCreateWithoutMapInput> | MapLayerAssociationCreateWithoutMapInput[] | MapLayerAssociationUncheckedCreateWithoutMapInput[]
    connectOrCreate?: MapLayerAssociationCreateOrConnectWithoutMapInput | MapLayerAssociationCreateOrConnectWithoutMapInput[]
    upsert?: MapLayerAssociationUpsertWithWhereUniqueWithoutMapInput | MapLayerAssociationUpsertWithWhereUniqueWithoutMapInput[]
    createMany?: MapLayerAssociationCreateManyMapInputEnvelope
    set?: MapLayerAssociationWhereUniqueInput | MapLayerAssociationWhereUniqueInput[]
    disconnect?: MapLayerAssociationWhereUniqueInput | MapLayerAssociationWhereUniqueInput[]
    delete?: MapLayerAssociationWhereUniqueInput | MapLayerAssociationWhereUniqueInput[]
    connect?: MapLayerAssociationWhereUniqueInput | MapLayerAssociationWhereUniqueInput[]
    update?: MapLayerAssociationUpdateWithWhereUniqueWithoutMapInput | MapLayerAssociationUpdateWithWhereUniqueWithoutMapInput[]
    updateMany?: MapLayerAssociationUpdateManyWithWhereWithoutMapInput | MapLayerAssociationUpdateManyWithWhereWithoutMapInput[]
    deleteMany?: MapLayerAssociationScalarWhereInput | MapLayerAssociationScalarWhereInput[]
  }

  export type RegionUncheckedUpdateManyWithoutMapsNestedInput = {
    create?: XOR<RegionCreateWithoutMapsInput, RegionUncheckedCreateWithoutMapsInput> | RegionCreateWithoutMapsInput[] | RegionUncheckedCreateWithoutMapsInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutMapsInput | RegionCreateOrConnectWithoutMapsInput[]
    upsert?: RegionUpsertWithWhereUniqueWithoutMapsInput | RegionUpsertWithWhereUniqueWithoutMapsInput[]
    set?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    disconnect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    delete?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    update?: RegionUpdateWithWhereUniqueWithoutMapsInput | RegionUpdateWithWhereUniqueWithoutMapsInput[]
    updateMany?: RegionUpdateManyWithWhereWithoutMapsInput | RegionUpdateManyWithWhereWithoutMapsInput[]
    deleteMany?: RegionScalarWhereInput | RegionScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutMapsNestedInput = {
    create?: XOR<TagCreateWithoutMapsInput, TagUncheckedCreateWithoutMapsInput> | TagCreateWithoutMapsInput[] | TagUncheckedCreateWithoutMapsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutMapsInput | TagCreateOrConnectWithoutMapsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutMapsInput | TagUpsertWithWhereUniqueWithoutMapsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutMapsInput | TagUpdateWithWhereUniqueWithoutMapsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutMapsInput | TagUpdateManyWithWhereWithoutMapsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutLayersInput = {
    create?: XOR<CategoryCreateWithoutLayersInput, CategoryUncheckedCreateWithoutLayersInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutLayersInput
    connect?: CategoryWhereUniqueInput
  }

  export type MapLayerAssociationCreateNestedManyWithoutLayerInput = {
    create?: XOR<MapLayerAssociationCreateWithoutLayerInput, MapLayerAssociationUncheckedCreateWithoutLayerInput> | MapLayerAssociationCreateWithoutLayerInput[] | MapLayerAssociationUncheckedCreateWithoutLayerInput[]
    connectOrCreate?: MapLayerAssociationCreateOrConnectWithoutLayerInput | MapLayerAssociationCreateOrConnectWithoutLayerInput[]
    createMany?: MapLayerAssociationCreateManyLayerInputEnvelope
    connect?: MapLayerAssociationWhereUniqueInput | MapLayerAssociationWhereUniqueInput[]
  }

  export type RegionCreateNestedManyWithoutLayersInput = {
    create?: XOR<RegionCreateWithoutLayersInput, RegionUncheckedCreateWithoutLayersInput> | RegionCreateWithoutLayersInput[] | RegionUncheckedCreateWithoutLayersInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutLayersInput | RegionCreateOrConnectWithoutLayersInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutLayersInput = {
    create?: XOR<TagCreateWithoutLayersInput, TagUncheckedCreateWithoutLayersInput> | TagCreateWithoutLayersInput[] | TagUncheckedCreateWithoutLayersInput[]
    connectOrCreate?: TagCreateOrConnectWithoutLayersInput | TagCreateOrConnectWithoutLayersInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type MapLayerAssociationUncheckedCreateNestedManyWithoutLayerInput = {
    create?: XOR<MapLayerAssociationCreateWithoutLayerInput, MapLayerAssociationUncheckedCreateWithoutLayerInput> | MapLayerAssociationCreateWithoutLayerInput[] | MapLayerAssociationUncheckedCreateWithoutLayerInput[]
    connectOrCreate?: MapLayerAssociationCreateOrConnectWithoutLayerInput | MapLayerAssociationCreateOrConnectWithoutLayerInput[]
    createMany?: MapLayerAssociationCreateManyLayerInputEnvelope
    connect?: MapLayerAssociationWhereUniqueInput | MapLayerAssociationWhereUniqueInput[]
  }

  export type RegionUncheckedCreateNestedManyWithoutLayersInput = {
    create?: XOR<RegionCreateWithoutLayersInput, RegionUncheckedCreateWithoutLayersInput> | RegionCreateWithoutLayersInput[] | RegionUncheckedCreateWithoutLayersInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutLayersInput | RegionCreateOrConnectWithoutLayersInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutLayersInput = {
    create?: XOR<TagCreateWithoutLayersInput, TagUncheckedCreateWithoutLayersInput> | TagCreateWithoutLayersInput[] | TagUncheckedCreateWithoutLayersInput[]
    connectOrCreate?: TagCreateOrConnectWithoutLayersInput | TagCreateOrConnectWithoutLayersInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type EnumLayerTypeFieldUpdateOperationsInput = {
    set?: $Enums.LayerType
  }

  export type EnumLayerSourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.LayerSourceType
  }

  export type CategoryUpdateOneWithoutLayersNestedInput = {
    create?: XOR<CategoryCreateWithoutLayersInput, CategoryUncheckedCreateWithoutLayersInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutLayersInput
    upsert?: CategoryUpsertWithoutLayersInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutLayersInput, CategoryUpdateWithoutLayersInput>, CategoryUncheckedUpdateWithoutLayersInput>
  }

  export type MapLayerAssociationUpdateManyWithoutLayerNestedInput = {
    create?: XOR<MapLayerAssociationCreateWithoutLayerInput, MapLayerAssociationUncheckedCreateWithoutLayerInput> | MapLayerAssociationCreateWithoutLayerInput[] | MapLayerAssociationUncheckedCreateWithoutLayerInput[]
    connectOrCreate?: MapLayerAssociationCreateOrConnectWithoutLayerInput | MapLayerAssociationCreateOrConnectWithoutLayerInput[]
    upsert?: MapLayerAssociationUpsertWithWhereUniqueWithoutLayerInput | MapLayerAssociationUpsertWithWhereUniqueWithoutLayerInput[]
    createMany?: MapLayerAssociationCreateManyLayerInputEnvelope
    set?: MapLayerAssociationWhereUniqueInput | MapLayerAssociationWhereUniqueInput[]
    disconnect?: MapLayerAssociationWhereUniqueInput | MapLayerAssociationWhereUniqueInput[]
    delete?: MapLayerAssociationWhereUniqueInput | MapLayerAssociationWhereUniqueInput[]
    connect?: MapLayerAssociationWhereUniqueInput | MapLayerAssociationWhereUniqueInput[]
    update?: MapLayerAssociationUpdateWithWhereUniqueWithoutLayerInput | MapLayerAssociationUpdateWithWhereUniqueWithoutLayerInput[]
    updateMany?: MapLayerAssociationUpdateManyWithWhereWithoutLayerInput | MapLayerAssociationUpdateManyWithWhereWithoutLayerInput[]
    deleteMany?: MapLayerAssociationScalarWhereInput | MapLayerAssociationScalarWhereInput[]
  }

  export type RegionUpdateManyWithoutLayersNestedInput = {
    create?: XOR<RegionCreateWithoutLayersInput, RegionUncheckedCreateWithoutLayersInput> | RegionCreateWithoutLayersInput[] | RegionUncheckedCreateWithoutLayersInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutLayersInput | RegionCreateOrConnectWithoutLayersInput[]
    upsert?: RegionUpsertWithWhereUniqueWithoutLayersInput | RegionUpsertWithWhereUniqueWithoutLayersInput[]
    set?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    disconnect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    delete?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    update?: RegionUpdateWithWhereUniqueWithoutLayersInput | RegionUpdateWithWhereUniqueWithoutLayersInput[]
    updateMany?: RegionUpdateManyWithWhereWithoutLayersInput | RegionUpdateManyWithWhereWithoutLayersInput[]
    deleteMany?: RegionScalarWhereInput | RegionScalarWhereInput[]
  }

  export type TagUpdateManyWithoutLayersNestedInput = {
    create?: XOR<TagCreateWithoutLayersInput, TagUncheckedCreateWithoutLayersInput> | TagCreateWithoutLayersInput[] | TagUncheckedCreateWithoutLayersInput[]
    connectOrCreate?: TagCreateOrConnectWithoutLayersInput | TagCreateOrConnectWithoutLayersInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutLayersInput | TagUpsertWithWhereUniqueWithoutLayersInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutLayersInput | TagUpdateWithWhereUniqueWithoutLayersInput[]
    updateMany?: TagUpdateManyWithWhereWithoutLayersInput | TagUpdateManyWithWhereWithoutLayersInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type MapLayerAssociationUncheckedUpdateManyWithoutLayerNestedInput = {
    create?: XOR<MapLayerAssociationCreateWithoutLayerInput, MapLayerAssociationUncheckedCreateWithoutLayerInput> | MapLayerAssociationCreateWithoutLayerInput[] | MapLayerAssociationUncheckedCreateWithoutLayerInput[]
    connectOrCreate?: MapLayerAssociationCreateOrConnectWithoutLayerInput | MapLayerAssociationCreateOrConnectWithoutLayerInput[]
    upsert?: MapLayerAssociationUpsertWithWhereUniqueWithoutLayerInput | MapLayerAssociationUpsertWithWhereUniqueWithoutLayerInput[]
    createMany?: MapLayerAssociationCreateManyLayerInputEnvelope
    set?: MapLayerAssociationWhereUniqueInput | MapLayerAssociationWhereUniqueInput[]
    disconnect?: MapLayerAssociationWhereUniqueInput | MapLayerAssociationWhereUniqueInput[]
    delete?: MapLayerAssociationWhereUniqueInput | MapLayerAssociationWhereUniqueInput[]
    connect?: MapLayerAssociationWhereUniqueInput | MapLayerAssociationWhereUniqueInput[]
    update?: MapLayerAssociationUpdateWithWhereUniqueWithoutLayerInput | MapLayerAssociationUpdateWithWhereUniqueWithoutLayerInput[]
    updateMany?: MapLayerAssociationUpdateManyWithWhereWithoutLayerInput | MapLayerAssociationUpdateManyWithWhereWithoutLayerInput[]
    deleteMany?: MapLayerAssociationScalarWhereInput | MapLayerAssociationScalarWhereInput[]
  }

  export type RegionUncheckedUpdateManyWithoutLayersNestedInput = {
    create?: XOR<RegionCreateWithoutLayersInput, RegionUncheckedCreateWithoutLayersInput> | RegionCreateWithoutLayersInput[] | RegionUncheckedCreateWithoutLayersInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutLayersInput | RegionCreateOrConnectWithoutLayersInput[]
    upsert?: RegionUpsertWithWhereUniqueWithoutLayersInput | RegionUpsertWithWhereUniqueWithoutLayersInput[]
    set?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    disconnect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    delete?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    update?: RegionUpdateWithWhereUniqueWithoutLayersInput | RegionUpdateWithWhereUniqueWithoutLayersInput[]
    updateMany?: RegionUpdateManyWithWhereWithoutLayersInput | RegionUpdateManyWithWhereWithoutLayersInput[]
    deleteMany?: RegionScalarWhereInput | RegionScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutLayersNestedInput = {
    create?: XOR<TagCreateWithoutLayersInput, TagUncheckedCreateWithoutLayersInput> | TagCreateWithoutLayersInput[] | TagUncheckedCreateWithoutLayersInput[]
    connectOrCreate?: TagCreateOrConnectWithoutLayersInput | TagCreateOrConnectWithoutLayersInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutLayersInput | TagUpsertWithWhereUniqueWithoutLayersInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutLayersInput | TagUpdateWithWhereUniqueWithoutLayersInput[]
    updateMany?: TagUpdateManyWithWhereWithoutLayersInput | TagUpdateManyWithWhereWithoutLayersInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type LayerCreateNestedOneWithoutMapsInput = {
    create?: XOR<LayerCreateWithoutMapsInput, LayerUncheckedCreateWithoutMapsInput>
    connectOrCreate?: LayerCreateOrConnectWithoutMapsInput
    connect?: LayerWhereUniqueInput
  }

  export type MapCreateNestedOneWithoutLayersInput = {
    create?: XOR<MapCreateWithoutLayersInput, MapUncheckedCreateWithoutLayersInput>
    connectOrCreate?: MapCreateOrConnectWithoutLayersInput
    connect?: MapWhereUniqueInput
  }

  export type LayerUpdateOneRequiredWithoutMapsNestedInput = {
    create?: XOR<LayerCreateWithoutMapsInput, LayerUncheckedCreateWithoutMapsInput>
    connectOrCreate?: LayerCreateOrConnectWithoutMapsInput
    upsert?: LayerUpsertWithoutMapsInput
    connect?: LayerWhereUniqueInput
    update?: XOR<XOR<LayerUpdateToOneWithWhereWithoutMapsInput, LayerUpdateWithoutMapsInput>, LayerUncheckedUpdateWithoutMapsInput>
  }

  export type MapUpdateOneRequiredWithoutLayersNestedInput = {
    create?: XOR<MapCreateWithoutLayersInput, MapUncheckedCreateWithoutLayersInput>
    connectOrCreate?: MapCreateOrConnectWithoutLayersInput
    upsert?: MapUpsertWithoutLayersInput
    connect?: MapWhereUniqueInput
    update?: XOR<XOR<MapUpdateToOneWithWhereWithoutLayersInput, MapUpdateWithoutLayersInput>, MapUncheckedUpdateWithoutLayersInput>
  }

  export type MediaCreateNestedOneWithoutThumbnailForCollectionsInput = {
    create?: XOR<MediaCreateWithoutThumbnailForCollectionsInput, MediaUncheckedCreateWithoutThumbnailForCollectionsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutThumbnailForCollectionsInput
    connect?: MediaWhereUniqueInput
  }

  export type SeriesCreateNestedManyWithoutCollectionInput = {
    create?: XOR<SeriesCreateWithoutCollectionInput, SeriesUncheckedCreateWithoutCollectionInput> | SeriesCreateWithoutCollectionInput[] | SeriesUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutCollectionInput | SeriesCreateOrConnectWithoutCollectionInput[]
    createMany?: SeriesCreateManyCollectionInputEnvelope
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
  }

  export type RegionCreateNestedManyWithoutCollectionsInput = {
    create?: XOR<RegionCreateWithoutCollectionsInput, RegionUncheckedCreateWithoutCollectionsInput> | RegionCreateWithoutCollectionsInput[] | RegionUncheckedCreateWithoutCollectionsInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutCollectionsInput | RegionCreateOrConnectWithoutCollectionsInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutCollectionsInput = {
    create?: XOR<TagCreateWithoutCollectionsInput, TagUncheckedCreateWithoutCollectionsInput> | TagCreateWithoutCollectionsInput[] | TagUncheckedCreateWithoutCollectionsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutCollectionsInput | TagCreateOrConnectWithoutCollectionsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type SeriesUncheckedCreateNestedManyWithoutCollectionInput = {
    create?: XOR<SeriesCreateWithoutCollectionInput, SeriesUncheckedCreateWithoutCollectionInput> | SeriesCreateWithoutCollectionInput[] | SeriesUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutCollectionInput | SeriesCreateOrConnectWithoutCollectionInput[]
    createMany?: SeriesCreateManyCollectionInputEnvelope
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
  }

  export type RegionUncheckedCreateNestedManyWithoutCollectionsInput = {
    create?: XOR<RegionCreateWithoutCollectionsInput, RegionUncheckedCreateWithoutCollectionsInput> | RegionCreateWithoutCollectionsInput[] | RegionUncheckedCreateWithoutCollectionsInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutCollectionsInput | RegionCreateOrConnectWithoutCollectionsInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutCollectionsInput = {
    create?: XOR<TagCreateWithoutCollectionsInput, TagUncheckedCreateWithoutCollectionsInput> | TagCreateWithoutCollectionsInput[] | TagUncheckedCreateWithoutCollectionsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutCollectionsInput | TagCreateOrConnectWithoutCollectionsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type MediaUpdateOneWithoutThumbnailForCollectionsNestedInput = {
    create?: XOR<MediaCreateWithoutThumbnailForCollectionsInput, MediaUncheckedCreateWithoutThumbnailForCollectionsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutThumbnailForCollectionsInput
    upsert?: MediaUpsertWithoutThumbnailForCollectionsInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutThumbnailForCollectionsInput, MediaUpdateWithoutThumbnailForCollectionsInput>, MediaUncheckedUpdateWithoutThumbnailForCollectionsInput>
  }

  export type SeriesUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<SeriesCreateWithoutCollectionInput, SeriesUncheckedCreateWithoutCollectionInput> | SeriesCreateWithoutCollectionInput[] | SeriesUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutCollectionInput | SeriesCreateOrConnectWithoutCollectionInput[]
    upsert?: SeriesUpsertWithWhereUniqueWithoutCollectionInput | SeriesUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: SeriesCreateManyCollectionInputEnvelope
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    update?: SeriesUpdateWithWhereUniqueWithoutCollectionInput | SeriesUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: SeriesUpdateManyWithWhereWithoutCollectionInput | SeriesUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
  }

  export type RegionUpdateManyWithoutCollectionsNestedInput = {
    create?: XOR<RegionCreateWithoutCollectionsInput, RegionUncheckedCreateWithoutCollectionsInput> | RegionCreateWithoutCollectionsInput[] | RegionUncheckedCreateWithoutCollectionsInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutCollectionsInput | RegionCreateOrConnectWithoutCollectionsInput[]
    upsert?: RegionUpsertWithWhereUniqueWithoutCollectionsInput | RegionUpsertWithWhereUniqueWithoutCollectionsInput[]
    set?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    disconnect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    delete?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    update?: RegionUpdateWithWhereUniqueWithoutCollectionsInput | RegionUpdateWithWhereUniqueWithoutCollectionsInput[]
    updateMany?: RegionUpdateManyWithWhereWithoutCollectionsInput | RegionUpdateManyWithWhereWithoutCollectionsInput[]
    deleteMany?: RegionScalarWhereInput | RegionScalarWhereInput[]
  }

  export type TagUpdateManyWithoutCollectionsNestedInput = {
    create?: XOR<TagCreateWithoutCollectionsInput, TagUncheckedCreateWithoutCollectionsInput> | TagCreateWithoutCollectionsInput[] | TagUncheckedCreateWithoutCollectionsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutCollectionsInput | TagCreateOrConnectWithoutCollectionsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutCollectionsInput | TagUpsertWithWhereUniqueWithoutCollectionsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutCollectionsInput | TagUpdateWithWhereUniqueWithoutCollectionsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutCollectionsInput | TagUpdateManyWithWhereWithoutCollectionsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type SeriesUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<SeriesCreateWithoutCollectionInput, SeriesUncheckedCreateWithoutCollectionInput> | SeriesCreateWithoutCollectionInput[] | SeriesUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutCollectionInput | SeriesCreateOrConnectWithoutCollectionInput[]
    upsert?: SeriesUpsertWithWhereUniqueWithoutCollectionInput | SeriesUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: SeriesCreateManyCollectionInputEnvelope
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    update?: SeriesUpdateWithWhereUniqueWithoutCollectionInput | SeriesUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: SeriesUpdateManyWithWhereWithoutCollectionInput | SeriesUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
  }

  export type RegionUncheckedUpdateManyWithoutCollectionsNestedInput = {
    create?: XOR<RegionCreateWithoutCollectionsInput, RegionUncheckedCreateWithoutCollectionsInput> | RegionCreateWithoutCollectionsInput[] | RegionUncheckedCreateWithoutCollectionsInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutCollectionsInput | RegionCreateOrConnectWithoutCollectionsInput[]
    upsert?: RegionUpsertWithWhereUniqueWithoutCollectionsInput | RegionUpsertWithWhereUniqueWithoutCollectionsInput[]
    set?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    disconnect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    delete?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    update?: RegionUpdateWithWhereUniqueWithoutCollectionsInput | RegionUpdateWithWhereUniqueWithoutCollectionsInput[]
    updateMany?: RegionUpdateManyWithWhereWithoutCollectionsInput | RegionUpdateManyWithWhereWithoutCollectionsInput[]
    deleteMany?: RegionScalarWhereInput | RegionScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutCollectionsNestedInput = {
    create?: XOR<TagCreateWithoutCollectionsInput, TagUncheckedCreateWithoutCollectionsInput> | TagCreateWithoutCollectionsInput[] | TagUncheckedCreateWithoutCollectionsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutCollectionsInput | TagCreateOrConnectWithoutCollectionsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutCollectionsInput | TagUpsertWithWhereUniqueWithoutCollectionsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutCollectionsInput | TagUpdateWithWhereUniqueWithoutCollectionsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutCollectionsInput | TagUpdateManyWithWhereWithoutCollectionsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type SeriesCreatelanguagesInput = {
    set: $Enums.ContentLanguage[]
  }

  export type CollectionCreateNestedOneWithoutSeriesInput = {
    create?: XOR<CollectionCreateWithoutSeriesInput, CollectionUncheckedCreateWithoutSeriesInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutSeriesInput
    connect?: CollectionWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutThumbnailForSeriesInput = {
    create?: XOR<MediaCreateWithoutThumbnailForSeriesInput, MediaUncheckedCreateWithoutThumbnailForSeriesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutThumbnailForSeriesInput
    connect?: MediaWhereUniqueInput
  }

  export type VolumeCreateNestedManyWithoutSeriesInput = {
    create?: XOR<VolumeCreateWithoutSeriesInput, VolumeUncheckedCreateWithoutSeriesInput> | VolumeCreateWithoutSeriesInput[] | VolumeUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: VolumeCreateOrConnectWithoutSeriesInput | VolumeCreateOrConnectWithoutSeriesInput[]
    createMany?: VolumeCreateManySeriesInputEnvelope
    connect?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
  }

  export type CategoryCreateNestedManyWithoutSeriesInput = {
    create?: XOR<CategoryCreateWithoutSeriesInput, CategoryUncheckedCreateWithoutSeriesInput> | CategoryCreateWithoutSeriesInput[] | CategoryUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutSeriesInput | CategoryCreateOrConnectWithoutSeriesInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type RegionCreateNestedManyWithoutSeriesInput = {
    create?: XOR<RegionCreateWithoutSeriesInput, RegionUncheckedCreateWithoutSeriesInput> | RegionCreateWithoutSeriesInput[] | RegionUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutSeriesInput | RegionCreateOrConnectWithoutSeriesInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutSeriesInput = {
    create?: XOR<TagCreateWithoutSeriesInput, TagUncheckedCreateWithoutSeriesInput> | TagCreateWithoutSeriesInput[] | TagUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutSeriesInput | TagCreateOrConnectWithoutSeriesInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type VolumeUncheckedCreateNestedManyWithoutSeriesInput = {
    create?: XOR<VolumeCreateWithoutSeriesInput, VolumeUncheckedCreateWithoutSeriesInput> | VolumeCreateWithoutSeriesInput[] | VolumeUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: VolumeCreateOrConnectWithoutSeriesInput | VolumeCreateOrConnectWithoutSeriesInput[]
    createMany?: VolumeCreateManySeriesInputEnvelope
    connect?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutSeriesInput = {
    create?: XOR<CategoryCreateWithoutSeriesInput, CategoryUncheckedCreateWithoutSeriesInput> | CategoryCreateWithoutSeriesInput[] | CategoryUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutSeriesInput | CategoryCreateOrConnectWithoutSeriesInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type RegionUncheckedCreateNestedManyWithoutSeriesInput = {
    create?: XOR<RegionCreateWithoutSeriesInput, RegionUncheckedCreateWithoutSeriesInput> | RegionCreateWithoutSeriesInput[] | RegionUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutSeriesInput | RegionCreateOrConnectWithoutSeriesInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutSeriesInput = {
    create?: XOR<TagCreateWithoutSeriesInput, TagUncheckedCreateWithoutSeriesInput> | TagCreateWithoutSeriesInput[] | TagUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutSeriesInput | TagCreateOrConnectWithoutSeriesInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type SeriesUpdatelanguagesInput = {
    set?: $Enums.ContentLanguage[]
    push?: $Enums.ContentLanguage | $Enums.ContentLanguage[]
  }

  export type CollectionUpdateOneWithoutSeriesNestedInput = {
    create?: XOR<CollectionCreateWithoutSeriesInput, CollectionUncheckedCreateWithoutSeriesInput>
    connectOrCreate?: CollectionCreateOrConnectWithoutSeriesInput
    upsert?: CollectionUpsertWithoutSeriesInput
    disconnect?: CollectionWhereInput | boolean
    delete?: CollectionWhereInput | boolean
    connect?: CollectionWhereUniqueInput
    update?: XOR<XOR<CollectionUpdateToOneWithWhereWithoutSeriesInput, CollectionUpdateWithoutSeriesInput>, CollectionUncheckedUpdateWithoutSeriesInput>
  }

  export type MediaUpdateOneWithoutThumbnailForSeriesNestedInput = {
    create?: XOR<MediaCreateWithoutThumbnailForSeriesInput, MediaUncheckedCreateWithoutThumbnailForSeriesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutThumbnailForSeriesInput
    upsert?: MediaUpsertWithoutThumbnailForSeriesInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutThumbnailForSeriesInput, MediaUpdateWithoutThumbnailForSeriesInput>, MediaUncheckedUpdateWithoutThumbnailForSeriesInput>
  }

  export type VolumeUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<VolumeCreateWithoutSeriesInput, VolumeUncheckedCreateWithoutSeriesInput> | VolumeCreateWithoutSeriesInput[] | VolumeUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: VolumeCreateOrConnectWithoutSeriesInput | VolumeCreateOrConnectWithoutSeriesInput[]
    upsert?: VolumeUpsertWithWhereUniqueWithoutSeriesInput | VolumeUpsertWithWhereUniqueWithoutSeriesInput[]
    createMany?: VolumeCreateManySeriesInputEnvelope
    set?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    disconnect?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    delete?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    connect?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    update?: VolumeUpdateWithWhereUniqueWithoutSeriesInput | VolumeUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: VolumeUpdateManyWithWhereWithoutSeriesInput | VolumeUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: VolumeScalarWhereInput | VolumeScalarWhereInput[]
  }

  export type CategoryUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<CategoryCreateWithoutSeriesInput, CategoryUncheckedCreateWithoutSeriesInput> | CategoryCreateWithoutSeriesInput[] | CategoryUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutSeriesInput | CategoryCreateOrConnectWithoutSeriesInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutSeriesInput | CategoryUpsertWithWhereUniqueWithoutSeriesInput[]
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutSeriesInput | CategoryUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutSeriesInput | CategoryUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type RegionUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<RegionCreateWithoutSeriesInput, RegionUncheckedCreateWithoutSeriesInput> | RegionCreateWithoutSeriesInput[] | RegionUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutSeriesInput | RegionCreateOrConnectWithoutSeriesInput[]
    upsert?: RegionUpsertWithWhereUniqueWithoutSeriesInput | RegionUpsertWithWhereUniqueWithoutSeriesInput[]
    set?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    disconnect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    delete?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    update?: RegionUpdateWithWhereUniqueWithoutSeriesInput | RegionUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: RegionUpdateManyWithWhereWithoutSeriesInput | RegionUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: RegionScalarWhereInput | RegionScalarWhereInput[]
  }

  export type TagUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<TagCreateWithoutSeriesInput, TagUncheckedCreateWithoutSeriesInput> | TagCreateWithoutSeriesInput[] | TagUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutSeriesInput | TagCreateOrConnectWithoutSeriesInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutSeriesInput | TagUpsertWithWhereUniqueWithoutSeriesInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutSeriesInput | TagUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: TagUpdateManyWithWhereWithoutSeriesInput | TagUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type VolumeUncheckedUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<VolumeCreateWithoutSeriesInput, VolumeUncheckedCreateWithoutSeriesInput> | VolumeCreateWithoutSeriesInput[] | VolumeUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: VolumeCreateOrConnectWithoutSeriesInput | VolumeCreateOrConnectWithoutSeriesInput[]
    upsert?: VolumeUpsertWithWhereUniqueWithoutSeriesInput | VolumeUpsertWithWhereUniqueWithoutSeriesInput[]
    createMany?: VolumeCreateManySeriesInputEnvelope
    set?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    disconnect?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    delete?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    connect?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    update?: VolumeUpdateWithWhereUniqueWithoutSeriesInput | VolumeUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: VolumeUpdateManyWithWhereWithoutSeriesInput | VolumeUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: VolumeScalarWhereInput | VolumeScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<CategoryCreateWithoutSeriesInput, CategoryUncheckedCreateWithoutSeriesInput> | CategoryCreateWithoutSeriesInput[] | CategoryUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutSeriesInput | CategoryCreateOrConnectWithoutSeriesInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutSeriesInput | CategoryUpsertWithWhereUniqueWithoutSeriesInput[]
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutSeriesInput | CategoryUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutSeriesInput | CategoryUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type RegionUncheckedUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<RegionCreateWithoutSeriesInput, RegionUncheckedCreateWithoutSeriesInput> | RegionCreateWithoutSeriesInput[] | RegionUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutSeriesInput | RegionCreateOrConnectWithoutSeriesInput[]
    upsert?: RegionUpsertWithWhereUniqueWithoutSeriesInput | RegionUpsertWithWhereUniqueWithoutSeriesInput[]
    set?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    disconnect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    delete?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    update?: RegionUpdateWithWhereUniqueWithoutSeriesInput | RegionUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: RegionUpdateManyWithWhereWithoutSeriesInput | RegionUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: RegionScalarWhereInput | RegionScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<TagCreateWithoutSeriesInput, TagUncheckedCreateWithoutSeriesInput> | TagCreateWithoutSeriesInput[] | TagUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutSeriesInput | TagCreateOrConnectWithoutSeriesInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutSeriesInput | TagUpsertWithWhereUniqueWithoutSeriesInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutSeriesInput | TagUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: TagUpdateManyWithWhereWithoutSeriesInput | TagUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type VolumeCreatelanguagesInput = {
    set: $Enums.ContentLanguage[]
  }

  export type VolumePageCreateNestedManyWithoutVolumeInput = {
    create?: XOR<VolumePageCreateWithoutVolumeInput, VolumePageUncheckedCreateWithoutVolumeInput> | VolumePageCreateWithoutVolumeInput[] | VolumePageUncheckedCreateWithoutVolumeInput[]
    connectOrCreate?: VolumePageCreateOrConnectWithoutVolumeInput | VolumePageCreateOrConnectWithoutVolumeInput[]
    createMany?: VolumePageCreateManyVolumeInputEnvelope
    connect?: VolumePageWhereUniqueInput | VolumePageWhereUniqueInput[]
  }

  export type SeriesCreateNestedOneWithoutVolumesInput = {
    create?: XOR<SeriesCreateWithoutVolumesInput, SeriesUncheckedCreateWithoutVolumesInput>
    connectOrCreate?: SeriesCreateOrConnectWithoutVolumesInput
    connect?: SeriesWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutThumbnailForVolumesInput = {
    create?: XOR<MediaCreateWithoutThumbnailForVolumesInput, MediaUncheckedCreateWithoutThumbnailForVolumesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutThumbnailForVolumesInput
    connect?: MediaWhereUniqueInput
  }

  export type RegionCreateNestedManyWithoutVolumesInput = {
    create?: XOR<RegionCreateWithoutVolumesInput, RegionUncheckedCreateWithoutVolumesInput> | RegionCreateWithoutVolumesInput[] | RegionUncheckedCreateWithoutVolumesInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutVolumesInput | RegionCreateOrConnectWithoutVolumesInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
  }

  export type VolumePageUncheckedCreateNestedManyWithoutVolumeInput = {
    create?: XOR<VolumePageCreateWithoutVolumeInput, VolumePageUncheckedCreateWithoutVolumeInput> | VolumePageCreateWithoutVolumeInput[] | VolumePageUncheckedCreateWithoutVolumeInput[]
    connectOrCreate?: VolumePageCreateOrConnectWithoutVolumeInput | VolumePageCreateOrConnectWithoutVolumeInput[]
    createMany?: VolumePageCreateManyVolumeInputEnvelope
    connect?: VolumePageWhereUniqueInput | VolumePageWhereUniqueInput[]
  }

  export type RegionUncheckedCreateNestedManyWithoutVolumesInput = {
    create?: XOR<RegionCreateWithoutVolumesInput, RegionUncheckedCreateWithoutVolumesInput> | RegionCreateWithoutVolumesInput[] | RegionUncheckedCreateWithoutVolumesInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutVolumesInput | RegionCreateOrConnectWithoutVolumesInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
  }

  export type VolumeUpdatelanguagesInput = {
    set?: $Enums.ContentLanguage[]
    push?: $Enums.ContentLanguage | $Enums.ContentLanguage[]
  }

  export type VolumePageUpdateManyWithoutVolumeNestedInput = {
    create?: XOR<VolumePageCreateWithoutVolumeInput, VolumePageUncheckedCreateWithoutVolumeInput> | VolumePageCreateWithoutVolumeInput[] | VolumePageUncheckedCreateWithoutVolumeInput[]
    connectOrCreate?: VolumePageCreateOrConnectWithoutVolumeInput | VolumePageCreateOrConnectWithoutVolumeInput[]
    upsert?: VolumePageUpsertWithWhereUniqueWithoutVolumeInput | VolumePageUpsertWithWhereUniqueWithoutVolumeInput[]
    createMany?: VolumePageCreateManyVolumeInputEnvelope
    set?: VolumePageWhereUniqueInput | VolumePageWhereUniqueInput[]
    disconnect?: VolumePageWhereUniqueInput | VolumePageWhereUniqueInput[]
    delete?: VolumePageWhereUniqueInput | VolumePageWhereUniqueInput[]
    connect?: VolumePageWhereUniqueInput | VolumePageWhereUniqueInput[]
    update?: VolumePageUpdateWithWhereUniqueWithoutVolumeInput | VolumePageUpdateWithWhereUniqueWithoutVolumeInput[]
    updateMany?: VolumePageUpdateManyWithWhereWithoutVolumeInput | VolumePageUpdateManyWithWhereWithoutVolumeInput[]
    deleteMany?: VolumePageScalarWhereInput | VolumePageScalarWhereInput[]
  }

  export type SeriesUpdateOneWithoutVolumesNestedInput = {
    create?: XOR<SeriesCreateWithoutVolumesInput, SeriesUncheckedCreateWithoutVolumesInput>
    connectOrCreate?: SeriesCreateOrConnectWithoutVolumesInput
    upsert?: SeriesUpsertWithoutVolumesInput
    disconnect?: SeriesWhereInput | boolean
    delete?: SeriesWhereInput | boolean
    connect?: SeriesWhereUniqueInput
    update?: XOR<XOR<SeriesUpdateToOneWithWhereWithoutVolumesInput, SeriesUpdateWithoutVolumesInput>, SeriesUncheckedUpdateWithoutVolumesInput>
  }

  export type MediaUpdateOneWithoutThumbnailForVolumesNestedInput = {
    create?: XOR<MediaCreateWithoutThumbnailForVolumesInput, MediaUncheckedCreateWithoutThumbnailForVolumesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutThumbnailForVolumesInput
    upsert?: MediaUpsertWithoutThumbnailForVolumesInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutThumbnailForVolumesInput, MediaUpdateWithoutThumbnailForVolumesInput>, MediaUncheckedUpdateWithoutThumbnailForVolumesInput>
  }

  export type RegionUpdateManyWithoutVolumesNestedInput = {
    create?: XOR<RegionCreateWithoutVolumesInput, RegionUncheckedCreateWithoutVolumesInput> | RegionCreateWithoutVolumesInput[] | RegionUncheckedCreateWithoutVolumesInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutVolumesInput | RegionCreateOrConnectWithoutVolumesInput[]
    upsert?: RegionUpsertWithWhereUniqueWithoutVolumesInput | RegionUpsertWithWhereUniqueWithoutVolumesInput[]
    set?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    disconnect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    delete?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    update?: RegionUpdateWithWhereUniqueWithoutVolumesInput | RegionUpdateWithWhereUniqueWithoutVolumesInput[]
    updateMany?: RegionUpdateManyWithWhereWithoutVolumesInput | RegionUpdateManyWithWhereWithoutVolumesInput[]
    deleteMany?: RegionScalarWhereInput | RegionScalarWhereInput[]
  }

  export type VolumePageUncheckedUpdateManyWithoutVolumeNestedInput = {
    create?: XOR<VolumePageCreateWithoutVolumeInput, VolumePageUncheckedCreateWithoutVolumeInput> | VolumePageCreateWithoutVolumeInput[] | VolumePageUncheckedCreateWithoutVolumeInput[]
    connectOrCreate?: VolumePageCreateOrConnectWithoutVolumeInput | VolumePageCreateOrConnectWithoutVolumeInput[]
    upsert?: VolumePageUpsertWithWhereUniqueWithoutVolumeInput | VolumePageUpsertWithWhereUniqueWithoutVolumeInput[]
    createMany?: VolumePageCreateManyVolumeInputEnvelope
    set?: VolumePageWhereUniqueInput | VolumePageWhereUniqueInput[]
    disconnect?: VolumePageWhereUniqueInput | VolumePageWhereUniqueInput[]
    delete?: VolumePageWhereUniqueInput | VolumePageWhereUniqueInput[]
    connect?: VolumePageWhereUniqueInput | VolumePageWhereUniqueInput[]
    update?: VolumePageUpdateWithWhereUniqueWithoutVolumeInput | VolumePageUpdateWithWhereUniqueWithoutVolumeInput[]
    updateMany?: VolumePageUpdateManyWithWhereWithoutVolumeInput | VolumePageUpdateManyWithWhereWithoutVolumeInput[]
    deleteMany?: VolumePageScalarWhereInput | VolumePageScalarWhereInput[]
  }

  export type RegionUncheckedUpdateManyWithoutVolumesNestedInput = {
    create?: XOR<RegionCreateWithoutVolumesInput, RegionUncheckedCreateWithoutVolumesInput> | RegionCreateWithoutVolumesInput[] | RegionUncheckedCreateWithoutVolumesInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutVolumesInput | RegionCreateOrConnectWithoutVolumesInput[]
    upsert?: RegionUpsertWithWhereUniqueWithoutVolumesInput | RegionUpsertWithWhereUniqueWithoutVolumesInput[]
    set?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    disconnect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    delete?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    update?: RegionUpdateWithWhereUniqueWithoutVolumesInput | RegionUpdateWithWhereUniqueWithoutVolumesInput[]
    updateMany?: RegionUpdateManyWithWhereWithoutVolumesInput | RegionUpdateManyWithWhereWithoutVolumesInput[]
    deleteMany?: RegionScalarWhereInput | RegionScalarWhereInput[]
  }

  export type PageDataCreateNestedOneWithoutPageInput = {
    create?: XOR<PageDataCreateWithoutPageInput, PageDataUncheckedCreateWithoutPageInput>
    connectOrCreate?: PageDataCreateOrConnectWithoutPageInput
    connect?: PageDataWhereUniqueInput
  }

  export type PageImageCreateNestedManyWithoutPageInput = {
    create?: XOR<PageImageCreateWithoutPageInput, PageImageUncheckedCreateWithoutPageInput> | PageImageCreateWithoutPageInput[] | PageImageUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PageImageCreateOrConnectWithoutPageInput | PageImageCreateOrConnectWithoutPageInput[]
    createMany?: PageImageCreateManyPageInputEnvelope
    connect?: PageImageWhereUniqueInput | PageImageWhereUniqueInput[]
  }

  export type PageTextCreateNestedManyWithoutPageInput = {
    create?: XOR<PageTextCreateWithoutPageInput, PageTextUncheckedCreateWithoutPageInput> | PageTextCreateWithoutPageInput[] | PageTextUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PageTextCreateOrConnectWithoutPageInput | PageTextCreateOrConnectWithoutPageInput[]
    createMany?: PageTextCreateManyPageInputEnvelope
    connect?: PageTextWhereUniqueInput | PageTextWhereUniqueInput[]
  }

  export type VolumeCreateNestedOneWithoutPagesInput = {
    create?: XOR<VolumeCreateWithoutPagesInput, VolumeUncheckedCreateWithoutPagesInput>
    connectOrCreate?: VolumeCreateOrConnectWithoutPagesInput
    connect?: VolumeWhereUniqueInput
  }

  export type ArtifactCreateNestedManyWithoutPagesInput = {
    create?: XOR<ArtifactCreateWithoutPagesInput, ArtifactUncheckedCreateWithoutPagesInput> | ArtifactCreateWithoutPagesInput[] | ArtifactUncheckedCreateWithoutPagesInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutPagesInput | ArtifactCreateOrConnectWithoutPagesInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
  }

  export type PageDataUncheckedCreateNestedOneWithoutPageInput = {
    create?: XOR<PageDataCreateWithoutPageInput, PageDataUncheckedCreateWithoutPageInput>
    connectOrCreate?: PageDataCreateOrConnectWithoutPageInput
    connect?: PageDataWhereUniqueInput
  }

  export type PageImageUncheckedCreateNestedManyWithoutPageInput = {
    create?: XOR<PageImageCreateWithoutPageInput, PageImageUncheckedCreateWithoutPageInput> | PageImageCreateWithoutPageInput[] | PageImageUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PageImageCreateOrConnectWithoutPageInput | PageImageCreateOrConnectWithoutPageInput[]
    createMany?: PageImageCreateManyPageInputEnvelope
    connect?: PageImageWhereUniqueInput | PageImageWhereUniqueInput[]
  }

  export type PageTextUncheckedCreateNestedManyWithoutPageInput = {
    create?: XOR<PageTextCreateWithoutPageInput, PageTextUncheckedCreateWithoutPageInput> | PageTextCreateWithoutPageInput[] | PageTextUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PageTextCreateOrConnectWithoutPageInput | PageTextCreateOrConnectWithoutPageInput[]
    createMany?: PageTextCreateManyPageInputEnvelope
    connect?: PageTextWhereUniqueInput | PageTextWhereUniqueInput[]
  }

  export type ArtifactUncheckedCreateNestedManyWithoutPagesInput = {
    create?: XOR<ArtifactCreateWithoutPagesInput, ArtifactUncheckedCreateWithoutPagesInput> | ArtifactCreateWithoutPagesInput[] | ArtifactUncheckedCreateWithoutPagesInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutPagesInput | ArtifactCreateOrConnectWithoutPagesInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
  }

  export type PageDataUpdateOneWithoutPageNestedInput = {
    create?: XOR<PageDataCreateWithoutPageInput, PageDataUncheckedCreateWithoutPageInput>
    connectOrCreate?: PageDataCreateOrConnectWithoutPageInput
    upsert?: PageDataUpsertWithoutPageInput
    disconnect?: PageDataWhereInput | boolean
    delete?: PageDataWhereInput | boolean
    connect?: PageDataWhereUniqueInput
    update?: XOR<XOR<PageDataUpdateToOneWithWhereWithoutPageInput, PageDataUpdateWithoutPageInput>, PageDataUncheckedUpdateWithoutPageInput>
  }

  export type PageImageUpdateManyWithoutPageNestedInput = {
    create?: XOR<PageImageCreateWithoutPageInput, PageImageUncheckedCreateWithoutPageInput> | PageImageCreateWithoutPageInput[] | PageImageUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PageImageCreateOrConnectWithoutPageInput | PageImageCreateOrConnectWithoutPageInput[]
    upsert?: PageImageUpsertWithWhereUniqueWithoutPageInput | PageImageUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: PageImageCreateManyPageInputEnvelope
    set?: PageImageWhereUniqueInput | PageImageWhereUniqueInput[]
    disconnect?: PageImageWhereUniqueInput | PageImageWhereUniqueInput[]
    delete?: PageImageWhereUniqueInput | PageImageWhereUniqueInput[]
    connect?: PageImageWhereUniqueInput | PageImageWhereUniqueInput[]
    update?: PageImageUpdateWithWhereUniqueWithoutPageInput | PageImageUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: PageImageUpdateManyWithWhereWithoutPageInput | PageImageUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: PageImageScalarWhereInput | PageImageScalarWhereInput[]
  }

  export type PageTextUpdateManyWithoutPageNestedInput = {
    create?: XOR<PageTextCreateWithoutPageInput, PageTextUncheckedCreateWithoutPageInput> | PageTextCreateWithoutPageInput[] | PageTextUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PageTextCreateOrConnectWithoutPageInput | PageTextCreateOrConnectWithoutPageInput[]
    upsert?: PageTextUpsertWithWhereUniqueWithoutPageInput | PageTextUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: PageTextCreateManyPageInputEnvelope
    set?: PageTextWhereUniqueInput | PageTextWhereUniqueInput[]
    disconnect?: PageTextWhereUniqueInput | PageTextWhereUniqueInput[]
    delete?: PageTextWhereUniqueInput | PageTextWhereUniqueInput[]
    connect?: PageTextWhereUniqueInput | PageTextWhereUniqueInput[]
    update?: PageTextUpdateWithWhereUniqueWithoutPageInput | PageTextUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: PageTextUpdateManyWithWhereWithoutPageInput | PageTextUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: PageTextScalarWhereInput | PageTextScalarWhereInput[]
  }

  export type VolumeUpdateOneWithoutPagesNestedInput = {
    create?: XOR<VolumeCreateWithoutPagesInput, VolumeUncheckedCreateWithoutPagesInput>
    connectOrCreate?: VolumeCreateOrConnectWithoutPagesInput
    upsert?: VolumeUpsertWithoutPagesInput
    disconnect?: VolumeWhereInput | boolean
    delete?: VolumeWhereInput | boolean
    connect?: VolumeWhereUniqueInput
    update?: XOR<XOR<VolumeUpdateToOneWithWhereWithoutPagesInput, VolumeUpdateWithoutPagesInput>, VolumeUncheckedUpdateWithoutPagesInput>
  }

  export type ArtifactUpdateManyWithoutPagesNestedInput = {
    create?: XOR<ArtifactCreateWithoutPagesInput, ArtifactUncheckedCreateWithoutPagesInput> | ArtifactCreateWithoutPagesInput[] | ArtifactUncheckedCreateWithoutPagesInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutPagesInput | ArtifactCreateOrConnectWithoutPagesInput[]
    upsert?: ArtifactUpsertWithWhereUniqueWithoutPagesInput | ArtifactUpsertWithWhereUniqueWithoutPagesInput[]
    set?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    disconnect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    delete?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    update?: ArtifactUpdateWithWhereUniqueWithoutPagesInput | ArtifactUpdateWithWhereUniqueWithoutPagesInput[]
    updateMany?: ArtifactUpdateManyWithWhereWithoutPagesInput | ArtifactUpdateManyWithWhereWithoutPagesInput[]
    deleteMany?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
  }

  export type PageDataUncheckedUpdateOneWithoutPageNestedInput = {
    create?: XOR<PageDataCreateWithoutPageInput, PageDataUncheckedCreateWithoutPageInput>
    connectOrCreate?: PageDataCreateOrConnectWithoutPageInput
    upsert?: PageDataUpsertWithoutPageInput
    disconnect?: PageDataWhereInput | boolean
    delete?: PageDataWhereInput | boolean
    connect?: PageDataWhereUniqueInput
    update?: XOR<XOR<PageDataUpdateToOneWithWhereWithoutPageInput, PageDataUpdateWithoutPageInput>, PageDataUncheckedUpdateWithoutPageInput>
  }

  export type PageImageUncheckedUpdateManyWithoutPageNestedInput = {
    create?: XOR<PageImageCreateWithoutPageInput, PageImageUncheckedCreateWithoutPageInput> | PageImageCreateWithoutPageInput[] | PageImageUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PageImageCreateOrConnectWithoutPageInput | PageImageCreateOrConnectWithoutPageInput[]
    upsert?: PageImageUpsertWithWhereUniqueWithoutPageInput | PageImageUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: PageImageCreateManyPageInputEnvelope
    set?: PageImageWhereUniqueInput | PageImageWhereUniqueInput[]
    disconnect?: PageImageWhereUniqueInput | PageImageWhereUniqueInput[]
    delete?: PageImageWhereUniqueInput | PageImageWhereUniqueInput[]
    connect?: PageImageWhereUniqueInput | PageImageWhereUniqueInput[]
    update?: PageImageUpdateWithWhereUniqueWithoutPageInput | PageImageUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: PageImageUpdateManyWithWhereWithoutPageInput | PageImageUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: PageImageScalarWhereInput | PageImageScalarWhereInput[]
  }

  export type PageTextUncheckedUpdateManyWithoutPageNestedInput = {
    create?: XOR<PageTextCreateWithoutPageInput, PageTextUncheckedCreateWithoutPageInput> | PageTextCreateWithoutPageInput[] | PageTextUncheckedCreateWithoutPageInput[]
    connectOrCreate?: PageTextCreateOrConnectWithoutPageInput | PageTextCreateOrConnectWithoutPageInput[]
    upsert?: PageTextUpsertWithWhereUniqueWithoutPageInput | PageTextUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: PageTextCreateManyPageInputEnvelope
    set?: PageTextWhereUniqueInput | PageTextWhereUniqueInput[]
    disconnect?: PageTextWhereUniqueInput | PageTextWhereUniqueInput[]
    delete?: PageTextWhereUniqueInput | PageTextWhereUniqueInput[]
    connect?: PageTextWhereUniqueInput | PageTextWhereUniqueInput[]
    update?: PageTextUpdateWithWhereUniqueWithoutPageInput | PageTextUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: PageTextUpdateManyWithWhereWithoutPageInput | PageTextUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: PageTextScalarWhereInput | PageTextScalarWhereInput[]
  }

  export type ArtifactUncheckedUpdateManyWithoutPagesNestedInput = {
    create?: XOR<ArtifactCreateWithoutPagesInput, ArtifactUncheckedCreateWithoutPagesInput> | ArtifactCreateWithoutPagesInput[] | ArtifactUncheckedCreateWithoutPagesInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutPagesInput | ArtifactCreateOrConnectWithoutPagesInput[]
    upsert?: ArtifactUpsertWithWhereUniqueWithoutPagesInput | ArtifactUpsertWithWhereUniqueWithoutPagesInput[]
    set?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    disconnect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    delete?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    update?: ArtifactUpdateWithWhereUniqueWithoutPagesInput | ArtifactUpdateWithWhereUniqueWithoutPagesInput[]
    updateMany?: ArtifactUpdateManyWithWhereWithoutPagesInput | ArtifactUpdateManyWithWhereWithoutPagesInput[]
    deleteMany?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
  }

  export type ArtifactCategoryCreateNestedOneWithoutArtifactsInput = {
    create?: XOR<ArtifactCategoryCreateWithoutArtifactsInput, ArtifactCategoryUncheckedCreateWithoutArtifactsInput>
    connectOrCreate?: ArtifactCategoryCreateOrConnectWithoutArtifactsInput
    connect?: ArtifactCategoryWhereUniqueInput
  }

  export type PeriodCreateNestedManyWithoutArtifactsInput = {
    create?: XOR<PeriodCreateWithoutArtifactsInput, PeriodUncheckedCreateWithoutArtifactsInput> | PeriodCreateWithoutArtifactsInput[] | PeriodUncheckedCreateWithoutArtifactsInput[]
    connectOrCreate?: PeriodCreateOrConnectWithoutArtifactsInput | PeriodCreateOrConnectWithoutArtifactsInput[]
    connect?: PeriodWhereUniqueInput | PeriodWhereUniqueInput[]
  }

  export type PlaceCreateNestedManyWithoutArtifactsInput = {
    create?: XOR<PlaceCreateWithoutArtifactsInput, PlaceUncheckedCreateWithoutArtifactsInput> | PlaceCreateWithoutArtifactsInput[] | PlaceUncheckedCreateWithoutArtifactsInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutArtifactsInput | PlaceCreateOrConnectWithoutArtifactsInput[]
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
  }

  export type RegionCreateNestedManyWithoutArtifactsInput = {
    create?: XOR<RegionCreateWithoutArtifactsInput, RegionUncheckedCreateWithoutArtifactsInput> | RegionCreateWithoutArtifactsInput[] | RegionUncheckedCreateWithoutArtifactsInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutArtifactsInput | RegionCreateOrConnectWithoutArtifactsInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutArtifactsInput = {
    create?: XOR<TagCreateWithoutArtifactsInput, TagUncheckedCreateWithoutArtifactsInput> | TagCreateWithoutArtifactsInput[] | TagUncheckedCreateWithoutArtifactsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutArtifactsInput | TagCreateOrConnectWithoutArtifactsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type VolumePageCreateNestedManyWithoutArtifactsInput = {
    create?: XOR<VolumePageCreateWithoutArtifactsInput, VolumePageUncheckedCreateWithoutArtifactsInput> | VolumePageCreateWithoutArtifactsInput[] | VolumePageUncheckedCreateWithoutArtifactsInput[]
    connectOrCreate?: VolumePageCreateOrConnectWithoutArtifactsInput | VolumePageCreateOrConnectWithoutArtifactsInput[]
    connect?: VolumePageWhereUniqueInput | VolumePageWhereUniqueInput[]
  }

  export type PeriodUncheckedCreateNestedManyWithoutArtifactsInput = {
    create?: XOR<PeriodCreateWithoutArtifactsInput, PeriodUncheckedCreateWithoutArtifactsInput> | PeriodCreateWithoutArtifactsInput[] | PeriodUncheckedCreateWithoutArtifactsInput[]
    connectOrCreate?: PeriodCreateOrConnectWithoutArtifactsInput | PeriodCreateOrConnectWithoutArtifactsInput[]
    connect?: PeriodWhereUniqueInput | PeriodWhereUniqueInput[]
  }

  export type PlaceUncheckedCreateNestedManyWithoutArtifactsInput = {
    create?: XOR<PlaceCreateWithoutArtifactsInput, PlaceUncheckedCreateWithoutArtifactsInput> | PlaceCreateWithoutArtifactsInput[] | PlaceUncheckedCreateWithoutArtifactsInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutArtifactsInput | PlaceCreateOrConnectWithoutArtifactsInput[]
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
  }

  export type RegionUncheckedCreateNestedManyWithoutArtifactsInput = {
    create?: XOR<RegionCreateWithoutArtifactsInput, RegionUncheckedCreateWithoutArtifactsInput> | RegionCreateWithoutArtifactsInput[] | RegionUncheckedCreateWithoutArtifactsInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutArtifactsInput | RegionCreateOrConnectWithoutArtifactsInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutArtifactsInput = {
    create?: XOR<TagCreateWithoutArtifactsInput, TagUncheckedCreateWithoutArtifactsInput> | TagCreateWithoutArtifactsInput[] | TagUncheckedCreateWithoutArtifactsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutArtifactsInput | TagCreateOrConnectWithoutArtifactsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type VolumePageUncheckedCreateNestedManyWithoutArtifactsInput = {
    create?: XOR<VolumePageCreateWithoutArtifactsInput, VolumePageUncheckedCreateWithoutArtifactsInput> | VolumePageCreateWithoutArtifactsInput[] | VolumePageUncheckedCreateWithoutArtifactsInput[]
    connectOrCreate?: VolumePageCreateOrConnectWithoutArtifactsInput | VolumePageCreateOrConnectWithoutArtifactsInput[]
    connect?: VolumePageWhereUniqueInput | VolumePageWhereUniqueInput[]
  }

  export type ArtifactCategoryUpdateOneWithoutArtifactsNestedInput = {
    create?: XOR<ArtifactCategoryCreateWithoutArtifactsInput, ArtifactCategoryUncheckedCreateWithoutArtifactsInput>
    connectOrCreate?: ArtifactCategoryCreateOrConnectWithoutArtifactsInput
    upsert?: ArtifactCategoryUpsertWithoutArtifactsInput
    disconnect?: ArtifactCategoryWhereInput | boolean
    delete?: ArtifactCategoryWhereInput | boolean
    connect?: ArtifactCategoryWhereUniqueInput
    update?: XOR<XOR<ArtifactCategoryUpdateToOneWithWhereWithoutArtifactsInput, ArtifactCategoryUpdateWithoutArtifactsInput>, ArtifactCategoryUncheckedUpdateWithoutArtifactsInput>
  }

  export type PeriodUpdateManyWithoutArtifactsNestedInput = {
    create?: XOR<PeriodCreateWithoutArtifactsInput, PeriodUncheckedCreateWithoutArtifactsInput> | PeriodCreateWithoutArtifactsInput[] | PeriodUncheckedCreateWithoutArtifactsInput[]
    connectOrCreate?: PeriodCreateOrConnectWithoutArtifactsInput | PeriodCreateOrConnectWithoutArtifactsInput[]
    upsert?: PeriodUpsertWithWhereUniqueWithoutArtifactsInput | PeriodUpsertWithWhereUniqueWithoutArtifactsInput[]
    set?: PeriodWhereUniqueInput | PeriodWhereUniqueInput[]
    disconnect?: PeriodWhereUniqueInput | PeriodWhereUniqueInput[]
    delete?: PeriodWhereUniqueInput | PeriodWhereUniqueInput[]
    connect?: PeriodWhereUniqueInput | PeriodWhereUniqueInput[]
    update?: PeriodUpdateWithWhereUniqueWithoutArtifactsInput | PeriodUpdateWithWhereUniqueWithoutArtifactsInput[]
    updateMany?: PeriodUpdateManyWithWhereWithoutArtifactsInput | PeriodUpdateManyWithWhereWithoutArtifactsInput[]
    deleteMany?: PeriodScalarWhereInput | PeriodScalarWhereInput[]
  }

  export type PlaceUpdateManyWithoutArtifactsNestedInput = {
    create?: XOR<PlaceCreateWithoutArtifactsInput, PlaceUncheckedCreateWithoutArtifactsInput> | PlaceCreateWithoutArtifactsInput[] | PlaceUncheckedCreateWithoutArtifactsInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutArtifactsInput | PlaceCreateOrConnectWithoutArtifactsInput[]
    upsert?: PlaceUpsertWithWhereUniqueWithoutArtifactsInput | PlaceUpsertWithWhereUniqueWithoutArtifactsInput[]
    set?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    disconnect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    delete?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    update?: PlaceUpdateWithWhereUniqueWithoutArtifactsInput | PlaceUpdateWithWhereUniqueWithoutArtifactsInput[]
    updateMany?: PlaceUpdateManyWithWhereWithoutArtifactsInput | PlaceUpdateManyWithWhereWithoutArtifactsInput[]
    deleteMany?: PlaceScalarWhereInput | PlaceScalarWhereInput[]
  }

  export type RegionUpdateManyWithoutArtifactsNestedInput = {
    create?: XOR<RegionCreateWithoutArtifactsInput, RegionUncheckedCreateWithoutArtifactsInput> | RegionCreateWithoutArtifactsInput[] | RegionUncheckedCreateWithoutArtifactsInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutArtifactsInput | RegionCreateOrConnectWithoutArtifactsInput[]
    upsert?: RegionUpsertWithWhereUniqueWithoutArtifactsInput | RegionUpsertWithWhereUniqueWithoutArtifactsInput[]
    set?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    disconnect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    delete?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    update?: RegionUpdateWithWhereUniqueWithoutArtifactsInput | RegionUpdateWithWhereUniqueWithoutArtifactsInput[]
    updateMany?: RegionUpdateManyWithWhereWithoutArtifactsInput | RegionUpdateManyWithWhereWithoutArtifactsInput[]
    deleteMany?: RegionScalarWhereInput | RegionScalarWhereInput[]
  }

  export type TagUpdateManyWithoutArtifactsNestedInput = {
    create?: XOR<TagCreateWithoutArtifactsInput, TagUncheckedCreateWithoutArtifactsInput> | TagCreateWithoutArtifactsInput[] | TagUncheckedCreateWithoutArtifactsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutArtifactsInput | TagCreateOrConnectWithoutArtifactsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutArtifactsInput | TagUpsertWithWhereUniqueWithoutArtifactsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutArtifactsInput | TagUpdateWithWhereUniqueWithoutArtifactsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutArtifactsInput | TagUpdateManyWithWhereWithoutArtifactsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type VolumePageUpdateManyWithoutArtifactsNestedInput = {
    create?: XOR<VolumePageCreateWithoutArtifactsInput, VolumePageUncheckedCreateWithoutArtifactsInput> | VolumePageCreateWithoutArtifactsInput[] | VolumePageUncheckedCreateWithoutArtifactsInput[]
    connectOrCreate?: VolumePageCreateOrConnectWithoutArtifactsInput | VolumePageCreateOrConnectWithoutArtifactsInput[]
    upsert?: VolumePageUpsertWithWhereUniqueWithoutArtifactsInput | VolumePageUpsertWithWhereUniqueWithoutArtifactsInput[]
    set?: VolumePageWhereUniqueInput | VolumePageWhereUniqueInput[]
    disconnect?: VolumePageWhereUniqueInput | VolumePageWhereUniqueInput[]
    delete?: VolumePageWhereUniqueInput | VolumePageWhereUniqueInput[]
    connect?: VolumePageWhereUniqueInput | VolumePageWhereUniqueInput[]
    update?: VolumePageUpdateWithWhereUniqueWithoutArtifactsInput | VolumePageUpdateWithWhereUniqueWithoutArtifactsInput[]
    updateMany?: VolumePageUpdateManyWithWhereWithoutArtifactsInput | VolumePageUpdateManyWithWhereWithoutArtifactsInput[]
    deleteMany?: VolumePageScalarWhereInput | VolumePageScalarWhereInput[]
  }

  export type PeriodUncheckedUpdateManyWithoutArtifactsNestedInput = {
    create?: XOR<PeriodCreateWithoutArtifactsInput, PeriodUncheckedCreateWithoutArtifactsInput> | PeriodCreateWithoutArtifactsInput[] | PeriodUncheckedCreateWithoutArtifactsInput[]
    connectOrCreate?: PeriodCreateOrConnectWithoutArtifactsInput | PeriodCreateOrConnectWithoutArtifactsInput[]
    upsert?: PeriodUpsertWithWhereUniqueWithoutArtifactsInput | PeriodUpsertWithWhereUniqueWithoutArtifactsInput[]
    set?: PeriodWhereUniqueInput | PeriodWhereUniqueInput[]
    disconnect?: PeriodWhereUniqueInput | PeriodWhereUniqueInput[]
    delete?: PeriodWhereUniqueInput | PeriodWhereUniqueInput[]
    connect?: PeriodWhereUniqueInput | PeriodWhereUniqueInput[]
    update?: PeriodUpdateWithWhereUniqueWithoutArtifactsInput | PeriodUpdateWithWhereUniqueWithoutArtifactsInput[]
    updateMany?: PeriodUpdateManyWithWhereWithoutArtifactsInput | PeriodUpdateManyWithWhereWithoutArtifactsInput[]
    deleteMany?: PeriodScalarWhereInput | PeriodScalarWhereInput[]
  }

  export type PlaceUncheckedUpdateManyWithoutArtifactsNestedInput = {
    create?: XOR<PlaceCreateWithoutArtifactsInput, PlaceUncheckedCreateWithoutArtifactsInput> | PlaceCreateWithoutArtifactsInput[] | PlaceUncheckedCreateWithoutArtifactsInput[]
    connectOrCreate?: PlaceCreateOrConnectWithoutArtifactsInput | PlaceCreateOrConnectWithoutArtifactsInput[]
    upsert?: PlaceUpsertWithWhereUniqueWithoutArtifactsInput | PlaceUpsertWithWhereUniqueWithoutArtifactsInput[]
    set?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    disconnect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    delete?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    connect?: PlaceWhereUniqueInput | PlaceWhereUniqueInput[]
    update?: PlaceUpdateWithWhereUniqueWithoutArtifactsInput | PlaceUpdateWithWhereUniqueWithoutArtifactsInput[]
    updateMany?: PlaceUpdateManyWithWhereWithoutArtifactsInput | PlaceUpdateManyWithWhereWithoutArtifactsInput[]
    deleteMany?: PlaceScalarWhereInput | PlaceScalarWhereInput[]
  }

  export type RegionUncheckedUpdateManyWithoutArtifactsNestedInput = {
    create?: XOR<RegionCreateWithoutArtifactsInput, RegionUncheckedCreateWithoutArtifactsInput> | RegionCreateWithoutArtifactsInput[] | RegionUncheckedCreateWithoutArtifactsInput[]
    connectOrCreate?: RegionCreateOrConnectWithoutArtifactsInput | RegionCreateOrConnectWithoutArtifactsInput[]
    upsert?: RegionUpsertWithWhereUniqueWithoutArtifactsInput | RegionUpsertWithWhereUniqueWithoutArtifactsInput[]
    set?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    disconnect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    delete?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    connect?: RegionWhereUniqueInput | RegionWhereUniqueInput[]
    update?: RegionUpdateWithWhereUniqueWithoutArtifactsInput | RegionUpdateWithWhereUniqueWithoutArtifactsInput[]
    updateMany?: RegionUpdateManyWithWhereWithoutArtifactsInput | RegionUpdateManyWithWhereWithoutArtifactsInput[]
    deleteMany?: RegionScalarWhereInput | RegionScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutArtifactsNestedInput = {
    create?: XOR<TagCreateWithoutArtifactsInput, TagUncheckedCreateWithoutArtifactsInput> | TagCreateWithoutArtifactsInput[] | TagUncheckedCreateWithoutArtifactsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutArtifactsInput | TagCreateOrConnectWithoutArtifactsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutArtifactsInput | TagUpsertWithWhereUniqueWithoutArtifactsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutArtifactsInput | TagUpdateWithWhereUniqueWithoutArtifactsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutArtifactsInput | TagUpdateManyWithWhereWithoutArtifactsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type VolumePageUncheckedUpdateManyWithoutArtifactsNestedInput = {
    create?: XOR<VolumePageCreateWithoutArtifactsInput, VolumePageUncheckedCreateWithoutArtifactsInput> | VolumePageCreateWithoutArtifactsInput[] | VolumePageUncheckedCreateWithoutArtifactsInput[]
    connectOrCreate?: VolumePageCreateOrConnectWithoutArtifactsInput | VolumePageCreateOrConnectWithoutArtifactsInput[]
    upsert?: VolumePageUpsertWithWhereUniqueWithoutArtifactsInput | VolumePageUpsertWithWhereUniqueWithoutArtifactsInput[]
    set?: VolumePageWhereUniqueInput | VolumePageWhereUniqueInput[]
    disconnect?: VolumePageWhereUniqueInput | VolumePageWhereUniqueInput[]
    delete?: VolumePageWhereUniqueInput | VolumePageWhereUniqueInput[]
    connect?: VolumePageWhereUniqueInput | VolumePageWhereUniqueInput[]
    update?: VolumePageUpdateWithWhereUniqueWithoutArtifactsInput | VolumePageUpdateWithWhereUniqueWithoutArtifactsInput[]
    updateMany?: VolumePageUpdateManyWithWhereWithoutArtifactsInput | VolumePageUpdateManyWithWhereWithoutArtifactsInput[]
    deleteMany?: VolumePageScalarWhereInput | VolumePageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPageTextsInput = {
    create?: XOR<UserCreateWithoutPageTextsInput, UserUncheckedCreateWithoutPageTextsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPageTextsInput
    connect?: UserWhereUniqueInput
  }

  export type VolumePageCreateNestedOneWithoutTextsInput = {
    create?: XOR<VolumePageCreateWithoutTextsInput, VolumePageUncheckedCreateWithoutTextsInput>
    connectOrCreate?: VolumePageCreateOrConnectWithoutTextsInput
    connect?: VolumePageWhereUniqueInput
  }

  export type EnumTextTypeFieldUpdateOperationsInput = {
    set?: $Enums.TextType
  }

  export type UserUpdateOneWithoutPageTextsNestedInput = {
    create?: XOR<UserCreateWithoutPageTextsInput, UserUncheckedCreateWithoutPageTextsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPageTextsInput
    upsert?: UserUpsertWithoutPageTextsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPageTextsInput, UserUpdateWithoutPageTextsInput>, UserUncheckedUpdateWithoutPageTextsInput>
  }

  export type VolumePageUpdateOneRequiredWithoutTextsNestedInput = {
    create?: XOR<VolumePageCreateWithoutTextsInput, VolumePageUncheckedCreateWithoutTextsInput>
    connectOrCreate?: VolumePageCreateOrConnectWithoutTextsInput
    upsert?: VolumePageUpsertWithoutTextsInput
    connect?: VolumePageWhereUniqueInput
    update?: XOR<XOR<VolumePageUpdateToOneWithWhereWithoutTextsInput, VolumePageUpdateWithoutTextsInput>, VolumePageUncheckedUpdateWithoutTextsInput>
  }

  export type VolumePageCreateNestedOneWithoutDataInput = {
    create?: XOR<VolumePageCreateWithoutDataInput, VolumePageUncheckedCreateWithoutDataInput>
    connectOrCreate?: VolumePageCreateOrConnectWithoutDataInput
    connect?: VolumePageWhereUniqueInput
  }

  export type VolumePageUpdateOneRequiredWithoutDataNestedInput = {
    create?: XOR<VolumePageCreateWithoutDataInput, VolumePageUncheckedCreateWithoutDataInput>
    connectOrCreate?: VolumePageCreateOrConnectWithoutDataInput
    upsert?: VolumePageUpsertWithoutDataInput
    connect?: VolumePageWhereUniqueInput
    update?: XOR<XOR<VolumePageUpdateToOneWithWhereWithoutDataInput, VolumePageUpdateWithoutDataInput>, VolumePageUncheckedUpdateWithoutDataInput>
  }

  export type VolumePageCreateNestedOneWithoutImagesInput = {
    create?: XOR<VolumePageCreateWithoutImagesInput, VolumePageUncheckedCreateWithoutImagesInput>
    connectOrCreate?: VolumePageCreateOrConnectWithoutImagesInput
    connect?: VolumePageWhereUniqueInput
  }

  export type StorageFileCreateNestedOneWithoutPageImagesInput = {
    create?: XOR<StorageFileCreateWithoutPageImagesInput, StorageFileUncheckedCreateWithoutPageImagesInput>
    connectOrCreate?: StorageFileCreateOrConnectWithoutPageImagesInput
    connect?: StorageFileWhereUniqueInput
  }

  export type EnumImageUseTypeFieldUpdateOperationsInput = {
    set?: $Enums.ImageUseType
  }

  export type VolumePageUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<VolumePageCreateWithoutImagesInput, VolumePageUncheckedCreateWithoutImagesInput>
    connectOrCreate?: VolumePageCreateOrConnectWithoutImagesInput
    upsert?: VolumePageUpsertWithoutImagesInput
    connect?: VolumePageWhereUniqueInput
    update?: XOR<XOR<VolumePageUpdateToOneWithWhereWithoutImagesInput, VolumePageUpdateWithoutImagesInput>, VolumePageUncheckedUpdateWithoutImagesInput>
  }

  export type StorageFileUpdateOneRequiredWithoutPageImagesNestedInput = {
    create?: XOR<StorageFileCreateWithoutPageImagesInput, StorageFileUncheckedCreateWithoutPageImagesInput>
    connectOrCreate?: StorageFileCreateOrConnectWithoutPageImagesInput
    upsert?: StorageFileUpsertWithoutPageImagesInput
    connect?: StorageFileWhereUniqueInput
    update?: XOR<XOR<StorageFileUpdateToOneWithWhereWithoutPageImagesInput, StorageFileUpdateWithoutPageImagesInput>, StorageFileUncheckedUpdateWithoutPageImagesInput>
  }

  export type MediaCreateNestedManyWithoutStorageFileInput = {
    create?: XOR<MediaCreateWithoutStorageFileInput, MediaUncheckedCreateWithoutStorageFileInput> | MediaCreateWithoutStorageFileInput[] | MediaUncheckedCreateWithoutStorageFileInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutStorageFileInput | MediaCreateOrConnectWithoutStorageFileInput[]
    createMany?: MediaCreateManyStorageFileInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type PageImageCreateNestedManyWithoutStorageFileInput = {
    create?: XOR<PageImageCreateWithoutStorageFileInput, PageImageUncheckedCreateWithoutStorageFileInput> | PageImageCreateWithoutStorageFileInput[] | PageImageUncheckedCreateWithoutStorageFileInput[]
    connectOrCreate?: PageImageCreateOrConnectWithoutStorageFileInput | PageImageCreateOrConnectWithoutStorageFileInput[]
    createMany?: PageImageCreateManyStorageFileInputEnvelope
    connect?: PageImageWhereUniqueInput | PageImageWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutStorageFileInput = {
    create?: XOR<MediaCreateWithoutStorageFileInput, MediaUncheckedCreateWithoutStorageFileInput> | MediaCreateWithoutStorageFileInput[] | MediaUncheckedCreateWithoutStorageFileInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutStorageFileInput | MediaCreateOrConnectWithoutStorageFileInput[]
    createMany?: MediaCreateManyStorageFileInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type PageImageUncheckedCreateNestedManyWithoutStorageFileInput = {
    create?: XOR<PageImageCreateWithoutStorageFileInput, PageImageUncheckedCreateWithoutStorageFileInput> | PageImageCreateWithoutStorageFileInput[] | PageImageUncheckedCreateWithoutStorageFileInput[]
    connectOrCreate?: PageImageCreateOrConnectWithoutStorageFileInput | PageImageCreateOrConnectWithoutStorageFileInput[]
    createMany?: PageImageCreateManyStorageFileInputEnvelope
    connect?: PageImageWhereUniqueInput | PageImageWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MediaUpdateManyWithoutStorageFileNestedInput = {
    create?: XOR<MediaCreateWithoutStorageFileInput, MediaUncheckedCreateWithoutStorageFileInput> | MediaCreateWithoutStorageFileInput[] | MediaUncheckedCreateWithoutStorageFileInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutStorageFileInput | MediaCreateOrConnectWithoutStorageFileInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutStorageFileInput | MediaUpsertWithWhereUniqueWithoutStorageFileInput[]
    createMany?: MediaCreateManyStorageFileInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutStorageFileInput | MediaUpdateWithWhereUniqueWithoutStorageFileInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutStorageFileInput | MediaUpdateManyWithWhereWithoutStorageFileInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type PageImageUpdateManyWithoutStorageFileNestedInput = {
    create?: XOR<PageImageCreateWithoutStorageFileInput, PageImageUncheckedCreateWithoutStorageFileInput> | PageImageCreateWithoutStorageFileInput[] | PageImageUncheckedCreateWithoutStorageFileInput[]
    connectOrCreate?: PageImageCreateOrConnectWithoutStorageFileInput | PageImageCreateOrConnectWithoutStorageFileInput[]
    upsert?: PageImageUpsertWithWhereUniqueWithoutStorageFileInput | PageImageUpsertWithWhereUniqueWithoutStorageFileInput[]
    createMany?: PageImageCreateManyStorageFileInputEnvelope
    set?: PageImageWhereUniqueInput | PageImageWhereUniqueInput[]
    disconnect?: PageImageWhereUniqueInput | PageImageWhereUniqueInput[]
    delete?: PageImageWhereUniqueInput | PageImageWhereUniqueInput[]
    connect?: PageImageWhereUniqueInput | PageImageWhereUniqueInput[]
    update?: PageImageUpdateWithWhereUniqueWithoutStorageFileInput | PageImageUpdateWithWhereUniqueWithoutStorageFileInput[]
    updateMany?: PageImageUpdateManyWithWhereWithoutStorageFileInput | PageImageUpdateManyWithWhereWithoutStorageFileInput[]
    deleteMany?: PageImageScalarWhereInput | PageImageScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutStorageFileNestedInput = {
    create?: XOR<MediaCreateWithoutStorageFileInput, MediaUncheckedCreateWithoutStorageFileInput> | MediaCreateWithoutStorageFileInput[] | MediaUncheckedCreateWithoutStorageFileInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutStorageFileInput | MediaCreateOrConnectWithoutStorageFileInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutStorageFileInput | MediaUpsertWithWhereUniqueWithoutStorageFileInput[]
    createMany?: MediaCreateManyStorageFileInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutStorageFileInput | MediaUpdateWithWhereUniqueWithoutStorageFileInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutStorageFileInput | MediaUpdateManyWithWhereWithoutStorageFileInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type PageImageUncheckedUpdateManyWithoutStorageFileNestedInput = {
    create?: XOR<PageImageCreateWithoutStorageFileInput, PageImageUncheckedCreateWithoutStorageFileInput> | PageImageCreateWithoutStorageFileInput[] | PageImageUncheckedCreateWithoutStorageFileInput[]
    connectOrCreate?: PageImageCreateOrConnectWithoutStorageFileInput | PageImageCreateOrConnectWithoutStorageFileInput[]
    upsert?: PageImageUpsertWithWhereUniqueWithoutStorageFileInput | PageImageUpsertWithWhereUniqueWithoutStorageFileInput[]
    createMany?: PageImageCreateManyStorageFileInputEnvelope
    set?: PageImageWhereUniqueInput | PageImageWhereUniqueInput[]
    disconnect?: PageImageWhereUniqueInput | PageImageWhereUniqueInput[]
    delete?: PageImageWhereUniqueInput | PageImageWhereUniqueInput[]
    connect?: PageImageWhereUniqueInput | PageImageWhereUniqueInput[]
    update?: PageImageUpdateWithWhereUniqueWithoutStorageFileInput | PageImageUpdateWithWhereUniqueWithoutStorageFileInput[]
    updateMany?: PageImageUpdateManyWithWhereWithoutStorageFileInput | PageImageUpdateManyWithWhereWithoutStorageFileInput[]
    deleteMany?: PageImageScalarWhereInput | PageImageScalarWhereInput[]
  }

  export type CategoryCreateNestedManyWithoutThumbnailInput = {
    create?: XOR<CategoryCreateWithoutThumbnailInput, CategoryUncheckedCreateWithoutThumbnailInput> | CategoryCreateWithoutThumbnailInput[] | CategoryUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutThumbnailInput | CategoryCreateOrConnectWithoutThumbnailInput[]
    createMany?: CategoryCreateManyThumbnailInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type CollectionCreateNestedManyWithoutThumbnailInput = {
    create?: XOR<CollectionCreateWithoutThumbnailInput, CollectionUncheckedCreateWithoutThumbnailInput> | CollectionCreateWithoutThumbnailInput[] | CollectionUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutThumbnailInput | CollectionCreateOrConnectWithoutThumbnailInput[]
    createMany?: CollectionCreateManyThumbnailInputEnvelope
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
  }

  export type MapCreateNestedManyWithoutThumbnailInput = {
    create?: XOR<MapCreateWithoutThumbnailInput, MapUncheckedCreateWithoutThumbnailInput> | MapCreateWithoutThumbnailInput[] | MapUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: MapCreateOrConnectWithoutThumbnailInput | MapCreateOrConnectWithoutThumbnailInput[]
    createMany?: MapCreateManyThumbnailInputEnvelope
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
  }

  export type StorageFileCreateNestedOneWithoutMediaInput = {
    create?: XOR<StorageFileCreateWithoutMediaInput, StorageFileUncheckedCreateWithoutMediaInput>
    connectOrCreate?: StorageFileCreateOrConnectWithoutMediaInput
    connect?: StorageFileWhereUniqueInput
  }

  export type PageCreateNestedManyWithoutThumbnailInput = {
    create?: XOR<PageCreateWithoutThumbnailInput, PageUncheckedCreateWithoutThumbnailInput> | PageCreateWithoutThumbnailInput[] | PageUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: PageCreateOrConnectWithoutThumbnailInput | PageCreateOrConnectWithoutThumbnailInput[]
    createMany?: PageCreateManyThumbnailInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutThumbnailInput = {
    create?: XOR<PostCreateWithoutThumbnailInput, PostUncheckedCreateWithoutThumbnailInput> | PostCreateWithoutThumbnailInput[] | PostUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: PostCreateOrConnectWithoutThumbnailInput | PostCreateOrConnectWithoutThumbnailInput[]
    createMany?: PostCreateManyThumbnailInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type ResearchDatasetCreateNestedManyWithoutThumbnailInput = {
    create?: XOR<ResearchDatasetCreateWithoutThumbnailInput, ResearchDatasetUncheckedCreateWithoutThumbnailInput> | ResearchDatasetCreateWithoutThumbnailInput[] | ResearchDatasetUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: ResearchDatasetCreateOrConnectWithoutThumbnailInput | ResearchDatasetCreateOrConnectWithoutThumbnailInput[]
    createMany?: ResearchDatasetCreateManyThumbnailInputEnvelope
    connect?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
  }

  export type SeriesCreateNestedManyWithoutThumbnailInput = {
    create?: XOR<SeriesCreateWithoutThumbnailInput, SeriesUncheckedCreateWithoutThumbnailInput> | SeriesCreateWithoutThumbnailInput[] | SeriesUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutThumbnailInput | SeriesCreateOrConnectWithoutThumbnailInput[]
    createMany?: SeriesCreateManyThumbnailInputEnvelope
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
  }

  export type VolumeCreateNestedManyWithoutThumbnailInput = {
    create?: XOR<VolumeCreateWithoutThumbnailInput, VolumeUncheckedCreateWithoutThumbnailInput> | VolumeCreateWithoutThumbnailInput[] | VolumeUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: VolumeCreateOrConnectWithoutThumbnailInput | VolumeCreateOrConnectWithoutThumbnailInput[]
    createMany?: VolumeCreateManyThumbnailInputEnvelope
    connect?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutThumbnailInput = {
    create?: XOR<CategoryCreateWithoutThumbnailInput, CategoryUncheckedCreateWithoutThumbnailInput> | CategoryCreateWithoutThumbnailInput[] | CategoryUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutThumbnailInput | CategoryCreateOrConnectWithoutThumbnailInput[]
    createMany?: CategoryCreateManyThumbnailInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type CollectionUncheckedCreateNestedManyWithoutThumbnailInput = {
    create?: XOR<CollectionCreateWithoutThumbnailInput, CollectionUncheckedCreateWithoutThumbnailInput> | CollectionCreateWithoutThumbnailInput[] | CollectionUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutThumbnailInput | CollectionCreateOrConnectWithoutThumbnailInput[]
    createMany?: CollectionCreateManyThumbnailInputEnvelope
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
  }

  export type MapUncheckedCreateNestedManyWithoutThumbnailInput = {
    create?: XOR<MapCreateWithoutThumbnailInput, MapUncheckedCreateWithoutThumbnailInput> | MapCreateWithoutThumbnailInput[] | MapUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: MapCreateOrConnectWithoutThumbnailInput | MapCreateOrConnectWithoutThumbnailInput[]
    createMany?: MapCreateManyThumbnailInputEnvelope
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
  }

  export type PageUncheckedCreateNestedManyWithoutThumbnailInput = {
    create?: XOR<PageCreateWithoutThumbnailInput, PageUncheckedCreateWithoutThumbnailInput> | PageCreateWithoutThumbnailInput[] | PageUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: PageCreateOrConnectWithoutThumbnailInput | PageCreateOrConnectWithoutThumbnailInput[]
    createMany?: PageCreateManyThumbnailInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutThumbnailInput = {
    create?: XOR<PostCreateWithoutThumbnailInput, PostUncheckedCreateWithoutThumbnailInput> | PostCreateWithoutThumbnailInput[] | PostUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: PostCreateOrConnectWithoutThumbnailInput | PostCreateOrConnectWithoutThumbnailInput[]
    createMany?: PostCreateManyThumbnailInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type ResearchDatasetUncheckedCreateNestedManyWithoutThumbnailInput = {
    create?: XOR<ResearchDatasetCreateWithoutThumbnailInput, ResearchDatasetUncheckedCreateWithoutThumbnailInput> | ResearchDatasetCreateWithoutThumbnailInput[] | ResearchDatasetUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: ResearchDatasetCreateOrConnectWithoutThumbnailInput | ResearchDatasetCreateOrConnectWithoutThumbnailInput[]
    createMany?: ResearchDatasetCreateManyThumbnailInputEnvelope
    connect?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
  }

  export type SeriesUncheckedCreateNestedManyWithoutThumbnailInput = {
    create?: XOR<SeriesCreateWithoutThumbnailInput, SeriesUncheckedCreateWithoutThumbnailInput> | SeriesCreateWithoutThumbnailInput[] | SeriesUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutThumbnailInput | SeriesCreateOrConnectWithoutThumbnailInput[]
    createMany?: SeriesCreateManyThumbnailInputEnvelope
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
  }

  export type VolumeUncheckedCreateNestedManyWithoutThumbnailInput = {
    create?: XOR<VolumeCreateWithoutThumbnailInput, VolumeUncheckedCreateWithoutThumbnailInput> | VolumeCreateWithoutThumbnailInput[] | VolumeUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: VolumeCreateOrConnectWithoutThumbnailInput | VolumeCreateOrConnectWithoutThumbnailInput[]
    createMany?: VolumeCreateManyThumbnailInputEnvelope
    connect?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
  }

  export type CategoryUpdateManyWithoutThumbnailNestedInput = {
    create?: XOR<CategoryCreateWithoutThumbnailInput, CategoryUncheckedCreateWithoutThumbnailInput> | CategoryCreateWithoutThumbnailInput[] | CategoryUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutThumbnailInput | CategoryCreateOrConnectWithoutThumbnailInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutThumbnailInput | CategoryUpsertWithWhereUniqueWithoutThumbnailInput[]
    createMany?: CategoryCreateManyThumbnailInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutThumbnailInput | CategoryUpdateWithWhereUniqueWithoutThumbnailInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutThumbnailInput | CategoryUpdateManyWithWhereWithoutThumbnailInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type CollectionUpdateManyWithoutThumbnailNestedInput = {
    create?: XOR<CollectionCreateWithoutThumbnailInput, CollectionUncheckedCreateWithoutThumbnailInput> | CollectionCreateWithoutThumbnailInput[] | CollectionUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutThumbnailInput | CollectionCreateOrConnectWithoutThumbnailInput[]
    upsert?: CollectionUpsertWithWhereUniqueWithoutThumbnailInput | CollectionUpsertWithWhereUniqueWithoutThumbnailInput[]
    createMany?: CollectionCreateManyThumbnailInputEnvelope
    set?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    disconnect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    delete?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    update?: CollectionUpdateWithWhereUniqueWithoutThumbnailInput | CollectionUpdateWithWhereUniqueWithoutThumbnailInput[]
    updateMany?: CollectionUpdateManyWithWhereWithoutThumbnailInput | CollectionUpdateManyWithWhereWithoutThumbnailInput[]
    deleteMany?: CollectionScalarWhereInput | CollectionScalarWhereInput[]
  }

  export type MapUpdateManyWithoutThumbnailNestedInput = {
    create?: XOR<MapCreateWithoutThumbnailInput, MapUncheckedCreateWithoutThumbnailInput> | MapCreateWithoutThumbnailInput[] | MapUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: MapCreateOrConnectWithoutThumbnailInput | MapCreateOrConnectWithoutThumbnailInput[]
    upsert?: MapUpsertWithWhereUniqueWithoutThumbnailInput | MapUpsertWithWhereUniqueWithoutThumbnailInput[]
    createMany?: MapCreateManyThumbnailInputEnvelope
    set?: MapWhereUniqueInput | MapWhereUniqueInput[]
    disconnect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    delete?: MapWhereUniqueInput | MapWhereUniqueInput[]
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    update?: MapUpdateWithWhereUniqueWithoutThumbnailInput | MapUpdateWithWhereUniqueWithoutThumbnailInput[]
    updateMany?: MapUpdateManyWithWhereWithoutThumbnailInput | MapUpdateManyWithWhereWithoutThumbnailInput[]
    deleteMany?: MapScalarWhereInput | MapScalarWhereInput[]
  }

  export type StorageFileUpdateOneWithoutMediaNestedInput = {
    create?: XOR<StorageFileCreateWithoutMediaInput, StorageFileUncheckedCreateWithoutMediaInput>
    connectOrCreate?: StorageFileCreateOrConnectWithoutMediaInput
    upsert?: StorageFileUpsertWithoutMediaInput
    disconnect?: StorageFileWhereInput | boolean
    delete?: StorageFileWhereInput | boolean
    connect?: StorageFileWhereUniqueInput
    update?: XOR<XOR<StorageFileUpdateToOneWithWhereWithoutMediaInput, StorageFileUpdateWithoutMediaInput>, StorageFileUncheckedUpdateWithoutMediaInput>
  }

  export type PageUpdateManyWithoutThumbnailNestedInput = {
    create?: XOR<PageCreateWithoutThumbnailInput, PageUncheckedCreateWithoutThumbnailInput> | PageCreateWithoutThumbnailInput[] | PageUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: PageCreateOrConnectWithoutThumbnailInput | PageCreateOrConnectWithoutThumbnailInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutThumbnailInput | PageUpsertWithWhereUniqueWithoutThumbnailInput[]
    createMany?: PageCreateManyThumbnailInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutThumbnailInput | PageUpdateWithWhereUniqueWithoutThumbnailInput[]
    updateMany?: PageUpdateManyWithWhereWithoutThumbnailInput | PageUpdateManyWithWhereWithoutThumbnailInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type PostUpdateManyWithoutThumbnailNestedInput = {
    create?: XOR<PostCreateWithoutThumbnailInput, PostUncheckedCreateWithoutThumbnailInput> | PostCreateWithoutThumbnailInput[] | PostUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: PostCreateOrConnectWithoutThumbnailInput | PostCreateOrConnectWithoutThumbnailInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutThumbnailInput | PostUpsertWithWhereUniqueWithoutThumbnailInput[]
    createMany?: PostCreateManyThumbnailInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutThumbnailInput | PostUpdateWithWhereUniqueWithoutThumbnailInput[]
    updateMany?: PostUpdateManyWithWhereWithoutThumbnailInput | PostUpdateManyWithWhereWithoutThumbnailInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type ResearchDatasetUpdateManyWithoutThumbnailNestedInput = {
    create?: XOR<ResearchDatasetCreateWithoutThumbnailInput, ResearchDatasetUncheckedCreateWithoutThumbnailInput> | ResearchDatasetCreateWithoutThumbnailInput[] | ResearchDatasetUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: ResearchDatasetCreateOrConnectWithoutThumbnailInput | ResearchDatasetCreateOrConnectWithoutThumbnailInput[]
    upsert?: ResearchDatasetUpsertWithWhereUniqueWithoutThumbnailInput | ResearchDatasetUpsertWithWhereUniqueWithoutThumbnailInput[]
    createMany?: ResearchDatasetCreateManyThumbnailInputEnvelope
    set?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    disconnect?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    delete?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    connect?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    update?: ResearchDatasetUpdateWithWhereUniqueWithoutThumbnailInput | ResearchDatasetUpdateWithWhereUniqueWithoutThumbnailInput[]
    updateMany?: ResearchDatasetUpdateManyWithWhereWithoutThumbnailInput | ResearchDatasetUpdateManyWithWhereWithoutThumbnailInput[]
    deleteMany?: ResearchDatasetScalarWhereInput | ResearchDatasetScalarWhereInput[]
  }

  export type SeriesUpdateManyWithoutThumbnailNestedInput = {
    create?: XOR<SeriesCreateWithoutThumbnailInput, SeriesUncheckedCreateWithoutThumbnailInput> | SeriesCreateWithoutThumbnailInput[] | SeriesUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutThumbnailInput | SeriesCreateOrConnectWithoutThumbnailInput[]
    upsert?: SeriesUpsertWithWhereUniqueWithoutThumbnailInput | SeriesUpsertWithWhereUniqueWithoutThumbnailInput[]
    createMany?: SeriesCreateManyThumbnailInputEnvelope
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    update?: SeriesUpdateWithWhereUniqueWithoutThumbnailInput | SeriesUpdateWithWhereUniqueWithoutThumbnailInput[]
    updateMany?: SeriesUpdateManyWithWhereWithoutThumbnailInput | SeriesUpdateManyWithWhereWithoutThumbnailInput[]
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
  }

  export type VolumeUpdateManyWithoutThumbnailNestedInput = {
    create?: XOR<VolumeCreateWithoutThumbnailInput, VolumeUncheckedCreateWithoutThumbnailInput> | VolumeCreateWithoutThumbnailInput[] | VolumeUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: VolumeCreateOrConnectWithoutThumbnailInput | VolumeCreateOrConnectWithoutThumbnailInput[]
    upsert?: VolumeUpsertWithWhereUniqueWithoutThumbnailInput | VolumeUpsertWithWhereUniqueWithoutThumbnailInput[]
    createMany?: VolumeCreateManyThumbnailInputEnvelope
    set?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    disconnect?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    delete?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    connect?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    update?: VolumeUpdateWithWhereUniqueWithoutThumbnailInput | VolumeUpdateWithWhereUniqueWithoutThumbnailInput[]
    updateMany?: VolumeUpdateManyWithWhereWithoutThumbnailInput | VolumeUpdateManyWithWhereWithoutThumbnailInput[]
    deleteMany?: VolumeScalarWhereInput | VolumeScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutThumbnailNestedInput = {
    create?: XOR<CategoryCreateWithoutThumbnailInput, CategoryUncheckedCreateWithoutThumbnailInput> | CategoryCreateWithoutThumbnailInput[] | CategoryUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutThumbnailInput | CategoryCreateOrConnectWithoutThumbnailInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutThumbnailInput | CategoryUpsertWithWhereUniqueWithoutThumbnailInput[]
    createMany?: CategoryCreateManyThumbnailInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutThumbnailInput | CategoryUpdateWithWhereUniqueWithoutThumbnailInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutThumbnailInput | CategoryUpdateManyWithWhereWithoutThumbnailInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type CollectionUncheckedUpdateManyWithoutThumbnailNestedInput = {
    create?: XOR<CollectionCreateWithoutThumbnailInput, CollectionUncheckedCreateWithoutThumbnailInput> | CollectionCreateWithoutThumbnailInput[] | CollectionUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutThumbnailInput | CollectionCreateOrConnectWithoutThumbnailInput[]
    upsert?: CollectionUpsertWithWhereUniqueWithoutThumbnailInput | CollectionUpsertWithWhereUniqueWithoutThumbnailInput[]
    createMany?: CollectionCreateManyThumbnailInputEnvelope
    set?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    disconnect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    delete?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    update?: CollectionUpdateWithWhereUniqueWithoutThumbnailInput | CollectionUpdateWithWhereUniqueWithoutThumbnailInput[]
    updateMany?: CollectionUpdateManyWithWhereWithoutThumbnailInput | CollectionUpdateManyWithWhereWithoutThumbnailInput[]
    deleteMany?: CollectionScalarWhereInput | CollectionScalarWhereInput[]
  }

  export type MapUncheckedUpdateManyWithoutThumbnailNestedInput = {
    create?: XOR<MapCreateWithoutThumbnailInput, MapUncheckedCreateWithoutThumbnailInput> | MapCreateWithoutThumbnailInput[] | MapUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: MapCreateOrConnectWithoutThumbnailInput | MapCreateOrConnectWithoutThumbnailInput[]
    upsert?: MapUpsertWithWhereUniqueWithoutThumbnailInput | MapUpsertWithWhereUniqueWithoutThumbnailInput[]
    createMany?: MapCreateManyThumbnailInputEnvelope
    set?: MapWhereUniqueInput | MapWhereUniqueInput[]
    disconnect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    delete?: MapWhereUniqueInput | MapWhereUniqueInput[]
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    update?: MapUpdateWithWhereUniqueWithoutThumbnailInput | MapUpdateWithWhereUniqueWithoutThumbnailInput[]
    updateMany?: MapUpdateManyWithWhereWithoutThumbnailInput | MapUpdateManyWithWhereWithoutThumbnailInput[]
    deleteMany?: MapScalarWhereInput | MapScalarWhereInput[]
  }

  export type PageUncheckedUpdateManyWithoutThumbnailNestedInput = {
    create?: XOR<PageCreateWithoutThumbnailInput, PageUncheckedCreateWithoutThumbnailInput> | PageCreateWithoutThumbnailInput[] | PageUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: PageCreateOrConnectWithoutThumbnailInput | PageCreateOrConnectWithoutThumbnailInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutThumbnailInput | PageUpsertWithWhereUniqueWithoutThumbnailInput[]
    createMany?: PageCreateManyThumbnailInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutThumbnailInput | PageUpdateWithWhereUniqueWithoutThumbnailInput[]
    updateMany?: PageUpdateManyWithWhereWithoutThumbnailInput | PageUpdateManyWithWhereWithoutThumbnailInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutThumbnailNestedInput = {
    create?: XOR<PostCreateWithoutThumbnailInput, PostUncheckedCreateWithoutThumbnailInput> | PostCreateWithoutThumbnailInput[] | PostUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: PostCreateOrConnectWithoutThumbnailInput | PostCreateOrConnectWithoutThumbnailInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutThumbnailInput | PostUpsertWithWhereUniqueWithoutThumbnailInput[]
    createMany?: PostCreateManyThumbnailInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutThumbnailInput | PostUpdateWithWhereUniqueWithoutThumbnailInput[]
    updateMany?: PostUpdateManyWithWhereWithoutThumbnailInput | PostUpdateManyWithWhereWithoutThumbnailInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type ResearchDatasetUncheckedUpdateManyWithoutThumbnailNestedInput = {
    create?: XOR<ResearchDatasetCreateWithoutThumbnailInput, ResearchDatasetUncheckedCreateWithoutThumbnailInput> | ResearchDatasetCreateWithoutThumbnailInput[] | ResearchDatasetUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: ResearchDatasetCreateOrConnectWithoutThumbnailInput | ResearchDatasetCreateOrConnectWithoutThumbnailInput[]
    upsert?: ResearchDatasetUpsertWithWhereUniqueWithoutThumbnailInput | ResearchDatasetUpsertWithWhereUniqueWithoutThumbnailInput[]
    createMany?: ResearchDatasetCreateManyThumbnailInputEnvelope
    set?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    disconnect?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    delete?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    connect?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    update?: ResearchDatasetUpdateWithWhereUniqueWithoutThumbnailInput | ResearchDatasetUpdateWithWhereUniqueWithoutThumbnailInput[]
    updateMany?: ResearchDatasetUpdateManyWithWhereWithoutThumbnailInput | ResearchDatasetUpdateManyWithWhereWithoutThumbnailInput[]
    deleteMany?: ResearchDatasetScalarWhereInput | ResearchDatasetScalarWhereInput[]
  }

  export type SeriesUncheckedUpdateManyWithoutThumbnailNestedInput = {
    create?: XOR<SeriesCreateWithoutThumbnailInput, SeriesUncheckedCreateWithoutThumbnailInput> | SeriesCreateWithoutThumbnailInput[] | SeriesUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutThumbnailInput | SeriesCreateOrConnectWithoutThumbnailInput[]
    upsert?: SeriesUpsertWithWhereUniqueWithoutThumbnailInput | SeriesUpsertWithWhereUniqueWithoutThumbnailInput[]
    createMany?: SeriesCreateManyThumbnailInputEnvelope
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    update?: SeriesUpdateWithWhereUniqueWithoutThumbnailInput | SeriesUpdateWithWhereUniqueWithoutThumbnailInput[]
    updateMany?: SeriesUpdateManyWithWhereWithoutThumbnailInput | SeriesUpdateManyWithWhereWithoutThumbnailInput[]
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
  }

  export type VolumeUncheckedUpdateManyWithoutThumbnailNestedInput = {
    create?: XOR<VolumeCreateWithoutThumbnailInput, VolumeUncheckedCreateWithoutThumbnailInput> | VolumeCreateWithoutThumbnailInput[] | VolumeUncheckedCreateWithoutThumbnailInput[]
    connectOrCreate?: VolumeCreateOrConnectWithoutThumbnailInput | VolumeCreateOrConnectWithoutThumbnailInput[]
    upsert?: VolumeUpsertWithWhereUniqueWithoutThumbnailInput | VolumeUpsertWithWhereUniqueWithoutThumbnailInput[]
    createMany?: VolumeCreateManyThumbnailInputEnvelope
    set?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    disconnect?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    delete?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    connect?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    update?: VolumeUpdateWithWhereUniqueWithoutThumbnailInput | VolumeUpdateWithWhereUniqueWithoutThumbnailInput[]
    updateMany?: VolumeUpdateManyWithWhereWithoutThumbnailInput | VolumeUpdateManyWithWhereWithoutThumbnailInput[]
    deleteMany?: VolumeScalarWhereInput | VolumeScalarWhereInput[]
  }

  export type AdministrativePlaceCreateNestedManyWithoutPlaceInput = {
    create?: XOR<AdministrativePlaceCreateWithoutPlaceInput, AdministrativePlaceUncheckedCreateWithoutPlaceInput> | AdministrativePlaceCreateWithoutPlaceInput[] | AdministrativePlaceUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: AdministrativePlaceCreateOrConnectWithoutPlaceInput | AdministrativePlaceCreateOrConnectWithoutPlaceInput[]
    createMany?: AdministrativePlaceCreateManyPlaceInputEnvelope
    connect?: AdministrativePlaceWhereUniqueInput | AdministrativePlaceWhereUniqueInput[]
  }

  export type ArtifactCreateNestedManyWithoutPlacesInput = {
    create?: XOR<ArtifactCreateWithoutPlacesInput, ArtifactUncheckedCreateWithoutPlacesInput> | ArtifactCreateWithoutPlacesInput[] | ArtifactUncheckedCreateWithoutPlacesInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutPlacesInput | ArtifactCreateOrConnectWithoutPlacesInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
  }

  export type AdministrativePlaceUncheckedCreateNestedManyWithoutPlaceInput = {
    create?: XOR<AdministrativePlaceCreateWithoutPlaceInput, AdministrativePlaceUncheckedCreateWithoutPlaceInput> | AdministrativePlaceCreateWithoutPlaceInput[] | AdministrativePlaceUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: AdministrativePlaceCreateOrConnectWithoutPlaceInput | AdministrativePlaceCreateOrConnectWithoutPlaceInput[]
    createMany?: AdministrativePlaceCreateManyPlaceInputEnvelope
    connect?: AdministrativePlaceWhereUniqueInput | AdministrativePlaceWhereUniqueInput[]
  }

  export type ArtifactUncheckedCreateNestedManyWithoutPlacesInput = {
    create?: XOR<ArtifactCreateWithoutPlacesInput, ArtifactUncheckedCreateWithoutPlacesInput> | ArtifactCreateWithoutPlacesInput[] | ArtifactUncheckedCreateWithoutPlacesInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutPlacesInput | ArtifactCreateOrConnectWithoutPlacesInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
  }

  export type AdministrativePlaceUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<AdministrativePlaceCreateWithoutPlaceInput, AdministrativePlaceUncheckedCreateWithoutPlaceInput> | AdministrativePlaceCreateWithoutPlaceInput[] | AdministrativePlaceUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: AdministrativePlaceCreateOrConnectWithoutPlaceInput | AdministrativePlaceCreateOrConnectWithoutPlaceInput[]
    upsert?: AdministrativePlaceUpsertWithWhereUniqueWithoutPlaceInput | AdministrativePlaceUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: AdministrativePlaceCreateManyPlaceInputEnvelope
    set?: AdministrativePlaceWhereUniqueInput | AdministrativePlaceWhereUniqueInput[]
    disconnect?: AdministrativePlaceWhereUniqueInput | AdministrativePlaceWhereUniqueInput[]
    delete?: AdministrativePlaceWhereUniqueInput | AdministrativePlaceWhereUniqueInput[]
    connect?: AdministrativePlaceWhereUniqueInput | AdministrativePlaceWhereUniqueInput[]
    update?: AdministrativePlaceUpdateWithWhereUniqueWithoutPlaceInput | AdministrativePlaceUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: AdministrativePlaceUpdateManyWithWhereWithoutPlaceInput | AdministrativePlaceUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: AdministrativePlaceScalarWhereInput | AdministrativePlaceScalarWhereInput[]
  }

  export type ArtifactUpdateManyWithoutPlacesNestedInput = {
    create?: XOR<ArtifactCreateWithoutPlacesInput, ArtifactUncheckedCreateWithoutPlacesInput> | ArtifactCreateWithoutPlacesInput[] | ArtifactUncheckedCreateWithoutPlacesInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutPlacesInput | ArtifactCreateOrConnectWithoutPlacesInput[]
    upsert?: ArtifactUpsertWithWhereUniqueWithoutPlacesInput | ArtifactUpsertWithWhereUniqueWithoutPlacesInput[]
    set?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    disconnect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    delete?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    update?: ArtifactUpdateWithWhereUniqueWithoutPlacesInput | ArtifactUpdateWithWhereUniqueWithoutPlacesInput[]
    updateMany?: ArtifactUpdateManyWithWhereWithoutPlacesInput | ArtifactUpdateManyWithWhereWithoutPlacesInput[]
    deleteMany?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
  }

  export type AdministrativePlaceUncheckedUpdateManyWithoutPlaceNestedInput = {
    create?: XOR<AdministrativePlaceCreateWithoutPlaceInput, AdministrativePlaceUncheckedCreateWithoutPlaceInput> | AdministrativePlaceCreateWithoutPlaceInput[] | AdministrativePlaceUncheckedCreateWithoutPlaceInput[]
    connectOrCreate?: AdministrativePlaceCreateOrConnectWithoutPlaceInput | AdministrativePlaceCreateOrConnectWithoutPlaceInput[]
    upsert?: AdministrativePlaceUpsertWithWhereUniqueWithoutPlaceInput | AdministrativePlaceUpsertWithWhereUniqueWithoutPlaceInput[]
    createMany?: AdministrativePlaceCreateManyPlaceInputEnvelope
    set?: AdministrativePlaceWhereUniqueInput | AdministrativePlaceWhereUniqueInput[]
    disconnect?: AdministrativePlaceWhereUniqueInput | AdministrativePlaceWhereUniqueInput[]
    delete?: AdministrativePlaceWhereUniqueInput | AdministrativePlaceWhereUniqueInput[]
    connect?: AdministrativePlaceWhereUniqueInput | AdministrativePlaceWhereUniqueInput[]
    update?: AdministrativePlaceUpdateWithWhereUniqueWithoutPlaceInput | AdministrativePlaceUpdateWithWhereUniqueWithoutPlaceInput[]
    updateMany?: AdministrativePlaceUpdateManyWithWhereWithoutPlaceInput | AdministrativePlaceUpdateManyWithWhereWithoutPlaceInput[]
    deleteMany?: AdministrativePlaceScalarWhereInput | AdministrativePlaceScalarWhereInput[]
  }

  export type ArtifactUncheckedUpdateManyWithoutPlacesNestedInput = {
    create?: XOR<ArtifactCreateWithoutPlacesInput, ArtifactUncheckedCreateWithoutPlacesInput> | ArtifactCreateWithoutPlacesInput[] | ArtifactUncheckedCreateWithoutPlacesInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutPlacesInput | ArtifactCreateOrConnectWithoutPlacesInput[]
    upsert?: ArtifactUpsertWithWhereUniqueWithoutPlacesInput | ArtifactUpsertWithWhereUniqueWithoutPlacesInput[]
    set?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    disconnect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    delete?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    update?: ArtifactUpdateWithWhereUniqueWithoutPlacesInput | ArtifactUpdateWithWhereUniqueWithoutPlacesInput[]
    updateMany?: ArtifactUpdateManyWithWhereWithoutPlacesInput | ArtifactUpdateManyWithWhereWithoutPlacesInput[]
    deleteMany?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
  }

  export type PlaceCreateNestedOneWithoutAdministrativePlacesInput = {
    create?: XOR<PlaceCreateWithoutAdministrativePlacesInput, PlaceUncheckedCreateWithoutAdministrativePlacesInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutAdministrativePlacesInput
    connect?: PlaceWhereUniqueInput
  }

  export type PlaceUpdateOneWithoutAdministrativePlacesNestedInput = {
    create?: XOR<PlaceCreateWithoutAdministrativePlacesInput, PlaceUncheckedCreateWithoutAdministrativePlacesInput>
    connectOrCreate?: PlaceCreateOrConnectWithoutAdministrativePlacesInput
    upsert?: PlaceUpsertWithoutAdministrativePlacesInput
    disconnect?: PlaceWhereInput | boolean
    delete?: PlaceWhereInput | boolean
    connect?: PlaceWhereUniqueInput
    update?: XOR<XOR<PlaceUpdateToOneWithWhereWithoutAdministrativePlacesInput, PlaceUpdateWithoutAdministrativePlacesInput>, PlaceUncheckedUpdateWithoutAdministrativePlacesInput>
  }

  export type PostTagCreateNestedManyWithoutTagInput = {
    create?: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput> | PostTagCreateWithoutTagInput[] | PostTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutTagInput | PostTagCreateOrConnectWithoutTagInput[]
    createMany?: PostTagCreateManyTagInputEnvelope
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
  }

  export type ArtifactCreateNestedManyWithoutTagsInput = {
    create?: XOR<ArtifactCreateWithoutTagsInput, ArtifactUncheckedCreateWithoutTagsInput> | ArtifactCreateWithoutTagsInput[] | ArtifactUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutTagsInput | ArtifactCreateOrConnectWithoutTagsInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
  }

  export type CollectionCreateNestedManyWithoutTagsInput = {
    create?: XOR<CollectionCreateWithoutTagsInput, CollectionUncheckedCreateWithoutTagsInput> | CollectionCreateWithoutTagsInput[] | CollectionUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutTagsInput | CollectionCreateOrConnectWithoutTagsInput[]
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
  }

  export type LayerCreateNestedManyWithoutTagsInput = {
    create?: XOR<LayerCreateWithoutTagsInput, LayerUncheckedCreateWithoutTagsInput> | LayerCreateWithoutTagsInput[] | LayerUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: LayerCreateOrConnectWithoutTagsInput | LayerCreateOrConnectWithoutTagsInput[]
    connect?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
  }

  export type MapCreateNestedManyWithoutTagsInput = {
    create?: XOR<MapCreateWithoutTagsInput, MapUncheckedCreateWithoutTagsInput> | MapCreateWithoutTagsInput[] | MapUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: MapCreateOrConnectWithoutTagsInput | MapCreateOrConnectWithoutTagsInput[]
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
  }

  export type PageCreateNestedManyWithoutTagsInput = {
    create?: XOR<PageCreateWithoutTagsInput, PageUncheckedCreateWithoutTagsInput> | PageCreateWithoutTagsInput[] | PageUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PageCreateOrConnectWithoutTagsInput | PageCreateOrConnectWithoutTagsInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type SeriesCreateNestedManyWithoutTagsInput = {
    create?: XOR<SeriesCreateWithoutTagsInput, SeriesUncheckedCreateWithoutTagsInput> | SeriesCreateWithoutTagsInput[] | SeriesUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutTagsInput | SeriesCreateOrConnectWithoutTagsInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
  }

  export type PostTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput> | PostTagCreateWithoutTagInput[] | PostTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutTagInput | PostTagCreateOrConnectWithoutTagInput[]
    createMany?: PostTagCreateManyTagInputEnvelope
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
  }

  export type ArtifactUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<ArtifactCreateWithoutTagsInput, ArtifactUncheckedCreateWithoutTagsInput> | ArtifactCreateWithoutTagsInput[] | ArtifactUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutTagsInput | ArtifactCreateOrConnectWithoutTagsInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
  }

  export type CollectionUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<CollectionCreateWithoutTagsInput, CollectionUncheckedCreateWithoutTagsInput> | CollectionCreateWithoutTagsInput[] | CollectionUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutTagsInput | CollectionCreateOrConnectWithoutTagsInput[]
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
  }

  export type LayerUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<LayerCreateWithoutTagsInput, LayerUncheckedCreateWithoutTagsInput> | LayerCreateWithoutTagsInput[] | LayerUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: LayerCreateOrConnectWithoutTagsInput | LayerCreateOrConnectWithoutTagsInput[]
    connect?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
  }

  export type MapUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<MapCreateWithoutTagsInput, MapUncheckedCreateWithoutTagsInput> | MapCreateWithoutTagsInput[] | MapUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: MapCreateOrConnectWithoutTagsInput | MapCreateOrConnectWithoutTagsInput[]
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
  }

  export type PageUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<PageCreateWithoutTagsInput, PageUncheckedCreateWithoutTagsInput> | PageCreateWithoutTagsInput[] | PageUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PageCreateOrConnectWithoutTagsInput | PageCreateOrConnectWithoutTagsInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type SeriesUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<SeriesCreateWithoutTagsInput, SeriesUncheckedCreateWithoutTagsInput> | SeriesCreateWithoutTagsInput[] | SeriesUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutTagsInput | SeriesCreateOrConnectWithoutTagsInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
  }

  export type PostTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput> | PostTagCreateWithoutTagInput[] | PostTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutTagInput | PostTagCreateOrConnectWithoutTagInput[]
    upsert?: PostTagUpsertWithWhereUniqueWithoutTagInput | PostTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: PostTagCreateManyTagInputEnvelope
    set?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    disconnect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    delete?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    update?: PostTagUpdateWithWhereUniqueWithoutTagInput | PostTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: PostTagUpdateManyWithWhereWithoutTagInput | PostTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
  }

  export type ArtifactUpdateManyWithoutTagsNestedInput = {
    create?: XOR<ArtifactCreateWithoutTagsInput, ArtifactUncheckedCreateWithoutTagsInput> | ArtifactCreateWithoutTagsInput[] | ArtifactUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutTagsInput | ArtifactCreateOrConnectWithoutTagsInput[]
    upsert?: ArtifactUpsertWithWhereUniqueWithoutTagsInput | ArtifactUpsertWithWhereUniqueWithoutTagsInput[]
    set?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    disconnect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    delete?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    update?: ArtifactUpdateWithWhereUniqueWithoutTagsInput | ArtifactUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: ArtifactUpdateManyWithWhereWithoutTagsInput | ArtifactUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
  }

  export type CollectionUpdateManyWithoutTagsNestedInput = {
    create?: XOR<CollectionCreateWithoutTagsInput, CollectionUncheckedCreateWithoutTagsInput> | CollectionCreateWithoutTagsInput[] | CollectionUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutTagsInput | CollectionCreateOrConnectWithoutTagsInput[]
    upsert?: CollectionUpsertWithWhereUniqueWithoutTagsInput | CollectionUpsertWithWhereUniqueWithoutTagsInput[]
    set?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    disconnect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    delete?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    update?: CollectionUpdateWithWhereUniqueWithoutTagsInput | CollectionUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: CollectionUpdateManyWithWhereWithoutTagsInput | CollectionUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: CollectionScalarWhereInput | CollectionScalarWhereInput[]
  }

  export type LayerUpdateManyWithoutTagsNestedInput = {
    create?: XOR<LayerCreateWithoutTagsInput, LayerUncheckedCreateWithoutTagsInput> | LayerCreateWithoutTagsInput[] | LayerUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: LayerCreateOrConnectWithoutTagsInput | LayerCreateOrConnectWithoutTagsInput[]
    upsert?: LayerUpsertWithWhereUniqueWithoutTagsInput | LayerUpsertWithWhereUniqueWithoutTagsInput[]
    set?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    disconnect?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    delete?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    connect?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    update?: LayerUpdateWithWhereUniqueWithoutTagsInput | LayerUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: LayerUpdateManyWithWhereWithoutTagsInput | LayerUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: LayerScalarWhereInput | LayerScalarWhereInput[]
  }

  export type MapUpdateManyWithoutTagsNestedInput = {
    create?: XOR<MapCreateWithoutTagsInput, MapUncheckedCreateWithoutTagsInput> | MapCreateWithoutTagsInput[] | MapUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: MapCreateOrConnectWithoutTagsInput | MapCreateOrConnectWithoutTagsInput[]
    upsert?: MapUpsertWithWhereUniqueWithoutTagsInput | MapUpsertWithWhereUniqueWithoutTagsInput[]
    set?: MapWhereUniqueInput | MapWhereUniqueInput[]
    disconnect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    delete?: MapWhereUniqueInput | MapWhereUniqueInput[]
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    update?: MapUpdateWithWhereUniqueWithoutTagsInput | MapUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: MapUpdateManyWithWhereWithoutTagsInput | MapUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: MapScalarWhereInput | MapScalarWhereInput[]
  }

  export type PageUpdateManyWithoutTagsNestedInput = {
    create?: XOR<PageCreateWithoutTagsInput, PageUncheckedCreateWithoutTagsInput> | PageCreateWithoutTagsInput[] | PageUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PageCreateOrConnectWithoutTagsInput | PageCreateOrConnectWithoutTagsInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutTagsInput | PageUpsertWithWhereUniqueWithoutTagsInput[]
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutTagsInput | PageUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: PageUpdateManyWithWhereWithoutTagsInput | PageUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type SeriesUpdateManyWithoutTagsNestedInput = {
    create?: XOR<SeriesCreateWithoutTagsInput, SeriesUncheckedCreateWithoutTagsInput> | SeriesCreateWithoutTagsInput[] | SeriesUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutTagsInput | SeriesCreateOrConnectWithoutTagsInput[]
    upsert?: SeriesUpsertWithWhereUniqueWithoutTagsInput | SeriesUpsertWithWhereUniqueWithoutTagsInput[]
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    update?: SeriesUpdateWithWhereUniqueWithoutTagsInput | SeriesUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: SeriesUpdateManyWithWhereWithoutTagsInput | SeriesUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
  }

  export type PostTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput> | PostTagCreateWithoutTagInput[] | PostTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutTagInput | PostTagCreateOrConnectWithoutTagInput[]
    upsert?: PostTagUpsertWithWhereUniqueWithoutTagInput | PostTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: PostTagCreateManyTagInputEnvelope
    set?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    disconnect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    delete?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    update?: PostTagUpdateWithWhereUniqueWithoutTagInput | PostTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: PostTagUpdateManyWithWhereWithoutTagInput | PostTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
  }

  export type ArtifactUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<ArtifactCreateWithoutTagsInput, ArtifactUncheckedCreateWithoutTagsInput> | ArtifactCreateWithoutTagsInput[] | ArtifactUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutTagsInput | ArtifactCreateOrConnectWithoutTagsInput[]
    upsert?: ArtifactUpsertWithWhereUniqueWithoutTagsInput | ArtifactUpsertWithWhereUniqueWithoutTagsInput[]
    set?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    disconnect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    delete?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    update?: ArtifactUpdateWithWhereUniqueWithoutTagsInput | ArtifactUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: ArtifactUpdateManyWithWhereWithoutTagsInput | ArtifactUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
  }

  export type CollectionUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<CollectionCreateWithoutTagsInput, CollectionUncheckedCreateWithoutTagsInput> | CollectionCreateWithoutTagsInput[] | CollectionUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutTagsInput | CollectionCreateOrConnectWithoutTagsInput[]
    upsert?: CollectionUpsertWithWhereUniqueWithoutTagsInput | CollectionUpsertWithWhereUniqueWithoutTagsInput[]
    set?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    disconnect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    delete?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    update?: CollectionUpdateWithWhereUniqueWithoutTagsInput | CollectionUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: CollectionUpdateManyWithWhereWithoutTagsInput | CollectionUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: CollectionScalarWhereInput | CollectionScalarWhereInput[]
  }

  export type LayerUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<LayerCreateWithoutTagsInput, LayerUncheckedCreateWithoutTagsInput> | LayerCreateWithoutTagsInput[] | LayerUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: LayerCreateOrConnectWithoutTagsInput | LayerCreateOrConnectWithoutTagsInput[]
    upsert?: LayerUpsertWithWhereUniqueWithoutTagsInput | LayerUpsertWithWhereUniqueWithoutTagsInput[]
    set?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    disconnect?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    delete?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    connect?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    update?: LayerUpdateWithWhereUniqueWithoutTagsInput | LayerUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: LayerUpdateManyWithWhereWithoutTagsInput | LayerUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: LayerScalarWhereInput | LayerScalarWhereInput[]
  }

  export type MapUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<MapCreateWithoutTagsInput, MapUncheckedCreateWithoutTagsInput> | MapCreateWithoutTagsInput[] | MapUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: MapCreateOrConnectWithoutTagsInput | MapCreateOrConnectWithoutTagsInput[]
    upsert?: MapUpsertWithWhereUniqueWithoutTagsInput | MapUpsertWithWhereUniqueWithoutTagsInput[]
    set?: MapWhereUniqueInput | MapWhereUniqueInput[]
    disconnect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    delete?: MapWhereUniqueInput | MapWhereUniqueInput[]
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    update?: MapUpdateWithWhereUniqueWithoutTagsInput | MapUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: MapUpdateManyWithWhereWithoutTagsInput | MapUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: MapScalarWhereInput | MapScalarWhereInput[]
  }

  export type PageUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<PageCreateWithoutTagsInput, PageUncheckedCreateWithoutTagsInput> | PageCreateWithoutTagsInput[] | PageUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PageCreateOrConnectWithoutTagsInput | PageCreateOrConnectWithoutTagsInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutTagsInput | PageUpsertWithWhereUniqueWithoutTagsInput[]
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutTagsInput | PageUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: PageUpdateManyWithWhereWithoutTagsInput | PageUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type SeriesUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<SeriesCreateWithoutTagsInput, SeriesUncheckedCreateWithoutTagsInput> | SeriesCreateWithoutTagsInput[] | SeriesUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutTagsInput | SeriesCreateOrConnectWithoutTagsInput[]
    upsert?: SeriesUpsertWithWhereUniqueWithoutTagsInput | SeriesUpsertWithWhereUniqueWithoutTagsInput[]
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    update?: SeriesUpdateWithWhereUniqueWithoutTagsInput | SeriesUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: SeriesUpdateManyWithWhereWithoutTagsInput | SeriesUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
  }

  export type ArtifactCreateNestedManyWithoutRegionsInput = {
    create?: XOR<ArtifactCreateWithoutRegionsInput, ArtifactUncheckedCreateWithoutRegionsInput> | ArtifactCreateWithoutRegionsInput[] | ArtifactUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutRegionsInput | ArtifactCreateOrConnectWithoutRegionsInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
  }

  export type CollectionCreateNestedManyWithoutRegionsInput = {
    create?: XOR<CollectionCreateWithoutRegionsInput, CollectionUncheckedCreateWithoutRegionsInput> | CollectionCreateWithoutRegionsInput[] | CollectionUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutRegionsInput | CollectionCreateOrConnectWithoutRegionsInput[]
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
  }

  export type LayerCreateNestedManyWithoutRegionsInput = {
    create?: XOR<LayerCreateWithoutRegionsInput, LayerUncheckedCreateWithoutRegionsInput> | LayerCreateWithoutRegionsInput[] | LayerUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: LayerCreateOrConnectWithoutRegionsInput | LayerCreateOrConnectWithoutRegionsInput[]
    connect?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
  }

  export type MapCreateNestedManyWithoutRegionsInput = {
    create?: XOR<MapCreateWithoutRegionsInput, MapUncheckedCreateWithoutRegionsInput> | MapCreateWithoutRegionsInput[] | MapUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: MapCreateOrConnectWithoutRegionsInput | MapCreateOrConnectWithoutRegionsInput[]
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
  }

  export type PageCreateNestedManyWithoutRegionsInput = {
    create?: XOR<PageCreateWithoutRegionsInput, PageUncheckedCreateWithoutRegionsInput> | PageCreateWithoutRegionsInput[] | PageUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: PageCreateOrConnectWithoutRegionsInput | PageCreateOrConnectWithoutRegionsInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutRegionsInput = {
    create?: XOR<PostCreateWithoutRegionsInput, PostUncheckedCreateWithoutRegionsInput> | PostCreateWithoutRegionsInput[] | PostUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutRegionsInput | PostCreateOrConnectWithoutRegionsInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type ResearchDatasetCreateNestedManyWithoutRegionsInput = {
    create?: XOR<ResearchDatasetCreateWithoutRegionsInput, ResearchDatasetUncheckedCreateWithoutRegionsInput> | ResearchDatasetCreateWithoutRegionsInput[] | ResearchDatasetUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: ResearchDatasetCreateOrConnectWithoutRegionsInput | ResearchDatasetCreateOrConnectWithoutRegionsInput[]
    connect?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
  }

  export type SeriesCreateNestedManyWithoutRegionsInput = {
    create?: XOR<SeriesCreateWithoutRegionsInput, SeriesUncheckedCreateWithoutRegionsInput> | SeriesCreateWithoutRegionsInput[] | SeriesUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutRegionsInput | SeriesCreateOrConnectWithoutRegionsInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
  }

  export type VolumeCreateNestedManyWithoutRegionsInput = {
    create?: XOR<VolumeCreateWithoutRegionsInput, VolumeUncheckedCreateWithoutRegionsInput> | VolumeCreateWithoutRegionsInput[] | VolumeUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: VolumeCreateOrConnectWithoutRegionsInput | VolumeCreateOrConnectWithoutRegionsInput[]
    connect?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
  }

  export type ArtifactUncheckedCreateNestedManyWithoutRegionsInput = {
    create?: XOR<ArtifactCreateWithoutRegionsInput, ArtifactUncheckedCreateWithoutRegionsInput> | ArtifactCreateWithoutRegionsInput[] | ArtifactUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutRegionsInput | ArtifactCreateOrConnectWithoutRegionsInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
  }

  export type CollectionUncheckedCreateNestedManyWithoutRegionsInput = {
    create?: XOR<CollectionCreateWithoutRegionsInput, CollectionUncheckedCreateWithoutRegionsInput> | CollectionCreateWithoutRegionsInput[] | CollectionUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutRegionsInput | CollectionCreateOrConnectWithoutRegionsInput[]
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
  }

  export type LayerUncheckedCreateNestedManyWithoutRegionsInput = {
    create?: XOR<LayerCreateWithoutRegionsInput, LayerUncheckedCreateWithoutRegionsInput> | LayerCreateWithoutRegionsInput[] | LayerUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: LayerCreateOrConnectWithoutRegionsInput | LayerCreateOrConnectWithoutRegionsInput[]
    connect?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
  }

  export type MapUncheckedCreateNestedManyWithoutRegionsInput = {
    create?: XOR<MapCreateWithoutRegionsInput, MapUncheckedCreateWithoutRegionsInput> | MapCreateWithoutRegionsInput[] | MapUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: MapCreateOrConnectWithoutRegionsInput | MapCreateOrConnectWithoutRegionsInput[]
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
  }

  export type PageUncheckedCreateNestedManyWithoutRegionsInput = {
    create?: XOR<PageCreateWithoutRegionsInput, PageUncheckedCreateWithoutRegionsInput> | PageCreateWithoutRegionsInput[] | PageUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: PageCreateOrConnectWithoutRegionsInput | PageCreateOrConnectWithoutRegionsInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutRegionsInput = {
    create?: XOR<PostCreateWithoutRegionsInput, PostUncheckedCreateWithoutRegionsInput> | PostCreateWithoutRegionsInput[] | PostUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutRegionsInput | PostCreateOrConnectWithoutRegionsInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type ResearchDatasetUncheckedCreateNestedManyWithoutRegionsInput = {
    create?: XOR<ResearchDatasetCreateWithoutRegionsInput, ResearchDatasetUncheckedCreateWithoutRegionsInput> | ResearchDatasetCreateWithoutRegionsInput[] | ResearchDatasetUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: ResearchDatasetCreateOrConnectWithoutRegionsInput | ResearchDatasetCreateOrConnectWithoutRegionsInput[]
    connect?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
  }

  export type SeriesUncheckedCreateNestedManyWithoutRegionsInput = {
    create?: XOR<SeriesCreateWithoutRegionsInput, SeriesUncheckedCreateWithoutRegionsInput> | SeriesCreateWithoutRegionsInput[] | SeriesUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutRegionsInput | SeriesCreateOrConnectWithoutRegionsInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
  }

  export type VolumeUncheckedCreateNestedManyWithoutRegionsInput = {
    create?: XOR<VolumeCreateWithoutRegionsInput, VolumeUncheckedCreateWithoutRegionsInput> | VolumeCreateWithoutRegionsInput[] | VolumeUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: VolumeCreateOrConnectWithoutRegionsInput | VolumeCreateOrConnectWithoutRegionsInput[]
    connect?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
  }

  export type ArtifactUpdateManyWithoutRegionsNestedInput = {
    create?: XOR<ArtifactCreateWithoutRegionsInput, ArtifactUncheckedCreateWithoutRegionsInput> | ArtifactCreateWithoutRegionsInput[] | ArtifactUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutRegionsInput | ArtifactCreateOrConnectWithoutRegionsInput[]
    upsert?: ArtifactUpsertWithWhereUniqueWithoutRegionsInput | ArtifactUpsertWithWhereUniqueWithoutRegionsInput[]
    set?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    disconnect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    delete?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    update?: ArtifactUpdateWithWhereUniqueWithoutRegionsInput | ArtifactUpdateWithWhereUniqueWithoutRegionsInput[]
    updateMany?: ArtifactUpdateManyWithWhereWithoutRegionsInput | ArtifactUpdateManyWithWhereWithoutRegionsInput[]
    deleteMany?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
  }

  export type CollectionUpdateManyWithoutRegionsNestedInput = {
    create?: XOR<CollectionCreateWithoutRegionsInput, CollectionUncheckedCreateWithoutRegionsInput> | CollectionCreateWithoutRegionsInput[] | CollectionUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutRegionsInput | CollectionCreateOrConnectWithoutRegionsInput[]
    upsert?: CollectionUpsertWithWhereUniqueWithoutRegionsInput | CollectionUpsertWithWhereUniqueWithoutRegionsInput[]
    set?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    disconnect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    delete?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    update?: CollectionUpdateWithWhereUniqueWithoutRegionsInput | CollectionUpdateWithWhereUniqueWithoutRegionsInput[]
    updateMany?: CollectionUpdateManyWithWhereWithoutRegionsInput | CollectionUpdateManyWithWhereWithoutRegionsInput[]
    deleteMany?: CollectionScalarWhereInput | CollectionScalarWhereInput[]
  }

  export type LayerUpdateManyWithoutRegionsNestedInput = {
    create?: XOR<LayerCreateWithoutRegionsInput, LayerUncheckedCreateWithoutRegionsInput> | LayerCreateWithoutRegionsInput[] | LayerUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: LayerCreateOrConnectWithoutRegionsInput | LayerCreateOrConnectWithoutRegionsInput[]
    upsert?: LayerUpsertWithWhereUniqueWithoutRegionsInput | LayerUpsertWithWhereUniqueWithoutRegionsInput[]
    set?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    disconnect?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    delete?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    connect?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    update?: LayerUpdateWithWhereUniqueWithoutRegionsInput | LayerUpdateWithWhereUniqueWithoutRegionsInput[]
    updateMany?: LayerUpdateManyWithWhereWithoutRegionsInput | LayerUpdateManyWithWhereWithoutRegionsInput[]
    deleteMany?: LayerScalarWhereInput | LayerScalarWhereInput[]
  }

  export type MapUpdateManyWithoutRegionsNestedInput = {
    create?: XOR<MapCreateWithoutRegionsInput, MapUncheckedCreateWithoutRegionsInput> | MapCreateWithoutRegionsInput[] | MapUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: MapCreateOrConnectWithoutRegionsInput | MapCreateOrConnectWithoutRegionsInput[]
    upsert?: MapUpsertWithWhereUniqueWithoutRegionsInput | MapUpsertWithWhereUniqueWithoutRegionsInput[]
    set?: MapWhereUniqueInput | MapWhereUniqueInput[]
    disconnect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    delete?: MapWhereUniqueInput | MapWhereUniqueInput[]
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    update?: MapUpdateWithWhereUniqueWithoutRegionsInput | MapUpdateWithWhereUniqueWithoutRegionsInput[]
    updateMany?: MapUpdateManyWithWhereWithoutRegionsInput | MapUpdateManyWithWhereWithoutRegionsInput[]
    deleteMany?: MapScalarWhereInput | MapScalarWhereInput[]
  }

  export type PageUpdateManyWithoutRegionsNestedInput = {
    create?: XOR<PageCreateWithoutRegionsInput, PageUncheckedCreateWithoutRegionsInput> | PageCreateWithoutRegionsInput[] | PageUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: PageCreateOrConnectWithoutRegionsInput | PageCreateOrConnectWithoutRegionsInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutRegionsInput | PageUpsertWithWhereUniqueWithoutRegionsInput[]
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutRegionsInput | PageUpdateWithWhereUniqueWithoutRegionsInput[]
    updateMany?: PageUpdateManyWithWhereWithoutRegionsInput | PageUpdateManyWithWhereWithoutRegionsInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type PostUpdateManyWithoutRegionsNestedInput = {
    create?: XOR<PostCreateWithoutRegionsInput, PostUncheckedCreateWithoutRegionsInput> | PostCreateWithoutRegionsInput[] | PostUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutRegionsInput | PostCreateOrConnectWithoutRegionsInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutRegionsInput | PostUpsertWithWhereUniqueWithoutRegionsInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutRegionsInput | PostUpdateWithWhereUniqueWithoutRegionsInput[]
    updateMany?: PostUpdateManyWithWhereWithoutRegionsInput | PostUpdateManyWithWhereWithoutRegionsInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type ResearchDatasetUpdateManyWithoutRegionsNestedInput = {
    create?: XOR<ResearchDatasetCreateWithoutRegionsInput, ResearchDatasetUncheckedCreateWithoutRegionsInput> | ResearchDatasetCreateWithoutRegionsInput[] | ResearchDatasetUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: ResearchDatasetCreateOrConnectWithoutRegionsInput | ResearchDatasetCreateOrConnectWithoutRegionsInput[]
    upsert?: ResearchDatasetUpsertWithWhereUniqueWithoutRegionsInput | ResearchDatasetUpsertWithWhereUniqueWithoutRegionsInput[]
    set?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    disconnect?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    delete?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    connect?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    update?: ResearchDatasetUpdateWithWhereUniqueWithoutRegionsInput | ResearchDatasetUpdateWithWhereUniqueWithoutRegionsInput[]
    updateMany?: ResearchDatasetUpdateManyWithWhereWithoutRegionsInput | ResearchDatasetUpdateManyWithWhereWithoutRegionsInput[]
    deleteMany?: ResearchDatasetScalarWhereInput | ResearchDatasetScalarWhereInput[]
  }

  export type SeriesUpdateManyWithoutRegionsNestedInput = {
    create?: XOR<SeriesCreateWithoutRegionsInput, SeriesUncheckedCreateWithoutRegionsInput> | SeriesCreateWithoutRegionsInput[] | SeriesUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutRegionsInput | SeriesCreateOrConnectWithoutRegionsInput[]
    upsert?: SeriesUpsertWithWhereUniqueWithoutRegionsInput | SeriesUpsertWithWhereUniqueWithoutRegionsInput[]
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    update?: SeriesUpdateWithWhereUniqueWithoutRegionsInput | SeriesUpdateWithWhereUniqueWithoutRegionsInput[]
    updateMany?: SeriesUpdateManyWithWhereWithoutRegionsInput | SeriesUpdateManyWithWhereWithoutRegionsInput[]
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
  }

  export type VolumeUpdateManyWithoutRegionsNestedInput = {
    create?: XOR<VolumeCreateWithoutRegionsInput, VolumeUncheckedCreateWithoutRegionsInput> | VolumeCreateWithoutRegionsInput[] | VolumeUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: VolumeCreateOrConnectWithoutRegionsInput | VolumeCreateOrConnectWithoutRegionsInput[]
    upsert?: VolumeUpsertWithWhereUniqueWithoutRegionsInput | VolumeUpsertWithWhereUniqueWithoutRegionsInput[]
    set?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    disconnect?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    delete?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    connect?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    update?: VolumeUpdateWithWhereUniqueWithoutRegionsInput | VolumeUpdateWithWhereUniqueWithoutRegionsInput[]
    updateMany?: VolumeUpdateManyWithWhereWithoutRegionsInput | VolumeUpdateManyWithWhereWithoutRegionsInput[]
    deleteMany?: VolumeScalarWhereInput | VolumeScalarWhereInput[]
  }

  export type ArtifactUncheckedUpdateManyWithoutRegionsNestedInput = {
    create?: XOR<ArtifactCreateWithoutRegionsInput, ArtifactUncheckedCreateWithoutRegionsInput> | ArtifactCreateWithoutRegionsInput[] | ArtifactUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutRegionsInput | ArtifactCreateOrConnectWithoutRegionsInput[]
    upsert?: ArtifactUpsertWithWhereUniqueWithoutRegionsInput | ArtifactUpsertWithWhereUniqueWithoutRegionsInput[]
    set?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    disconnect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    delete?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    update?: ArtifactUpdateWithWhereUniqueWithoutRegionsInput | ArtifactUpdateWithWhereUniqueWithoutRegionsInput[]
    updateMany?: ArtifactUpdateManyWithWhereWithoutRegionsInput | ArtifactUpdateManyWithWhereWithoutRegionsInput[]
    deleteMany?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
  }

  export type CollectionUncheckedUpdateManyWithoutRegionsNestedInput = {
    create?: XOR<CollectionCreateWithoutRegionsInput, CollectionUncheckedCreateWithoutRegionsInput> | CollectionCreateWithoutRegionsInput[] | CollectionUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: CollectionCreateOrConnectWithoutRegionsInput | CollectionCreateOrConnectWithoutRegionsInput[]
    upsert?: CollectionUpsertWithWhereUniqueWithoutRegionsInput | CollectionUpsertWithWhereUniqueWithoutRegionsInput[]
    set?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    disconnect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    delete?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    connect?: CollectionWhereUniqueInput | CollectionWhereUniqueInput[]
    update?: CollectionUpdateWithWhereUniqueWithoutRegionsInput | CollectionUpdateWithWhereUniqueWithoutRegionsInput[]
    updateMany?: CollectionUpdateManyWithWhereWithoutRegionsInput | CollectionUpdateManyWithWhereWithoutRegionsInput[]
    deleteMany?: CollectionScalarWhereInput | CollectionScalarWhereInput[]
  }

  export type LayerUncheckedUpdateManyWithoutRegionsNestedInput = {
    create?: XOR<LayerCreateWithoutRegionsInput, LayerUncheckedCreateWithoutRegionsInput> | LayerCreateWithoutRegionsInput[] | LayerUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: LayerCreateOrConnectWithoutRegionsInput | LayerCreateOrConnectWithoutRegionsInput[]
    upsert?: LayerUpsertWithWhereUniqueWithoutRegionsInput | LayerUpsertWithWhereUniqueWithoutRegionsInput[]
    set?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    disconnect?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    delete?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    connect?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    update?: LayerUpdateWithWhereUniqueWithoutRegionsInput | LayerUpdateWithWhereUniqueWithoutRegionsInput[]
    updateMany?: LayerUpdateManyWithWhereWithoutRegionsInput | LayerUpdateManyWithWhereWithoutRegionsInput[]
    deleteMany?: LayerScalarWhereInput | LayerScalarWhereInput[]
  }

  export type MapUncheckedUpdateManyWithoutRegionsNestedInput = {
    create?: XOR<MapCreateWithoutRegionsInput, MapUncheckedCreateWithoutRegionsInput> | MapCreateWithoutRegionsInput[] | MapUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: MapCreateOrConnectWithoutRegionsInput | MapCreateOrConnectWithoutRegionsInput[]
    upsert?: MapUpsertWithWhereUniqueWithoutRegionsInput | MapUpsertWithWhereUniqueWithoutRegionsInput[]
    set?: MapWhereUniqueInput | MapWhereUniqueInput[]
    disconnect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    delete?: MapWhereUniqueInput | MapWhereUniqueInput[]
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    update?: MapUpdateWithWhereUniqueWithoutRegionsInput | MapUpdateWithWhereUniqueWithoutRegionsInput[]
    updateMany?: MapUpdateManyWithWhereWithoutRegionsInput | MapUpdateManyWithWhereWithoutRegionsInput[]
    deleteMany?: MapScalarWhereInput | MapScalarWhereInput[]
  }

  export type PageUncheckedUpdateManyWithoutRegionsNestedInput = {
    create?: XOR<PageCreateWithoutRegionsInput, PageUncheckedCreateWithoutRegionsInput> | PageCreateWithoutRegionsInput[] | PageUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: PageCreateOrConnectWithoutRegionsInput | PageCreateOrConnectWithoutRegionsInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutRegionsInput | PageUpsertWithWhereUniqueWithoutRegionsInput[]
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutRegionsInput | PageUpdateWithWhereUniqueWithoutRegionsInput[]
    updateMany?: PageUpdateManyWithWhereWithoutRegionsInput | PageUpdateManyWithWhereWithoutRegionsInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutRegionsNestedInput = {
    create?: XOR<PostCreateWithoutRegionsInput, PostUncheckedCreateWithoutRegionsInput> | PostCreateWithoutRegionsInput[] | PostUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutRegionsInput | PostCreateOrConnectWithoutRegionsInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutRegionsInput | PostUpsertWithWhereUniqueWithoutRegionsInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutRegionsInput | PostUpdateWithWhereUniqueWithoutRegionsInput[]
    updateMany?: PostUpdateManyWithWhereWithoutRegionsInput | PostUpdateManyWithWhereWithoutRegionsInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type ResearchDatasetUncheckedUpdateManyWithoutRegionsNestedInput = {
    create?: XOR<ResearchDatasetCreateWithoutRegionsInput, ResearchDatasetUncheckedCreateWithoutRegionsInput> | ResearchDatasetCreateWithoutRegionsInput[] | ResearchDatasetUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: ResearchDatasetCreateOrConnectWithoutRegionsInput | ResearchDatasetCreateOrConnectWithoutRegionsInput[]
    upsert?: ResearchDatasetUpsertWithWhereUniqueWithoutRegionsInput | ResearchDatasetUpsertWithWhereUniqueWithoutRegionsInput[]
    set?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    disconnect?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    delete?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    connect?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    update?: ResearchDatasetUpdateWithWhereUniqueWithoutRegionsInput | ResearchDatasetUpdateWithWhereUniqueWithoutRegionsInput[]
    updateMany?: ResearchDatasetUpdateManyWithWhereWithoutRegionsInput | ResearchDatasetUpdateManyWithWhereWithoutRegionsInput[]
    deleteMany?: ResearchDatasetScalarWhereInput | ResearchDatasetScalarWhereInput[]
  }

  export type SeriesUncheckedUpdateManyWithoutRegionsNestedInput = {
    create?: XOR<SeriesCreateWithoutRegionsInput, SeriesUncheckedCreateWithoutRegionsInput> | SeriesCreateWithoutRegionsInput[] | SeriesUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutRegionsInput | SeriesCreateOrConnectWithoutRegionsInput[]
    upsert?: SeriesUpsertWithWhereUniqueWithoutRegionsInput | SeriesUpsertWithWhereUniqueWithoutRegionsInput[]
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    update?: SeriesUpdateWithWhereUniqueWithoutRegionsInput | SeriesUpdateWithWhereUniqueWithoutRegionsInput[]
    updateMany?: SeriesUpdateManyWithWhereWithoutRegionsInput | SeriesUpdateManyWithWhereWithoutRegionsInput[]
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
  }

  export type VolumeUncheckedUpdateManyWithoutRegionsNestedInput = {
    create?: XOR<VolumeCreateWithoutRegionsInput, VolumeUncheckedCreateWithoutRegionsInput> | VolumeCreateWithoutRegionsInput[] | VolumeUncheckedCreateWithoutRegionsInput[]
    connectOrCreate?: VolumeCreateOrConnectWithoutRegionsInput | VolumeCreateOrConnectWithoutRegionsInput[]
    upsert?: VolumeUpsertWithWhereUniqueWithoutRegionsInput | VolumeUpsertWithWhereUniqueWithoutRegionsInput[]
    set?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    disconnect?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    delete?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    connect?: VolumeWhereUniqueInput | VolumeWhereUniqueInput[]
    update?: VolumeUpdateWithWhereUniqueWithoutRegionsInput | VolumeUpdateWithWhereUniqueWithoutRegionsInput[]
    updateMany?: VolumeUpdateManyWithWhereWithoutRegionsInput | VolumeUpdateManyWithWhereWithoutRegionsInput[]
    deleteMany?: VolumeScalarWhereInput | VolumeScalarWhereInput[]
  }

  export type MediaCreateNestedOneWithoutThumbnailForCategoryInput = {
    create?: XOR<MediaCreateWithoutThumbnailForCategoryInput, MediaUncheckedCreateWithoutThumbnailForCategoryInput>
    connectOrCreate?: MediaCreateOrConnectWithoutThumbnailForCategoryInput
    connect?: MediaWhereUniqueInput
  }

  export type LayerCreateNestedManyWithoutCategoryInput = {
    create?: XOR<LayerCreateWithoutCategoryInput, LayerUncheckedCreateWithoutCategoryInput> | LayerCreateWithoutCategoryInput[] | LayerUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: LayerCreateOrConnectWithoutCategoryInput | LayerCreateOrConnectWithoutCategoryInput[]
    createMany?: LayerCreateManyCategoryInputEnvelope
    connect?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
  }

  export type MapCreateNestedManyWithoutCategoryInput = {
    create?: XOR<MapCreateWithoutCategoryInput, MapUncheckedCreateWithoutCategoryInput> | MapCreateWithoutCategoryInput[] | MapUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: MapCreateOrConnectWithoutCategoryInput | MapCreateOrConnectWithoutCategoryInput[]
    createMany?: MapCreateManyCategoryInputEnvelope
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
  }

  export type ResearchDatasetCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ResearchDatasetCreateWithoutCategoryInput, ResearchDatasetUncheckedCreateWithoutCategoryInput> | ResearchDatasetCreateWithoutCategoryInput[] | ResearchDatasetUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ResearchDatasetCreateOrConnectWithoutCategoryInput | ResearchDatasetCreateOrConnectWithoutCategoryInput[]
    createMany?: ResearchDatasetCreateManyCategoryInputEnvelope
    connect?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<PostCreateWithoutCategoriesInput, PostUncheckedCreateWithoutCategoriesInput> | PostCreateWithoutCategoriesInput[] | PostUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCategoriesInput | PostCreateOrConnectWithoutCategoriesInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type SeriesCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<SeriesCreateWithoutCategoriesInput, SeriesUncheckedCreateWithoutCategoriesInput> | SeriesCreateWithoutCategoriesInput[] | SeriesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutCategoriesInput | SeriesCreateOrConnectWithoutCategoriesInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
  }

  export type LayerUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<LayerCreateWithoutCategoryInput, LayerUncheckedCreateWithoutCategoryInput> | LayerCreateWithoutCategoryInput[] | LayerUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: LayerCreateOrConnectWithoutCategoryInput | LayerCreateOrConnectWithoutCategoryInput[]
    createMany?: LayerCreateManyCategoryInputEnvelope
    connect?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
  }

  export type MapUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<MapCreateWithoutCategoryInput, MapUncheckedCreateWithoutCategoryInput> | MapCreateWithoutCategoryInput[] | MapUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: MapCreateOrConnectWithoutCategoryInput | MapCreateOrConnectWithoutCategoryInput[]
    createMany?: MapCreateManyCategoryInputEnvelope
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
  }

  export type ResearchDatasetUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ResearchDatasetCreateWithoutCategoryInput, ResearchDatasetUncheckedCreateWithoutCategoryInput> | ResearchDatasetCreateWithoutCategoryInput[] | ResearchDatasetUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ResearchDatasetCreateOrConnectWithoutCategoryInput | ResearchDatasetCreateOrConnectWithoutCategoryInput[]
    createMany?: ResearchDatasetCreateManyCategoryInputEnvelope
    connect?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<PostCreateWithoutCategoriesInput, PostUncheckedCreateWithoutCategoriesInput> | PostCreateWithoutCategoriesInput[] | PostUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCategoriesInput | PostCreateOrConnectWithoutCategoriesInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type SeriesUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<SeriesCreateWithoutCategoriesInput, SeriesUncheckedCreateWithoutCategoriesInput> | SeriesCreateWithoutCategoriesInput[] | SeriesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutCategoriesInput | SeriesCreateOrConnectWithoutCategoriesInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
  }

  export type MediaUpdateOneWithoutThumbnailForCategoryNestedInput = {
    create?: XOR<MediaCreateWithoutThumbnailForCategoryInput, MediaUncheckedCreateWithoutThumbnailForCategoryInput>
    connectOrCreate?: MediaCreateOrConnectWithoutThumbnailForCategoryInput
    upsert?: MediaUpsertWithoutThumbnailForCategoryInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutThumbnailForCategoryInput, MediaUpdateWithoutThumbnailForCategoryInput>, MediaUncheckedUpdateWithoutThumbnailForCategoryInput>
  }

  export type LayerUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<LayerCreateWithoutCategoryInput, LayerUncheckedCreateWithoutCategoryInput> | LayerCreateWithoutCategoryInput[] | LayerUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: LayerCreateOrConnectWithoutCategoryInput | LayerCreateOrConnectWithoutCategoryInput[]
    upsert?: LayerUpsertWithWhereUniqueWithoutCategoryInput | LayerUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: LayerCreateManyCategoryInputEnvelope
    set?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    disconnect?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    delete?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    connect?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    update?: LayerUpdateWithWhereUniqueWithoutCategoryInput | LayerUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: LayerUpdateManyWithWhereWithoutCategoryInput | LayerUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: LayerScalarWhereInput | LayerScalarWhereInput[]
  }

  export type MapUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<MapCreateWithoutCategoryInput, MapUncheckedCreateWithoutCategoryInput> | MapCreateWithoutCategoryInput[] | MapUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: MapCreateOrConnectWithoutCategoryInput | MapCreateOrConnectWithoutCategoryInput[]
    upsert?: MapUpsertWithWhereUniqueWithoutCategoryInput | MapUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: MapCreateManyCategoryInputEnvelope
    set?: MapWhereUniqueInput | MapWhereUniqueInput[]
    disconnect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    delete?: MapWhereUniqueInput | MapWhereUniqueInput[]
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    update?: MapUpdateWithWhereUniqueWithoutCategoryInput | MapUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: MapUpdateManyWithWhereWithoutCategoryInput | MapUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: MapScalarWhereInput | MapScalarWhereInput[]
  }

  export type ResearchDatasetUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ResearchDatasetCreateWithoutCategoryInput, ResearchDatasetUncheckedCreateWithoutCategoryInput> | ResearchDatasetCreateWithoutCategoryInput[] | ResearchDatasetUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ResearchDatasetCreateOrConnectWithoutCategoryInput | ResearchDatasetCreateOrConnectWithoutCategoryInput[]
    upsert?: ResearchDatasetUpsertWithWhereUniqueWithoutCategoryInput | ResearchDatasetUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ResearchDatasetCreateManyCategoryInputEnvelope
    set?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    disconnect?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    delete?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    connect?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    update?: ResearchDatasetUpdateWithWhereUniqueWithoutCategoryInput | ResearchDatasetUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ResearchDatasetUpdateManyWithWhereWithoutCategoryInput | ResearchDatasetUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ResearchDatasetScalarWhereInput | ResearchDatasetScalarWhereInput[]
  }

  export type PostUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<PostCreateWithoutCategoriesInput, PostUncheckedCreateWithoutCategoriesInput> | PostCreateWithoutCategoriesInput[] | PostUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCategoriesInput | PostCreateOrConnectWithoutCategoriesInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutCategoriesInput | PostUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutCategoriesInput | PostUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: PostUpdateManyWithWhereWithoutCategoriesInput | PostUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type SeriesUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<SeriesCreateWithoutCategoriesInput, SeriesUncheckedCreateWithoutCategoriesInput> | SeriesCreateWithoutCategoriesInput[] | SeriesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutCategoriesInput | SeriesCreateOrConnectWithoutCategoriesInput[]
    upsert?: SeriesUpsertWithWhereUniqueWithoutCategoriesInput | SeriesUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    update?: SeriesUpdateWithWhereUniqueWithoutCategoriesInput | SeriesUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: SeriesUpdateManyWithWhereWithoutCategoriesInput | SeriesUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
  }

  export type LayerUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<LayerCreateWithoutCategoryInput, LayerUncheckedCreateWithoutCategoryInput> | LayerCreateWithoutCategoryInput[] | LayerUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: LayerCreateOrConnectWithoutCategoryInput | LayerCreateOrConnectWithoutCategoryInput[]
    upsert?: LayerUpsertWithWhereUniqueWithoutCategoryInput | LayerUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: LayerCreateManyCategoryInputEnvelope
    set?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    disconnect?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    delete?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    connect?: LayerWhereUniqueInput | LayerWhereUniqueInput[]
    update?: LayerUpdateWithWhereUniqueWithoutCategoryInput | LayerUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: LayerUpdateManyWithWhereWithoutCategoryInput | LayerUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: LayerScalarWhereInput | LayerScalarWhereInput[]
  }

  export type MapUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<MapCreateWithoutCategoryInput, MapUncheckedCreateWithoutCategoryInput> | MapCreateWithoutCategoryInput[] | MapUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: MapCreateOrConnectWithoutCategoryInput | MapCreateOrConnectWithoutCategoryInput[]
    upsert?: MapUpsertWithWhereUniqueWithoutCategoryInput | MapUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: MapCreateManyCategoryInputEnvelope
    set?: MapWhereUniqueInput | MapWhereUniqueInput[]
    disconnect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    delete?: MapWhereUniqueInput | MapWhereUniqueInput[]
    connect?: MapWhereUniqueInput | MapWhereUniqueInput[]
    update?: MapUpdateWithWhereUniqueWithoutCategoryInput | MapUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: MapUpdateManyWithWhereWithoutCategoryInput | MapUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: MapScalarWhereInput | MapScalarWhereInput[]
  }

  export type ResearchDatasetUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ResearchDatasetCreateWithoutCategoryInput, ResearchDatasetUncheckedCreateWithoutCategoryInput> | ResearchDatasetCreateWithoutCategoryInput[] | ResearchDatasetUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ResearchDatasetCreateOrConnectWithoutCategoryInput | ResearchDatasetCreateOrConnectWithoutCategoryInput[]
    upsert?: ResearchDatasetUpsertWithWhereUniqueWithoutCategoryInput | ResearchDatasetUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ResearchDatasetCreateManyCategoryInputEnvelope
    set?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    disconnect?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    delete?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    connect?: ResearchDatasetWhereUniqueInput | ResearchDatasetWhereUniqueInput[]
    update?: ResearchDatasetUpdateWithWhereUniqueWithoutCategoryInput | ResearchDatasetUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ResearchDatasetUpdateManyWithWhereWithoutCategoryInput | ResearchDatasetUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ResearchDatasetScalarWhereInput | ResearchDatasetScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<PostCreateWithoutCategoriesInput, PostUncheckedCreateWithoutCategoriesInput> | PostCreateWithoutCategoriesInput[] | PostUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: PostCreateOrConnectWithoutCategoriesInput | PostCreateOrConnectWithoutCategoriesInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutCategoriesInput | PostUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutCategoriesInput | PostUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: PostUpdateManyWithWhereWithoutCategoriesInput | PostUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type SeriesUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<SeriesCreateWithoutCategoriesInput, SeriesUncheckedCreateWithoutCategoriesInput> | SeriesCreateWithoutCategoriesInput[] | SeriesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: SeriesCreateOrConnectWithoutCategoriesInput | SeriesCreateOrConnectWithoutCategoriesInput[]
    upsert?: SeriesUpsertWithWhereUniqueWithoutCategoriesInput | SeriesUpsertWithWhereUniqueWithoutCategoriesInput[]
    set?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    disconnect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    delete?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    connect?: SeriesWhereUniqueInput | SeriesWhereUniqueInput[]
    update?: SeriesUpdateWithWhereUniqueWithoutCategoriesInput | SeriesUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: SeriesUpdateManyWithWhereWithoutCategoriesInput | SeriesUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
  }

  export type ArtifactCreateNestedManyWithoutArtifactCategoryInput = {
    create?: XOR<ArtifactCreateWithoutArtifactCategoryInput, ArtifactUncheckedCreateWithoutArtifactCategoryInput> | ArtifactCreateWithoutArtifactCategoryInput[] | ArtifactUncheckedCreateWithoutArtifactCategoryInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutArtifactCategoryInput | ArtifactCreateOrConnectWithoutArtifactCategoryInput[]
    createMany?: ArtifactCreateManyArtifactCategoryInputEnvelope
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
  }

  export type ArtifactUncheckedCreateNestedManyWithoutArtifactCategoryInput = {
    create?: XOR<ArtifactCreateWithoutArtifactCategoryInput, ArtifactUncheckedCreateWithoutArtifactCategoryInput> | ArtifactCreateWithoutArtifactCategoryInput[] | ArtifactUncheckedCreateWithoutArtifactCategoryInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutArtifactCategoryInput | ArtifactCreateOrConnectWithoutArtifactCategoryInput[]
    createMany?: ArtifactCreateManyArtifactCategoryInputEnvelope
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
  }

  export type ArtifactUpdateManyWithoutArtifactCategoryNestedInput = {
    create?: XOR<ArtifactCreateWithoutArtifactCategoryInput, ArtifactUncheckedCreateWithoutArtifactCategoryInput> | ArtifactCreateWithoutArtifactCategoryInput[] | ArtifactUncheckedCreateWithoutArtifactCategoryInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutArtifactCategoryInput | ArtifactCreateOrConnectWithoutArtifactCategoryInput[]
    upsert?: ArtifactUpsertWithWhereUniqueWithoutArtifactCategoryInput | ArtifactUpsertWithWhereUniqueWithoutArtifactCategoryInput[]
    createMany?: ArtifactCreateManyArtifactCategoryInputEnvelope
    set?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    disconnect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    delete?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    update?: ArtifactUpdateWithWhereUniqueWithoutArtifactCategoryInput | ArtifactUpdateWithWhereUniqueWithoutArtifactCategoryInput[]
    updateMany?: ArtifactUpdateManyWithWhereWithoutArtifactCategoryInput | ArtifactUpdateManyWithWhereWithoutArtifactCategoryInput[]
    deleteMany?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
  }

  export type ArtifactUncheckedUpdateManyWithoutArtifactCategoryNestedInput = {
    create?: XOR<ArtifactCreateWithoutArtifactCategoryInput, ArtifactUncheckedCreateWithoutArtifactCategoryInput> | ArtifactCreateWithoutArtifactCategoryInput[] | ArtifactUncheckedCreateWithoutArtifactCategoryInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutArtifactCategoryInput | ArtifactCreateOrConnectWithoutArtifactCategoryInput[]
    upsert?: ArtifactUpsertWithWhereUniqueWithoutArtifactCategoryInput | ArtifactUpsertWithWhereUniqueWithoutArtifactCategoryInput[]
    createMany?: ArtifactCreateManyArtifactCategoryInputEnvelope
    set?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    disconnect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    delete?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    update?: ArtifactUpdateWithWhereUniqueWithoutArtifactCategoryInput | ArtifactUpdateWithWhereUniqueWithoutArtifactCategoryInput[]
    updateMany?: ArtifactUpdateManyWithWhereWithoutArtifactCategoryInput | ArtifactUpdateManyWithWhereWithoutArtifactCategoryInput[]
    deleteMany?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
  }

  export type ArtifactCreateNestedManyWithoutPeriodsInput = {
    create?: XOR<ArtifactCreateWithoutPeriodsInput, ArtifactUncheckedCreateWithoutPeriodsInput> | ArtifactCreateWithoutPeriodsInput[] | ArtifactUncheckedCreateWithoutPeriodsInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutPeriodsInput | ArtifactCreateOrConnectWithoutPeriodsInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
  }

  export type ArtifactUncheckedCreateNestedManyWithoutPeriodsInput = {
    create?: XOR<ArtifactCreateWithoutPeriodsInput, ArtifactUncheckedCreateWithoutPeriodsInput> | ArtifactCreateWithoutPeriodsInput[] | ArtifactUncheckedCreateWithoutPeriodsInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutPeriodsInput | ArtifactCreateOrConnectWithoutPeriodsInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
  }

  export type ArtifactUpdateManyWithoutPeriodsNestedInput = {
    create?: XOR<ArtifactCreateWithoutPeriodsInput, ArtifactUncheckedCreateWithoutPeriodsInput> | ArtifactCreateWithoutPeriodsInput[] | ArtifactUncheckedCreateWithoutPeriodsInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutPeriodsInput | ArtifactCreateOrConnectWithoutPeriodsInput[]
    upsert?: ArtifactUpsertWithWhereUniqueWithoutPeriodsInput | ArtifactUpsertWithWhereUniqueWithoutPeriodsInput[]
    set?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    disconnect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    delete?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    update?: ArtifactUpdateWithWhereUniqueWithoutPeriodsInput | ArtifactUpdateWithWhereUniqueWithoutPeriodsInput[]
    updateMany?: ArtifactUpdateManyWithWhereWithoutPeriodsInput | ArtifactUpdateManyWithWhereWithoutPeriodsInput[]
    deleteMany?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
  }

  export type ArtifactUncheckedUpdateManyWithoutPeriodsNestedInput = {
    create?: XOR<ArtifactCreateWithoutPeriodsInput, ArtifactUncheckedCreateWithoutPeriodsInput> | ArtifactCreateWithoutPeriodsInput[] | ArtifactUncheckedCreateWithoutPeriodsInput[]
    connectOrCreate?: ArtifactCreateOrConnectWithoutPeriodsInput | ArtifactCreateOrConnectWithoutPeriodsInput[]
    upsert?: ArtifactUpsertWithWhereUniqueWithoutPeriodsInput | ArtifactUpsertWithWhereUniqueWithoutPeriodsInput[]
    set?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    disconnect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    delete?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    connect?: ArtifactWhereUniqueInput | ArtifactWhereUniqueInput[]
    update?: ArtifactUpdateWithWhereUniqueWithoutPeriodsInput | ArtifactUpdateWithWhereUniqueWithoutPeriodsInput[]
    updateMany?: ArtifactUpdateManyWithWhereWithoutPeriodsInput | ArtifactUpdateManyWithWhereWithoutPeriodsInput[]
    deleteMany?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
  }

  export type MenuItemCreateNestedManyWithoutMenuInput = {
    create?: XOR<MenuItemCreateWithoutMenuInput, MenuItemUncheckedCreateWithoutMenuInput> | MenuItemCreateWithoutMenuInput[] | MenuItemUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutMenuInput | MenuItemCreateOrConnectWithoutMenuInput[]
    createMany?: MenuItemCreateManyMenuInputEnvelope
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
  }

  export type MenuItemUncheckedCreateNestedManyWithoutMenuInput = {
    create?: XOR<MenuItemCreateWithoutMenuInput, MenuItemUncheckedCreateWithoutMenuInput> | MenuItemCreateWithoutMenuInput[] | MenuItemUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutMenuInput | MenuItemCreateOrConnectWithoutMenuInput[]
    createMany?: MenuItemCreateManyMenuInputEnvelope
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
  }

  export type EnumMenuLocationFieldUpdateOperationsInput = {
    set?: $Enums.MenuLocation
  }

  export type MenuItemUpdateManyWithoutMenuNestedInput = {
    create?: XOR<MenuItemCreateWithoutMenuInput, MenuItemUncheckedCreateWithoutMenuInput> | MenuItemCreateWithoutMenuInput[] | MenuItemUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutMenuInput | MenuItemCreateOrConnectWithoutMenuInput[]
    upsert?: MenuItemUpsertWithWhereUniqueWithoutMenuInput | MenuItemUpsertWithWhereUniqueWithoutMenuInput[]
    createMany?: MenuItemCreateManyMenuInputEnvelope
    set?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    disconnect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    delete?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    update?: MenuItemUpdateWithWhereUniqueWithoutMenuInput | MenuItemUpdateWithWhereUniqueWithoutMenuInput[]
    updateMany?: MenuItemUpdateManyWithWhereWithoutMenuInput | MenuItemUpdateManyWithWhereWithoutMenuInput[]
    deleteMany?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
  }

  export type MenuItemUncheckedUpdateManyWithoutMenuNestedInput = {
    create?: XOR<MenuItemCreateWithoutMenuInput, MenuItemUncheckedCreateWithoutMenuInput> | MenuItemCreateWithoutMenuInput[] | MenuItemUncheckedCreateWithoutMenuInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutMenuInput | MenuItemCreateOrConnectWithoutMenuInput[]
    upsert?: MenuItemUpsertWithWhereUniqueWithoutMenuInput | MenuItemUpsertWithWhereUniqueWithoutMenuInput[]
    createMany?: MenuItemCreateManyMenuInputEnvelope
    set?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    disconnect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    delete?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    update?: MenuItemUpdateWithWhereUniqueWithoutMenuInput | MenuItemUpdateWithWhereUniqueWithoutMenuInput[]
    updateMany?: MenuItemUpdateManyWithWhereWithoutMenuInput | MenuItemUpdateManyWithWhereWithoutMenuInput[]
    deleteMany?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
  }

  export type MenuCreateNestedOneWithoutItemsInput = {
    create?: XOR<MenuCreateWithoutItemsInput, MenuUncheckedCreateWithoutItemsInput>
    connectOrCreate?: MenuCreateOrConnectWithoutItemsInput
    connect?: MenuWhereUniqueInput
  }

  export type MenuItemCreateNestedOneWithoutChildrenInput = {
    create?: XOR<MenuItemCreateWithoutChildrenInput, MenuItemUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: MenuItemCreateOrConnectWithoutChildrenInput
    connect?: MenuItemWhereUniqueInput
  }

  export type MenuItemCreateNestedManyWithoutParentInput = {
    create?: XOR<MenuItemCreateWithoutParentInput, MenuItemUncheckedCreateWithoutParentInput> | MenuItemCreateWithoutParentInput[] | MenuItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutParentInput | MenuItemCreateOrConnectWithoutParentInput[]
    createMany?: MenuItemCreateManyParentInputEnvelope
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
  }

  export type PageCreateNestedOneWithoutMenuItemsInput = {
    create?: XOR<PageCreateWithoutMenuItemsInput, PageUncheckedCreateWithoutMenuItemsInput>
    connectOrCreate?: PageCreateOrConnectWithoutMenuItemsInput
    connect?: PageWhereUniqueInput
  }

  export type MenuItemUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<MenuItemCreateWithoutParentInput, MenuItemUncheckedCreateWithoutParentInput> | MenuItemCreateWithoutParentInput[] | MenuItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutParentInput | MenuItemCreateOrConnectWithoutParentInput[]
    createMany?: MenuItemCreateManyParentInputEnvelope
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
  }

  export type EnumItemVariantFieldUpdateOperationsInput = {
    set?: $Enums.ItemVariant
  }

  export type MenuUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<MenuCreateWithoutItemsInput, MenuUncheckedCreateWithoutItemsInput>
    connectOrCreate?: MenuCreateOrConnectWithoutItemsInput
    upsert?: MenuUpsertWithoutItemsInput
    connect?: MenuWhereUniqueInput
    update?: XOR<XOR<MenuUpdateToOneWithWhereWithoutItemsInput, MenuUpdateWithoutItemsInput>, MenuUncheckedUpdateWithoutItemsInput>
  }

  export type MenuItemUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<MenuItemCreateWithoutChildrenInput, MenuItemUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: MenuItemCreateOrConnectWithoutChildrenInput
    upsert?: MenuItemUpsertWithoutChildrenInput
    disconnect?: MenuItemWhereInput | boolean
    delete?: MenuItemWhereInput | boolean
    connect?: MenuItemWhereUniqueInput
    update?: XOR<XOR<MenuItemUpdateToOneWithWhereWithoutChildrenInput, MenuItemUpdateWithoutChildrenInput>, MenuItemUncheckedUpdateWithoutChildrenInput>
  }

  export type MenuItemUpdateManyWithoutParentNestedInput = {
    create?: XOR<MenuItemCreateWithoutParentInput, MenuItemUncheckedCreateWithoutParentInput> | MenuItemCreateWithoutParentInput[] | MenuItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutParentInput | MenuItemCreateOrConnectWithoutParentInput[]
    upsert?: MenuItemUpsertWithWhereUniqueWithoutParentInput | MenuItemUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: MenuItemCreateManyParentInputEnvelope
    set?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    disconnect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    delete?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    update?: MenuItemUpdateWithWhereUniqueWithoutParentInput | MenuItemUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: MenuItemUpdateManyWithWhereWithoutParentInput | MenuItemUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
  }

  export type PageUpdateOneWithoutMenuItemsNestedInput = {
    create?: XOR<PageCreateWithoutMenuItemsInput, PageUncheckedCreateWithoutMenuItemsInput>
    connectOrCreate?: PageCreateOrConnectWithoutMenuItemsInput
    upsert?: PageUpsertWithoutMenuItemsInput
    disconnect?: PageWhereInput | boolean
    delete?: PageWhereInput | boolean
    connect?: PageWhereUniqueInput
    update?: XOR<XOR<PageUpdateToOneWithWhereWithoutMenuItemsInput, PageUpdateWithoutMenuItemsInput>, PageUncheckedUpdateWithoutMenuItemsInput>
  }

  export type MenuItemUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<MenuItemCreateWithoutParentInput, MenuItemUncheckedCreateWithoutParentInput> | MenuItemCreateWithoutParentInput[] | MenuItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MenuItemCreateOrConnectWithoutParentInput | MenuItemCreateOrConnectWithoutParentInput[]
    upsert?: MenuItemUpsertWithWhereUniqueWithoutParentInput | MenuItemUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: MenuItemCreateManyParentInputEnvelope
    set?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    disconnect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    delete?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    connect?: MenuItemWhereUniqueInput | MenuItemWhereUniqueInput[]
    update?: MenuItemUpdateWithWhereUniqueWithoutParentInput | MenuItemUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: MenuItemUpdateManyWithWhereWithoutParentInput | MenuItemUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
  }

  export type FooterColumnItemCreateNestedManyWithoutFooterColumnInput = {
    create?: XOR<FooterColumnItemCreateWithoutFooterColumnInput, FooterColumnItemUncheckedCreateWithoutFooterColumnInput> | FooterColumnItemCreateWithoutFooterColumnInput[] | FooterColumnItemUncheckedCreateWithoutFooterColumnInput[]
    connectOrCreate?: FooterColumnItemCreateOrConnectWithoutFooterColumnInput | FooterColumnItemCreateOrConnectWithoutFooterColumnInput[]
    createMany?: FooterColumnItemCreateManyFooterColumnInputEnvelope
    connect?: FooterColumnItemWhereUniqueInput | FooterColumnItemWhereUniqueInput[]
  }

  export type FooterColumnItemUncheckedCreateNestedManyWithoutFooterColumnInput = {
    create?: XOR<FooterColumnItemCreateWithoutFooterColumnInput, FooterColumnItemUncheckedCreateWithoutFooterColumnInput> | FooterColumnItemCreateWithoutFooterColumnInput[] | FooterColumnItemUncheckedCreateWithoutFooterColumnInput[]
    connectOrCreate?: FooterColumnItemCreateOrConnectWithoutFooterColumnInput | FooterColumnItemCreateOrConnectWithoutFooterColumnInput[]
    createMany?: FooterColumnItemCreateManyFooterColumnInputEnvelope
    connect?: FooterColumnItemWhereUniqueInput | FooterColumnItemWhereUniqueInput[]
  }

  export type EnumMenuTypeFieldUpdateOperationsInput = {
    set?: $Enums.MenuType
  }

  export type FooterColumnItemUpdateManyWithoutFooterColumnNestedInput = {
    create?: XOR<FooterColumnItemCreateWithoutFooterColumnInput, FooterColumnItemUncheckedCreateWithoutFooterColumnInput> | FooterColumnItemCreateWithoutFooterColumnInput[] | FooterColumnItemUncheckedCreateWithoutFooterColumnInput[]
    connectOrCreate?: FooterColumnItemCreateOrConnectWithoutFooterColumnInput | FooterColumnItemCreateOrConnectWithoutFooterColumnInput[]
    upsert?: FooterColumnItemUpsertWithWhereUniqueWithoutFooterColumnInput | FooterColumnItemUpsertWithWhereUniqueWithoutFooterColumnInput[]
    createMany?: FooterColumnItemCreateManyFooterColumnInputEnvelope
    set?: FooterColumnItemWhereUniqueInput | FooterColumnItemWhereUniqueInput[]
    disconnect?: FooterColumnItemWhereUniqueInput | FooterColumnItemWhereUniqueInput[]
    delete?: FooterColumnItemWhereUniqueInput | FooterColumnItemWhereUniqueInput[]
    connect?: FooterColumnItemWhereUniqueInput | FooterColumnItemWhereUniqueInput[]
    update?: FooterColumnItemUpdateWithWhereUniqueWithoutFooterColumnInput | FooterColumnItemUpdateWithWhereUniqueWithoutFooterColumnInput[]
    updateMany?: FooterColumnItemUpdateManyWithWhereWithoutFooterColumnInput | FooterColumnItemUpdateManyWithWhereWithoutFooterColumnInput[]
    deleteMany?: FooterColumnItemScalarWhereInput | FooterColumnItemScalarWhereInput[]
  }

  export type FooterColumnItemUncheckedUpdateManyWithoutFooterColumnNestedInput = {
    create?: XOR<FooterColumnItemCreateWithoutFooterColumnInput, FooterColumnItemUncheckedCreateWithoutFooterColumnInput> | FooterColumnItemCreateWithoutFooterColumnInput[] | FooterColumnItemUncheckedCreateWithoutFooterColumnInput[]
    connectOrCreate?: FooterColumnItemCreateOrConnectWithoutFooterColumnInput | FooterColumnItemCreateOrConnectWithoutFooterColumnInput[]
    upsert?: FooterColumnItemUpsertWithWhereUniqueWithoutFooterColumnInput | FooterColumnItemUpsertWithWhereUniqueWithoutFooterColumnInput[]
    createMany?: FooterColumnItemCreateManyFooterColumnInputEnvelope
    set?: FooterColumnItemWhereUniqueInput | FooterColumnItemWhereUniqueInput[]
    disconnect?: FooterColumnItemWhereUniqueInput | FooterColumnItemWhereUniqueInput[]
    delete?: FooterColumnItemWhereUniqueInput | FooterColumnItemWhereUniqueInput[]
    connect?: FooterColumnItemWhereUniqueInput | FooterColumnItemWhereUniqueInput[]
    update?: FooterColumnItemUpdateWithWhereUniqueWithoutFooterColumnInput | FooterColumnItemUpdateWithWhereUniqueWithoutFooterColumnInput[]
    updateMany?: FooterColumnItemUpdateManyWithWhereWithoutFooterColumnInput | FooterColumnItemUpdateManyWithWhereWithoutFooterColumnInput[]
    deleteMany?: FooterColumnItemScalarWhereInput | FooterColumnItemScalarWhereInput[]
  }

  export type FooterColumnCreateNestedOneWithoutItemsInput = {
    create?: XOR<FooterColumnCreateWithoutItemsInput, FooterColumnUncheckedCreateWithoutItemsInput>
    connectOrCreate?: FooterColumnCreateOrConnectWithoutItemsInput
    connect?: FooterColumnWhereUniqueInput
  }

  export type PageCreateNestedOneWithoutFooterItemsInput = {
    create?: XOR<PageCreateWithoutFooterItemsInput, PageUncheckedCreateWithoutFooterItemsInput>
    connectOrCreate?: PageCreateOrConnectWithoutFooterItemsInput
    connect?: PageWhereUniqueInput
  }

  export type FooterColumnUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<FooterColumnCreateWithoutItemsInput, FooterColumnUncheckedCreateWithoutItemsInput>
    connectOrCreate?: FooterColumnCreateOrConnectWithoutItemsInput
    upsert?: FooterColumnUpsertWithoutItemsInput
    connect?: FooterColumnWhereUniqueInput
    update?: XOR<XOR<FooterColumnUpdateToOneWithWhereWithoutItemsInput, FooterColumnUpdateWithoutItemsInput>, FooterColumnUncheckedUpdateWithoutItemsInput>
  }

  export type PageUpdateOneWithoutFooterItemsNestedInput = {
    create?: XOR<PageCreateWithoutFooterItemsInput, PageUncheckedCreateWithoutFooterItemsInput>
    connectOrCreate?: PageCreateOrConnectWithoutFooterItemsInput
    upsert?: PageUpsertWithoutFooterItemsInput
    disconnect?: PageWhereInput | boolean
    delete?: PageWhereInput | boolean
    connect?: PageWhereUniqueInput
    update?: XOR<XOR<PageUpdateToOneWithWhereWithoutFooterItemsInput, PageUpdateWithoutFooterItemsInput>, PageUncheckedUpdateWithoutFooterItemsInput>
  }

  export type DocumentPageCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentPageCreateWithoutDocumentInput, DocumentPageUncheckedCreateWithoutDocumentInput> | DocumentPageCreateWithoutDocumentInput[] | DocumentPageUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentPageCreateOrConnectWithoutDocumentInput | DocumentPageCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentPageCreateManyDocumentInputEnvelope
    connect?: DocumentPageWhereUniqueInput | DocumentPageWhereUniqueInput[]
  }

  export type DocumentPageUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentPageCreateWithoutDocumentInput, DocumentPageUncheckedCreateWithoutDocumentInput> | DocumentPageCreateWithoutDocumentInput[] | DocumentPageUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentPageCreateOrConnectWithoutDocumentInput | DocumentPageCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentPageCreateManyDocumentInputEnvelope
    connect?: DocumentPageWhereUniqueInput | DocumentPageWhereUniqueInput[]
  }

  export type EnumContentLanguageFieldUpdateOperationsInput = {
    set?: $Enums.ContentLanguage
  }

  export type DocumentPageUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentPageCreateWithoutDocumentInput, DocumentPageUncheckedCreateWithoutDocumentInput> | DocumentPageCreateWithoutDocumentInput[] | DocumentPageUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentPageCreateOrConnectWithoutDocumentInput | DocumentPageCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentPageUpsertWithWhereUniqueWithoutDocumentInput | DocumentPageUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentPageCreateManyDocumentInputEnvelope
    set?: DocumentPageWhereUniqueInput | DocumentPageWhereUniqueInput[]
    disconnect?: DocumentPageWhereUniqueInput | DocumentPageWhereUniqueInput[]
    delete?: DocumentPageWhereUniqueInput | DocumentPageWhereUniqueInput[]
    connect?: DocumentPageWhereUniqueInput | DocumentPageWhereUniqueInput[]
    update?: DocumentPageUpdateWithWhereUniqueWithoutDocumentInput | DocumentPageUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentPageUpdateManyWithWhereWithoutDocumentInput | DocumentPageUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentPageScalarWhereInput | DocumentPageScalarWhereInput[]
  }

  export type DocumentPageUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentPageCreateWithoutDocumentInput, DocumentPageUncheckedCreateWithoutDocumentInput> | DocumentPageCreateWithoutDocumentInput[] | DocumentPageUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentPageCreateOrConnectWithoutDocumentInput | DocumentPageCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentPageUpsertWithWhereUniqueWithoutDocumentInput | DocumentPageUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentPageCreateManyDocumentInputEnvelope
    set?: DocumentPageWhereUniqueInput | DocumentPageWhereUniqueInput[]
    disconnect?: DocumentPageWhereUniqueInput | DocumentPageWhereUniqueInput[]
    delete?: DocumentPageWhereUniqueInput | DocumentPageWhereUniqueInput[]
    connect?: DocumentPageWhereUniqueInput | DocumentPageWhereUniqueInput[]
    update?: DocumentPageUpdateWithWhereUniqueWithoutDocumentInput | DocumentPageUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentPageUpdateManyWithWhereWithoutDocumentInput | DocumentPageUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentPageScalarWhereInput | DocumentPageScalarWhereInput[]
  }

  export type DocumentCreateNestedOneWithoutPagesInput = {
    create?: XOR<DocumentCreateWithoutPagesInput, DocumentUncheckedCreateWithoutPagesInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutPagesInput
    connect?: DocumentWhereUniqueInput
  }

  export type DocumentUpdateOneRequiredWithoutPagesNestedInput = {
    create?: XOR<DocumentCreateWithoutPagesInput, DocumentUncheckedCreateWithoutPagesInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutPagesInput
    upsert?: DocumentUpsertWithoutPagesInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutPagesInput, DocumentUpdateWithoutPagesInput>, DocumentUncheckedUpdateWithoutPagesInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumAppLanguageFilter<$PrismaModel = never> = {
    equals?: $Enums.AppLanguage | EnumAppLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.AppLanguage[] | ListEnumAppLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppLanguage[] | ListEnumAppLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumAppLanguageFilter<$PrismaModel> | $Enums.AppLanguage
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumContentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusFilter<$PrismaModel> | $Enums.ContentStatus
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAppLanguageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppLanguage | EnumAppLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.AppLanguage[] | ListEnumAppLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppLanguage[] | ListEnumAppLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumAppLanguageWithAggregatesFilter<$PrismaModel> | $Enums.AppLanguage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppLanguageFilter<$PrismaModel>
    _max?: NestedEnumAppLanguageFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumContentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentStatus[] | ListEnumContentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentStatusFilter<$PrismaModel>
    _max?: NestedEnumContentStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumDataMaturityFilter<$PrismaModel = never> = {
    equals?: $Enums.DataMaturity | EnumDataMaturityFieldRefInput<$PrismaModel>
    in?: $Enums.DataMaturity[] | ListEnumDataMaturityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataMaturity[] | ListEnumDataMaturityFieldRefInput<$PrismaModel>
    not?: NestedEnumDataMaturityFilter<$PrismaModel> | $Enums.DataMaturity
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumDataMaturityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DataMaturity | EnumDataMaturityFieldRefInput<$PrismaModel>
    in?: $Enums.DataMaturity[] | ListEnumDataMaturityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DataMaturity[] | ListEnumDataMaturityFieldRefInput<$PrismaModel>
    not?: NestedEnumDataMaturityWithAggregatesFilter<$PrismaModel> | $Enums.DataMaturity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDataMaturityFilter<$PrismaModel>
    _max?: NestedEnumDataMaturityFilter<$PrismaModel>
  }

  export type NestedEnumResouceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResouceType | EnumResouceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResouceType[] | ListEnumResouceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResouceType[] | ListEnumResouceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResouceTypeFilter<$PrismaModel> | $Enums.ResouceType
  }

  export type NestedEnumResouceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResouceType | EnumResouceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResouceType[] | ListEnumResouceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResouceType[] | ListEnumResouceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResouceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ResouceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResouceTypeFilter<$PrismaModel>
    _max?: NestedEnumResouceTypeFilter<$PrismaModel>
  }

  export type NestedEnumLayerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LayerType | EnumLayerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LayerType[] | ListEnumLayerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LayerType[] | ListEnumLayerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLayerTypeFilter<$PrismaModel> | $Enums.LayerType
  }

  export type NestedEnumLayerSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LayerSourceType | EnumLayerSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LayerSourceType[] | ListEnumLayerSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LayerSourceType[] | ListEnumLayerSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLayerSourceTypeFilter<$PrismaModel> | $Enums.LayerSourceType
  }

  export type NestedEnumLayerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LayerType | EnumLayerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LayerType[] | ListEnumLayerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LayerType[] | ListEnumLayerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLayerTypeWithAggregatesFilter<$PrismaModel> | $Enums.LayerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLayerTypeFilter<$PrismaModel>
    _max?: NestedEnumLayerTypeFilter<$PrismaModel>
  }

  export type NestedEnumLayerSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LayerSourceType | EnumLayerSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LayerSourceType[] | ListEnumLayerSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LayerSourceType[] | ListEnumLayerSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLayerSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.LayerSourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLayerSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumLayerSourceTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumTextTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TextType | EnumTextTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TextType[] | ListEnumTextTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextType[] | ListEnumTextTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTextTypeFilter<$PrismaModel> | $Enums.TextType
  }

  export type NestedEnumTextTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TextType | EnumTextTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TextType[] | ListEnumTextTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TextType[] | ListEnumTextTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTextTypeWithAggregatesFilter<$PrismaModel> | $Enums.TextType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTextTypeFilter<$PrismaModel>
    _max?: NestedEnumTextTypeFilter<$PrismaModel>
  }

  export type NestedEnumImageUseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageUseType | EnumImageUseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImageUseType[] | ListEnumImageUseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImageUseType[] | ListEnumImageUseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImageUseTypeFilter<$PrismaModel> | $Enums.ImageUseType
  }

  export type NestedEnumImageUseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImageUseType | EnumImageUseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImageUseType[] | ListEnumImageUseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImageUseType[] | ListEnumImageUseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImageUseTypeWithAggregatesFilter<$PrismaModel> | $Enums.ImageUseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImageUseTypeFilter<$PrismaModel>
    _max?: NestedEnumImageUseTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumMenuLocationFilter<$PrismaModel = never> = {
    equals?: $Enums.MenuLocation | EnumMenuLocationFieldRefInput<$PrismaModel>
    in?: $Enums.MenuLocation[] | ListEnumMenuLocationFieldRefInput<$PrismaModel>
    notIn?: $Enums.MenuLocation[] | ListEnumMenuLocationFieldRefInput<$PrismaModel>
    not?: NestedEnumMenuLocationFilter<$PrismaModel> | $Enums.MenuLocation
  }

  export type NestedEnumMenuLocationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MenuLocation | EnumMenuLocationFieldRefInput<$PrismaModel>
    in?: $Enums.MenuLocation[] | ListEnumMenuLocationFieldRefInput<$PrismaModel>
    notIn?: $Enums.MenuLocation[] | ListEnumMenuLocationFieldRefInput<$PrismaModel>
    not?: NestedEnumMenuLocationWithAggregatesFilter<$PrismaModel> | $Enums.MenuLocation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMenuLocationFilter<$PrismaModel>
    _max?: NestedEnumMenuLocationFilter<$PrismaModel>
  }

  export type NestedEnumItemVariantFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemVariant | EnumItemVariantFieldRefInput<$PrismaModel>
    in?: $Enums.ItemVariant[] | ListEnumItemVariantFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemVariant[] | ListEnumItemVariantFieldRefInput<$PrismaModel>
    not?: NestedEnumItemVariantFilter<$PrismaModel> | $Enums.ItemVariant
  }

  export type NestedEnumItemVariantWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemVariant | EnumItemVariantFieldRefInput<$PrismaModel>
    in?: $Enums.ItemVariant[] | ListEnumItemVariantFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemVariant[] | ListEnumItemVariantFieldRefInput<$PrismaModel>
    not?: NestedEnumItemVariantWithAggregatesFilter<$PrismaModel> | $Enums.ItemVariant
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemVariantFilter<$PrismaModel>
    _max?: NestedEnumItemVariantFilter<$PrismaModel>
  }

  export type NestedEnumMenuTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MenuType | EnumMenuTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MenuType[] | ListEnumMenuTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MenuType[] | ListEnumMenuTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMenuTypeFilter<$PrismaModel> | $Enums.MenuType
  }

  export type NestedEnumMenuTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MenuType | EnumMenuTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MenuType[] | ListEnumMenuTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MenuType[] | ListEnumMenuTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMenuTypeWithAggregatesFilter<$PrismaModel> | $Enums.MenuType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMenuTypeFilter<$PrismaModel>
    _max?: NestedEnumMenuTypeFilter<$PrismaModel>
  }

  export type NestedEnumContentLanguageFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentLanguage | EnumContentLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.ContentLanguage[] | ListEnumContentLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentLanguage[] | ListEnumContentLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumContentLanguageFilter<$PrismaModel> | $Enums.ContentLanguage
  }

  export type NestedEnumContentLanguageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentLanguage | EnumContentLanguageFieldRefInput<$PrismaModel>
    in?: $Enums.ContentLanguage[] | ListEnumContentLanguageFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentLanguage[] | ListEnumContentLanguageFieldRefInput<$PrismaModel>
    not?: NestedEnumContentLanguageWithAggregatesFilter<$PrismaModel> | $Enums.ContentLanguage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentLanguageFilter<$PrismaModel>
    _max?: NestedEnumContentLanguageFilter<$PrismaModel>
  }

  export type UserCreateWithoutPagesInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    pageTexts?: PageTextCreateNestedManyWithoutContributorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPagesInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    pageTexts?: PageTextUncheckedCreateNestedManyWithoutContributorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPagesInput, UserUncheckedCreateWithoutPagesInput>
  }

  export type PageCreateWithoutChildrenInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content?: string | null
    excerpt?: string | null
    sources?: string | null
    citations?: string | null
    language?: $Enums.AppLanguage
    translationGroupId?: string | null
    status?: $Enums.ContentStatus
    metaDescription?: string | null
    metaKeywords?: string | null
    template?: string | null
    menuOrder?: number
    showInMenu?: boolean
    author?: UserCreateNestedOneWithoutPagesInput
    parent?: PageCreateNestedOneWithoutChildrenInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForPagesInput
    regions?: RegionCreateNestedManyWithoutPagesInput
    tags?: TagCreateNestedManyWithoutPagesInput
    menuItems?: MenuItemCreateNestedManyWithoutPageInput
    footerItems?: FooterColumnItemCreateNestedManyWithoutPageInput
  }

  export type PageUncheckedCreateWithoutChildrenInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content?: string | null
    excerpt?: string | null
    sources?: string | null
    citations?: string | null
    language?: $Enums.AppLanguage
    translationGroupId?: string | null
    status?: $Enums.ContentStatus
    authorId?: string | null
    parentId?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    thumbnailId?: string | null
    template?: string | null
    menuOrder?: number
    showInMenu?: boolean
    regions?: RegionUncheckedCreateNestedManyWithoutPagesInput
    tags?: TagUncheckedCreateNestedManyWithoutPagesInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutPageInput
    footerItems?: FooterColumnItemUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageCreateOrConnectWithoutChildrenInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutChildrenInput, PageUncheckedCreateWithoutChildrenInput>
  }

  export type PageCreateWithoutParentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content?: string | null
    excerpt?: string | null
    sources?: string | null
    citations?: string | null
    language?: $Enums.AppLanguage
    translationGroupId?: string | null
    status?: $Enums.ContentStatus
    metaDescription?: string | null
    metaKeywords?: string | null
    template?: string | null
    menuOrder?: number
    showInMenu?: boolean
    author?: UserCreateNestedOneWithoutPagesInput
    children?: PageCreateNestedManyWithoutParentInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForPagesInput
    regions?: RegionCreateNestedManyWithoutPagesInput
    tags?: TagCreateNestedManyWithoutPagesInput
    menuItems?: MenuItemCreateNestedManyWithoutPageInput
    footerItems?: FooterColumnItemCreateNestedManyWithoutPageInput
  }

  export type PageUncheckedCreateWithoutParentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content?: string | null
    excerpt?: string | null
    sources?: string | null
    citations?: string | null
    language?: $Enums.AppLanguage
    translationGroupId?: string | null
    status?: $Enums.ContentStatus
    authorId?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    thumbnailId?: string | null
    template?: string | null
    menuOrder?: number
    showInMenu?: boolean
    children?: PageUncheckedCreateNestedManyWithoutParentInput
    regions?: RegionUncheckedCreateNestedManyWithoutPagesInput
    tags?: TagUncheckedCreateNestedManyWithoutPagesInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutPageInput
    footerItems?: FooterColumnItemUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageCreateOrConnectWithoutParentInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutParentInput, PageUncheckedCreateWithoutParentInput>
  }

  export type PageCreateManyParentInputEnvelope = {
    data: PageCreateManyParentInput | PageCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type MediaCreateWithoutThumbnailForPagesInput = {
    id?: string
    filename: string
    url: string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailForCategory?: CategoryCreateNestedManyWithoutThumbnailInput
    thumbnailForCollections?: CollectionCreateNestedManyWithoutThumbnailInput
    thumbnailForMaps?: MapCreateNestedManyWithoutThumbnailInput
    storageFile?: StorageFileCreateNestedOneWithoutMediaInput
    thumbnailForPosts?: PostCreateNestedManyWithoutThumbnailInput
    thumbnailForDataset?: ResearchDatasetCreateNestedManyWithoutThumbnailInput
    thumbnailForSeries?: SeriesCreateNestedManyWithoutThumbnailInput
    thumbnailForVolumes?: VolumeCreateNestedManyWithoutThumbnailInput
  }

  export type MediaUncheckedCreateWithoutThumbnailForPagesInput = {
    id?: string
    filename: string
    url: string
    storageFileId?: string | null
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailForCategory?: CategoryUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForCollections?: CollectionUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForMaps?: MapUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForPosts?: PostUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForDataset?: ResearchDatasetUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForSeries?: SeriesUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForVolumes?: VolumeUncheckedCreateNestedManyWithoutThumbnailInput
  }

  export type MediaCreateOrConnectWithoutThumbnailForPagesInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutThumbnailForPagesInput, MediaUncheckedCreateWithoutThumbnailForPagesInput>
  }

  export type RegionCreateWithoutPagesInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    artifacts?: ArtifactCreateNestedManyWithoutRegionsInput
    collections?: CollectionCreateNestedManyWithoutRegionsInput
    layers?: LayerCreateNestedManyWithoutRegionsInput
    maps?: MapCreateNestedManyWithoutRegionsInput
    posts?: PostCreateNestedManyWithoutRegionsInput
    datasets?: ResearchDatasetCreateNestedManyWithoutRegionsInput
    series?: SeriesCreateNestedManyWithoutRegionsInput
    volumes?: VolumeCreateNestedManyWithoutRegionsInput
  }

  export type RegionUncheckedCreateWithoutPagesInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutRegionsInput
    collections?: CollectionUncheckedCreateNestedManyWithoutRegionsInput
    layers?: LayerUncheckedCreateNestedManyWithoutRegionsInput
    maps?: MapUncheckedCreateNestedManyWithoutRegionsInput
    posts?: PostUncheckedCreateNestedManyWithoutRegionsInput
    datasets?: ResearchDatasetUncheckedCreateNestedManyWithoutRegionsInput
    series?: SeriesUncheckedCreateNestedManyWithoutRegionsInput
    volumes?: VolumeUncheckedCreateNestedManyWithoutRegionsInput
  }

  export type RegionCreateOrConnectWithoutPagesInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutPagesInput, RegionUncheckedCreateWithoutPagesInput>
  }

  export type TagCreateWithoutPagesInput = {
    id?: string
    slug: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    posts?: PostTagCreateNestedManyWithoutTagInput
    artifacts?: ArtifactCreateNestedManyWithoutTagsInput
    collections?: CollectionCreateNestedManyWithoutTagsInput
    layers?: LayerCreateNestedManyWithoutTagsInput
    maps?: MapCreateNestedManyWithoutTagsInput
    series?: SeriesCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutPagesInput = {
    id?: string
    slug: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    posts?: PostTagUncheckedCreateNestedManyWithoutTagInput
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutTagsInput
    collections?: CollectionUncheckedCreateNestedManyWithoutTagsInput
    layers?: LayerUncheckedCreateNestedManyWithoutTagsInput
    maps?: MapUncheckedCreateNestedManyWithoutTagsInput
    series?: SeriesUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutPagesInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutPagesInput, TagUncheckedCreateWithoutPagesInput>
  }

  export type MenuItemCreateWithoutPageInput = {
    id?: string
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    variant?: $Enums.ItemVariant
    order?: number
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    menu: MenuCreateNestedOneWithoutItemsInput
    parent?: MenuItemCreateNestedOneWithoutChildrenInput
    children?: MenuItemCreateNestedManyWithoutParentInput
  }

  export type MenuItemUncheckedCreateWithoutPageInput = {
    id?: string
    menuId: string
    parentId?: string | null
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    variant?: $Enums.ItemVariant
    order?: number
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: MenuItemUncheckedCreateNestedManyWithoutParentInput
  }

  export type MenuItemCreateOrConnectWithoutPageInput = {
    where: MenuItemWhereUniqueInput
    create: XOR<MenuItemCreateWithoutPageInput, MenuItemUncheckedCreateWithoutPageInput>
  }

  export type MenuItemCreateManyPageInputEnvelope = {
    data: MenuItemCreateManyPageInput | MenuItemCreateManyPageInput[]
    skipDuplicates?: boolean
  }

  export type FooterColumnItemCreateWithoutPageInput = {
    id?: string
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    order?: number
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    footerColumn: FooterColumnCreateNestedOneWithoutItemsInput
  }

  export type FooterColumnItemUncheckedCreateWithoutPageInput = {
    id?: string
    footerColumnId: string
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    order?: number
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FooterColumnItemCreateOrConnectWithoutPageInput = {
    where: FooterColumnItemWhereUniqueInput
    create: XOR<FooterColumnItemCreateWithoutPageInput, FooterColumnItemUncheckedCreateWithoutPageInput>
  }

  export type FooterColumnItemCreateManyPageInputEnvelope = {
    data: FooterColumnItemCreateManyPageInput | FooterColumnItemCreateManyPageInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPagesInput = {
    update: XOR<UserUpdateWithoutPagesInput, UserUncheckedUpdateWithoutPagesInput>
    create: XOR<UserCreateWithoutPagesInput, UserUncheckedCreateWithoutPagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPagesInput, UserUncheckedUpdateWithoutPagesInput>
  }

  export type UserUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    pageTexts?: PageTextUpdateManyWithoutContributorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    pageTexts?: PageTextUncheckedUpdateManyWithoutContributorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PageUpsertWithoutChildrenInput = {
    update: XOR<PageUpdateWithoutChildrenInput, PageUncheckedUpdateWithoutChildrenInput>
    create: XOR<PageCreateWithoutChildrenInput, PageUncheckedCreateWithoutChildrenInput>
    where?: PageWhereInput
  }

  export type PageUpdateToOneWithWhereWithoutChildrenInput = {
    where?: PageWhereInput
    data: XOR<PageUpdateWithoutChildrenInput, PageUncheckedUpdateWithoutChildrenInput>
  }

  export type PageUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
    author?: UserUpdateOneWithoutPagesNestedInput
    parent?: PageUpdateOneWithoutChildrenNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForPagesNestedInput
    regions?: RegionUpdateManyWithoutPagesNestedInput
    tags?: TagUpdateManyWithoutPagesNestedInput
    menuItems?: MenuItemUpdateManyWithoutPageNestedInput
    footerItems?: FooterColumnItemUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
    regions?: RegionUncheckedUpdateManyWithoutPagesNestedInput
    tags?: TagUncheckedUpdateManyWithoutPagesNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutPageNestedInput
    footerItems?: FooterColumnItemUncheckedUpdateManyWithoutPageNestedInput
  }

  export type PageUpsertWithWhereUniqueWithoutParentInput = {
    where: PageWhereUniqueInput
    update: XOR<PageUpdateWithoutParentInput, PageUncheckedUpdateWithoutParentInput>
    create: XOR<PageCreateWithoutParentInput, PageUncheckedCreateWithoutParentInput>
  }

  export type PageUpdateWithWhereUniqueWithoutParentInput = {
    where: PageWhereUniqueInput
    data: XOR<PageUpdateWithoutParentInput, PageUncheckedUpdateWithoutParentInput>
  }

  export type PageUpdateManyWithWhereWithoutParentInput = {
    where: PageScalarWhereInput
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyWithoutParentInput>
  }

  export type PageScalarWhereInput = {
    AND?: PageScalarWhereInput | PageScalarWhereInput[]
    OR?: PageScalarWhereInput[]
    NOT?: PageScalarWhereInput | PageScalarWhereInput[]
    id?: UuidFilter<"Page"> | string
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
    title?: StringFilter<"Page"> | string
    slug?: StringFilter<"Page"> | string
    content?: StringNullableFilter<"Page"> | string | null
    excerpt?: StringNullableFilter<"Page"> | string | null
    sources?: StringNullableFilter<"Page"> | string | null
    citations?: StringNullableFilter<"Page"> | string | null
    language?: EnumAppLanguageFilter<"Page"> | $Enums.AppLanguage
    translationGroupId?: UuidNullableFilter<"Page"> | string | null
    status?: EnumContentStatusFilter<"Page"> | $Enums.ContentStatus
    authorId?: UuidNullableFilter<"Page"> | string | null
    parentId?: UuidNullableFilter<"Page"> | string | null
    metaDescription?: StringNullableFilter<"Page"> | string | null
    metaKeywords?: StringNullableFilter<"Page"> | string | null
    thumbnailId?: UuidNullableFilter<"Page"> | string | null
    template?: StringNullableFilter<"Page"> | string | null
    menuOrder?: IntFilter<"Page"> | number
    showInMenu?: BoolFilter<"Page"> | boolean
  }

  export type MediaUpsertWithoutThumbnailForPagesInput = {
    update: XOR<MediaUpdateWithoutThumbnailForPagesInput, MediaUncheckedUpdateWithoutThumbnailForPagesInput>
    create: XOR<MediaCreateWithoutThumbnailForPagesInput, MediaUncheckedCreateWithoutThumbnailForPagesInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutThumbnailForPagesInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutThumbnailForPagesInput, MediaUncheckedUpdateWithoutThumbnailForPagesInput>
  }

  export type MediaUpdateWithoutThumbnailForPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailForCategory?: CategoryUpdateManyWithoutThumbnailNestedInput
    thumbnailForCollections?: CollectionUpdateManyWithoutThumbnailNestedInput
    thumbnailForMaps?: MapUpdateManyWithoutThumbnailNestedInput
    storageFile?: StorageFileUpdateOneWithoutMediaNestedInput
    thumbnailForPosts?: PostUpdateManyWithoutThumbnailNestedInput
    thumbnailForDataset?: ResearchDatasetUpdateManyWithoutThumbnailNestedInput
    thumbnailForSeries?: SeriesUpdateManyWithoutThumbnailNestedInput
    thumbnailForVolumes?: VolumeUpdateManyWithoutThumbnailNestedInput
  }

  export type MediaUncheckedUpdateWithoutThumbnailForPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    storageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailForCategory?: CategoryUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForCollections?: CollectionUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForMaps?: MapUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForPosts?: PostUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForDataset?: ResearchDatasetUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForSeries?: SeriesUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForVolumes?: VolumeUncheckedUpdateManyWithoutThumbnailNestedInput
  }

  export type RegionUpsertWithWhereUniqueWithoutPagesInput = {
    where: RegionWhereUniqueInput
    update: XOR<RegionUpdateWithoutPagesInput, RegionUncheckedUpdateWithoutPagesInput>
    create: XOR<RegionCreateWithoutPagesInput, RegionUncheckedCreateWithoutPagesInput>
  }

  export type RegionUpdateWithWhereUniqueWithoutPagesInput = {
    where: RegionWhereUniqueInput
    data: XOR<RegionUpdateWithoutPagesInput, RegionUncheckedUpdateWithoutPagesInput>
  }

  export type RegionUpdateManyWithWhereWithoutPagesInput = {
    where: RegionScalarWhereInput
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyWithoutPagesInput>
  }

  export type RegionScalarWhereInput = {
    AND?: RegionScalarWhereInput | RegionScalarWhereInput[]
    OR?: RegionScalarWhereInput[]
    NOT?: RegionScalarWhereInput | RegionScalarWhereInput[]
    id?: UuidFilter<"Region"> | string
    slug?: StringFilter<"Region"> | string
    name?: StringFilter<"Region"> | string
    nameI18n?: JsonFilter<"Region">
    createdAt?: DateTimeFilter<"Region"> | Date | string
  }

  export type TagUpsertWithWhereUniqueWithoutPagesInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutPagesInput, TagUncheckedUpdateWithoutPagesInput>
    create: XOR<TagCreateWithoutPagesInput, TagUncheckedCreateWithoutPagesInput>
  }

  export type TagUpdateWithWhereUniqueWithoutPagesInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutPagesInput, TagUncheckedUpdateWithoutPagesInput>
  }

  export type TagUpdateManyWithWhereWithoutPagesInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutPagesInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: UuidFilter<"Tag"> | string
    slug?: StringFilter<"Tag"> | string
    nameI18n?: JsonFilter<"Tag">
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    name?: StringFilter<"Tag"> | string
  }

  export type MenuItemUpsertWithWhereUniqueWithoutPageInput = {
    where: MenuItemWhereUniqueInput
    update: XOR<MenuItemUpdateWithoutPageInput, MenuItemUncheckedUpdateWithoutPageInput>
    create: XOR<MenuItemCreateWithoutPageInput, MenuItemUncheckedCreateWithoutPageInput>
  }

  export type MenuItemUpdateWithWhereUniqueWithoutPageInput = {
    where: MenuItemWhereUniqueInput
    data: XOR<MenuItemUpdateWithoutPageInput, MenuItemUncheckedUpdateWithoutPageInput>
  }

  export type MenuItemUpdateManyWithWhereWithoutPageInput = {
    where: MenuItemScalarWhereInput
    data: XOR<MenuItemUpdateManyMutationInput, MenuItemUncheckedUpdateManyWithoutPageInput>
  }

  export type MenuItemScalarWhereInput = {
    AND?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
    OR?: MenuItemScalarWhereInput[]
    NOT?: MenuItemScalarWhereInput | MenuItemScalarWhereInput[]
    id?: UuidFilter<"MenuItem"> | string
    menuId?: UuidFilter<"MenuItem"> | string
    parentId?: UuidNullableFilter<"MenuItem"> | string | null
    label?: StringFilter<"MenuItem"> | string
    labelI18n?: JsonFilter<"MenuItem">
    icon?: StringNullableFilter<"MenuItem"> | string | null
    variant?: EnumItemVariantFilter<"MenuItem"> | $Enums.ItemVariant
    order?: IntFilter<"MenuItem"> | number
    pageId?: UuidNullableFilter<"MenuItem"> | string | null
    url?: StringNullableFilter<"MenuItem"> | string | null
    createdAt?: DateTimeFilter<"MenuItem"> | Date | string
    updatedAt?: DateTimeFilter<"MenuItem"> | Date | string
  }

  export type FooterColumnItemUpsertWithWhereUniqueWithoutPageInput = {
    where: FooterColumnItemWhereUniqueInput
    update: XOR<FooterColumnItemUpdateWithoutPageInput, FooterColumnItemUncheckedUpdateWithoutPageInput>
    create: XOR<FooterColumnItemCreateWithoutPageInput, FooterColumnItemUncheckedCreateWithoutPageInput>
  }

  export type FooterColumnItemUpdateWithWhereUniqueWithoutPageInput = {
    where: FooterColumnItemWhereUniqueInput
    data: XOR<FooterColumnItemUpdateWithoutPageInput, FooterColumnItemUncheckedUpdateWithoutPageInput>
  }

  export type FooterColumnItemUpdateManyWithWhereWithoutPageInput = {
    where: FooterColumnItemScalarWhereInput
    data: XOR<FooterColumnItemUpdateManyMutationInput, FooterColumnItemUncheckedUpdateManyWithoutPageInput>
  }

  export type FooterColumnItemScalarWhereInput = {
    AND?: FooterColumnItemScalarWhereInput | FooterColumnItemScalarWhereInput[]
    OR?: FooterColumnItemScalarWhereInput[]
    NOT?: FooterColumnItemScalarWhereInput | FooterColumnItemScalarWhereInput[]
    id?: UuidFilter<"FooterColumnItem"> | string
    footerColumnId?: UuidFilter<"FooterColumnItem"> | string
    label?: StringFilter<"FooterColumnItem"> | string
    labelI18n?: JsonFilter<"FooterColumnItem">
    icon?: StringNullableFilter<"FooterColumnItem"> | string | null
    order?: IntFilter<"FooterColumnItem"> | number
    pageId?: UuidNullableFilter<"FooterColumnItem"> | string | null
    url?: StringNullableFilter<"FooterColumnItem"> | string | null
    createdAt?: DateTimeFilter<"FooterColumnItem"> | Date | string
    updatedAt?: DateTimeFilter<"FooterColumnItem"> | Date | string
  }

  export type PostTagCreateWithoutPostInput = {
    tag: TagCreateNestedOneWithoutPostsInput
  }

  export type PostTagUncheckedCreateWithoutPostInput = {
    tagId: string
  }

  export type PostTagCreateOrConnectWithoutPostInput = {
    where: PostTagWhereUniqueInput
    create: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput>
  }

  export type PostTagCreateManyPostInputEnvelope = {
    data: PostTagCreateManyPostInput | PostTagCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutPostsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    pageTexts?: PageTextCreateNestedManyWithoutContributorInput
    pages?: PageCreateNestedManyWithoutAuthorInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    pageTexts?: PageTextUncheckedCreateNestedManyWithoutContributorInput
    pages?: PageUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type MediaCreateWithoutThumbnailForPostsInput = {
    id?: string
    filename: string
    url: string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailForCategory?: CategoryCreateNestedManyWithoutThumbnailInput
    thumbnailForCollections?: CollectionCreateNestedManyWithoutThumbnailInput
    thumbnailForMaps?: MapCreateNestedManyWithoutThumbnailInput
    storageFile?: StorageFileCreateNestedOneWithoutMediaInput
    thumbnailForPages?: PageCreateNestedManyWithoutThumbnailInput
    thumbnailForDataset?: ResearchDatasetCreateNestedManyWithoutThumbnailInput
    thumbnailForSeries?: SeriesCreateNestedManyWithoutThumbnailInput
    thumbnailForVolumes?: VolumeCreateNestedManyWithoutThumbnailInput
  }

  export type MediaUncheckedCreateWithoutThumbnailForPostsInput = {
    id?: string
    filename: string
    url: string
    storageFileId?: string | null
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailForCategory?: CategoryUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForCollections?: CollectionUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForMaps?: MapUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForPages?: PageUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForDataset?: ResearchDatasetUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForSeries?: SeriesUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForVolumes?: VolumeUncheckedCreateNestedManyWithoutThumbnailInput
  }

  export type MediaCreateOrConnectWithoutThumbnailForPostsInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutThumbnailForPostsInput, MediaUncheckedCreateWithoutThumbnailForPostsInput>
  }

  export type CategoryCreateWithoutPostsInput = {
    id?: string
    title: string
    slug: string
    createdAt?: Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForCategoryInput
    layers?: LayerCreateNestedManyWithoutCategoryInput
    maps?: MapCreateNestedManyWithoutCategoryInput
    datasets?: ResearchDatasetCreateNestedManyWithoutCategoryInput
    series?: SeriesCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateWithoutPostsInput = {
    id?: string
    title: string
    slug: string
    thumbnailId?: string | null
    createdAt?: Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    layers?: LayerUncheckedCreateNestedManyWithoutCategoryInput
    maps?: MapUncheckedCreateNestedManyWithoutCategoryInput
    datasets?: ResearchDatasetUncheckedCreateNestedManyWithoutCategoryInput
    series?: SeriesUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryCreateOrConnectWithoutPostsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput>
  }

  export type RegionCreateWithoutPostsInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    artifacts?: ArtifactCreateNestedManyWithoutRegionsInput
    collections?: CollectionCreateNestedManyWithoutRegionsInput
    layers?: LayerCreateNestedManyWithoutRegionsInput
    maps?: MapCreateNestedManyWithoutRegionsInput
    pages?: PageCreateNestedManyWithoutRegionsInput
    datasets?: ResearchDatasetCreateNestedManyWithoutRegionsInput
    series?: SeriesCreateNestedManyWithoutRegionsInput
    volumes?: VolumeCreateNestedManyWithoutRegionsInput
  }

  export type RegionUncheckedCreateWithoutPostsInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutRegionsInput
    collections?: CollectionUncheckedCreateNestedManyWithoutRegionsInput
    layers?: LayerUncheckedCreateNestedManyWithoutRegionsInput
    maps?: MapUncheckedCreateNestedManyWithoutRegionsInput
    pages?: PageUncheckedCreateNestedManyWithoutRegionsInput
    datasets?: ResearchDatasetUncheckedCreateNestedManyWithoutRegionsInput
    series?: SeriesUncheckedCreateNestedManyWithoutRegionsInput
    volumes?: VolumeUncheckedCreateNestedManyWithoutRegionsInput
  }

  export type RegionCreateOrConnectWithoutPostsInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutPostsInput, RegionUncheckedCreateWithoutPostsInput>
  }

  export type PostTagUpsertWithWhereUniqueWithoutPostInput = {
    where: PostTagWhereUniqueInput
    update: XOR<PostTagUpdateWithoutPostInput, PostTagUncheckedUpdateWithoutPostInput>
    create: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput>
  }

  export type PostTagUpdateWithWhereUniqueWithoutPostInput = {
    where: PostTagWhereUniqueInput
    data: XOR<PostTagUpdateWithoutPostInput, PostTagUncheckedUpdateWithoutPostInput>
  }

  export type PostTagUpdateManyWithWhereWithoutPostInput = {
    where: PostTagScalarWhereInput
    data: XOR<PostTagUpdateManyMutationInput, PostTagUncheckedUpdateManyWithoutPostInput>
  }

  export type PostTagScalarWhereInput = {
    AND?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
    OR?: PostTagScalarWhereInput[]
    NOT?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
    postId?: UuidFilter<"PostTag"> | string
    tagId?: UuidFilter<"PostTag"> | string
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    pageTexts?: PageTextUpdateManyWithoutContributorNestedInput
    pages?: PageUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    pageTexts?: PageTextUncheckedUpdateManyWithoutContributorNestedInput
    pages?: PageUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MediaUpsertWithoutThumbnailForPostsInput = {
    update: XOR<MediaUpdateWithoutThumbnailForPostsInput, MediaUncheckedUpdateWithoutThumbnailForPostsInput>
    create: XOR<MediaCreateWithoutThumbnailForPostsInput, MediaUncheckedCreateWithoutThumbnailForPostsInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutThumbnailForPostsInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutThumbnailForPostsInput, MediaUncheckedUpdateWithoutThumbnailForPostsInput>
  }

  export type MediaUpdateWithoutThumbnailForPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailForCategory?: CategoryUpdateManyWithoutThumbnailNestedInput
    thumbnailForCollections?: CollectionUpdateManyWithoutThumbnailNestedInput
    thumbnailForMaps?: MapUpdateManyWithoutThumbnailNestedInput
    storageFile?: StorageFileUpdateOneWithoutMediaNestedInput
    thumbnailForPages?: PageUpdateManyWithoutThumbnailNestedInput
    thumbnailForDataset?: ResearchDatasetUpdateManyWithoutThumbnailNestedInput
    thumbnailForSeries?: SeriesUpdateManyWithoutThumbnailNestedInput
    thumbnailForVolumes?: VolumeUpdateManyWithoutThumbnailNestedInput
  }

  export type MediaUncheckedUpdateWithoutThumbnailForPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    storageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailForCategory?: CategoryUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForCollections?: CollectionUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForMaps?: MapUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForPages?: PageUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForDataset?: ResearchDatasetUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForSeries?: SeriesUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForVolumes?: VolumeUncheckedUpdateManyWithoutThumbnailNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutPostsInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutPostsInput, CategoryUncheckedUpdateWithoutPostsInput>
    create: XOR<CategoryCreateWithoutPostsInput, CategoryUncheckedCreateWithoutPostsInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutPostsInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutPostsInput, CategoryUncheckedUpdateWithoutPostsInput>
  }

  export type CategoryUpdateManyWithWhereWithoutPostsInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutPostsInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: UuidFilter<"Category"> | string
    title?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    thumbnailId?: UuidNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    titleI18n?: JsonFilter<"Category">
  }

  export type RegionUpsertWithWhereUniqueWithoutPostsInput = {
    where: RegionWhereUniqueInput
    update: XOR<RegionUpdateWithoutPostsInput, RegionUncheckedUpdateWithoutPostsInput>
    create: XOR<RegionCreateWithoutPostsInput, RegionUncheckedCreateWithoutPostsInput>
  }

  export type RegionUpdateWithWhereUniqueWithoutPostsInput = {
    where: RegionWhereUniqueInput
    data: XOR<RegionUpdateWithoutPostsInput, RegionUncheckedUpdateWithoutPostsInput>
  }

  export type RegionUpdateManyWithWhereWithoutPostsInput = {
    where: RegionScalarWhereInput
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyWithoutPostsInput>
  }

  export type PostCreateWithoutTagsInput = {
    id?: string
    translationGroupId?: string
    language?: $Enums.AppLanguage
    title: string
    slug: string
    content?: string | null
    sources?: string | null
    excerpt?: string | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    author?: UserCreateNestedOneWithoutPostsInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForPostsInput
    categories?: CategoryCreateNestedManyWithoutPostsInput
    regions?: RegionCreateNestedManyWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutTagsInput = {
    id?: string
    translationGroupId?: string
    language?: $Enums.AppLanguage
    title: string
    slug: string
    content?: string | null
    sources?: string | null
    excerpt?: string | null
    status?: $Enums.ContentStatus
    authorId?: string | null
    thumbnailId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categories?: CategoryUncheckedCreateNestedManyWithoutPostsInput
    regions?: RegionUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostCreateOrConnectWithoutTagsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutPostsInput = {
    id?: string
    slug: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    artifacts?: ArtifactCreateNestedManyWithoutTagsInput
    collections?: CollectionCreateNestedManyWithoutTagsInput
    layers?: LayerCreateNestedManyWithoutTagsInput
    maps?: MapCreateNestedManyWithoutTagsInput
    pages?: PageCreateNestedManyWithoutTagsInput
    series?: SeriesCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutPostsInput = {
    id?: string
    slug: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutTagsInput
    collections?: CollectionUncheckedCreateNestedManyWithoutTagsInput
    layers?: LayerUncheckedCreateNestedManyWithoutTagsInput
    maps?: MapUncheckedCreateNestedManyWithoutTagsInput
    pages?: PageUncheckedCreateNestedManyWithoutTagsInput
    series?: SeriesUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutPostsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
  }

  export type PostUpsertWithoutTagsInput = {
    update: XOR<PostUpdateWithoutTagsInput, PostUncheckedUpdateWithoutTagsInput>
    create: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutTagsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutTagsInput, PostUncheckedUpdateWithoutTagsInput>
  }

  export type PostUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationGroupId?: StringFieldUpdateOperationsInput | string
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneWithoutPostsNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForPostsNestedInput
    categories?: CategoryUpdateManyWithoutPostsNestedInput
    regions?: RegionUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationGroupId?: StringFieldUpdateOperationsInput | string
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: CategoryUncheckedUpdateManyWithoutPostsNestedInput
    regions?: RegionUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type TagUpsertWithoutPostsInput = {
    update: XOR<TagUpdateWithoutPostsInput, TagUncheckedUpdateWithoutPostsInput>
    create: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutPostsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutPostsInput, TagUncheckedUpdateWithoutPostsInput>
  }

  export type TagUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    artifacts?: ArtifactUpdateManyWithoutTagsNestedInput
    collections?: CollectionUpdateManyWithoutTagsNestedInput
    layers?: LayerUpdateManyWithoutTagsNestedInput
    maps?: MapUpdateManyWithoutTagsNestedInput
    pages?: PageUpdateManyWithoutTagsNestedInput
    series?: SeriesUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    artifacts?: ArtifactUncheckedUpdateManyWithoutTagsNestedInput
    collections?: CollectionUncheckedUpdateManyWithoutTagsNestedInput
    layers?: LayerUncheckedUpdateManyWithoutTagsNestedInput
    maps?: MapUncheckedUpdateManyWithoutTagsNestedInput
    pages?: PageUncheckedUpdateManyWithoutTagsNestedInput
    series?: SeriesUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PageTextCreateWithoutContributorInput = {
    id?: string
    content: string
    type?: $Enums.TextType
    language: $Enums.AppLanguage
    textAccuracy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    page: VolumePageCreateNestedOneWithoutTextsInput
  }

  export type PageTextUncheckedCreateWithoutContributorInput = {
    id?: string
    pageId: string
    content: string
    type?: $Enums.TextType
    language: $Enums.AppLanguage
    textAccuracy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageTextCreateOrConnectWithoutContributorInput = {
    where: PageTextWhereUniqueInput
    create: XOR<PageTextCreateWithoutContributorInput, PageTextUncheckedCreateWithoutContributorInput>
  }

  export type PageTextCreateManyContributorInputEnvelope = {
    data: PageTextCreateManyContributorInput | PageTextCreateManyContributorInput[]
    skipDuplicates?: boolean
  }

  export type PageCreateWithoutAuthorInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content?: string | null
    excerpt?: string | null
    sources?: string | null
    citations?: string | null
    language?: $Enums.AppLanguage
    translationGroupId?: string | null
    status?: $Enums.ContentStatus
    metaDescription?: string | null
    metaKeywords?: string | null
    template?: string | null
    menuOrder?: number
    showInMenu?: boolean
    parent?: PageCreateNestedOneWithoutChildrenInput
    children?: PageCreateNestedManyWithoutParentInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForPagesInput
    regions?: RegionCreateNestedManyWithoutPagesInput
    tags?: TagCreateNestedManyWithoutPagesInput
    menuItems?: MenuItemCreateNestedManyWithoutPageInput
    footerItems?: FooterColumnItemCreateNestedManyWithoutPageInput
  }

  export type PageUncheckedCreateWithoutAuthorInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content?: string | null
    excerpt?: string | null
    sources?: string | null
    citations?: string | null
    language?: $Enums.AppLanguage
    translationGroupId?: string | null
    status?: $Enums.ContentStatus
    parentId?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    thumbnailId?: string | null
    template?: string | null
    menuOrder?: number
    showInMenu?: boolean
    children?: PageUncheckedCreateNestedManyWithoutParentInput
    regions?: RegionUncheckedCreateNestedManyWithoutPagesInput
    tags?: TagUncheckedCreateNestedManyWithoutPagesInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutPageInput
    footerItems?: FooterColumnItemUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageCreateOrConnectWithoutAuthorInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutAuthorInput, PageUncheckedCreateWithoutAuthorInput>
  }

  export type PageCreateManyAuthorInputEnvelope = {
    data: PageCreateManyAuthorInput | PageCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutAuthorInput = {
    id?: string
    translationGroupId?: string
    language?: $Enums.AppLanguage
    title: string
    slug: string
    content?: string | null
    sources?: string | null
    excerpt?: string | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: PostTagCreateNestedManyWithoutPostInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForPostsInput
    categories?: CategoryCreateNestedManyWithoutPostsInput
    regions?: RegionCreateNestedManyWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutAuthorInput = {
    id?: string
    translationGroupId?: string
    language?: $Enums.AppLanguage
    title: string
    slug: string
    content?: string | null
    sources?: string | null
    excerpt?: string | null
    status?: $Enums.ContentStatus
    thumbnailId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    categories?: CategoryUncheckedCreateNestedManyWithoutPostsInput
    regions?: RegionUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostCreateOrConnectWithoutAuthorInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostCreateManyAuthorInputEnvelope = {
    data: PostCreateManyAuthorInput | PostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: UuidFilter<"Account"> | string
    userId?: UuidFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type PageTextUpsertWithWhereUniqueWithoutContributorInput = {
    where: PageTextWhereUniqueInput
    update: XOR<PageTextUpdateWithoutContributorInput, PageTextUncheckedUpdateWithoutContributorInput>
    create: XOR<PageTextCreateWithoutContributorInput, PageTextUncheckedCreateWithoutContributorInput>
  }

  export type PageTextUpdateWithWhereUniqueWithoutContributorInput = {
    where: PageTextWhereUniqueInput
    data: XOR<PageTextUpdateWithoutContributorInput, PageTextUncheckedUpdateWithoutContributorInput>
  }

  export type PageTextUpdateManyWithWhereWithoutContributorInput = {
    where: PageTextScalarWhereInput
    data: XOR<PageTextUpdateManyMutationInput, PageTextUncheckedUpdateManyWithoutContributorInput>
  }

  export type PageTextScalarWhereInput = {
    AND?: PageTextScalarWhereInput | PageTextScalarWhereInput[]
    OR?: PageTextScalarWhereInput[]
    NOT?: PageTextScalarWhereInput | PageTextScalarWhereInput[]
    id?: UuidFilter<"PageText"> | string
    pageId?: UuidFilter<"PageText"> | string
    content?: StringFilter<"PageText"> | string
    type?: EnumTextTypeFilter<"PageText"> | $Enums.TextType
    language?: EnumAppLanguageFilter<"PageText"> | $Enums.AppLanguage
    textAccuracy?: IntNullableFilter<"PageText"> | number | null
    contributorId?: UuidNullableFilter<"PageText"> | string | null
    createdAt?: DateTimeFilter<"PageText"> | Date | string
    updatedAt?: DateTimeFilter<"PageText"> | Date | string
  }

  export type PageUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PageWhereUniqueInput
    update: XOR<PageUpdateWithoutAuthorInput, PageUncheckedUpdateWithoutAuthorInput>
    create: XOR<PageCreateWithoutAuthorInput, PageUncheckedCreateWithoutAuthorInput>
  }

  export type PageUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PageWhereUniqueInput
    data: XOR<PageUpdateWithoutAuthorInput, PageUncheckedUpdateWithoutAuthorInput>
  }

  export type PageUpdateManyWithWhereWithoutAuthorInput = {
    where: PageScalarWhereInput
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
  }

  export type PostUpdateManyWithWhereWithoutAuthorInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: UuidFilter<"Post"> | string
    translationGroupId?: UuidFilter<"Post"> | string
    language?: EnumAppLanguageFilter<"Post"> | $Enums.AppLanguage
    title?: StringFilter<"Post"> | string
    slug?: StringFilter<"Post"> | string
    content?: StringNullableFilter<"Post"> | string | null
    sources?: StringNullableFilter<"Post"> | string | null
    excerpt?: StringNullableFilter<"Post"> | string | null
    status?: EnumContentStatusFilter<"Post"> | $Enums.ContentStatus
    authorId?: UuidNullableFilter<"Post"> | string | null
    thumbnailId?: UuidNullableFilter<"Post"> | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: UuidFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: UuidFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    pageTexts?: PageTextCreateNestedManyWithoutContributorInput
    pages?: PageCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    pageTexts?: PageTextUncheckedCreateNestedManyWithoutContributorInput
    pages?: PageUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    pageTexts?: PageTextUpdateManyWithoutContributorNestedInput
    pages?: PageUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    pageTexts?: PageTextUncheckedUpdateManyWithoutContributorNestedInput
    pages?: PageUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    pageTexts?: PageTextCreateNestedManyWithoutContributorInput
    pages?: PageCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    pageTexts?: PageTextUncheckedCreateNestedManyWithoutContributorInput
    pages?: PageUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    pageTexts?: PageTextUpdateManyWithoutContributorNestedInput
    pages?: PageUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    pageTexts?: PageTextUncheckedUpdateManyWithoutContributorNestedInput
    pages?: PageUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type DatasetResourceCreateWithoutDatasetInput = {
    id?: string
    url: string
    isMainFile?: boolean
    createdAt?: Date | string
    name: string
    slug: string
    format?: $Enums.ResouceType
    filename?: string | null
    mimeType?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    map?: MapCreateNestedOneWithoutResourcesInput
  }

  export type DatasetResourceUncheckedCreateWithoutDatasetInput = {
    id?: string
    url: string
    isMainFile?: boolean
    createdAt?: Date | string
    name: string
    slug: string
    format?: $Enums.ResouceType
    filename?: string | null
    mimeType?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    mapId?: string | null
  }

  export type DatasetResourceCreateOrConnectWithoutDatasetInput = {
    where: DatasetResourceWhereUniqueInput
    create: XOR<DatasetResourceCreateWithoutDatasetInput, DatasetResourceUncheckedCreateWithoutDatasetInput>
  }

  export type DatasetResourceCreateManyDatasetInputEnvelope = {
    data: DatasetResourceCreateManyDatasetInput | DatasetResourceCreateManyDatasetInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutDatasetsInput = {
    id?: string
    title: string
    slug: string
    createdAt?: Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForCategoryInput
    layers?: LayerCreateNestedManyWithoutCategoryInput
    maps?: MapCreateNestedManyWithoutCategoryInput
    posts?: PostCreateNestedManyWithoutCategoriesInput
    series?: SeriesCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateWithoutDatasetsInput = {
    id?: string
    title: string
    slug: string
    thumbnailId?: string | null
    createdAt?: Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    layers?: LayerUncheckedCreateNestedManyWithoutCategoryInput
    maps?: MapUncheckedCreateNestedManyWithoutCategoryInput
    posts?: PostUncheckedCreateNestedManyWithoutCategoriesInput
    series?: SeriesUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryCreateOrConnectWithoutDatasetsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutDatasetsInput, CategoryUncheckedCreateWithoutDatasetsInput>
  }

  export type MediaCreateWithoutThumbnailForDatasetInput = {
    id?: string
    filename: string
    url: string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailForCategory?: CategoryCreateNestedManyWithoutThumbnailInput
    thumbnailForCollections?: CollectionCreateNestedManyWithoutThumbnailInput
    thumbnailForMaps?: MapCreateNestedManyWithoutThumbnailInput
    storageFile?: StorageFileCreateNestedOneWithoutMediaInput
    thumbnailForPages?: PageCreateNestedManyWithoutThumbnailInput
    thumbnailForPosts?: PostCreateNestedManyWithoutThumbnailInput
    thumbnailForSeries?: SeriesCreateNestedManyWithoutThumbnailInput
    thumbnailForVolumes?: VolumeCreateNestedManyWithoutThumbnailInput
  }

  export type MediaUncheckedCreateWithoutThumbnailForDatasetInput = {
    id?: string
    filename: string
    url: string
    storageFileId?: string | null
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailForCategory?: CategoryUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForCollections?: CollectionUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForMaps?: MapUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForPages?: PageUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForPosts?: PostUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForSeries?: SeriesUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForVolumes?: VolumeUncheckedCreateNestedManyWithoutThumbnailInput
  }

  export type MediaCreateOrConnectWithoutThumbnailForDatasetInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutThumbnailForDatasetInput, MediaUncheckedCreateWithoutThumbnailForDatasetInput>
  }

  export type RegionCreateWithoutDatasetsInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    artifacts?: ArtifactCreateNestedManyWithoutRegionsInput
    collections?: CollectionCreateNestedManyWithoutRegionsInput
    layers?: LayerCreateNestedManyWithoutRegionsInput
    maps?: MapCreateNestedManyWithoutRegionsInput
    pages?: PageCreateNestedManyWithoutRegionsInput
    posts?: PostCreateNestedManyWithoutRegionsInput
    series?: SeriesCreateNestedManyWithoutRegionsInput
    volumes?: VolumeCreateNestedManyWithoutRegionsInput
  }

  export type RegionUncheckedCreateWithoutDatasetsInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutRegionsInput
    collections?: CollectionUncheckedCreateNestedManyWithoutRegionsInput
    layers?: LayerUncheckedCreateNestedManyWithoutRegionsInput
    maps?: MapUncheckedCreateNestedManyWithoutRegionsInput
    pages?: PageUncheckedCreateNestedManyWithoutRegionsInput
    posts?: PostUncheckedCreateNestedManyWithoutRegionsInput
    series?: SeriesUncheckedCreateNestedManyWithoutRegionsInput
    volumes?: VolumeUncheckedCreateNestedManyWithoutRegionsInput
  }

  export type RegionCreateOrConnectWithoutDatasetsInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutDatasetsInput, RegionUncheckedCreateWithoutDatasetsInput>
  }

  export type DatasetResourceUpsertWithWhereUniqueWithoutDatasetInput = {
    where: DatasetResourceWhereUniqueInput
    update: XOR<DatasetResourceUpdateWithoutDatasetInput, DatasetResourceUncheckedUpdateWithoutDatasetInput>
    create: XOR<DatasetResourceCreateWithoutDatasetInput, DatasetResourceUncheckedCreateWithoutDatasetInput>
  }

  export type DatasetResourceUpdateWithWhereUniqueWithoutDatasetInput = {
    where: DatasetResourceWhereUniqueInput
    data: XOR<DatasetResourceUpdateWithoutDatasetInput, DatasetResourceUncheckedUpdateWithoutDatasetInput>
  }

  export type DatasetResourceUpdateManyWithWhereWithoutDatasetInput = {
    where: DatasetResourceScalarWhereInput
    data: XOR<DatasetResourceUpdateManyMutationInput, DatasetResourceUncheckedUpdateManyWithoutDatasetInput>
  }

  export type DatasetResourceScalarWhereInput = {
    AND?: DatasetResourceScalarWhereInput | DatasetResourceScalarWhereInput[]
    OR?: DatasetResourceScalarWhereInput[]
    NOT?: DatasetResourceScalarWhereInput | DatasetResourceScalarWhereInput[]
    id?: UuidFilter<"DatasetResource"> | string
    datasetId?: UuidNullableFilter<"DatasetResource"> | string | null
    url?: StringFilter<"DatasetResource"> | string
    isMainFile?: BoolFilter<"DatasetResource"> | boolean
    createdAt?: DateTimeFilter<"DatasetResource"> | Date | string
    name?: StringFilter<"DatasetResource"> | string
    slug?: StringFilter<"DatasetResource"> | string
    format?: EnumResouceTypeFilter<"DatasetResource"> | $Enums.ResouceType
    filename?: StringNullableFilter<"DatasetResource"> | string | null
    mimeType?: StringNullableFilter<"DatasetResource"> | string | null
    excerptI18n?: JsonNullableFilter<"DatasetResource">
    mapId?: UuidNullableFilter<"DatasetResource"> | string | null
  }

  export type CategoryUpsertWithoutDatasetsInput = {
    update: XOR<CategoryUpdateWithoutDatasetsInput, CategoryUncheckedUpdateWithoutDatasetsInput>
    create: XOR<CategoryCreateWithoutDatasetsInput, CategoryUncheckedCreateWithoutDatasetsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutDatasetsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutDatasetsInput, CategoryUncheckedUpdateWithoutDatasetsInput>
  }

  export type CategoryUpdateWithoutDatasetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    thumbnail?: MediaUpdateOneWithoutThumbnailForCategoryNestedInput
    layers?: LayerUpdateManyWithoutCategoryNestedInput
    maps?: MapUpdateManyWithoutCategoryNestedInput
    posts?: PostUpdateManyWithoutCategoriesNestedInput
    series?: SeriesUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateWithoutDatasetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    layers?: LayerUncheckedUpdateManyWithoutCategoryNestedInput
    maps?: MapUncheckedUpdateManyWithoutCategoryNestedInput
    posts?: PostUncheckedUpdateManyWithoutCategoriesNestedInput
    series?: SeriesUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type MediaUpsertWithoutThumbnailForDatasetInput = {
    update: XOR<MediaUpdateWithoutThumbnailForDatasetInput, MediaUncheckedUpdateWithoutThumbnailForDatasetInput>
    create: XOR<MediaCreateWithoutThumbnailForDatasetInput, MediaUncheckedCreateWithoutThumbnailForDatasetInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutThumbnailForDatasetInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutThumbnailForDatasetInput, MediaUncheckedUpdateWithoutThumbnailForDatasetInput>
  }

  export type MediaUpdateWithoutThumbnailForDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailForCategory?: CategoryUpdateManyWithoutThumbnailNestedInput
    thumbnailForCollections?: CollectionUpdateManyWithoutThumbnailNestedInput
    thumbnailForMaps?: MapUpdateManyWithoutThumbnailNestedInput
    storageFile?: StorageFileUpdateOneWithoutMediaNestedInput
    thumbnailForPages?: PageUpdateManyWithoutThumbnailNestedInput
    thumbnailForPosts?: PostUpdateManyWithoutThumbnailNestedInput
    thumbnailForSeries?: SeriesUpdateManyWithoutThumbnailNestedInput
    thumbnailForVolumes?: VolumeUpdateManyWithoutThumbnailNestedInput
  }

  export type MediaUncheckedUpdateWithoutThumbnailForDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    storageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailForCategory?: CategoryUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForCollections?: CollectionUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForMaps?: MapUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForPages?: PageUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForPosts?: PostUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForSeries?: SeriesUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForVolumes?: VolumeUncheckedUpdateManyWithoutThumbnailNestedInput
  }

  export type RegionUpsertWithWhereUniqueWithoutDatasetsInput = {
    where: RegionWhereUniqueInput
    update: XOR<RegionUpdateWithoutDatasetsInput, RegionUncheckedUpdateWithoutDatasetsInput>
    create: XOR<RegionCreateWithoutDatasetsInput, RegionUncheckedCreateWithoutDatasetsInput>
  }

  export type RegionUpdateWithWhereUniqueWithoutDatasetsInput = {
    where: RegionWhereUniqueInput
    data: XOR<RegionUpdateWithoutDatasetsInput, RegionUncheckedUpdateWithoutDatasetsInput>
  }

  export type RegionUpdateManyWithWhereWithoutDatasetsInput = {
    where: RegionScalarWhereInput
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyWithoutDatasetsInput>
  }

  export type ResearchDatasetCreateWithoutResourcesInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ContentStatus
    maturity?: $Enums.DataMaturity
    version?: string | null
    license?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    title?: string
    citationText?: string | null
    codebookText?: string | null
    maxYear?: number | null
    minYear?: number | null
    sources?: string | null
    isVisible?: boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    category?: CategoryCreateNestedOneWithoutDatasetsInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForDatasetInput
    regions?: RegionCreateNestedManyWithoutDatasetsInput
  }

  export type ResearchDatasetUncheckedCreateWithoutResourcesInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ContentStatus
    maturity?: $Enums.DataMaturity
    version?: string | null
    license?: string | null
    thumbnailId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    title?: string
    categoryId?: string | null
    citationText?: string | null
    codebookText?: string | null
    maxYear?: number | null
    minYear?: number | null
    sources?: string | null
    isVisible?: boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    regions?: RegionUncheckedCreateNestedManyWithoutDatasetsInput
  }

  export type ResearchDatasetCreateOrConnectWithoutResourcesInput = {
    where: ResearchDatasetWhereUniqueInput
    create: XOR<ResearchDatasetCreateWithoutResourcesInput, ResearchDatasetUncheckedCreateWithoutResourcesInput>
  }

  export type MapCreateWithoutResourcesInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: number | null
    version?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    period?: string | null
    title?: string
    yearMax?: number | null
    yearMin?: number | null
    status?: $Enums.ContentStatus
    layers?: MapLayerAssociationCreateNestedManyWithoutMapInput
    category?: CategoryCreateNestedOneWithoutMapsInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForMapsInput
    regions?: RegionCreateNestedManyWithoutMapsInput
    tags?: TagCreateNestedManyWithoutMapsInput
  }

  export type MapUncheckedCreateWithoutResourcesInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: number | null
    version?: string | null
    thumbnailId?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    period?: string | null
    title?: string
    yearMax?: number | null
    yearMin?: number | null
    categoryId?: string | null
    status?: $Enums.ContentStatus
    layers?: MapLayerAssociationUncheckedCreateNestedManyWithoutMapInput
    regions?: RegionUncheckedCreateNestedManyWithoutMapsInput
    tags?: TagUncheckedCreateNestedManyWithoutMapsInput
  }

  export type MapCreateOrConnectWithoutResourcesInput = {
    where: MapWhereUniqueInput
    create: XOR<MapCreateWithoutResourcesInput, MapUncheckedCreateWithoutResourcesInput>
  }

  export type ResearchDatasetUpsertWithoutResourcesInput = {
    update: XOR<ResearchDatasetUpdateWithoutResourcesInput, ResearchDatasetUncheckedUpdateWithoutResourcesInput>
    create: XOR<ResearchDatasetCreateWithoutResourcesInput, ResearchDatasetUncheckedCreateWithoutResourcesInput>
    where?: ResearchDatasetWhereInput
  }

  export type ResearchDatasetUpdateToOneWithWhereWithoutResourcesInput = {
    where?: ResearchDatasetWhereInput
    data: XOR<ResearchDatasetUpdateWithoutResourcesInput, ResearchDatasetUncheckedUpdateWithoutResourcesInput>
  }

  export type ResearchDatasetUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    version?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    category?: CategoryUpdateOneWithoutDatasetsNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForDatasetNestedInput
    regions?: RegionUpdateManyWithoutDatasetsNestedInput
  }

  export type ResearchDatasetUncheckedUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    version?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    regions?: RegionUncheckedUpdateManyWithoutDatasetsNestedInput
  }

  export type MapUpsertWithoutResourcesInput = {
    update: XOR<MapUpdateWithoutResourcesInput, MapUncheckedUpdateWithoutResourcesInput>
    create: XOR<MapCreateWithoutResourcesInput, MapUncheckedCreateWithoutResourcesInput>
    where?: MapWhereInput
  }

  export type MapUpdateToOneWithWhereWithoutResourcesInput = {
    where?: MapWhereInput
    data: XOR<MapUpdateWithoutResourcesInput, MapUncheckedUpdateWithoutResourcesInput>
  }

  export type MapUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    layers?: MapLayerAssociationUpdateManyWithoutMapNestedInput
    category?: CategoryUpdateOneWithoutMapsNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForMapsNestedInput
    regions?: RegionUpdateManyWithoutMapsNestedInput
    tags?: TagUpdateManyWithoutMapsNestedInput
  }

  export type MapUncheckedUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    layers?: MapLayerAssociationUncheckedUpdateManyWithoutMapNestedInput
    regions?: RegionUncheckedUpdateManyWithoutMapsNestedInput
    tags?: TagUncheckedUpdateManyWithoutMapsNestedInput
  }

  export type DatasetResourceCreateWithoutMapInput = {
    id?: string
    url: string
    isMainFile?: boolean
    createdAt?: Date | string
    name: string
    slug: string
    format?: $Enums.ResouceType
    filename?: string | null
    mimeType?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    dataset?: ResearchDatasetCreateNestedOneWithoutResourcesInput
  }

  export type DatasetResourceUncheckedCreateWithoutMapInput = {
    id?: string
    datasetId?: string | null
    url: string
    isMainFile?: boolean
    createdAt?: Date | string
    name: string
    slug: string
    format?: $Enums.ResouceType
    filename?: string | null
    mimeType?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DatasetResourceCreateOrConnectWithoutMapInput = {
    where: DatasetResourceWhereUniqueInput
    create: XOR<DatasetResourceCreateWithoutMapInput, DatasetResourceUncheckedCreateWithoutMapInput>
  }

  export type DatasetResourceCreateManyMapInputEnvelope = {
    data: DatasetResourceCreateManyMapInput | DatasetResourceCreateManyMapInput[]
    skipDuplicates?: boolean
  }

  export type MapLayerAssociationCreateWithoutMapInput = {
    id?: string
    zIndex?: number
    isVisible?: boolean
    isVisibleByDefault?: boolean
    styleOverride?: NullableJsonNullValueInput | InputJsonValue
    interactionConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    layer: LayerCreateNestedOneWithoutMapsInput
  }

  export type MapLayerAssociationUncheckedCreateWithoutMapInput = {
    id?: string
    layerId: string
    zIndex?: number
    isVisible?: boolean
    isVisibleByDefault?: boolean
    styleOverride?: NullableJsonNullValueInput | InputJsonValue
    interactionConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MapLayerAssociationCreateOrConnectWithoutMapInput = {
    where: MapLayerAssociationWhereUniqueInput
    create: XOR<MapLayerAssociationCreateWithoutMapInput, MapLayerAssociationUncheckedCreateWithoutMapInput>
  }

  export type MapLayerAssociationCreateManyMapInputEnvelope = {
    data: MapLayerAssociationCreateManyMapInput | MapLayerAssociationCreateManyMapInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutMapsInput = {
    id?: string
    title: string
    slug: string
    createdAt?: Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForCategoryInput
    layers?: LayerCreateNestedManyWithoutCategoryInput
    datasets?: ResearchDatasetCreateNestedManyWithoutCategoryInput
    posts?: PostCreateNestedManyWithoutCategoriesInput
    series?: SeriesCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateWithoutMapsInput = {
    id?: string
    title: string
    slug: string
    thumbnailId?: string | null
    createdAt?: Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    layers?: LayerUncheckedCreateNestedManyWithoutCategoryInput
    datasets?: ResearchDatasetUncheckedCreateNestedManyWithoutCategoryInput
    posts?: PostUncheckedCreateNestedManyWithoutCategoriesInput
    series?: SeriesUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryCreateOrConnectWithoutMapsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutMapsInput, CategoryUncheckedCreateWithoutMapsInput>
  }

  export type MediaCreateWithoutThumbnailForMapsInput = {
    id?: string
    filename: string
    url: string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailForCategory?: CategoryCreateNestedManyWithoutThumbnailInput
    thumbnailForCollections?: CollectionCreateNestedManyWithoutThumbnailInput
    storageFile?: StorageFileCreateNestedOneWithoutMediaInput
    thumbnailForPages?: PageCreateNestedManyWithoutThumbnailInput
    thumbnailForPosts?: PostCreateNestedManyWithoutThumbnailInput
    thumbnailForDataset?: ResearchDatasetCreateNestedManyWithoutThumbnailInput
    thumbnailForSeries?: SeriesCreateNestedManyWithoutThumbnailInput
    thumbnailForVolumes?: VolumeCreateNestedManyWithoutThumbnailInput
  }

  export type MediaUncheckedCreateWithoutThumbnailForMapsInput = {
    id?: string
    filename: string
    url: string
    storageFileId?: string | null
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailForCategory?: CategoryUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForCollections?: CollectionUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForPages?: PageUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForPosts?: PostUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForDataset?: ResearchDatasetUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForSeries?: SeriesUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForVolumes?: VolumeUncheckedCreateNestedManyWithoutThumbnailInput
  }

  export type MediaCreateOrConnectWithoutThumbnailForMapsInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutThumbnailForMapsInput, MediaUncheckedCreateWithoutThumbnailForMapsInput>
  }

  export type RegionCreateWithoutMapsInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    artifacts?: ArtifactCreateNestedManyWithoutRegionsInput
    collections?: CollectionCreateNestedManyWithoutRegionsInput
    layers?: LayerCreateNestedManyWithoutRegionsInput
    pages?: PageCreateNestedManyWithoutRegionsInput
    posts?: PostCreateNestedManyWithoutRegionsInput
    datasets?: ResearchDatasetCreateNestedManyWithoutRegionsInput
    series?: SeriesCreateNestedManyWithoutRegionsInput
    volumes?: VolumeCreateNestedManyWithoutRegionsInput
  }

  export type RegionUncheckedCreateWithoutMapsInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutRegionsInput
    collections?: CollectionUncheckedCreateNestedManyWithoutRegionsInput
    layers?: LayerUncheckedCreateNestedManyWithoutRegionsInput
    pages?: PageUncheckedCreateNestedManyWithoutRegionsInput
    posts?: PostUncheckedCreateNestedManyWithoutRegionsInput
    datasets?: ResearchDatasetUncheckedCreateNestedManyWithoutRegionsInput
    series?: SeriesUncheckedCreateNestedManyWithoutRegionsInput
    volumes?: VolumeUncheckedCreateNestedManyWithoutRegionsInput
  }

  export type RegionCreateOrConnectWithoutMapsInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutMapsInput, RegionUncheckedCreateWithoutMapsInput>
  }

  export type TagCreateWithoutMapsInput = {
    id?: string
    slug: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    posts?: PostTagCreateNestedManyWithoutTagInput
    artifacts?: ArtifactCreateNestedManyWithoutTagsInput
    collections?: CollectionCreateNestedManyWithoutTagsInput
    layers?: LayerCreateNestedManyWithoutTagsInput
    pages?: PageCreateNestedManyWithoutTagsInput
    series?: SeriesCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutMapsInput = {
    id?: string
    slug: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    posts?: PostTagUncheckedCreateNestedManyWithoutTagInput
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutTagsInput
    collections?: CollectionUncheckedCreateNestedManyWithoutTagsInput
    layers?: LayerUncheckedCreateNestedManyWithoutTagsInput
    pages?: PageUncheckedCreateNestedManyWithoutTagsInput
    series?: SeriesUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutMapsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutMapsInput, TagUncheckedCreateWithoutMapsInput>
  }

  export type DatasetResourceUpsertWithWhereUniqueWithoutMapInput = {
    where: DatasetResourceWhereUniqueInput
    update: XOR<DatasetResourceUpdateWithoutMapInput, DatasetResourceUncheckedUpdateWithoutMapInput>
    create: XOR<DatasetResourceCreateWithoutMapInput, DatasetResourceUncheckedCreateWithoutMapInput>
  }

  export type DatasetResourceUpdateWithWhereUniqueWithoutMapInput = {
    where: DatasetResourceWhereUniqueInput
    data: XOR<DatasetResourceUpdateWithoutMapInput, DatasetResourceUncheckedUpdateWithoutMapInput>
  }

  export type DatasetResourceUpdateManyWithWhereWithoutMapInput = {
    where: DatasetResourceScalarWhereInput
    data: XOR<DatasetResourceUpdateManyMutationInput, DatasetResourceUncheckedUpdateManyWithoutMapInput>
  }

  export type MapLayerAssociationUpsertWithWhereUniqueWithoutMapInput = {
    where: MapLayerAssociationWhereUniqueInput
    update: XOR<MapLayerAssociationUpdateWithoutMapInput, MapLayerAssociationUncheckedUpdateWithoutMapInput>
    create: XOR<MapLayerAssociationCreateWithoutMapInput, MapLayerAssociationUncheckedCreateWithoutMapInput>
  }

  export type MapLayerAssociationUpdateWithWhereUniqueWithoutMapInput = {
    where: MapLayerAssociationWhereUniqueInput
    data: XOR<MapLayerAssociationUpdateWithoutMapInput, MapLayerAssociationUncheckedUpdateWithoutMapInput>
  }

  export type MapLayerAssociationUpdateManyWithWhereWithoutMapInput = {
    where: MapLayerAssociationScalarWhereInput
    data: XOR<MapLayerAssociationUpdateManyMutationInput, MapLayerAssociationUncheckedUpdateManyWithoutMapInput>
  }

  export type MapLayerAssociationScalarWhereInput = {
    AND?: MapLayerAssociationScalarWhereInput | MapLayerAssociationScalarWhereInput[]
    OR?: MapLayerAssociationScalarWhereInput[]
    NOT?: MapLayerAssociationScalarWhereInput | MapLayerAssociationScalarWhereInput[]
    id?: UuidFilter<"MapLayerAssociation"> | string
    mapId?: UuidFilter<"MapLayerAssociation"> | string
    layerId?: UuidFilter<"MapLayerAssociation"> | string
    zIndex?: IntFilter<"MapLayerAssociation"> | number
    isVisible?: BoolFilter<"MapLayerAssociation"> | boolean
    isVisibleByDefault?: BoolFilter<"MapLayerAssociation"> | boolean
    styleOverride?: JsonNullableFilter<"MapLayerAssociation">
    interactionConfig?: JsonNullableFilter<"MapLayerAssociation">
    createdAt?: DateTimeFilter<"MapLayerAssociation"> | Date | string
  }

  export type CategoryUpsertWithoutMapsInput = {
    update: XOR<CategoryUpdateWithoutMapsInput, CategoryUncheckedUpdateWithoutMapsInput>
    create: XOR<CategoryCreateWithoutMapsInput, CategoryUncheckedCreateWithoutMapsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutMapsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutMapsInput, CategoryUncheckedUpdateWithoutMapsInput>
  }

  export type CategoryUpdateWithoutMapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    thumbnail?: MediaUpdateOneWithoutThumbnailForCategoryNestedInput
    layers?: LayerUpdateManyWithoutCategoryNestedInput
    datasets?: ResearchDatasetUpdateManyWithoutCategoryNestedInput
    posts?: PostUpdateManyWithoutCategoriesNestedInput
    series?: SeriesUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateWithoutMapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    layers?: LayerUncheckedUpdateManyWithoutCategoryNestedInput
    datasets?: ResearchDatasetUncheckedUpdateManyWithoutCategoryNestedInput
    posts?: PostUncheckedUpdateManyWithoutCategoriesNestedInput
    series?: SeriesUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type MediaUpsertWithoutThumbnailForMapsInput = {
    update: XOR<MediaUpdateWithoutThumbnailForMapsInput, MediaUncheckedUpdateWithoutThumbnailForMapsInput>
    create: XOR<MediaCreateWithoutThumbnailForMapsInput, MediaUncheckedCreateWithoutThumbnailForMapsInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutThumbnailForMapsInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutThumbnailForMapsInput, MediaUncheckedUpdateWithoutThumbnailForMapsInput>
  }

  export type MediaUpdateWithoutThumbnailForMapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailForCategory?: CategoryUpdateManyWithoutThumbnailNestedInput
    thumbnailForCollections?: CollectionUpdateManyWithoutThumbnailNestedInput
    storageFile?: StorageFileUpdateOneWithoutMediaNestedInput
    thumbnailForPages?: PageUpdateManyWithoutThumbnailNestedInput
    thumbnailForPosts?: PostUpdateManyWithoutThumbnailNestedInput
    thumbnailForDataset?: ResearchDatasetUpdateManyWithoutThumbnailNestedInput
    thumbnailForSeries?: SeriesUpdateManyWithoutThumbnailNestedInput
    thumbnailForVolumes?: VolumeUpdateManyWithoutThumbnailNestedInput
  }

  export type MediaUncheckedUpdateWithoutThumbnailForMapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    storageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailForCategory?: CategoryUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForCollections?: CollectionUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForPages?: PageUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForPosts?: PostUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForDataset?: ResearchDatasetUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForSeries?: SeriesUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForVolumes?: VolumeUncheckedUpdateManyWithoutThumbnailNestedInput
  }

  export type RegionUpsertWithWhereUniqueWithoutMapsInput = {
    where: RegionWhereUniqueInput
    update: XOR<RegionUpdateWithoutMapsInput, RegionUncheckedUpdateWithoutMapsInput>
    create: XOR<RegionCreateWithoutMapsInput, RegionUncheckedCreateWithoutMapsInput>
  }

  export type RegionUpdateWithWhereUniqueWithoutMapsInput = {
    where: RegionWhereUniqueInput
    data: XOR<RegionUpdateWithoutMapsInput, RegionUncheckedUpdateWithoutMapsInput>
  }

  export type RegionUpdateManyWithWhereWithoutMapsInput = {
    where: RegionScalarWhereInput
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyWithoutMapsInput>
  }

  export type TagUpsertWithWhereUniqueWithoutMapsInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutMapsInput, TagUncheckedUpdateWithoutMapsInput>
    create: XOR<TagCreateWithoutMapsInput, TagUncheckedCreateWithoutMapsInput>
  }

  export type TagUpdateWithWhereUniqueWithoutMapsInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutMapsInput, TagUncheckedUpdateWithoutMapsInput>
  }

  export type TagUpdateManyWithWhereWithoutMapsInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutMapsInput>
  }

  export type CategoryCreateWithoutLayersInput = {
    id?: string
    title: string
    slug: string
    createdAt?: Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForCategoryInput
    maps?: MapCreateNestedManyWithoutCategoryInput
    datasets?: ResearchDatasetCreateNestedManyWithoutCategoryInput
    posts?: PostCreateNestedManyWithoutCategoriesInput
    series?: SeriesCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateWithoutLayersInput = {
    id?: string
    title: string
    slug: string
    thumbnailId?: string | null
    createdAt?: Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    maps?: MapUncheckedCreateNestedManyWithoutCategoryInput
    datasets?: ResearchDatasetUncheckedCreateNestedManyWithoutCategoryInput
    posts?: PostUncheckedCreateNestedManyWithoutCategoriesInput
    series?: SeriesUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryCreateOrConnectWithoutLayersInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutLayersInput, CategoryUncheckedCreateWithoutLayersInput>
  }

  export type MapLayerAssociationCreateWithoutLayerInput = {
    id?: string
    zIndex?: number
    isVisible?: boolean
    isVisibleByDefault?: boolean
    styleOverride?: NullableJsonNullValueInput | InputJsonValue
    interactionConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    map: MapCreateNestedOneWithoutLayersInput
  }

  export type MapLayerAssociationUncheckedCreateWithoutLayerInput = {
    id?: string
    mapId: string
    zIndex?: number
    isVisible?: boolean
    isVisibleByDefault?: boolean
    styleOverride?: NullableJsonNullValueInput | InputJsonValue
    interactionConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MapLayerAssociationCreateOrConnectWithoutLayerInput = {
    where: MapLayerAssociationWhereUniqueInput
    create: XOR<MapLayerAssociationCreateWithoutLayerInput, MapLayerAssociationUncheckedCreateWithoutLayerInput>
  }

  export type MapLayerAssociationCreateManyLayerInputEnvelope = {
    data: MapLayerAssociationCreateManyLayerInput | MapLayerAssociationCreateManyLayerInput[]
    skipDuplicates?: boolean
  }

  export type RegionCreateWithoutLayersInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    artifacts?: ArtifactCreateNestedManyWithoutRegionsInput
    collections?: CollectionCreateNestedManyWithoutRegionsInput
    maps?: MapCreateNestedManyWithoutRegionsInput
    pages?: PageCreateNestedManyWithoutRegionsInput
    posts?: PostCreateNestedManyWithoutRegionsInput
    datasets?: ResearchDatasetCreateNestedManyWithoutRegionsInput
    series?: SeriesCreateNestedManyWithoutRegionsInput
    volumes?: VolumeCreateNestedManyWithoutRegionsInput
  }

  export type RegionUncheckedCreateWithoutLayersInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutRegionsInput
    collections?: CollectionUncheckedCreateNestedManyWithoutRegionsInput
    maps?: MapUncheckedCreateNestedManyWithoutRegionsInput
    pages?: PageUncheckedCreateNestedManyWithoutRegionsInput
    posts?: PostUncheckedCreateNestedManyWithoutRegionsInput
    datasets?: ResearchDatasetUncheckedCreateNestedManyWithoutRegionsInput
    series?: SeriesUncheckedCreateNestedManyWithoutRegionsInput
    volumes?: VolumeUncheckedCreateNestedManyWithoutRegionsInput
  }

  export type RegionCreateOrConnectWithoutLayersInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutLayersInput, RegionUncheckedCreateWithoutLayersInput>
  }

  export type TagCreateWithoutLayersInput = {
    id?: string
    slug: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    posts?: PostTagCreateNestedManyWithoutTagInput
    artifacts?: ArtifactCreateNestedManyWithoutTagsInput
    collections?: CollectionCreateNestedManyWithoutTagsInput
    maps?: MapCreateNestedManyWithoutTagsInput
    pages?: PageCreateNestedManyWithoutTagsInput
    series?: SeriesCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutLayersInput = {
    id?: string
    slug: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    posts?: PostTagUncheckedCreateNestedManyWithoutTagInput
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutTagsInput
    collections?: CollectionUncheckedCreateNestedManyWithoutTagsInput
    maps?: MapUncheckedCreateNestedManyWithoutTagsInput
    pages?: PageUncheckedCreateNestedManyWithoutTagsInput
    series?: SeriesUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutLayersInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutLayersInput, TagUncheckedCreateWithoutLayersInput>
  }

  export type CategoryUpsertWithoutLayersInput = {
    update: XOR<CategoryUpdateWithoutLayersInput, CategoryUncheckedUpdateWithoutLayersInput>
    create: XOR<CategoryCreateWithoutLayersInput, CategoryUncheckedCreateWithoutLayersInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutLayersInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutLayersInput, CategoryUncheckedUpdateWithoutLayersInput>
  }

  export type CategoryUpdateWithoutLayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    thumbnail?: MediaUpdateOneWithoutThumbnailForCategoryNestedInput
    maps?: MapUpdateManyWithoutCategoryNestedInput
    datasets?: ResearchDatasetUpdateManyWithoutCategoryNestedInput
    posts?: PostUpdateManyWithoutCategoriesNestedInput
    series?: SeriesUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateWithoutLayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    maps?: MapUncheckedUpdateManyWithoutCategoryNestedInput
    datasets?: ResearchDatasetUncheckedUpdateManyWithoutCategoryNestedInput
    posts?: PostUncheckedUpdateManyWithoutCategoriesNestedInput
    series?: SeriesUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type MapLayerAssociationUpsertWithWhereUniqueWithoutLayerInput = {
    where: MapLayerAssociationWhereUniqueInput
    update: XOR<MapLayerAssociationUpdateWithoutLayerInput, MapLayerAssociationUncheckedUpdateWithoutLayerInput>
    create: XOR<MapLayerAssociationCreateWithoutLayerInput, MapLayerAssociationUncheckedCreateWithoutLayerInput>
  }

  export type MapLayerAssociationUpdateWithWhereUniqueWithoutLayerInput = {
    where: MapLayerAssociationWhereUniqueInput
    data: XOR<MapLayerAssociationUpdateWithoutLayerInput, MapLayerAssociationUncheckedUpdateWithoutLayerInput>
  }

  export type MapLayerAssociationUpdateManyWithWhereWithoutLayerInput = {
    where: MapLayerAssociationScalarWhereInput
    data: XOR<MapLayerAssociationUpdateManyMutationInput, MapLayerAssociationUncheckedUpdateManyWithoutLayerInput>
  }

  export type RegionUpsertWithWhereUniqueWithoutLayersInput = {
    where: RegionWhereUniqueInput
    update: XOR<RegionUpdateWithoutLayersInput, RegionUncheckedUpdateWithoutLayersInput>
    create: XOR<RegionCreateWithoutLayersInput, RegionUncheckedCreateWithoutLayersInput>
  }

  export type RegionUpdateWithWhereUniqueWithoutLayersInput = {
    where: RegionWhereUniqueInput
    data: XOR<RegionUpdateWithoutLayersInput, RegionUncheckedUpdateWithoutLayersInput>
  }

  export type RegionUpdateManyWithWhereWithoutLayersInput = {
    where: RegionScalarWhereInput
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyWithoutLayersInput>
  }

  export type TagUpsertWithWhereUniqueWithoutLayersInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutLayersInput, TagUncheckedUpdateWithoutLayersInput>
    create: XOR<TagCreateWithoutLayersInput, TagUncheckedCreateWithoutLayersInput>
  }

  export type TagUpdateWithWhereUniqueWithoutLayersInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutLayersInput, TagUncheckedUpdateWithoutLayersInput>
  }

  export type TagUpdateManyWithWhereWithoutLayersInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutLayersInput>
  }

  export type LayerCreateWithoutMapsInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: string | null
    status?: $Enums.ContentStatus
    version?: string | null
    type?: $Enums.LayerType
    citationText?: string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: string | null
    maturity?: $Enums.DataMaturity
    minYear?: number | null
    maxYear?: number | null
    sourceType?: $Enums.LayerSourceType
    sourceUrl?: string | null
    downloadUrl?: string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutLayersInput
    regions?: RegionCreateNestedManyWithoutLayersInput
    tags?: TagCreateNestedManyWithoutLayersInput
  }

  export type LayerUncheckedCreateWithoutMapsInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: string | null
    status?: $Enums.ContentStatus
    version?: string | null
    categoryId?: string | null
    type?: $Enums.LayerType
    citationText?: string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: string | null
    maturity?: $Enums.DataMaturity
    minYear?: number | null
    maxYear?: number | null
    sourceType?: $Enums.LayerSourceType
    sourceUrl?: string | null
    downloadUrl?: string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    regions?: RegionUncheckedCreateNestedManyWithoutLayersInput
    tags?: TagUncheckedCreateNestedManyWithoutLayersInput
  }

  export type LayerCreateOrConnectWithoutMapsInput = {
    where: LayerWhereUniqueInput
    create: XOR<LayerCreateWithoutMapsInput, LayerUncheckedCreateWithoutMapsInput>
  }

  export type MapCreateWithoutLayersInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: number | null
    version?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    period?: string | null
    title?: string
    yearMax?: number | null
    yearMin?: number | null
    status?: $Enums.ContentStatus
    resources?: DatasetResourceCreateNestedManyWithoutMapInput
    category?: CategoryCreateNestedOneWithoutMapsInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForMapsInput
    regions?: RegionCreateNestedManyWithoutMapsInput
    tags?: TagCreateNestedManyWithoutMapsInput
  }

  export type MapUncheckedCreateWithoutLayersInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: number | null
    version?: string | null
    thumbnailId?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    period?: string | null
    title?: string
    yearMax?: number | null
    yearMin?: number | null
    categoryId?: string | null
    status?: $Enums.ContentStatus
    resources?: DatasetResourceUncheckedCreateNestedManyWithoutMapInput
    regions?: RegionUncheckedCreateNestedManyWithoutMapsInput
    tags?: TagUncheckedCreateNestedManyWithoutMapsInput
  }

  export type MapCreateOrConnectWithoutLayersInput = {
    where: MapWhereUniqueInput
    create: XOR<MapCreateWithoutLayersInput, MapUncheckedCreateWithoutLayersInput>
  }

  export type LayerUpsertWithoutMapsInput = {
    update: XOR<LayerUpdateWithoutMapsInput, LayerUncheckedUpdateWithoutMapsInput>
    create: XOR<LayerCreateWithoutMapsInput, LayerUncheckedCreateWithoutMapsInput>
    where?: LayerWhereInput
  }

  export type LayerUpdateToOneWithWhereWithoutMapsInput = {
    where?: LayerWhereInput
    data: XOR<LayerUpdateWithoutMapsInput, LayerUncheckedUpdateWithoutMapsInput>
  }

  export type LayerUpdateWithoutMapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    version?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLayerTypeFieldUpdateOperationsInput | $Enums.LayerType
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: NullableStringFieldUpdateOperationsInput | string | null
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumLayerSourceTypeFieldUpdateOperationsInput | $Enums.LayerSourceType
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutLayersNestedInput
    regions?: RegionUpdateManyWithoutLayersNestedInput
    tags?: TagUpdateManyWithoutLayersNestedInput
  }

  export type LayerUncheckedUpdateWithoutMapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    version?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLayerTypeFieldUpdateOperationsInput | $Enums.LayerType
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: NullableStringFieldUpdateOperationsInput | string | null
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumLayerSourceTypeFieldUpdateOperationsInput | $Enums.LayerSourceType
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    regions?: RegionUncheckedUpdateManyWithoutLayersNestedInput
    tags?: TagUncheckedUpdateManyWithoutLayersNestedInput
  }

  export type MapUpsertWithoutLayersInput = {
    update: XOR<MapUpdateWithoutLayersInput, MapUncheckedUpdateWithoutLayersInput>
    create: XOR<MapCreateWithoutLayersInput, MapUncheckedCreateWithoutLayersInput>
    where?: MapWhereInput
  }

  export type MapUpdateToOneWithWhereWithoutLayersInput = {
    where?: MapWhereInput
    data: XOR<MapUpdateWithoutLayersInput, MapUncheckedUpdateWithoutLayersInput>
  }

  export type MapUpdateWithoutLayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    resources?: DatasetResourceUpdateManyWithoutMapNestedInput
    category?: CategoryUpdateOneWithoutMapsNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForMapsNestedInput
    regions?: RegionUpdateManyWithoutMapsNestedInput
    tags?: TagUpdateManyWithoutMapsNestedInput
  }

  export type MapUncheckedUpdateWithoutLayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    resources?: DatasetResourceUncheckedUpdateManyWithoutMapNestedInput
    regions?: RegionUncheckedUpdateManyWithoutMapsNestedInput
    tags?: TagUncheckedUpdateManyWithoutMapsNestedInput
  }

  export type MediaCreateWithoutThumbnailForCollectionsInput = {
    id?: string
    filename: string
    url: string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailForCategory?: CategoryCreateNestedManyWithoutThumbnailInput
    thumbnailForMaps?: MapCreateNestedManyWithoutThumbnailInput
    storageFile?: StorageFileCreateNestedOneWithoutMediaInput
    thumbnailForPages?: PageCreateNestedManyWithoutThumbnailInput
    thumbnailForPosts?: PostCreateNestedManyWithoutThumbnailInput
    thumbnailForDataset?: ResearchDatasetCreateNestedManyWithoutThumbnailInput
    thumbnailForSeries?: SeriesCreateNestedManyWithoutThumbnailInput
    thumbnailForVolumes?: VolumeCreateNestedManyWithoutThumbnailInput
  }

  export type MediaUncheckedCreateWithoutThumbnailForCollectionsInput = {
    id?: string
    filename: string
    url: string
    storageFileId?: string | null
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailForCategory?: CategoryUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForMaps?: MapUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForPages?: PageUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForPosts?: PostUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForDataset?: ResearchDatasetUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForSeries?: SeriesUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForVolumes?: VolumeUncheckedCreateNestedManyWithoutThumbnailInput
  }

  export type MediaCreateOrConnectWithoutThumbnailForCollectionsInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutThumbnailForCollectionsInput, MediaUncheckedCreateWithoutThumbnailForCollectionsInput>
  }

  export type SeriesCreateWithoutCollectionInput = {
    id?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: number | null
    volumeLabelFormat?: string | null
    createdAt?: Date | string
    slug: string
    name?: string
    description?: string | null
    license?: string | null
    period?: string | null
    sourceLink?: string | null
    sources?: string | null
    author?: string | null
    editor?: string | null
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    languages?: SeriesCreatelanguagesInput | $Enums.ContentLanguage[]
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForSeriesInput
    volumes?: VolumeCreateNestedManyWithoutSeriesInput
    categories?: CategoryCreateNestedManyWithoutSeriesInput
    regions?: RegionCreateNestedManyWithoutSeriesInput
    tags?: TagCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUncheckedCreateWithoutCollectionInput = {
    id?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: number | null
    volumeLabelFormat?: string | null
    thumbnailId?: string | null
    createdAt?: Date | string
    slug: string
    name?: string
    description?: string | null
    license?: string | null
    period?: string | null
    sourceLink?: string | null
    sources?: string | null
    author?: string | null
    editor?: string | null
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    languages?: SeriesCreatelanguagesInput | $Enums.ContentLanguage[]
    volumes?: VolumeUncheckedCreateNestedManyWithoutSeriesInput
    categories?: CategoryUncheckedCreateNestedManyWithoutSeriesInput
    regions?: RegionUncheckedCreateNestedManyWithoutSeriesInput
    tags?: TagUncheckedCreateNestedManyWithoutSeriesInput
  }

  export type SeriesCreateOrConnectWithoutCollectionInput = {
    where: SeriesWhereUniqueInput
    create: XOR<SeriesCreateWithoutCollectionInput, SeriesUncheckedCreateWithoutCollectionInput>
  }

  export type SeriesCreateManyCollectionInputEnvelope = {
    data: SeriesCreateManyCollectionInput | SeriesCreateManyCollectionInput[]
    skipDuplicates?: boolean
  }

  export type RegionCreateWithoutCollectionsInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    artifacts?: ArtifactCreateNestedManyWithoutRegionsInput
    layers?: LayerCreateNestedManyWithoutRegionsInput
    maps?: MapCreateNestedManyWithoutRegionsInput
    pages?: PageCreateNestedManyWithoutRegionsInput
    posts?: PostCreateNestedManyWithoutRegionsInput
    datasets?: ResearchDatasetCreateNestedManyWithoutRegionsInput
    series?: SeriesCreateNestedManyWithoutRegionsInput
    volumes?: VolumeCreateNestedManyWithoutRegionsInput
  }

  export type RegionUncheckedCreateWithoutCollectionsInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutRegionsInput
    layers?: LayerUncheckedCreateNestedManyWithoutRegionsInput
    maps?: MapUncheckedCreateNestedManyWithoutRegionsInput
    pages?: PageUncheckedCreateNestedManyWithoutRegionsInput
    posts?: PostUncheckedCreateNestedManyWithoutRegionsInput
    datasets?: ResearchDatasetUncheckedCreateNestedManyWithoutRegionsInput
    series?: SeriesUncheckedCreateNestedManyWithoutRegionsInput
    volumes?: VolumeUncheckedCreateNestedManyWithoutRegionsInput
  }

  export type RegionCreateOrConnectWithoutCollectionsInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutCollectionsInput, RegionUncheckedCreateWithoutCollectionsInput>
  }

  export type TagCreateWithoutCollectionsInput = {
    id?: string
    slug: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    posts?: PostTagCreateNestedManyWithoutTagInput
    artifacts?: ArtifactCreateNestedManyWithoutTagsInput
    layers?: LayerCreateNestedManyWithoutTagsInput
    maps?: MapCreateNestedManyWithoutTagsInput
    pages?: PageCreateNestedManyWithoutTagsInput
    series?: SeriesCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutCollectionsInput = {
    id?: string
    slug: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    posts?: PostTagUncheckedCreateNestedManyWithoutTagInput
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutTagsInput
    layers?: LayerUncheckedCreateNestedManyWithoutTagsInput
    maps?: MapUncheckedCreateNestedManyWithoutTagsInput
    pages?: PageUncheckedCreateNestedManyWithoutTagsInput
    series?: SeriesUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutCollectionsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutCollectionsInput, TagUncheckedCreateWithoutCollectionsInput>
  }

  export type MediaUpsertWithoutThumbnailForCollectionsInput = {
    update: XOR<MediaUpdateWithoutThumbnailForCollectionsInput, MediaUncheckedUpdateWithoutThumbnailForCollectionsInput>
    create: XOR<MediaCreateWithoutThumbnailForCollectionsInput, MediaUncheckedCreateWithoutThumbnailForCollectionsInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutThumbnailForCollectionsInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutThumbnailForCollectionsInput, MediaUncheckedUpdateWithoutThumbnailForCollectionsInput>
  }

  export type MediaUpdateWithoutThumbnailForCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailForCategory?: CategoryUpdateManyWithoutThumbnailNestedInput
    thumbnailForMaps?: MapUpdateManyWithoutThumbnailNestedInput
    storageFile?: StorageFileUpdateOneWithoutMediaNestedInput
    thumbnailForPages?: PageUpdateManyWithoutThumbnailNestedInput
    thumbnailForPosts?: PostUpdateManyWithoutThumbnailNestedInput
    thumbnailForDataset?: ResearchDatasetUpdateManyWithoutThumbnailNestedInput
    thumbnailForSeries?: SeriesUpdateManyWithoutThumbnailNestedInput
    thumbnailForVolumes?: VolumeUpdateManyWithoutThumbnailNestedInput
  }

  export type MediaUncheckedUpdateWithoutThumbnailForCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    storageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailForCategory?: CategoryUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForMaps?: MapUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForPages?: PageUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForPosts?: PostUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForDataset?: ResearchDatasetUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForSeries?: SeriesUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForVolumes?: VolumeUncheckedUpdateManyWithoutThumbnailNestedInput
  }

  export type SeriesUpsertWithWhereUniqueWithoutCollectionInput = {
    where: SeriesWhereUniqueInput
    update: XOR<SeriesUpdateWithoutCollectionInput, SeriesUncheckedUpdateWithoutCollectionInput>
    create: XOR<SeriesCreateWithoutCollectionInput, SeriesUncheckedCreateWithoutCollectionInput>
  }

  export type SeriesUpdateWithWhereUniqueWithoutCollectionInput = {
    where: SeriesWhereUniqueInput
    data: XOR<SeriesUpdateWithoutCollectionInput, SeriesUncheckedUpdateWithoutCollectionInput>
  }

  export type SeriesUpdateManyWithWhereWithoutCollectionInput = {
    where: SeriesScalarWhereInput
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyWithoutCollectionInput>
  }

  export type SeriesScalarWhereInput = {
    AND?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
    OR?: SeriesScalarWhereInput[]
    NOT?: SeriesScalarWhereInput | SeriesScalarWhereInput[]
    id?: UuidFilter<"Series"> | string
    collectionId?: UuidNullableFilter<"Series"> | string | null
    nameI18n?: JsonFilter<"Series">
    descriptionI18n?: JsonNullableFilter<"Series">
    indexNumber?: IntNullableFilter<"Series"> | number | null
    volumeLabelFormat?: StringNullableFilter<"Series"> | string | null
    thumbnailId?: UuidNullableFilter<"Series"> | string | null
    createdAt?: DateTimeFilter<"Series"> | Date | string
    slug?: StringFilter<"Series"> | string
    name?: StringFilter<"Series"> | string
    description?: StringNullableFilter<"Series"> | string | null
    license?: StringNullableFilter<"Series"> | string | null
    period?: StringNullableFilter<"Series"> | string | null
    sourceLink?: StringNullableFilter<"Series"> | string | null
    sources?: StringNullableFilter<"Series"> | string | null
    author?: StringNullableFilter<"Series"> | string | null
    editor?: StringNullableFilter<"Series"> | string | null
    referenceCode?: StringNullableFilter<"Series"> | string | null
    yearMax?: IntNullableFilter<"Series"> | number | null
    yearMin?: IntNullableFilter<"Series"> | number | null
    languages?: EnumContentLanguageNullableListFilter<"Series">
  }

  export type RegionUpsertWithWhereUniqueWithoutCollectionsInput = {
    where: RegionWhereUniqueInput
    update: XOR<RegionUpdateWithoutCollectionsInput, RegionUncheckedUpdateWithoutCollectionsInput>
    create: XOR<RegionCreateWithoutCollectionsInput, RegionUncheckedCreateWithoutCollectionsInput>
  }

  export type RegionUpdateWithWhereUniqueWithoutCollectionsInput = {
    where: RegionWhereUniqueInput
    data: XOR<RegionUpdateWithoutCollectionsInput, RegionUncheckedUpdateWithoutCollectionsInput>
  }

  export type RegionUpdateManyWithWhereWithoutCollectionsInput = {
    where: RegionScalarWhereInput
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyWithoutCollectionsInput>
  }

  export type TagUpsertWithWhereUniqueWithoutCollectionsInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutCollectionsInput, TagUncheckedUpdateWithoutCollectionsInput>
    create: XOR<TagCreateWithoutCollectionsInput, TagUncheckedCreateWithoutCollectionsInput>
  }

  export type TagUpdateWithWhereUniqueWithoutCollectionsInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutCollectionsInput, TagUncheckedUpdateWithoutCollectionsInput>
  }

  export type TagUpdateManyWithWhereWithoutCollectionsInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutCollectionsInput>
  }

  export type CollectionCreateWithoutSeriesInput = {
    id?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForCollectionsInput
    regions?: RegionCreateNestedManyWithoutCollectionsInput
    tags?: TagCreateNestedManyWithoutCollectionsInput
  }

  export type CollectionUncheckedCreateWithoutSeriesInput = {
    id?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailId?: string | null
    name?: string
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    regions?: RegionUncheckedCreateNestedManyWithoutCollectionsInput
    tags?: TagUncheckedCreateNestedManyWithoutCollectionsInput
  }

  export type CollectionCreateOrConnectWithoutSeriesInput = {
    where: CollectionWhereUniqueInput
    create: XOR<CollectionCreateWithoutSeriesInput, CollectionUncheckedCreateWithoutSeriesInput>
  }

  export type MediaCreateWithoutThumbnailForSeriesInput = {
    id?: string
    filename: string
    url: string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailForCategory?: CategoryCreateNestedManyWithoutThumbnailInput
    thumbnailForCollections?: CollectionCreateNestedManyWithoutThumbnailInput
    thumbnailForMaps?: MapCreateNestedManyWithoutThumbnailInput
    storageFile?: StorageFileCreateNestedOneWithoutMediaInput
    thumbnailForPages?: PageCreateNestedManyWithoutThumbnailInput
    thumbnailForPosts?: PostCreateNestedManyWithoutThumbnailInput
    thumbnailForDataset?: ResearchDatasetCreateNestedManyWithoutThumbnailInput
    thumbnailForVolumes?: VolumeCreateNestedManyWithoutThumbnailInput
  }

  export type MediaUncheckedCreateWithoutThumbnailForSeriesInput = {
    id?: string
    filename: string
    url: string
    storageFileId?: string | null
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailForCategory?: CategoryUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForCollections?: CollectionUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForMaps?: MapUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForPages?: PageUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForPosts?: PostUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForDataset?: ResearchDatasetUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForVolumes?: VolumeUncheckedCreateNestedManyWithoutThumbnailInput
  }

  export type MediaCreateOrConnectWithoutThumbnailForSeriesInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutThumbnailForSeriesInput, MediaUncheckedCreateWithoutThumbnailForSeriesInput>
  }

  export type VolumeCreateWithoutSeriesInput = {
    id?: string
    indexNumber?: number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: string | null
    yearContent?: number | null
    createdAt?: Date | string
    slug: string
    title?: string
    description?: string | null
    license?: string | null
    sourceLink?: string | null
    sources?: string | null
    year?: number | null
    author?: string | null
    editor?: string | null
    languages?: VolumeCreatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: number | null
    yearMin?: number | null
    pages?: VolumePageCreateNestedManyWithoutVolumeInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForVolumesInput
    regions?: RegionCreateNestedManyWithoutVolumesInput
  }

  export type VolumeUncheckedCreateWithoutSeriesInput = {
    id?: string
    indexNumber?: number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: string | null
    yearContent?: number | null
    thumbnailId?: string | null
    createdAt?: Date | string
    slug: string
    title?: string
    description?: string | null
    license?: string | null
    sourceLink?: string | null
    sources?: string | null
    year?: number | null
    author?: string | null
    editor?: string | null
    languages?: VolumeCreatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: number | null
    yearMin?: number | null
    pages?: VolumePageUncheckedCreateNestedManyWithoutVolumeInput
    regions?: RegionUncheckedCreateNestedManyWithoutVolumesInput
  }

  export type VolumeCreateOrConnectWithoutSeriesInput = {
    where: VolumeWhereUniqueInput
    create: XOR<VolumeCreateWithoutSeriesInput, VolumeUncheckedCreateWithoutSeriesInput>
  }

  export type VolumeCreateManySeriesInputEnvelope = {
    data: VolumeCreateManySeriesInput | VolumeCreateManySeriesInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutSeriesInput = {
    id?: string
    title: string
    slug: string
    createdAt?: Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForCategoryInput
    layers?: LayerCreateNestedManyWithoutCategoryInput
    maps?: MapCreateNestedManyWithoutCategoryInput
    datasets?: ResearchDatasetCreateNestedManyWithoutCategoryInput
    posts?: PostCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateWithoutSeriesInput = {
    id?: string
    title: string
    slug: string
    thumbnailId?: string | null
    createdAt?: Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    layers?: LayerUncheckedCreateNestedManyWithoutCategoryInput
    maps?: MapUncheckedCreateNestedManyWithoutCategoryInput
    datasets?: ResearchDatasetUncheckedCreateNestedManyWithoutCategoryInput
    posts?: PostUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryCreateOrConnectWithoutSeriesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutSeriesInput, CategoryUncheckedCreateWithoutSeriesInput>
  }

  export type RegionCreateWithoutSeriesInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    artifacts?: ArtifactCreateNestedManyWithoutRegionsInput
    collections?: CollectionCreateNestedManyWithoutRegionsInput
    layers?: LayerCreateNestedManyWithoutRegionsInput
    maps?: MapCreateNestedManyWithoutRegionsInput
    pages?: PageCreateNestedManyWithoutRegionsInput
    posts?: PostCreateNestedManyWithoutRegionsInput
    datasets?: ResearchDatasetCreateNestedManyWithoutRegionsInput
    volumes?: VolumeCreateNestedManyWithoutRegionsInput
  }

  export type RegionUncheckedCreateWithoutSeriesInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutRegionsInput
    collections?: CollectionUncheckedCreateNestedManyWithoutRegionsInput
    layers?: LayerUncheckedCreateNestedManyWithoutRegionsInput
    maps?: MapUncheckedCreateNestedManyWithoutRegionsInput
    pages?: PageUncheckedCreateNestedManyWithoutRegionsInput
    posts?: PostUncheckedCreateNestedManyWithoutRegionsInput
    datasets?: ResearchDatasetUncheckedCreateNestedManyWithoutRegionsInput
    volumes?: VolumeUncheckedCreateNestedManyWithoutRegionsInput
  }

  export type RegionCreateOrConnectWithoutSeriesInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutSeriesInput, RegionUncheckedCreateWithoutSeriesInput>
  }

  export type TagCreateWithoutSeriesInput = {
    id?: string
    slug: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    posts?: PostTagCreateNestedManyWithoutTagInput
    artifacts?: ArtifactCreateNestedManyWithoutTagsInput
    collections?: CollectionCreateNestedManyWithoutTagsInput
    layers?: LayerCreateNestedManyWithoutTagsInput
    maps?: MapCreateNestedManyWithoutTagsInput
    pages?: PageCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutSeriesInput = {
    id?: string
    slug: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    posts?: PostTagUncheckedCreateNestedManyWithoutTagInput
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutTagsInput
    collections?: CollectionUncheckedCreateNestedManyWithoutTagsInput
    layers?: LayerUncheckedCreateNestedManyWithoutTagsInput
    maps?: MapUncheckedCreateNestedManyWithoutTagsInput
    pages?: PageUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutSeriesInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutSeriesInput, TagUncheckedCreateWithoutSeriesInput>
  }

  export type CollectionUpsertWithoutSeriesInput = {
    update: XOR<CollectionUpdateWithoutSeriesInput, CollectionUncheckedUpdateWithoutSeriesInput>
    create: XOR<CollectionCreateWithoutSeriesInput, CollectionUncheckedCreateWithoutSeriesInput>
    where?: CollectionWhereInput
  }

  export type CollectionUpdateToOneWithWhereWithoutSeriesInput = {
    where?: CollectionWhereInput
    data: XOR<CollectionUpdateWithoutSeriesInput, CollectionUncheckedUpdateWithoutSeriesInput>
  }

  export type CollectionUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnail?: MediaUpdateOneWithoutThumbnailForCollectionsNestedInput
    regions?: RegionUpdateManyWithoutCollectionsNestedInput
    tags?: TagUpdateManyWithoutCollectionsNestedInput
  }

  export type CollectionUncheckedUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    regions?: RegionUncheckedUpdateManyWithoutCollectionsNestedInput
    tags?: TagUncheckedUpdateManyWithoutCollectionsNestedInput
  }

  export type MediaUpsertWithoutThumbnailForSeriesInput = {
    update: XOR<MediaUpdateWithoutThumbnailForSeriesInput, MediaUncheckedUpdateWithoutThumbnailForSeriesInput>
    create: XOR<MediaCreateWithoutThumbnailForSeriesInput, MediaUncheckedCreateWithoutThumbnailForSeriesInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutThumbnailForSeriesInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutThumbnailForSeriesInput, MediaUncheckedUpdateWithoutThumbnailForSeriesInput>
  }

  export type MediaUpdateWithoutThumbnailForSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailForCategory?: CategoryUpdateManyWithoutThumbnailNestedInput
    thumbnailForCollections?: CollectionUpdateManyWithoutThumbnailNestedInput
    thumbnailForMaps?: MapUpdateManyWithoutThumbnailNestedInput
    storageFile?: StorageFileUpdateOneWithoutMediaNestedInput
    thumbnailForPages?: PageUpdateManyWithoutThumbnailNestedInput
    thumbnailForPosts?: PostUpdateManyWithoutThumbnailNestedInput
    thumbnailForDataset?: ResearchDatasetUpdateManyWithoutThumbnailNestedInput
    thumbnailForVolumes?: VolumeUpdateManyWithoutThumbnailNestedInput
  }

  export type MediaUncheckedUpdateWithoutThumbnailForSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    storageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailForCategory?: CategoryUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForCollections?: CollectionUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForMaps?: MapUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForPages?: PageUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForPosts?: PostUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForDataset?: ResearchDatasetUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForVolumes?: VolumeUncheckedUpdateManyWithoutThumbnailNestedInput
  }

  export type VolumeUpsertWithWhereUniqueWithoutSeriesInput = {
    where: VolumeWhereUniqueInput
    update: XOR<VolumeUpdateWithoutSeriesInput, VolumeUncheckedUpdateWithoutSeriesInput>
    create: XOR<VolumeCreateWithoutSeriesInput, VolumeUncheckedCreateWithoutSeriesInput>
  }

  export type VolumeUpdateWithWhereUniqueWithoutSeriesInput = {
    where: VolumeWhereUniqueInput
    data: XOR<VolumeUpdateWithoutSeriesInput, VolumeUncheckedUpdateWithoutSeriesInput>
  }

  export type VolumeUpdateManyWithWhereWithoutSeriesInput = {
    where: VolumeScalarWhereInput
    data: XOR<VolumeUpdateManyMutationInput, VolumeUncheckedUpdateManyWithoutSeriesInput>
  }

  export type VolumeScalarWhereInput = {
    AND?: VolumeScalarWhereInput | VolumeScalarWhereInput[]
    OR?: VolumeScalarWhereInput[]
    NOT?: VolumeScalarWhereInput | VolumeScalarWhereInput[]
    id?: UuidFilter<"Volume"> | string
    seriesId?: UuidNullableFilter<"Volume"> | string | null
    indexNumber?: IntNullableFilter<"Volume"> | number | null
    titleI18n?: JsonFilter<"Volume">
    descriptionI18n?: JsonNullableFilter<"Volume">
    languageOfContent?: StringNullableFilter<"Volume"> | string | null
    yearContent?: IntNullableFilter<"Volume"> | number | null
    thumbnailId?: UuidNullableFilter<"Volume"> | string | null
    createdAt?: DateTimeFilter<"Volume"> | Date | string
    slug?: StringFilter<"Volume"> | string
    title?: StringFilter<"Volume"> | string
    description?: StringNullableFilter<"Volume"> | string | null
    license?: StringNullableFilter<"Volume"> | string | null
    sourceLink?: StringNullableFilter<"Volume"> | string | null
    sources?: StringNullableFilter<"Volume"> | string | null
    year?: IntNullableFilter<"Volume"> | number | null
    author?: StringNullableFilter<"Volume"> | string | null
    editor?: StringNullableFilter<"Volume"> | string | null
    languages?: EnumContentLanguageNullableListFilter<"Volume">
    yearMax?: IntNullableFilter<"Volume"> | number | null
    yearMin?: IntNullableFilter<"Volume"> | number | null
  }

  export type CategoryUpsertWithWhereUniqueWithoutSeriesInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutSeriesInput, CategoryUncheckedUpdateWithoutSeriesInput>
    create: XOR<CategoryCreateWithoutSeriesInput, CategoryUncheckedCreateWithoutSeriesInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutSeriesInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutSeriesInput, CategoryUncheckedUpdateWithoutSeriesInput>
  }

  export type CategoryUpdateManyWithWhereWithoutSeriesInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutSeriesInput>
  }

  export type RegionUpsertWithWhereUniqueWithoutSeriesInput = {
    where: RegionWhereUniqueInput
    update: XOR<RegionUpdateWithoutSeriesInput, RegionUncheckedUpdateWithoutSeriesInput>
    create: XOR<RegionCreateWithoutSeriesInput, RegionUncheckedCreateWithoutSeriesInput>
  }

  export type RegionUpdateWithWhereUniqueWithoutSeriesInput = {
    where: RegionWhereUniqueInput
    data: XOR<RegionUpdateWithoutSeriesInput, RegionUncheckedUpdateWithoutSeriesInput>
  }

  export type RegionUpdateManyWithWhereWithoutSeriesInput = {
    where: RegionScalarWhereInput
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyWithoutSeriesInput>
  }

  export type TagUpsertWithWhereUniqueWithoutSeriesInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutSeriesInput, TagUncheckedUpdateWithoutSeriesInput>
    create: XOR<TagCreateWithoutSeriesInput, TagUncheckedCreateWithoutSeriesInput>
  }

  export type TagUpdateWithWhereUniqueWithoutSeriesInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutSeriesInput, TagUncheckedUpdateWithoutSeriesInput>
  }

  export type TagUpdateManyWithWhereWithoutSeriesInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutSeriesInput>
  }

  export type VolumePageCreateWithoutVolumeInput = {
    id?: string
    sequenceIndex: number
    label?: string
    createdAt?: Date | string
    isVisible?: boolean
    data?: PageDataCreateNestedOneWithoutPageInput
    images?: PageImageCreateNestedManyWithoutPageInput
    texts?: PageTextCreateNestedManyWithoutPageInput
    artifacts?: ArtifactCreateNestedManyWithoutPagesInput
  }

  export type VolumePageUncheckedCreateWithoutVolumeInput = {
    id?: string
    sequenceIndex: number
    label?: string
    createdAt?: Date | string
    isVisible?: boolean
    data?: PageDataUncheckedCreateNestedOneWithoutPageInput
    images?: PageImageUncheckedCreateNestedManyWithoutPageInput
    texts?: PageTextUncheckedCreateNestedManyWithoutPageInput
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutPagesInput
  }

  export type VolumePageCreateOrConnectWithoutVolumeInput = {
    where: VolumePageWhereUniqueInput
    create: XOR<VolumePageCreateWithoutVolumeInput, VolumePageUncheckedCreateWithoutVolumeInput>
  }

  export type VolumePageCreateManyVolumeInputEnvelope = {
    data: VolumePageCreateManyVolumeInput | VolumePageCreateManyVolumeInput[]
    skipDuplicates?: boolean
  }

  export type SeriesCreateWithoutVolumesInput = {
    id?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: number | null
    volumeLabelFormat?: string | null
    createdAt?: Date | string
    slug: string
    name?: string
    description?: string | null
    license?: string | null
    period?: string | null
    sourceLink?: string | null
    sources?: string | null
    author?: string | null
    editor?: string | null
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    languages?: SeriesCreatelanguagesInput | $Enums.ContentLanguage[]
    collection?: CollectionCreateNestedOneWithoutSeriesInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForSeriesInput
    categories?: CategoryCreateNestedManyWithoutSeriesInput
    regions?: RegionCreateNestedManyWithoutSeriesInput
    tags?: TagCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUncheckedCreateWithoutVolumesInput = {
    id?: string
    collectionId?: string | null
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: number | null
    volumeLabelFormat?: string | null
    thumbnailId?: string | null
    createdAt?: Date | string
    slug: string
    name?: string
    description?: string | null
    license?: string | null
    period?: string | null
    sourceLink?: string | null
    sources?: string | null
    author?: string | null
    editor?: string | null
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    languages?: SeriesCreatelanguagesInput | $Enums.ContentLanguage[]
    categories?: CategoryUncheckedCreateNestedManyWithoutSeriesInput
    regions?: RegionUncheckedCreateNestedManyWithoutSeriesInput
    tags?: TagUncheckedCreateNestedManyWithoutSeriesInput
  }

  export type SeriesCreateOrConnectWithoutVolumesInput = {
    where: SeriesWhereUniqueInput
    create: XOR<SeriesCreateWithoutVolumesInput, SeriesUncheckedCreateWithoutVolumesInput>
  }

  export type MediaCreateWithoutThumbnailForVolumesInput = {
    id?: string
    filename: string
    url: string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailForCategory?: CategoryCreateNestedManyWithoutThumbnailInput
    thumbnailForCollections?: CollectionCreateNestedManyWithoutThumbnailInput
    thumbnailForMaps?: MapCreateNestedManyWithoutThumbnailInput
    storageFile?: StorageFileCreateNestedOneWithoutMediaInput
    thumbnailForPages?: PageCreateNestedManyWithoutThumbnailInput
    thumbnailForPosts?: PostCreateNestedManyWithoutThumbnailInput
    thumbnailForDataset?: ResearchDatasetCreateNestedManyWithoutThumbnailInput
    thumbnailForSeries?: SeriesCreateNestedManyWithoutThumbnailInput
  }

  export type MediaUncheckedCreateWithoutThumbnailForVolumesInput = {
    id?: string
    filename: string
    url: string
    storageFileId?: string | null
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailForCategory?: CategoryUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForCollections?: CollectionUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForMaps?: MapUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForPages?: PageUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForPosts?: PostUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForDataset?: ResearchDatasetUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForSeries?: SeriesUncheckedCreateNestedManyWithoutThumbnailInput
  }

  export type MediaCreateOrConnectWithoutThumbnailForVolumesInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutThumbnailForVolumesInput, MediaUncheckedCreateWithoutThumbnailForVolumesInput>
  }

  export type RegionCreateWithoutVolumesInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    artifacts?: ArtifactCreateNestedManyWithoutRegionsInput
    collections?: CollectionCreateNestedManyWithoutRegionsInput
    layers?: LayerCreateNestedManyWithoutRegionsInput
    maps?: MapCreateNestedManyWithoutRegionsInput
    pages?: PageCreateNestedManyWithoutRegionsInput
    posts?: PostCreateNestedManyWithoutRegionsInput
    datasets?: ResearchDatasetCreateNestedManyWithoutRegionsInput
    series?: SeriesCreateNestedManyWithoutRegionsInput
  }

  export type RegionUncheckedCreateWithoutVolumesInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutRegionsInput
    collections?: CollectionUncheckedCreateNestedManyWithoutRegionsInput
    layers?: LayerUncheckedCreateNestedManyWithoutRegionsInput
    maps?: MapUncheckedCreateNestedManyWithoutRegionsInput
    pages?: PageUncheckedCreateNestedManyWithoutRegionsInput
    posts?: PostUncheckedCreateNestedManyWithoutRegionsInput
    datasets?: ResearchDatasetUncheckedCreateNestedManyWithoutRegionsInput
    series?: SeriesUncheckedCreateNestedManyWithoutRegionsInput
  }

  export type RegionCreateOrConnectWithoutVolumesInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutVolumesInput, RegionUncheckedCreateWithoutVolumesInput>
  }

  export type VolumePageUpsertWithWhereUniqueWithoutVolumeInput = {
    where: VolumePageWhereUniqueInput
    update: XOR<VolumePageUpdateWithoutVolumeInput, VolumePageUncheckedUpdateWithoutVolumeInput>
    create: XOR<VolumePageCreateWithoutVolumeInput, VolumePageUncheckedCreateWithoutVolumeInput>
  }

  export type VolumePageUpdateWithWhereUniqueWithoutVolumeInput = {
    where: VolumePageWhereUniqueInput
    data: XOR<VolumePageUpdateWithoutVolumeInput, VolumePageUncheckedUpdateWithoutVolumeInput>
  }

  export type VolumePageUpdateManyWithWhereWithoutVolumeInput = {
    where: VolumePageScalarWhereInput
    data: XOR<VolumePageUpdateManyMutationInput, VolumePageUncheckedUpdateManyWithoutVolumeInput>
  }

  export type VolumePageScalarWhereInput = {
    AND?: VolumePageScalarWhereInput | VolumePageScalarWhereInput[]
    OR?: VolumePageScalarWhereInput[]
    NOT?: VolumePageScalarWhereInput | VolumePageScalarWhereInput[]
    id?: UuidFilter<"VolumePage"> | string
    volumeId?: UuidNullableFilter<"VolumePage"> | string | null
    sequenceIndex?: IntFilter<"VolumePage"> | number
    label?: StringFilter<"VolumePage"> | string
    createdAt?: DateTimeFilter<"VolumePage"> | Date | string
    isVisible?: BoolFilter<"VolumePage"> | boolean
  }

  export type SeriesUpsertWithoutVolumesInput = {
    update: XOR<SeriesUpdateWithoutVolumesInput, SeriesUncheckedUpdateWithoutVolumesInput>
    create: XOR<SeriesCreateWithoutVolumesInput, SeriesUncheckedCreateWithoutVolumesInput>
    where?: SeriesWhereInput
  }

  export type SeriesUpdateToOneWithWhereWithoutVolumesInput = {
    where?: SeriesWhereInput
    data: XOR<SeriesUpdateWithoutVolumesInput, SeriesUncheckedUpdateWithoutVolumesInput>
  }

  export type SeriesUpdateWithoutVolumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    volumeLabelFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    languages?: SeriesUpdatelanguagesInput | $Enums.ContentLanguage[]
    collection?: CollectionUpdateOneWithoutSeriesNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForSeriesNestedInput
    categories?: CategoryUpdateManyWithoutSeriesNestedInput
    regions?: RegionUpdateManyWithoutSeriesNestedInput
    tags?: TagUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateWithoutVolumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    volumeLabelFormat?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    languages?: SeriesUpdatelanguagesInput | $Enums.ContentLanguage[]
    categories?: CategoryUncheckedUpdateManyWithoutSeriesNestedInput
    regions?: RegionUncheckedUpdateManyWithoutSeriesNestedInput
    tags?: TagUncheckedUpdateManyWithoutSeriesNestedInput
  }

  export type MediaUpsertWithoutThumbnailForVolumesInput = {
    update: XOR<MediaUpdateWithoutThumbnailForVolumesInput, MediaUncheckedUpdateWithoutThumbnailForVolumesInput>
    create: XOR<MediaCreateWithoutThumbnailForVolumesInput, MediaUncheckedCreateWithoutThumbnailForVolumesInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutThumbnailForVolumesInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutThumbnailForVolumesInput, MediaUncheckedUpdateWithoutThumbnailForVolumesInput>
  }

  export type MediaUpdateWithoutThumbnailForVolumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailForCategory?: CategoryUpdateManyWithoutThumbnailNestedInput
    thumbnailForCollections?: CollectionUpdateManyWithoutThumbnailNestedInput
    thumbnailForMaps?: MapUpdateManyWithoutThumbnailNestedInput
    storageFile?: StorageFileUpdateOneWithoutMediaNestedInput
    thumbnailForPages?: PageUpdateManyWithoutThumbnailNestedInput
    thumbnailForPosts?: PostUpdateManyWithoutThumbnailNestedInput
    thumbnailForDataset?: ResearchDatasetUpdateManyWithoutThumbnailNestedInput
    thumbnailForSeries?: SeriesUpdateManyWithoutThumbnailNestedInput
  }

  export type MediaUncheckedUpdateWithoutThumbnailForVolumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    storageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailForCategory?: CategoryUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForCollections?: CollectionUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForMaps?: MapUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForPages?: PageUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForPosts?: PostUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForDataset?: ResearchDatasetUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForSeries?: SeriesUncheckedUpdateManyWithoutThumbnailNestedInput
  }

  export type RegionUpsertWithWhereUniqueWithoutVolumesInput = {
    where: RegionWhereUniqueInput
    update: XOR<RegionUpdateWithoutVolumesInput, RegionUncheckedUpdateWithoutVolumesInput>
    create: XOR<RegionCreateWithoutVolumesInput, RegionUncheckedCreateWithoutVolumesInput>
  }

  export type RegionUpdateWithWhereUniqueWithoutVolumesInput = {
    where: RegionWhereUniqueInput
    data: XOR<RegionUpdateWithoutVolumesInput, RegionUncheckedUpdateWithoutVolumesInput>
  }

  export type RegionUpdateManyWithWhereWithoutVolumesInput = {
    where: RegionScalarWhereInput
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyWithoutVolumesInput>
  }

  export type PageDataCreateWithoutPageInput = {
    id?: string
    ocrData: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type PageDataUncheckedCreateWithoutPageInput = {
    id?: string
    ocrData: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type PageDataCreateOrConnectWithoutPageInput = {
    where: PageDataWhereUniqueInput
    create: XOR<PageDataCreateWithoutPageInput, PageDataUncheckedCreateWithoutPageInput>
  }

  export type PageImageCreateWithoutPageInput = {
    id?: string
    useType?: $Enums.ImageUseType
    createdAt?: Date | string
    storageFile: StorageFileCreateNestedOneWithoutPageImagesInput
  }

  export type PageImageUncheckedCreateWithoutPageInput = {
    id?: string
    storageFileId: string
    useType?: $Enums.ImageUseType
    createdAt?: Date | string
  }

  export type PageImageCreateOrConnectWithoutPageInput = {
    where: PageImageWhereUniqueInput
    create: XOR<PageImageCreateWithoutPageInput, PageImageUncheckedCreateWithoutPageInput>
  }

  export type PageImageCreateManyPageInputEnvelope = {
    data: PageImageCreateManyPageInput | PageImageCreateManyPageInput[]
    skipDuplicates?: boolean
  }

  export type PageTextCreateWithoutPageInput = {
    id?: string
    content: string
    type?: $Enums.TextType
    language: $Enums.AppLanguage
    textAccuracy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contributor?: UserCreateNestedOneWithoutPageTextsInput
  }

  export type PageTextUncheckedCreateWithoutPageInput = {
    id?: string
    content: string
    type?: $Enums.TextType
    language: $Enums.AppLanguage
    textAccuracy?: number | null
    contributorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageTextCreateOrConnectWithoutPageInput = {
    where: PageTextWhereUniqueInput
    create: XOR<PageTextCreateWithoutPageInput, PageTextUncheckedCreateWithoutPageInput>
  }

  export type PageTextCreateManyPageInputEnvelope = {
    data: PageTextCreateManyPageInput | PageTextCreateManyPageInput[]
    skipDuplicates?: boolean
  }

  export type VolumeCreateWithoutPagesInput = {
    id?: string
    indexNumber?: number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: string | null
    yearContent?: number | null
    createdAt?: Date | string
    slug: string
    title?: string
    description?: string | null
    license?: string | null
    sourceLink?: string | null
    sources?: string | null
    year?: number | null
    author?: string | null
    editor?: string | null
    languages?: VolumeCreatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: number | null
    yearMin?: number | null
    series?: SeriesCreateNestedOneWithoutVolumesInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForVolumesInput
    regions?: RegionCreateNestedManyWithoutVolumesInput
  }

  export type VolumeUncheckedCreateWithoutPagesInput = {
    id?: string
    seriesId?: string | null
    indexNumber?: number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: string | null
    yearContent?: number | null
    thumbnailId?: string | null
    createdAt?: Date | string
    slug: string
    title?: string
    description?: string | null
    license?: string | null
    sourceLink?: string | null
    sources?: string | null
    year?: number | null
    author?: string | null
    editor?: string | null
    languages?: VolumeCreatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: number | null
    yearMin?: number | null
    regions?: RegionUncheckedCreateNestedManyWithoutVolumesInput
  }

  export type VolumeCreateOrConnectWithoutPagesInput = {
    where: VolumeWhereUniqueInput
    create: XOR<VolumeCreateWithoutPagesInput, VolumeUncheckedCreateWithoutPagesInput>
  }

  export type ArtifactCreateWithoutPagesInput = {
    id?: string
    slug: string
    content?: string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: number | null
    dateDisplay?: string | null
    dateSort?: Date | string | null
    excerpt?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: boolean
    displayTexts?: boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategory?: ArtifactCategoryCreateNestedOneWithoutArtifactsInput
    periods?: PeriodCreateNestedManyWithoutArtifactsInput
    places?: PlaceCreateNestedManyWithoutArtifactsInput
    regions?: RegionCreateNestedManyWithoutArtifactsInput
    tags?: TagCreateNestedManyWithoutArtifactsInput
  }

  export type ArtifactUncheckedCreateWithoutPagesInput = {
    id?: string
    slug: string
    content?: string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: number | null
    dateDisplay?: string | null
    dateSort?: Date | string | null
    excerpt?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: boolean
    displayTexts?: boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategoryId?: string | null
    periods?: PeriodUncheckedCreateNestedManyWithoutArtifactsInput
    places?: PlaceUncheckedCreateNestedManyWithoutArtifactsInput
    regions?: RegionUncheckedCreateNestedManyWithoutArtifactsInput
    tags?: TagUncheckedCreateNestedManyWithoutArtifactsInput
  }

  export type ArtifactCreateOrConnectWithoutPagesInput = {
    where: ArtifactWhereUniqueInput
    create: XOR<ArtifactCreateWithoutPagesInput, ArtifactUncheckedCreateWithoutPagesInput>
  }

  export type PageDataUpsertWithoutPageInput = {
    update: XOR<PageDataUpdateWithoutPageInput, PageDataUncheckedUpdateWithoutPageInput>
    create: XOR<PageDataCreateWithoutPageInput, PageDataUncheckedCreateWithoutPageInput>
    where?: PageDataWhereInput
  }

  export type PageDataUpdateToOneWithWhereWithoutPageInput = {
    where?: PageDataWhereInput
    data: XOR<PageDataUpdateWithoutPageInput, PageDataUncheckedUpdateWithoutPageInput>
  }

  export type PageDataUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    ocrData?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageDataUncheckedUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    ocrData?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageImageUpsertWithWhereUniqueWithoutPageInput = {
    where: PageImageWhereUniqueInput
    update: XOR<PageImageUpdateWithoutPageInput, PageImageUncheckedUpdateWithoutPageInput>
    create: XOR<PageImageCreateWithoutPageInput, PageImageUncheckedCreateWithoutPageInput>
  }

  export type PageImageUpdateWithWhereUniqueWithoutPageInput = {
    where: PageImageWhereUniqueInput
    data: XOR<PageImageUpdateWithoutPageInput, PageImageUncheckedUpdateWithoutPageInput>
  }

  export type PageImageUpdateManyWithWhereWithoutPageInput = {
    where: PageImageScalarWhereInput
    data: XOR<PageImageUpdateManyMutationInput, PageImageUncheckedUpdateManyWithoutPageInput>
  }

  export type PageImageScalarWhereInput = {
    AND?: PageImageScalarWhereInput | PageImageScalarWhereInput[]
    OR?: PageImageScalarWhereInput[]
    NOT?: PageImageScalarWhereInput | PageImageScalarWhereInput[]
    id?: UuidFilter<"PageImage"> | string
    pageId?: UuidFilter<"PageImage"> | string
    storageFileId?: UuidFilter<"PageImage"> | string
    useType?: EnumImageUseTypeFilter<"PageImage"> | $Enums.ImageUseType
    createdAt?: DateTimeFilter<"PageImage"> | Date | string
  }

  export type PageTextUpsertWithWhereUniqueWithoutPageInput = {
    where: PageTextWhereUniqueInput
    update: XOR<PageTextUpdateWithoutPageInput, PageTextUncheckedUpdateWithoutPageInput>
    create: XOR<PageTextCreateWithoutPageInput, PageTextUncheckedCreateWithoutPageInput>
  }

  export type PageTextUpdateWithWhereUniqueWithoutPageInput = {
    where: PageTextWhereUniqueInput
    data: XOR<PageTextUpdateWithoutPageInput, PageTextUncheckedUpdateWithoutPageInput>
  }

  export type PageTextUpdateManyWithWhereWithoutPageInput = {
    where: PageTextScalarWhereInput
    data: XOR<PageTextUpdateManyMutationInput, PageTextUncheckedUpdateManyWithoutPageInput>
  }

  export type VolumeUpsertWithoutPagesInput = {
    update: XOR<VolumeUpdateWithoutPagesInput, VolumeUncheckedUpdateWithoutPagesInput>
    create: XOR<VolumeCreateWithoutPagesInput, VolumeUncheckedCreateWithoutPagesInput>
    where?: VolumeWhereInput
  }

  export type VolumeUpdateToOneWithWhereWithoutPagesInput = {
    where?: VolumeWhereInput
    data: XOR<VolumeUpdateWithoutPagesInput, VolumeUncheckedUpdateWithoutPagesInput>
  }

  export type VolumeUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: NullableStringFieldUpdateOperationsInput | string | null
    yearContent?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: VolumeUpdatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    series?: SeriesUpdateOneWithoutVolumesNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForVolumesNestedInput
    regions?: RegionUpdateManyWithoutVolumesNestedInput
  }

  export type VolumeUncheckedUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesId?: NullableStringFieldUpdateOperationsInput | string | null
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: NullableStringFieldUpdateOperationsInput | string | null
    yearContent?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: VolumeUpdatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    regions?: RegionUncheckedUpdateManyWithoutVolumesNestedInput
  }

  export type ArtifactUpsertWithWhereUniqueWithoutPagesInput = {
    where: ArtifactWhereUniqueInput
    update: XOR<ArtifactUpdateWithoutPagesInput, ArtifactUncheckedUpdateWithoutPagesInput>
    create: XOR<ArtifactCreateWithoutPagesInput, ArtifactUncheckedCreateWithoutPagesInput>
  }

  export type ArtifactUpdateWithWhereUniqueWithoutPagesInput = {
    where: ArtifactWhereUniqueInput
    data: XOR<ArtifactUpdateWithoutPagesInput, ArtifactUncheckedUpdateWithoutPagesInput>
  }

  export type ArtifactUpdateManyWithWhereWithoutPagesInput = {
    where: ArtifactScalarWhereInput
    data: XOR<ArtifactUpdateManyMutationInput, ArtifactUncheckedUpdateManyWithoutPagesInput>
  }

  export type ArtifactScalarWhereInput = {
    AND?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
    OR?: ArtifactScalarWhereInput[]
    NOT?: ArtifactScalarWhereInput | ArtifactScalarWhereInput[]
    id?: UuidFilter<"Artifact"> | string
    slug?: StringFilter<"Artifact"> | string
    content?: StringFilter<"Artifact"> | string
    contentI18n?: JsonFilter<"Artifact">
    year?: IntNullableFilter<"Artifact"> | number | null
    dateDisplay?: StringNullableFilter<"Artifact"> | string | null
    dateSort?: DateTimeNullableFilter<"Artifact"> | Date | string | null
    excerpt?: StringNullableFilter<"Artifact"> | string | null
    excerptI18n?: JsonNullableFilter<"Artifact">
    createdAt?: DateTimeFilter<"Artifact"> | Date | string
    description?: StringNullableFilter<"Artifact"> | string | null
    descriptionI18n?: JsonNullableFilter<"Artifact">
    displayScans?: BoolFilter<"Artifact"> | boolean
    displayTexts?: BoolFilter<"Artifact"> | boolean
    sources?: JsonFilter<"Artifact">
    title?: StringFilter<"Artifact"> | string
    titleI18n?: JsonFilter<"Artifact">
    artifactCategoryId?: UuidNullableFilter<"Artifact"> | string | null
  }

  export type ArtifactCategoryCreateWithoutArtifactsInput = {
    id?: string
    slug: string
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ArtifactCategoryUncheckedCreateWithoutArtifactsInput = {
    id?: string
    slug: string
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ArtifactCategoryCreateOrConnectWithoutArtifactsInput = {
    where: ArtifactCategoryWhereUniqueInput
    create: XOR<ArtifactCategoryCreateWithoutArtifactsInput, ArtifactCategoryUncheckedCreateWithoutArtifactsInput>
  }

  export type PeriodCreateWithoutArtifactsInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    createdAt?: Date | string
  }

  export type PeriodUncheckedCreateWithoutArtifactsInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    dateStart?: Date | string | null
    dateEnd?: Date | string | null
    createdAt?: Date | string
  }

  export type PeriodCreateOrConnectWithoutArtifactsInput = {
    where: PeriodWhereUniqueInput
    create: XOR<PeriodCreateWithoutArtifactsInput, PeriodUncheckedCreateWithoutArtifactsInput>
  }

  export type PlaceCreateWithoutArtifactsInput = {
    id?: string
    geoname: string
    geocode: string
    lat?: number | null
    lon?: number | null
    countryCode: string
    admin1?: string | null
    admin2?: string | null
    administrativePlaces?: AdministrativePlaceCreateNestedManyWithoutPlaceInput
  }

  export type PlaceUncheckedCreateWithoutArtifactsInput = {
    id?: string
    geoname: string
    geocode: string
    lat?: number | null
    lon?: number | null
    countryCode: string
    admin1?: string | null
    admin2?: string | null
    administrativePlaces?: AdministrativePlaceUncheckedCreateNestedManyWithoutPlaceInput
  }

  export type PlaceCreateOrConnectWithoutArtifactsInput = {
    where: PlaceWhereUniqueInput
    create: XOR<PlaceCreateWithoutArtifactsInput, PlaceUncheckedCreateWithoutArtifactsInput>
  }

  export type RegionCreateWithoutArtifactsInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    collections?: CollectionCreateNestedManyWithoutRegionsInput
    layers?: LayerCreateNestedManyWithoutRegionsInput
    maps?: MapCreateNestedManyWithoutRegionsInput
    pages?: PageCreateNestedManyWithoutRegionsInput
    posts?: PostCreateNestedManyWithoutRegionsInput
    datasets?: ResearchDatasetCreateNestedManyWithoutRegionsInput
    series?: SeriesCreateNestedManyWithoutRegionsInput
    volumes?: VolumeCreateNestedManyWithoutRegionsInput
  }

  export type RegionUncheckedCreateWithoutArtifactsInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    collections?: CollectionUncheckedCreateNestedManyWithoutRegionsInput
    layers?: LayerUncheckedCreateNestedManyWithoutRegionsInput
    maps?: MapUncheckedCreateNestedManyWithoutRegionsInput
    pages?: PageUncheckedCreateNestedManyWithoutRegionsInput
    posts?: PostUncheckedCreateNestedManyWithoutRegionsInput
    datasets?: ResearchDatasetUncheckedCreateNestedManyWithoutRegionsInput
    series?: SeriesUncheckedCreateNestedManyWithoutRegionsInput
    volumes?: VolumeUncheckedCreateNestedManyWithoutRegionsInput
  }

  export type RegionCreateOrConnectWithoutArtifactsInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutArtifactsInput, RegionUncheckedCreateWithoutArtifactsInput>
  }

  export type TagCreateWithoutArtifactsInput = {
    id?: string
    slug: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    posts?: PostTagCreateNestedManyWithoutTagInput
    collections?: CollectionCreateNestedManyWithoutTagsInput
    layers?: LayerCreateNestedManyWithoutTagsInput
    maps?: MapCreateNestedManyWithoutTagsInput
    pages?: PageCreateNestedManyWithoutTagsInput
    series?: SeriesCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutArtifactsInput = {
    id?: string
    slug: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    posts?: PostTagUncheckedCreateNestedManyWithoutTagInput
    collections?: CollectionUncheckedCreateNestedManyWithoutTagsInput
    layers?: LayerUncheckedCreateNestedManyWithoutTagsInput
    maps?: MapUncheckedCreateNestedManyWithoutTagsInput
    pages?: PageUncheckedCreateNestedManyWithoutTagsInput
    series?: SeriesUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutArtifactsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutArtifactsInput, TagUncheckedCreateWithoutArtifactsInput>
  }

  export type VolumePageCreateWithoutArtifactsInput = {
    id?: string
    sequenceIndex: number
    label?: string
    createdAt?: Date | string
    isVisible?: boolean
    data?: PageDataCreateNestedOneWithoutPageInput
    images?: PageImageCreateNestedManyWithoutPageInput
    texts?: PageTextCreateNestedManyWithoutPageInput
    volume?: VolumeCreateNestedOneWithoutPagesInput
  }

  export type VolumePageUncheckedCreateWithoutArtifactsInput = {
    id?: string
    volumeId?: string | null
    sequenceIndex: number
    label?: string
    createdAt?: Date | string
    isVisible?: boolean
    data?: PageDataUncheckedCreateNestedOneWithoutPageInput
    images?: PageImageUncheckedCreateNestedManyWithoutPageInput
    texts?: PageTextUncheckedCreateNestedManyWithoutPageInput
  }

  export type VolumePageCreateOrConnectWithoutArtifactsInput = {
    where: VolumePageWhereUniqueInput
    create: XOR<VolumePageCreateWithoutArtifactsInput, VolumePageUncheckedCreateWithoutArtifactsInput>
  }

  export type ArtifactCategoryUpsertWithoutArtifactsInput = {
    update: XOR<ArtifactCategoryUpdateWithoutArtifactsInput, ArtifactCategoryUncheckedUpdateWithoutArtifactsInput>
    create: XOR<ArtifactCategoryCreateWithoutArtifactsInput, ArtifactCategoryUncheckedCreateWithoutArtifactsInput>
    where?: ArtifactCategoryWhereInput
  }

  export type ArtifactCategoryUpdateToOneWithWhereWithoutArtifactsInput = {
    where?: ArtifactCategoryWhereInput
    data: XOR<ArtifactCategoryUpdateWithoutArtifactsInput, ArtifactCategoryUncheckedUpdateWithoutArtifactsInput>
  }

  export type ArtifactCategoryUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtifactCategoryUncheckedUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PeriodUpsertWithWhereUniqueWithoutArtifactsInput = {
    where: PeriodWhereUniqueInput
    update: XOR<PeriodUpdateWithoutArtifactsInput, PeriodUncheckedUpdateWithoutArtifactsInput>
    create: XOR<PeriodCreateWithoutArtifactsInput, PeriodUncheckedCreateWithoutArtifactsInput>
  }

  export type PeriodUpdateWithWhereUniqueWithoutArtifactsInput = {
    where: PeriodWhereUniqueInput
    data: XOR<PeriodUpdateWithoutArtifactsInput, PeriodUncheckedUpdateWithoutArtifactsInput>
  }

  export type PeriodUpdateManyWithWhereWithoutArtifactsInput = {
    where: PeriodScalarWhereInput
    data: XOR<PeriodUpdateManyMutationInput, PeriodUncheckedUpdateManyWithoutArtifactsInput>
  }

  export type PeriodScalarWhereInput = {
    AND?: PeriodScalarWhereInput | PeriodScalarWhereInput[]
    OR?: PeriodScalarWhereInput[]
    NOT?: PeriodScalarWhereInput | PeriodScalarWhereInput[]
    id?: UuidFilter<"Period"> | string
    slug?: StringFilter<"Period"> | string
    name?: StringFilter<"Period"> | string
    nameI18n?: JsonFilter<"Period">
    dateStart?: DateTimeNullableFilter<"Period"> | Date | string | null
    dateEnd?: DateTimeNullableFilter<"Period"> | Date | string | null
    createdAt?: DateTimeFilter<"Period"> | Date | string
  }

  export type PlaceUpsertWithWhereUniqueWithoutArtifactsInput = {
    where: PlaceWhereUniqueInput
    update: XOR<PlaceUpdateWithoutArtifactsInput, PlaceUncheckedUpdateWithoutArtifactsInput>
    create: XOR<PlaceCreateWithoutArtifactsInput, PlaceUncheckedCreateWithoutArtifactsInput>
  }

  export type PlaceUpdateWithWhereUniqueWithoutArtifactsInput = {
    where: PlaceWhereUniqueInput
    data: XOR<PlaceUpdateWithoutArtifactsInput, PlaceUncheckedUpdateWithoutArtifactsInput>
  }

  export type PlaceUpdateManyWithWhereWithoutArtifactsInput = {
    where: PlaceScalarWhereInput
    data: XOR<PlaceUpdateManyMutationInput, PlaceUncheckedUpdateManyWithoutArtifactsInput>
  }

  export type PlaceScalarWhereInput = {
    AND?: PlaceScalarWhereInput | PlaceScalarWhereInput[]
    OR?: PlaceScalarWhereInput[]
    NOT?: PlaceScalarWhereInput | PlaceScalarWhereInput[]
    id?: UuidFilter<"Place"> | string
    geoname?: StringFilter<"Place"> | string
    geocode?: StringFilter<"Place"> | string
    lat?: FloatNullableFilter<"Place"> | number | null
    lon?: FloatNullableFilter<"Place"> | number | null
    countryCode?: StringFilter<"Place"> | string
    admin1?: StringNullableFilter<"Place"> | string | null
    admin2?: StringNullableFilter<"Place"> | string | null
  }

  export type RegionUpsertWithWhereUniqueWithoutArtifactsInput = {
    where: RegionWhereUniqueInput
    update: XOR<RegionUpdateWithoutArtifactsInput, RegionUncheckedUpdateWithoutArtifactsInput>
    create: XOR<RegionCreateWithoutArtifactsInput, RegionUncheckedCreateWithoutArtifactsInput>
  }

  export type RegionUpdateWithWhereUniqueWithoutArtifactsInput = {
    where: RegionWhereUniqueInput
    data: XOR<RegionUpdateWithoutArtifactsInput, RegionUncheckedUpdateWithoutArtifactsInput>
  }

  export type RegionUpdateManyWithWhereWithoutArtifactsInput = {
    where: RegionScalarWhereInput
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyWithoutArtifactsInput>
  }

  export type TagUpsertWithWhereUniqueWithoutArtifactsInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutArtifactsInput, TagUncheckedUpdateWithoutArtifactsInput>
    create: XOR<TagCreateWithoutArtifactsInput, TagUncheckedCreateWithoutArtifactsInput>
  }

  export type TagUpdateWithWhereUniqueWithoutArtifactsInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutArtifactsInput, TagUncheckedUpdateWithoutArtifactsInput>
  }

  export type TagUpdateManyWithWhereWithoutArtifactsInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutArtifactsInput>
  }

  export type VolumePageUpsertWithWhereUniqueWithoutArtifactsInput = {
    where: VolumePageWhereUniqueInput
    update: XOR<VolumePageUpdateWithoutArtifactsInput, VolumePageUncheckedUpdateWithoutArtifactsInput>
    create: XOR<VolumePageCreateWithoutArtifactsInput, VolumePageUncheckedCreateWithoutArtifactsInput>
  }

  export type VolumePageUpdateWithWhereUniqueWithoutArtifactsInput = {
    where: VolumePageWhereUniqueInput
    data: XOR<VolumePageUpdateWithoutArtifactsInput, VolumePageUncheckedUpdateWithoutArtifactsInput>
  }

  export type VolumePageUpdateManyWithWhereWithoutArtifactsInput = {
    where: VolumePageScalarWhereInput
    data: XOR<VolumePageUpdateManyMutationInput, VolumePageUncheckedUpdateManyWithoutArtifactsInput>
  }

  export type UserCreateWithoutPageTextsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    pages?: PageCreateNestedManyWithoutAuthorInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPageTextsInput = {
    id?: string
    email: string
    name?: string | null
    passwordHash?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    emailVerified?: Date | string | null
    image?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    pages?: PageUncheckedCreateNestedManyWithoutAuthorInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPageTextsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPageTextsInput, UserUncheckedCreateWithoutPageTextsInput>
  }

  export type VolumePageCreateWithoutTextsInput = {
    id?: string
    sequenceIndex: number
    label?: string
    createdAt?: Date | string
    isVisible?: boolean
    data?: PageDataCreateNestedOneWithoutPageInput
    images?: PageImageCreateNestedManyWithoutPageInput
    volume?: VolumeCreateNestedOneWithoutPagesInput
    artifacts?: ArtifactCreateNestedManyWithoutPagesInput
  }

  export type VolumePageUncheckedCreateWithoutTextsInput = {
    id?: string
    volumeId?: string | null
    sequenceIndex: number
    label?: string
    createdAt?: Date | string
    isVisible?: boolean
    data?: PageDataUncheckedCreateNestedOneWithoutPageInput
    images?: PageImageUncheckedCreateNestedManyWithoutPageInput
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutPagesInput
  }

  export type VolumePageCreateOrConnectWithoutTextsInput = {
    where: VolumePageWhereUniqueInput
    create: XOR<VolumePageCreateWithoutTextsInput, VolumePageUncheckedCreateWithoutTextsInput>
  }

  export type UserUpsertWithoutPageTextsInput = {
    update: XOR<UserUpdateWithoutPageTextsInput, UserUncheckedUpdateWithoutPageTextsInput>
    create: XOR<UserCreateWithoutPageTextsInput, UserUncheckedCreateWithoutPageTextsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPageTextsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPageTextsInput, UserUncheckedUpdateWithoutPageTextsInput>
  }

  export type UserUpdateWithoutPageTextsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    pages?: PageUpdateManyWithoutAuthorNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPageTextsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    pages?: PageUncheckedUpdateManyWithoutAuthorNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VolumePageUpsertWithoutTextsInput = {
    update: XOR<VolumePageUpdateWithoutTextsInput, VolumePageUncheckedUpdateWithoutTextsInput>
    create: XOR<VolumePageCreateWithoutTextsInput, VolumePageUncheckedCreateWithoutTextsInput>
    where?: VolumePageWhereInput
  }

  export type VolumePageUpdateToOneWithWhereWithoutTextsInput = {
    where?: VolumePageWhereInput
    data: XOR<VolumePageUpdateWithoutTextsInput, VolumePageUncheckedUpdateWithoutTextsInput>
  }

  export type VolumePageUpdateWithoutTextsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequenceIndex?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    data?: PageDataUpdateOneWithoutPageNestedInput
    images?: PageImageUpdateManyWithoutPageNestedInput
    volume?: VolumeUpdateOneWithoutPagesNestedInput
    artifacts?: ArtifactUpdateManyWithoutPagesNestedInput
  }

  export type VolumePageUncheckedUpdateWithoutTextsInput = {
    id?: StringFieldUpdateOperationsInput | string
    volumeId?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceIndex?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    data?: PageDataUncheckedUpdateOneWithoutPageNestedInput
    images?: PageImageUncheckedUpdateManyWithoutPageNestedInput
    artifacts?: ArtifactUncheckedUpdateManyWithoutPagesNestedInput
  }

  export type VolumePageCreateWithoutDataInput = {
    id?: string
    sequenceIndex: number
    label?: string
    createdAt?: Date | string
    isVisible?: boolean
    images?: PageImageCreateNestedManyWithoutPageInput
    texts?: PageTextCreateNestedManyWithoutPageInput
    volume?: VolumeCreateNestedOneWithoutPagesInput
    artifacts?: ArtifactCreateNestedManyWithoutPagesInput
  }

  export type VolumePageUncheckedCreateWithoutDataInput = {
    id?: string
    volumeId?: string | null
    sequenceIndex: number
    label?: string
    createdAt?: Date | string
    isVisible?: boolean
    images?: PageImageUncheckedCreateNestedManyWithoutPageInput
    texts?: PageTextUncheckedCreateNestedManyWithoutPageInput
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutPagesInput
  }

  export type VolumePageCreateOrConnectWithoutDataInput = {
    where: VolumePageWhereUniqueInput
    create: XOR<VolumePageCreateWithoutDataInput, VolumePageUncheckedCreateWithoutDataInput>
  }

  export type VolumePageUpsertWithoutDataInput = {
    update: XOR<VolumePageUpdateWithoutDataInput, VolumePageUncheckedUpdateWithoutDataInput>
    create: XOR<VolumePageCreateWithoutDataInput, VolumePageUncheckedCreateWithoutDataInput>
    where?: VolumePageWhereInput
  }

  export type VolumePageUpdateToOneWithWhereWithoutDataInput = {
    where?: VolumePageWhereInput
    data: XOR<VolumePageUpdateWithoutDataInput, VolumePageUncheckedUpdateWithoutDataInput>
  }

  export type VolumePageUpdateWithoutDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequenceIndex?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    images?: PageImageUpdateManyWithoutPageNestedInput
    texts?: PageTextUpdateManyWithoutPageNestedInput
    volume?: VolumeUpdateOneWithoutPagesNestedInput
    artifacts?: ArtifactUpdateManyWithoutPagesNestedInput
  }

  export type VolumePageUncheckedUpdateWithoutDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    volumeId?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceIndex?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    images?: PageImageUncheckedUpdateManyWithoutPageNestedInput
    texts?: PageTextUncheckedUpdateManyWithoutPageNestedInput
    artifacts?: ArtifactUncheckedUpdateManyWithoutPagesNestedInput
  }

  export type VolumePageCreateWithoutImagesInput = {
    id?: string
    sequenceIndex: number
    label?: string
    createdAt?: Date | string
    isVisible?: boolean
    data?: PageDataCreateNestedOneWithoutPageInput
    texts?: PageTextCreateNestedManyWithoutPageInput
    volume?: VolumeCreateNestedOneWithoutPagesInput
    artifacts?: ArtifactCreateNestedManyWithoutPagesInput
  }

  export type VolumePageUncheckedCreateWithoutImagesInput = {
    id?: string
    volumeId?: string | null
    sequenceIndex: number
    label?: string
    createdAt?: Date | string
    isVisible?: boolean
    data?: PageDataUncheckedCreateNestedOneWithoutPageInput
    texts?: PageTextUncheckedCreateNestedManyWithoutPageInput
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutPagesInput
  }

  export type VolumePageCreateOrConnectWithoutImagesInput = {
    where: VolumePageWhereUniqueInput
    create: XOR<VolumePageCreateWithoutImagesInput, VolumePageUncheckedCreateWithoutImagesInput>
  }

  export type StorageFileCreateWithoutPageImagesInput = {
    id?: string
    bucketName?: string
    storageKey: string
    filename: string
    mimeType?: string | null
    sizeBytes?: number | null
    hashEtag?: string | null
    publicUrl?: string | null
    isPublic?: boolean
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: MediaCreateNestedManyWithoutStorageFileInput
  }

  export type StorageFileUncheckedCreateWithoutPageImagesInput = {
    id?: string
    bucketName?: string
    storageKey: string
    filename: string
    mimeType?: string | null
    sizeBytes?: number | null
    hashEtag?: string | null
    publicUrl?: string | null
    isPublic?: boolean
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: MediaUncheckedCreateNestedManyWithoutStorageFileInput
  }

  export type StorageFileCreateOrConnectWithoutPageImagesInput = {
    where: StorageFileWhereUniqueInput
    create: XOR<StorageFileCreateWithoutPageImagesInput, StorageFileUncheckedCreateWithoutPageImagesInput>
  }

  export type VolumePageUpsertWithoutImagesInput = {
    update: XOR<VolumePageUpdateWithoutImagesInput, VolumePageUncheckedUpdateWithoutImagesInput>
    create: XOR<VolumePageCreateWithoutImagesInput, VolumePageUncheckedCreateWithoutImagesInput>
    where?: VolumePageWhereInput
  }

  export type VolumePageUpdateToOneWithWhereWithoutImagesInput = {
    where?: VolumePageWhereInput
    data: XOR<VolumePageUpdateWithoutImagesInput, VolumePageUncheckedUpdateWithoutImagesInput>
  }

  export type VolumePageUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequenceIndex?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    data?: PageDataUpdateOneWithoutPageNestedInput
    texts?: PageTextUpdateManyWithoutPageNestedInput
    volume?: VolumeUpdateOneWithoutPagesNestedInput
    artifacts?: ArtifactUpdateManyWithoutPagesNestedInput
  }

  export type VolumePageUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    volumeId?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceIndex?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    data?: PageDataUncheckedUpdateOneWithoutPageNestedInput
    texts?: PageTextUncheckedUpdateManyWithoutPageNestedInput
    artifacts?: ArtifactUncheckedUpdateManyWithoutPagesNestedInput
  }

  export type StorageFileUpsertWithoutPageImagesInput = {
    update: XOR<StorageFileUpdateWithoutPageImagesInput, StorageFileUncheckedUpdateWithoutPageImagesInput>
    create: XOR<StorageFileCreateWithoutPageImagesInput, StorageFileUncheckedCreateWithoutPageImagesInput>
    where?: StorageFileWhereInput
  }

  export type StorageFileUpdateToOneWithWhereWithoutPageImagesInput = {
    where?: StorageFileWhereInput
    data: XOR<StorageFileUpdateWithoutPageImagesInput, StorageFileUncheckedUpdateWithoutPageImagesInput>
  }

  export type StorageFileUpdateWithoutPageImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableFloatFieldUpdateOperationsInput | number | null
    hashEtag?: NullableStringFieldUpdateOperationsInput | string | null
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: MediaUpdateManyWithoutStorageFileNestedInput
  }

  export type StorageFileUncheckedUpdateWithoutPageImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableFloatFieldUpdateOperationsInput | number | null
    hashEtag?: NullableStringFieldUpdateOperationsInput | string | null
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: MediaUncheckedUpdateManyWithoutStorageFileNestedInput
  }

  export type MediaCreateWithoutStorageFileInput = {
    id?: string
    filename: string
    url: string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailForCategory?: CategoryCreateNestedManyWithoutThumbnailInput
    thumbnailForCollections?: CollectionCreateNestedManyWithoutThumbnailInput
    thumbnailForMaps?: MapCreateNestedManyWithoutThumbnailInput
    thumbnailForPages?: PageCreateNestedManyWithoutThumbnailInput
    thumbnailForPosts?: PostCreateNestedManyWithoutThumbnailInput
    thumbnailForDataset?: ResearchDatasetCreateNestedManyWithoutThumbnailInput
    thumbnailForSeries?: SeriesCreateNestedManyWithoutThumbnailInput
    thumbnailForVolumes?: VolumeCreateNestedManyWithoutThumbnailInput
  }

  export type MediaUncheckedCreateWithoutStorageFileInput = {
    id?: string
    filename: string
    url: string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailForCategory?: CategoryUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForCollections?: CollectionUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForMaps?: MapUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForPages?: PageUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForPosts?: PostUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForDataset?: ResearchDatasetUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForSeries?: SeriesUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForVolumes?: VolumeUncheckedCreateNestedManyWithoutThumbnailInput
  }

  export type MediaCreateOrConnectWithoutStorageFileInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutStorageFileInput, MediaUncheckedCreateWithoutStorageFileInput>
  }

  export type MediaCreateManyStorageFileInputEnvelope = {
    data: MediaCreateManyStorageFileInput | MediaCreateManyStorageFileInput[]
    skipDuplicates?: boolean
  }

  export type PageImageCreateWithoutStorageFileInput = {
    id?: string
    useType?: $Enums.ImageUseType
    createdAt?: Date | string
    page: VolumePageCreateNestedOneWithoutImagesInput
  }

  export type PageImageUncheckedCreateWithoutStorageFileInput = {
    id?: string
    pageId: string
    useType?: $Enums.ImageUseType
    createdAt?: Date | string
  }

  export type PageImageCreateOrConnectWithoutStorageFileInput = {
    where: PageImageWhereUniqueInput
    create: XOR<PageImageCreateWithoutStorageFileInput, PageImageUncheckedCreateWithoutStorageFileInput>
  }

  export type PageImageCreateManyStorageFileInputEnvelope = {
    data: PageImageCreateManyStorageFileInput | PageImageCreateManyStorageFileInput[]
    skipDuplicates?: boolean
  }

  export type MediaUpsertWithWhereUniqueWithoutStorageFileInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutStorageFileInput, MediaUncheckedUpdateWithoutStorageFileInput>
    create: XOR<MediaCreateWithoutStorageFileInput, MediaUncheckedCreateWithoutStorageFileInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutStorageFileInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutStorageFileInput, MediaUncheckedUpdateWithoutStorageFileInput>
  }

  export type MediaUpdateManyWithWhereWithoutStorageFileInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutStorageFileInput>
  }

  export type MediaScalarWhereInput = {
    AND?: MediaScalarWhereInput | MediaScalarWhereInput[]
    OR?: MediaScalarWhereInput[]
    NOT?: MediaScalarWhereInput | MediaScalarWhereInput[]
    id?: UuidFilter<"Media"> | string
    filename?: StringFilter<"Media"> | string
    url?: StringFilter<"Media"> | string
    storageFileId?: UuidNullableFilter<"Media"> | string | null
    altTextI18n?: JsonNullableFilter<"Media">
    createdAt?: DateTimeFilter<"Media"> | Date | string
  }

  export type PageImageUpsertWithWhereUniqueWithoutStorageFileInput = {
    where: PageImageWhereUniqueInput
    update: XOR<PageImageUpdateWithoutStorageFileInput, PageImageUncheckedUpdateWithoutStorageFileInput>
    create: XOR<PageImageCreateWithoutStorageFileInput, PageImageUncheckedCreateWithoutStorageFileInput>
  }

  export type PageImageUpdateWithWhereUniqueWithoutStorageFileInput = {
    where: PageImageWhereUniqueInput
    data: XOR<PageImageUpdateWithoutStorageFileInput, PageImageUncheckedUpdateWithoutStorageFileInput>
  }

  export type PageImageUpdateManyWithWhereWithoutStorageFileInput = {
    where: PageImageScalarWhereInput
    data: XOR<PageImageUpdateManyMutationInput, PageImageUncheckedUpdateManyWithoutStorageFileInput>
  }

  export type CategoryCreateWithoutThumbnailInput = {
    id?: string
    title: string
    slug: string
    createdAt?: Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    layers?: LayerCreateNestedManyWithoutCategoryInput
    maps?: MapCreateNestedManyWithoutCategoryInput
    datasets?: ResearchDatasetCreateNestedManyWithoutCategoryInput
    posts?: PostCreateNestedManyWithoutCategoriesInput
    series?: SeriesCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryUncheckedCreateWithoutThumbnailInput = {
    id?: string
    title: string
    slug: string
    createdAt?: Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    layers?: LayerUncheckedCreateNestedManyWithoutCategoryInput
    maps?: MapUncheckedCreateNestedManyWithoutCategoryInput
    datasets?: ResearchDatasetUncheckedCreateNestedManyWithoutCategoryInput
    posts?: PostUncheckedCreateNestedManyWithoutCategoriesInput
    series?: SeriesUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type CategoryCreateOrConnectWithoutThumbnailInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutThumbnailInput, CategoryUncheckedCreateWithoutThumbnailInput>
  }

  export type CategoryCreateManyThumbnailInputEnvelope = {
    data: CategoryCreateManyThumbnailInput | CategoryCreateManyThumbnailInput[]
    skipDuplicates?: boolean
  }

  export type CollectionCreateWithoutThumbnailInput = {
    id?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    series?: SeriesCreateNestedManyWithoutCollectionInput
    regions?: RegionCreateNestedManyWithoutCollectionsInput
    tags?: TagCreateNestedManyWithoutCollectionsInput
  }

  export type CollectionUncheckedCreateWithoutThumbnailInput = {
    id?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    series?: SeriesUncheckedCreateNestedManyWithoutCollectionInput
    regions?: RegionUncheckedCreateNestedManyWithoutCollectionsInput
    tags?: TagUncheckedCreateNestedManyWithoutCollectionsInput
  }

  export type CollectionCreateOrConnectWithoutThumbnailInput = {
    where: CollectionWhereUniqueInput
    create: XOR<CollectionCreateWithoutThumbnailInput, CollectionUncheckedCreateWithoutThumbnailInput>
  }

  export type CollectionCreateManyThumbnailInputEnvelope = {
    data: CollectionCreateManyThumbnailInput | CollectionCreateManyThumbnailInput[]
    skipDuplicates?: boolean
  }

  export type MapCreateWithoutThumbnailInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: number | null
    version?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    period?: string | null
    title?: string
    yearMax?: number | null
    yearMin?: number | null
    status?: $Enums.ContentStatus
    resources?: DatasetResourceCreateNestedManyWithoutMapInput
    layers?: MapLayerAssociationCreateNestedManyWithoutMapInput
    category?: CategoryCreateNestedOneWithoutMapsInput
    regions?: RegionCreateNestedManyWithoutMapsInput
    tags?: TagCreateNestedManyWithoutMapsInput
  }

  export type MapUncheckedCreateWithoutThumbnailInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: number | null
    version?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    period?: string | null
    title?: string
    yearMax?: number | null
    yearMin?: number | null
    categoryId?: string | null
    status?: $Enums.ContentStatus
    resources?: DatasetResourceUncheckedCreateNestedManyWithoutMapInput
    layers?: MapLayerAssociationUncheckedCreateNestedManyWithoutMapInput
    regions?: RegionUncheckedCreateNestedManyWithoutMapsInput
    tags?: TagUncheckedCreateNestedManyWithoutMapsInput
  }

  export type MapCreateOrConnectWithoutThumbnailInput = {
    where: MapWhereUniqueInput
    create: XOR<MapCreateWithoutThumbnailInput, MapUncheckedCreateWithoutThumbnailInput>
  }

  export type MapCreateManyThumbnailInputEnvelope = {
    data: MapCreateManyThumbnailInput | MapCreateManyThumbnailInput[]
    skipDuplicates?: boolean
  }

  export type StorageFileCreateWithoutMediaInput = {
    id?: string
    bucketName?: string
    storageKey: string
    filename: string
    mimeType?: string | null
    sizeBytes?: number | null
    hashEtag?: string | null
    publicUrl?: string | null
    isPublic?: boolean
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pageImages?: PageImageCreateNestedManyWithoutStorageFileInput
  }

  export type StorageFileUncheckedCreateWithoutMediaInput = {
    id?: string
    bucketName?: string
    storageKey: string
    filename: string
    mimeType?: string | null
    sizeBytes?: number | null
    hashEtag?: string | null
    publicUrl?: string | null
    isPublic?: boolean
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pageImages?: PageImageUncheckedCreateNestedManyWithoutStorageFileInput
  }

  export type StorageFileCreateOrConnectWithoutMediaInput = {
    where: StorageFileWhereUniqueInput
    create: XOR<StorageFileCreateWithoutMediaInput, StorageFileUncheckedCreateWithoutMediaInput>
  }

  export type PageCreateWithoutThumbnailInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content?: string | null
    excerpt?: string | null
    sources?: string | null
    citations?: string | null
    language?: $Enums.AppLanguage
    translationGroupId?: string | null
    status?: $Enums.ContentStatus
    metaDescription?: string | null
    metaKeywords?: string | null
    template?: string | null
    menuOrder?: number
    showInMenu?: boolean
    author?: UserCreateNestedOneWithoutPagesInput
    parent?: PageCreateNestedOneWithoutChildrenInput
    children?: PageCreateNestedManyWithoutParentInput
    regions?: RegionCreateNestedManyWithoutPagesInput
    tags?: TagCreateNestedManyWithoutPagesInput
    menuItems?: MenuItemCreateNestedManyWithoutPageInput
    footerItems?: FooterColumnItemCreateNestedManyWithoutPageInput
  }

  export type PageUncheckedCreateWithoutThumbnailInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content?: string | null
    excerpt?: string | null
    sources?: string | null
    citations?: string | null
    language?: $Enums.AppLanguage
    translationGroupId?: string | null
    status?: $Enums.ContentStatus
    authorId?: string | null
    parentId?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    template?: string | null
    menuOrder?: number
    showInMenu?: boolean
    children?: PageUncheckedCreateNestedManyWithoutParentInput
    regions?: RegionUncheckedCreateNestedManyWithoutPagesInput
    tags?: TagUncheckedCreateNestedManyWithoutPagesInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutPageInput
    footerItems?: FooterColumnItemUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageCreateOrConnectWithoutThumbnailInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutThumbnailInput, PageUncheckedCreateWithoutThumbnailInput>
  }

  export type PageCreateManyThumbnailInputEnvelope = {
    data: PageCreateManyThumbnailInput | PageCreateManyThumbnailInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutThumbnailInput = {
    id?: string
    translationGroupId?: string
    language?: $Enums.AppLanguage
    title: string
    slug: string
    content?: string | null
    sources?: string | null
    excerpt?: string | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: PostTagCreateNestedManyWithoutPostInput
    author?: UserCreateNestedOneWithoutPostsInput
    categories?: CategoryCreateNestedManyWithoutPostsInput
    regions?: RegionCreateNestedManyWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutThumbnailInput = {
    id?: string
    translationGroupId?: string
    language?: $Enums.AppLanguage
    title: string
    slug: string
    content?: string | null
    sources?: string | null
    excerpt?: string | null
    status?: $Enums.ContentStatus
    authorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    categories?: CategoryUncheckedCreateNestedManyWithoutPostsInput
    regions?: RegionUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostCreateOrConnectWithoutThumbnailInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutThumbnailInput, PostUncheckedCreateWithoutThumbnailInput>
  }

  export type PostCreateManyThumbnailInputEnvelope = {
    data: PostCreateManyThumbnailInput | PostCreateManyThumbnailInput[]
    skipDuplicates?: boolean
  }

  export type ResearchDatasetCreateWithoutThumbnailInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ContentStatus
    maturity?: $Enums.DataMaturity
    version?: string | null
    license?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    title?: string
    citationText?: string | null
    codebookText?: string | null
    maxYear?: number | null
    minYear?: number | null
    sources?: string | null
    isVisible?: boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    resources?: DatasetResourceCreateNestedManyWithoutDatasetInput
    category?: CategoryCreateNestedOneWithoutDatasetsInput
    regions?: RegionCreateNestedManyWithoutDatasetsInput
  }

  export type ResearchDatasetUncheckedCreateWithoutThumbnailInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ContentStatus
    maturity?: $Enums.DataMaturity
    version?: string | null
    license?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    title?: string
    categoryId?: string | null
    citationText?: string | null
    codebookText?: string | null
    maxYear?: number | null
    minYear?: number | null
    sources?: string | null
    isVisible?: boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    resources?: DatasetResourceUncheckedCreateNestedManyWithoutDatasetInput
    regions?: RegionUncheckedCreateNestedManyWithoutDatasetsInput
  }

  export type ResearchDatasetCreateOrConnectWithoutThumbnailInput = {
    where: ResearchDatasetWhereUniqueInput
    create: XOR<ResearchDatasetCreateWithoutThumbnailInput, ResearchDatasetUncheckedCreateWithoutThumbnailInput>
  }

  export type ResearchDatasetCreateManyThumbnailInputEnvelope = {
    data: ResearchDatasetCreateManyThumbnailInput | ResearchDatasetCreateManyThumbnailInput[]
    skipDuplicates?: boolean
  }

  export type SeriesCreateWithoutThumbnailInput = {
    id?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: number | null
    volumeLabelFormat?: string | null
    createdAt?: Date | string
    slug: string
    name?: string
    description?: string | null
    license?: string | null
    period?: string | null
    sourceLink?: string | null
    sources?: string | null
    author?: string | null
    editor?: string | null
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    languages?: SeriesCreatelanguagesInput | $Enums.ContentLanguage[]
    collection?: CollectionCreateNestedOneWithoutSeriesInput
    volumes?: VolumeCreateNestedManyWithoutSeriesInput
    categories?: CategoryCreateNestedManyWithoutSeriesInput
    regions?: RegionCreateNestedManyWithoutSeriesInput
    tags?: TagCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUncheckedCreateWithoutThumbnailInput = {
    id?: string
    collectionId?: string | null
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: number | null
    volumeLabelFormat?: string | null
    createdAt?: Date | string
    slug: string
    name?: string
    description?: string | null
    license?: string | null
    period?: string | null
    sourceLink?: string | null
    sources?: string | null
    author?: string | null
    editor?: string | null
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    languages?: SeriesCreatelanguagesInput | $Enums.ContentLanguage[]
    volumes?: VolumeUncheckedCreateNestedManyWithoutSeriesInput
    categories?: CategoryUncheckedCreateNestedManyWithoutSeriesInput
    regions?: RegionUncheckedCreateNestedManyWithoutSeriesInput
    tags?: TagUncheckedCreateNestedManyWithoutSeriesInput
  }

  export type SeriesCreateOrConnectWithoutThumbnailInput = {
    where: SeriesWhereUniqueInput
    create: XOR<SeriesCreateWithoutThumbnailInput, SeriesUncheckedCreateWithoutThumbnailInput>
  }

  export type SeriesCreateManyThumbnailInputEnvelope = {
    data: SeriesCreateManyThumbnailInput | SeriesCreateManyThumbnailInput[]
    skipDuplicates?: boolean
  }

  export type VolumeCreateWithoutThumbnailInput = {
    id?: string
    indexNumber?: number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: string | null
    yearContent?: number | null
    createdAt?: Date | string
    slug: string
    title?: string
    description?: string | null
    license?: string | null
    sourceLink?: string | null
    sources?: string | null
    year?: number | null
    author?: string | null
    editor?: string | null
    languages?: VolumeCreatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: number | null
    yearMin?: number | null
    pages?: VolumePageCreateNestedManyWithoutVolumeInput
    series?: SeriesCreateNestedOneWithoutVolumesInput
    regions?: RegionCreateNestedManyWithoutVolumesInput
  }

  export type VolumeUncheckedCreateWithoutThumbnailInput = {
    id?: string
    seriesId?: string | null
    indexNumber?: number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: string | null
    yearContent?: number | null
    createdAt?: Date | string
    slug: string
    title?: string
    description?: string | null
    license?: string | null
    sourceLink?: string | null
    sources?: string | null
    year?: number | null
    author?: string | null
    editor?: string | null
    languages?: VolumeCreatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: number | null
    yearMin?: number | null
    pages?: VolumePageUncheckedCreateNestedManyWithoutVolumeInput
    regions?: RegionUncheckedCreateNestedManyWithoutVolumesInput
  }

  export type VolumeCreateOrConnectWithoutThumbnailInput = {
    where: VolumeWhereUniqueInput
    create: XOR<VolumeCreateWithoutThumbnailInput, VolumeUncheckedCreateWithoutThumbnailInput>
  }

  export type VolumeCreateManyThumbnailInputEnvelope = {
    data: VolumeCreateManyThumbnailInput | VolumeCreateManyThumbnailInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithWhereUniqueWithoutThumbnailInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutThumbnailInput, CategoryUncheckedUpdateWithoutThumbnailInput>
    create: XOR<CategoryCreateWithoutThumbnailInput, CategoryUncheckedCreateWithoutThumbnailInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutThumbnailInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutThumbnailInput, CategoryUncheckedUpdateWithoutThumbnailInput>
  }

  export type CategoryUpdateManyWithWhereWithoutThumbnailInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutThumbnailInput>
  }

  export type CollectionUpsertWithWhereUniqueWithoutThumbnailInput = {
    where: CollectionWhereUniqueInput
    update: XOR<CollectionUpdateWithoutThumbnailInput, CollectionUncheckedUpdateWithoutThumbnailInput>
    create: XOR<CollectionCreateWithoutThumbnailInput, CollectionUncheckedCreateWithoutThumbnailInput>
  }

  export type CollectionUpdateWithWhereUniqueWithoutThumbnailInput = {
    where: CollectionWhereUniqueInput
    data: XOR<CollectionUpdateWithoutThumbnailInput, CollectionUncheckedUpdateWithoutThumbnailInput>
  }

  export type CollectionUpdateManyWithWhereWithoutThumbnailInput = {
    where: CollectionScalarWhereInput
    data: XOR<CollectionUpdateManyMutationInput, CollectionUncheckedUpdateManyWithoutThumbnailInput>
  }

  export type CollectionScalarWhereInput = {
    AND?: CollectionScalarWhereInput | CollectionScalarWhereInput[]
    OR?: CollectionScalarWhereInput[]
    NOT?: CollectionScalarWhereInput | CollectionScalarWhereInput[]
    id?: UuidFilter<"Collection"> | string
    nameI18n?: JsonFilter<"Collection">
    descriptionI18n?: JsonNullableFilter<"Collection">
    createdAt?: DateTimeFilter<"Collection"> | Date | string
    thumbnailId?: UuidNullableFilter<"Collection"> | string | null
    name?: StringFilter<"Collection"> | string
    referenceCode?: StringNullableFilter<"Collection"> | string | null
    yearMax?: IntNullableFilter<"Collection"> | number | null
    yearMin?: IntNullableFilter<"Collection"> | number | null
  }

  export type MapUpsertWithWhereUniqueWithoutThumbnailInput = {
    where: MapWhereUniqueInput
    update: XOR<MapUpdateWithoutThumbnailInput, MapUncheckedUpdateWithoutThumbnailInput>
    create: XOR<MapCreateWithoutThumbnailInput, MapUncheckedCreateWithoutThumbnailInput>
  }

  export type MapUpdateWithWhereUniqueWithoutThumbnailInput = {
    where: MapWhereUniqueInput
    data: XOR<MapUpdateWithoutThumbnailInput, MapUncheckedUpdateWithoutThumbnailInput>
  }

  export type MapUpdateManyWithWhereWithoutThumbnailInput = {
    where: MapScalarWhereInput
    data: XOR<MapUpdateManyMutationInput, MapUncheckedUpdateManyWithoutThumbnailInput>
  }

  export type MapScalarWhereInput = {
    AND?: MapScalarWhereInput | MapScalarWhereInput[]
    OR?: MapScalarWhereInput[]
    NOT?: MapScalarWhereInput | MapScalarWhereInput[]
    id?: UuidFilter<"Map"> | string
    slug?: StringFilter<"Map"> | string
    titleI18n?: JsonNullableFilter<"Map">
    descriptionI18n?: JsonNullableFilter<"Map">
    year?: IntNullableFilter<"Map"> | number | null
    version?: StringNullableFilter<"Map"> | string | null
    thumbnailId?: UuidNullableFilter<"Map"> | string | null
    config?: JsonNullableFilter<"Map">
    globalStyleConfig?: JsonNullableFilter<"Map">
    referenceLinks?: JsonNullableFilter<"Map">
    createdAt?: DateTimeFilter<"Map"> | Date | string
    updatedAt?: DateTimeFilter<"Map"> | Date | string
    description?: StringNullableFilter<"Map"> | string | null
    period?: StringNullableFilter<"Map"> | string | null
    title?: StringFilter<"Map"> | string
    yearMax?: IntNullableFilter<"Map"> | number | null
    yearMin?: IntNullableFilter<"Map"> | number | null
    categoryId?: UuidNullableFilter<"Map"> | string | null
    status?: EnumContentStatusFilter<"Map"> | $Enums.ContentStatus
  }

  export type StorageFileUpsertWithoutMediaInput = {
    update: XOR<StorageFileUpdateWithoutMediaInput, StorageFileUncheckedUpdateWithoutMediaInput>
    create: XOR<StorageFileCreateWithoutMediaInput, StorageFileUncheckedCreateWithoutMediaInput>
    where?: StorageFileWhereInput
  }

  export type StorageFileUpdateToOneWithWhereWithoutMediaInput = {
    where?: StorageFileWhereInput
    data: XOR<StorageFileUpdateWithoutMediaInput, StorageFileUncheckedUpdateWithoutMediaInput>
  }

  export type StorageFileUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableFloatFieldUpdateOperationsInput | number | null
    hashEtag?: NullableStringFieldUpdateOperationsInput | string | null
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pageImages?: PageImageUpdateManyWithoutStorageFileNestedInput
  }

  export type StorageFileUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    bucketName?: StringFieldUpdateOperationsInput | string
    storageKey?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    sizeBytes?: NullableFloatFieldUpdateOperationsInput | number | null
    hashEtag?: NullableStringFieldUpdateOperationsInput | string | null
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pageImages?: PageImageUncheckedUpdateManyWithoutStorageFileNestedInput
  }

  export type PageUpsertWithWhereUniqueWithoutThumbnailInput = {
    where: PageWhereUniqueInput
    update: XOR<PageUpdateWithoutThumbnailInput, PageUncheckedUpdateWithoutThumbnailInput>
    create: XOR<PageCreateWithoutThumbnailInput, PageUncheckedCreateWithoutThumbnailInput>
  }

  export type PageUpdateWithWhereUniqueWithoutThumbnailInput = {
    where: PageWhereUniqueInput
    data: XOR<PageUpdateWithoutThumbnailInput, PageUncheckedUpdateWithoutThumbnailInput>
  }

  export type PageUpdateManyWithWhereWithoutThumbnailInput = {
    where: PageScalarWhereInput
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyWithoutThumbnailInput>
  }

  export type PostUpsertWithWhereUniqueWithoutThumbnailInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutThumbnailInput, PostUncheckedUpdateWithoutThumbnailInput>
    create: XOR<PostCreateWithoutThumbnailInput, PostUncheckedCreateWithoutThumbnailInput>
  }

  export type PostUpdateWithWhereUniqueWithoutThumbnailInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutThumbnailInput, PostUncheckedUpdateWithoutThumbnailInput>
  }

  export type PostUpdateManyWithWhereWithoutThumbnailInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutThumbnailInput>
  }

  export type ResearchDatasetUpsertWithWhereUniqueWithoutThumbnailInput = {
    where: ResearchDatasetWhereUniqueInput
    update: XOR<ResearchDatasetUpdateWithoutThumbnailInput, ResearchDatasetUncheckedUpdateWithoutThumbnailInput>
    create: XOR<ResearchDatasetCreateWithoutThumbnailInput, ResearchDatasetUncheckedCreateWithoutThumbnailInput>
  }

  export type ResearchDatasetUpdateWithWhereUniqueWithoutThumbnailInput = {
    where: ResearchDatasetWhereUniqueInput
    data: XOR<ResearchDatasetUpdateWithoutThumbnailInput, ResearchDatasetUncheckedUpdateWithoutThumbnailInput>
  }

  export type ResearchDatasetUpdateManyWithWhereWithoutThumbnailInput = {
    where: ResearchDatasetScalarWhereInput
    data: XOR<ResearchDatasetUpdateManyMutationInput, ResearchDatasetUncheckedUpdateManyWithoutThumbnailInput>
  }

  export type ResearchDatasetScalarWhereInput = {
    AND?: ResearchDatasetScalarWhereInput | ResearchDatasetScalarWhereInput[]
    OR?: ResearchDatasetScalarWhereInput[]
    NOT?: ResearchDatasetScalarWhereInput | ResearchDatasetScalarWhereInput[]
    id?: UuidFilter<"ResearchDataset"> | string
    slug?: StringFilter<"ResearchDataset"> | string
    titleI18n?: JsonNullableFilter<"ResearchDataset">
    codebookTextI18n?: JsonNullableFilter<"ResearchDataset">
    status?: EnumContentStatusFilter<"ResearchDataset"> | $Enums.ContentStatus
    maturity?: EnumDataMaturityFilter<"ResearchDataset"> | $Enums.DataMaturity
    version?: StringNullableFilter<"ResearchDataset"> | string | null
    license?: StringNullableFilter<"ResearchDataset"> | string | null
    thumbnailId?: UuidNullableFilter<"ResearchDataset"> | string | null
    createdAt?: DateTimeFilter<"ResearchDataset"> | Date | string
    updatedAt?: DateTimeFilter<"ResearchDataset"> | Date | string
    description?: StringNullableFilter<"ResearchDataset"> | string | null
    title?: StringFilter<"ResearchDataset"> | string
    categoryId?: UuidNullableFilter<"ResearchDataset"> | string | null
    citationText?: StringNullableFilter<"ResearchDataset"> | string | null
    codebookText?: StringNullableFilter<"ResearchDataset"> | string | null
    maxYear?: IntNullableFilter<"ResearchDataset"> | number | null
    minYear?: IntNullableFilter<"ResearchDataset"> | number | null
    sources?: StringNullableFilter<"ResearchDataset"> | string | null
    isVisible?: BoolFilter<"ResearchDataset"> | boolean
    sourcesI18n?: JsonNullableFilter<"ResearchDataset">
    descriptionI18n?: JsonNullableFilter<"ResearchDataset">
  }

  export type SeriesUpsertWithWhereUniqueWithoutThumbnailInput = {
    where: SeriesWhereUniqueInput
    update: XOR<SeriesUpdateWithoutThumbnailInput, SeriesUncheckedUpdateWithoutThumbnailInput>
    create: XOR<SeriesCreateWithoutThumbnailInput, SeriesUncheckedCreateWithoutThumbnailInput>
  }

  export type SeriesUpdateWithWhereUniqueWithoutThumbnailInput = {
    where: SeriesWhereUniqueInput
    data: XOR<SeriesUpdateWithoutThumbnailInput, SeriesUncheckedUpdateWithoutThumbnailInput>
  }

  export type SeriesUpdateManyWithWhereWithoutThumbnailInput = {
    where: SeriesScalarWhereInput
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyWithoutThumbnailInput>
  }

  export type VolumeUpsertWithWhereUniqueWithoutThumbnailInput = {
    where: VolumeWhereUniqueInput
    update: XOR<VolumeUpdateWithoutThumbnailInput, VolumeUncheckedUpdateWithoutThumbnailInput>
    create: XOR<VolumeCreateWithoutThumbnailInput, VolumeUncheckedCreateWithoutThumbnailInput>
  }

  export type VolumeUpdateWithWhereUniqueWithoutThumbnailInput = {
    where: VolumeWhereUniqueInput
    data: XOR<VolumeUpdateWithoutThumbnailInput, VolumeUncheckedUpdateWithoutThumbnailInput>
  }

  export type VolumeUpdateManyWithWhereWithoutThumbnailInput = {
    where: VolumeScalarWhereInput
    data: XOR<VolumeUpdateManyMutationInput, VolumeUncheckedUpdateManyWithoutThumbnailInput>
  }

  export type AdministrativePlaceCreateWithoutPlaceInput = {
    id?: string
    name: string
    year?: string | null
    source?: string | null
    admin1?: string | null
    admin2?: string | null
    jewishPop?: number | null
    totalPop?: number | null
  }

  export type AdministrativePlaceUncheckedCreateWithoutPlaceInput = {
    id?: string
    name: string
    year?: string | null
    source?: string | null
    admin1?: string | null
    admin2?: string | null
    jewishPop?: number | null
    totalPop?: number | null
  }

  export type AdministrativePlaceCreateOrConnectWithoutPlaceInput = {
    where: AdministrativePlaceWhereUniqueInput
    create: XOR<AdministrativePlaceCreateWithoutPlaceInput, AdministrativePlaceUncheckedCreateWithoutPlaceInput>
  }

  export type AdministrativePlaceCreateManyPlaceInputEnvelope = {
    data: AdministrativePlaceCreateManyPlaceInput | AdministrativePlaceCreateManyPlaceInput[]
    skipDuplicates?: boolean
  }

  export type ArtifactCreateWithoutPlacesInput = {
    id?: string
    slug: string
    content?: string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: number | null
    dateDisplay?: string | null
    dateSort?: Date | string | null
    excerpt?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: boolean
    displayTexts?: boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategory?: ArtifactCategoryCreateNestedOneWithoutArtifactsInput
    periods?: PeriodCreateNestedManyWithoutArtifactsInput
    regions?: RegionCreateNestedManyWithoutArtifactsInput
    tags?: TagCreateNestedManyWithoutArtifactsInput
    pages?: VolumePageCreateNestedManyWithoutArtifactsInput
  }

  export type ArtifactUncheckedCreateWithoutPlacesInput = {
    id?: string
    slug: string
    content?: string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: number | null
    dateDisplay?: string | null
    dateSort?: Date | string | null
    excerpt?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: boolean
    displayTexts?: boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategoryId?: string | null
    periods?: PeriodUncheckedCreateNestedManyWithoutArtifactsInput
    regions?: RegionUncheckedCreateNestedManyWithoutArtifactsInput
    tags?: TagUncheckedCreateNestedManyWithoutArtifactsInput
    pages?: VolumePageUncheckedCreateNestedManyWithoutArtifactsInput
  }

  export type ArtifactCreateOrConnectWithoutPlacesInput = {
    where: ArtifactWhereUniqueInput
    create: XOR<ArtifactCreateWithoutPlacesInput, ArtifactUncheckedCreateWithoutPlacesInput>
  }

  export type AdministrativePlaceUpsertWithWhereUniqueWithoutPlaceInput = {
    where: AdministrativePlaceWhereUniqueInput
    update: XOR<AdministrativePlaceUpdateWithoutPlaceInput, AdministrativePlaceUncheckedUpdateWithoutPlaceInput>
    create: XOR<AdministrativePlaceCreateWithoutPlaceInput, AdministrativePlaceUncheckedCreateWithoutPlaceInput>
  }

  export type AdministrativePlaceUpdateWithWhereUniqueWithoutPlaceInput = {
    where: AdministrativePlaceWhereUniqueInput
    data: XOR<AdministrativePlaceUpdateWithoutPlaceInput, AdministrativePlaceUncheckedUpdateWithoutPlaceInput>
  }

  export type AdministrativePlaceUpdateManyWithWhereWithoutPlaceInput = {
    where: AdministrativePlaceScalarWhereInput
    data: XOR<AdministrativePlaceUpdateManyMutationInput, AdministrativePlaceUncheckedUpdateManyWithoutPlaceInput>
  }

  export type AdministrativePlaceScalarWhereInput = {
    AND?: AdministrativePlaceScalarWhereInput | AdministrativePlaceScalarWhereInput[]
    OR?: AdministrativePlaceScalarWhereInput[]
    NOT?: AdministrativePlaceScalarWhereInput | AdministrativePlaceScalarWhereInput[]
    id?: UuidFilter<"AdministrativePlace"> | string
    name?: StringFilter<"AdministrativePlace"> | string
    year?: StringNullableFilter<"AdministrativePlace"> | string | null
    source?: StringNullableFilter<"AdministrativePlace"> | string | null
    admin1?: StringNullableFilter<"AdministrativePlace"> | string | null
    admin2?: StringNullableFilter<"AdministrativePlace"> | string | null
    jewishPop?: IntNullableFilter<"AdministrativePlace"> | number | null
    totalPop?: IntNullableFilter<"AdministrativePlace"> | number | null
    placeId?: UuidNullableFilter<"AdministrativePlace"> | string | null
  }

  export type ArtifactUpsertWithWhereUniqueWithoutPlacesInput = {
    where: ArtifactWhereUniqueInput
    update: XOR<ArtifactUpdateWithoutPlacesInput, ArtifactUncheckedUpdateWithoutPlacesInput>
    create: XOR<ArtifactCreateWithoutPlacesInput, ArtifactUncheckedCreateWithoutPlacesInput>
  }

  export type ArtifactUpdateWithWhereUniqueWithoutPlacesInput = {
    where: ArtifactWhereUniqueInput
    data: XOR<ArtifactUpdateWithoutPlacesInput, ArtifactUncheckedUpdateWithoutPlacesInput>
  }

  export type ArtifactUpdateManyWithWhereWithoutPlacesInput = {
    where: ArtifactScalarWhereInput
    data: XOR<ArtifactUpdateManyMutationInput, ArtifactUncheckedUpdateManyWithoutPlacesInput>
  }

  export type PlaceCreateWithoutAdministrativePlacesInput = {
    id?: string
    geoname: string
    geocode: string
    lat?: number | null
    lon?: number | null
    countryCode: string
    admin1?: string | null
    admin2?: string | null
    artifacts?: ArtifactCreateNestedManyWithoutPlacesInput
  }

  export type PlaceUncheckedCreateWithoutAdministrativePlacesInput = {
    id?: string
    geoname: string
    geocode: string
    lat?: number | null
    lon?: number | null
    countryCode: string
    admin1?: string | null
    admin2?: string | null
    artifacts?: ArtifactUncheckedCreateNestedManyWithoutPlacesInput
  }

  export type PlaceCreateOrConnectWithoutAdministrativePlacesInput = {
    where: PlaceWhereUniqueInput
    create: XOR<PlaceCreateWithoutAdministrativePlacesInput, PlaceUncheckedCreateWithoutAdministrativePlacesInput>
  }

  export type PlaceUpsertWithoutAdministrativePlacesInput = {
    update: XOR<PlaceUpdateWithoutAdministrativePlacesInput, PlaceUncheckedUpdateWithoutAdministrativePlacesInput>
    create: XOR<PlaceCreateWithoutAdministrativePlacesInput, PlaceUncheckedCreateWithoutAdministrativePlacesInput>
    where?: PlaceWhereInput
  }

  export type PlaceUpdateToOneWithWhereWithoutAdministrativePlacesInput = {
    where?: PlaceWhereInput
    data: XOR<PlaceUpdateWithoutAdministrativePlacesInput, PlaceUncheckedUpdateWithoutAdministrativePlacesInput>
  }

  export type PlaceUpdateWithoutAdministrativePlacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    geoname?: StringFieldUpdateOperationsInput | string
    geocode?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    countryCode?: StringFieldUpdateOperationsInput | string
    admin1?: NullableStringFieldUpdateOperationsInput | string | null
    admin2?: NullableStringFieldUpdateOperationsInput | string | null
    artifacts?: ArtifactUpdateManyWithoutPlacesNestedInput
  }

  export type PlaceUncheckedUpdateWithoutAdministrativePlacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    geoname?: StringFieldUpdateOperationsInput | string
    geocode?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    countryCode?: StringFieldUpdateOperationsInput | string
    admin1?: NullableStringFieldUpdateOperationsInput | string | null
    admin2?: NullableStringFieldUpdateOperationsInput | string | null
    artifacts?: ArtifactUncheckedUpdateManyWithoutPlacesNestedInput
  }

  export type PostTagCreateWithoutTagInput = {
    post: PostCreateNestedOneWithoutTagsInput
  }

  export type PostTagUncheckedCreateWithoutTagInput = {
    postId: string
  }

  export type PostTagCreateOrConnectWithoutTagInput = {
    where: PostTagWhereUniqueInput
    create: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput>
  }

  export type PostTagCreateManyTagInputEnvelope = {
    data: PostTagCreateManyTagInput | PostTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type ArtifactCreateWithoutTagsInput = {
    id?: string
    slug: string
    content?: string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: number | null
    dateDisplay?: string | null
    dateSort?: Date | string | null
    excerpt?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: boolean
    displayTexts?: boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategory?: ArtifactCategoryCreateNestedOneWithoutArtifactsInput
    periods?: PeriodCreateNestedManyWithoutArtifactsInput
    places?: PlaceCreateNestedManyWithoutArtifactsInput
    regions?: RegionCreateNestedManyWithoutArtifactsInput
    pages?: VolumePageCreateNestedManyWithoutArtifactsInput
  }

  export type ArtifactUncheckedCreateWithoutTagsInput = {
    id?: string
    slug: string
    content?: string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: number | null
    dateDisplay?: string | null
    dateSort?: Date | string | null
    excerpt?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: boolean
    displayTexts?: boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategoryId?: string | null
    periods?: PeriodUncheckedCreateNestedManyWithoutArtifactsInput
    places?: PlaceUncheckedCreateNestedManyWithoutArtifactsInput
    regions?: RegionUncheckedCreateNestedManyWithoutArtifactsInput
    pages?: VolumePageUncheckedCreateNestedManyWithoutArtifactsInput
  }

  export type ArtifactCreateOrConnectWithoutTagsInput = {
    where: ArtifactWhereUniqueInput
    create: XOR<ArtifactCreateWithoutTagsInput, ArtifactUncheckedCreateWithoutTagsInput>
  }

  export type CollectionCreateWithoutTagsInput = {
    id?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForCollectionsInput
    series?: SeriesCreateNestedManyWithoutCollectionInput
    regions?: RegionCreateNestedManyWithoutCollectionsInput
  }

  export type CollectionUncheckedCreateWithoutTagsInput = {
    id?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailId?: string | null
    name?: string
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    series?: SeriesUncheckedCreateNestedManyWithoutCollectionInput
    regions?: RegionUncheckedCreateNestedManyWithoutCollectionsInput
  }

  export type CollectionCreateOrConnectWithoutTagsInput = {
    where: CollectionWhereUniqueInput
    create: XOR<CollectionCreateWithoutTagsInput, CollectionUncheckedCreateWithoutTagsInput>
  }

  export type LayerCreateWithoutTagsInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: string | null
    status?: $Enums.ContentStatus
    version?: string | null
    type?: $Enums.LayerType
    citationText?: string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: string | null
    maturity?: $Enums.DataMaturity
    minYear?: number | null
    maxYear?: number | null
    sourceType?: $Enums.LayerSourceType
    sourceUrl?: string | null
    downloadUrl?: string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutLayersInput
    maps?: MapLayerAssociationCreateNestedManyWithoutLayerInput
    regions?: RegionCreateNestedManyWithoutLayersInput
  }

  export type LayerUncheckedCreateWithoutTagsInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: string | null
    status?: $Enums.ContentStatus
    version?: string | null
    categoryId?: string | null
    type?: $Enums.LayerType
    citationText?: string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: string | null
    maturity?: $Enums.DataMaturity
    minYear?: number | null
    maxYear?: number | null
    sourceType?: $Enums.LayerSourceType
    sourceUrl?: string | null
    downloadUrl?: string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    maps?: MapLayerAssociationUncheckedCreateNestedManyWithoutLayerInput
    regions?: RegionUncheckedCreateNestedManyWithoutLayersInput
  }

  export type LayerCreateOrConnectWithoutTagsInput = {
    where: LayerWhereUniqueInput
    create: XOR<LayerCreateWithoutTagsInput, LayerUncheckedCreateWithoutTagsInput>
  }

  export type MapCreateWithoutTagsInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: number | null
    version?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    period?: string | null
    title?: string
    yearMax?: number | null
    yearMin?: number | null
    status?: $Enums.ContentStatus
    resources?: DatasetResourceCreateNestedManyWithoutMapInput
    layers?: MapLayerAssociationCreateNestedManyWithoutMapInput
    category?: CategoryCreateNestedOneWithoutMapsInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForMapsInput
    regions?: RegionCreateNestedManyWithoutMapsInput
  }

  export type MapUncheckedCreateWithoutTagsInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: number | null
    version?: string | null
    thumbnailId?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    period?: string | null
    title?: string
    yearMax?: number | null
    yearMin?: number | null
    categoryId?: string | null
    status?: $Enums.ContentStatus
    resources?: DatasetResourceUncheckedCreateNestedManyWithoutMapInput
    layers?: MapLayerAssociationUncheckedCreateNestedManyWithoutMapInput
    regions?: RegionUncheckedCreateNestedManyWithoutMapsInput
  }

  export type MapCreateOrConnectWithoutTagsInput = {
    where: MapWhereUniqueInput
    create: XOR<MapCreateWithoutTagsInput, MapUncheckedCreateWithoutTagsInput>
  }

  export type PageCreateWithoutTagsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content?: string | null
    excerpt?: string | null
    sources?: string | null
    citations?: string | null
    language?: $Enums.AppLanguage
    translationGroupId?: string | null
    status?: $Enums.ContentStatus
    metaDescription?: string | null
    metaKeywords?: string | null
    template?: string | null
    menuOrder?: number
    showInMenu?: boolean
    author?: UserCreateNestedOneWithoutPagesInput
    parent?: PageCreateNestedOneWithoutChildrenInput
    children?: PageCreateNestedManyWithoutParentInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForPagesInput
    regions?: RegionCreateNestedManyWithoutPagesInput
    menuItems?: MenuItemCreateNestedManyWithoutPageInput
    footerItems?: FooterColumnItemCreateNestedManyWithoutPageInput
  }

  export type PageUncheckedCreateWithoutTagsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content?: string | null
    excerpt?: string | null
    sources?: string | null
    citations?: string | null
    language?: $Enums.AppLanguage
    translationGroupId?: string | null
    status?: $Enums.ContentStatus
    authorId?: string | null
    parentId?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    thumbnailId?: string | null
    template?: string | null
    menuOrder?: number
    showInMenu?: boolean
    children?: PageUncheckedCreateNestedManyWithoutParentInput
    regions?: RegionUncheckedCreateNestedManyWithoutPagesInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutPageInput
    footerItems?: FooterColumnItemUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageCreateOrConnectWithoutTagsInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutTagsInput, PageUncheckedCreateWithoutTagsInput>
  }

  export type SeriesCreateWithoutTagsInput = {
    id?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: number | null
    volumeLabelFormat?: string | null
    createdAt?: Date | string
    slug: string
    name?: string
    description?: string | null
    license?: string | null
    period?: string | null
    sourceLink?: string | null
    sources?: string | null
    author?: string | null
    editor?: string | null
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    languages?: SeriesCreatelanguagesInput | $Enums.ContentLanguage[]
    collection?: CollectionCreateNestedOneWithoutSeriesInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForSeriesInput
    volumes?: VolumeCreateNestedManyWithoutSeriesInput
    categories?: CategoryCreateNestedManyWithoutSeriesInput
    regions?: RegionCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUncheckedCreateWithoutTagsInput = {
    id?: string
    collectionId?: string | null
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: number | null
    volumeLabelFormat?: string | null
    thumbnailId?: string | null
    createdAt?: Date | string
    slug: string
    name?: string
    description?: string | null
    license?: string | null
    period?: string | null
    sourceLink?: string | null
    sources?: string | null
    author?: string | null
    editor?: string | null
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    languages?: SeriesCreatelanguagesInput | $Enums.ContentLanguage[]
    volumes?: VolumeUncheckedCreateNestedManyWithoutSeriesInput
    categories?: CategoryUncheckedCreateNestedManyWithoutSeriesInput
    regions?: RegionUncheckedCreateNestedManyWithoutSeriesInput
  }

  export type SeriesCreateOrConnectWithoutTagsInput = {
    where: SeriesWhereUniqueInput
    create: XOR<SeriesCreateWithoutTagsInput, SeriesUncheckedCreateWithoutTagsInput>
  }

  export type PostTagUpsertWithWhereUniqueWithoutTagInput = {
    where: PostTagWhereUniqueInput
    update: XOR<PostTagUpdateWithoutTagInput, PostTagUncheckedUpdateWithoutTagInput>
    create: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput>
  }

  export type PostTagUpdateWithWhereUniqueWithoutTagInput = {
    where: PostTagWhereUniqueInput
    data: XOR<PostTagUpdateWithoutTagInput, PostTagUncheckedUpdateWithoutTagInput>
  }

  export type PostTagUpdateManyWithWhereWithoutTagInput = {
    where: PostTagScalarWhereInput
    data: XOR<PostTagUpdateManyMutationInput, PostTagUncheckedUpdateManyWithoutTagInput>
  }

  export type ArtifactUpsertWithWhereUniqueWithoutTagsInput = {
    where: ArtifactWhereUniqueInput
    update: XOR<ArtifactUpdateWithoutTagsInput, ArtifactUncheckedUpdateWithoutTagsInput>
    create: XOR<ArtifactCreateWithoutTagsInput, ArtifactUncheckedCreateWithoutTagsInput>
  }

  export type ArtifactUpdateWithWhereUniqueWithoutTagsInput = {
    where: ArtifactWhereUniqueInput
    data: XOR<ArtifactUpdateWithoutTagsInput, ArtifactUncheckedUpdateWithoutTagsInput>
  }

  export type ArtifactUpdateManyWithWhereWithoutTagsInput = {
    where: ArtifactScalarWhereInput
    data: XOR<ArtifactUpdateManyMutationInput, ArtifactUncheckedUpdateManyWithoutTagsInput>
  }

  export type CollectionUpsertWithWhereUniqueWithoutTagsInput = {
    where: CollectionWhereUniqueInput
    update: XOR<CollectionUpdateWithoutTagsInput, CollectionUncheckedUpdateWithoutTagsInput>
    create: XOR<CollectionCreateWithoutTagsInput, CollectionUncheckedCreateWithoutTagsInput>
  }

  export type CollectionUpdateWithWhereUniqueWithoutTagsInput = {
    where: CollectionWhereUniqueInput
    data: XOR<CollectionUpdateWithoutTagsInput, CollectionUncheckedUpdateWithoutTagsInput>
  }

  export type CollectionUpdateManyWithWhereWithoutTagsInput = {
    where: CollectionScalarWhereInput
    data: XOR<CollectionUpdateManyMutationInput, CollectionUncheckedUpdateManyWithoutTagsInput>
  }

  export type LayerUpsertWithWhereUniqueWithoutTagsInput = {
    where: LayerWhereUniqueInput
    update: XOR<LayerUpdateWithoutTagsInput, LayerUncheckedUpdateWithoutTagsInput>
    create: XOR<LayerCreateWithoutTagsInput, LayerUncheckedCreateWithoutTagsInput>
  }

  export type LayerUpdateWithWhereUniqueWithoutTagsInput = {
    where: LayerWhereUniqueInput
    data: XOR<LayerUpdateWithoutTagsInput, LayerUncheckedUpdateWithoutTagsInput>
  }

  export type LayerUpdateManyWithWhereWithoutTagsInput = {
    where: LayerScalarWhereInput
    data: XOR<LayerUpdateManyMutationInput, LayerUncheckedUpdateManyWithoutTagsInput>
  }

  export type LayerScalarWhereInput = {
    AND?: LayerScalarWhereInput | LayerScalarWhereInput[]
    OR?: LayerScalarWhereInput[]
    NOT?: LayerScalarWhereInput | LayerScalarWhereInput[]
    id?: UuidFilter<"Layer"> | string
    slug?: StringFilter<"Layer"> | string
    name?: StringFilter<"Layer"> | string
    nameI18n?: JsonNullableFilter<"Layer">
    description?: StringNullableFilter<"Layer"> | string | null
    descriptionI18n?: JsonNullableFilter<"Layer">
    filename?: StringNullableFilter<"Layer"> | string | null
    status?: EnumContentStatusFilter<"Layer"> | $Enums.ContentStatus
    version?: StringNullableFilter<"Layer"> | string | null
    categoryId?: UuidNullableFilter<"Layer"> | string | null
    type?: EnumLayerTypeFilter<"Layer"> | $Enums.LayerType
    citationText?: StringNullableFilter<"Layer"> | string | null
    citationTextI18n?: JsonNullableFilter<"Layer">
    codebookText?: StringNullableFilter<"Layer"> | string | null
    codebookTextI18n?: JsonNullableFilter<"Layer">
    sources?: StringNullableFilter<"Layer"> | string | null
    sourcesI18n?: JsonNullableFilter<"Layer">
    license?: StringNullableFilter<"Layer"> | string | null
    maturity?: EnumDataMaturityFilter<"Layer"> | $Enums.DataMaturity
    minYear?: IntNullableFilter<"Layer"> | number | null
    maxYear?: IntNullableFilter<"Layer"> | number | null
    sourceType?: EnumLayerSourceTypeFilter<"Layer"> | $Enums.LayerSourceType
    sourceUrl?: StringNullableFilter<"Layer"> | string | null
    downloadUrl?: StringNullableFilter<"Layer"> | string | null
    geoJsonData?: JsonNullableFilter<"Layer">
    styleConfig?: JsonFilter<"Layer">
    thumbnail?: StringNullableFilter<"Layer"> | string | null
    createdAt?: DateTimeFilter<"Layer"> | Date | string
    updatedAt?: DateTimeFilter<"Layer"> | Date | string
  }

  export type MapUpsertWithWhereUniqueWithoutTagsInput = {
    where: MapWhereUniqueInput
    update: XOR<MapUpdateWithoutTagsInput, MapUncheckedUpdateWithoutTagsInput>
    create: XOR<MapCreateWithoutTagsInput, MapUncheckedCreateWithoutTagsInput>
  }

  export type MapUpdateWithWhereUniqueWithoutTagsInput = {
    where: MapWhereUniqueInput
    data: XOR<MapUpdateWithoutTagsInput, MapUncheckedUpdateWithoutTagsInput>
  }

  export type MapUpdateManyWithWhereWithoutTagsInput = {
    where: MapScalarWhereInput
    data: XOR<MapUpdateManyMutationInput, MapUncheckedUpdateManyWithoutTagsInput>
  }

  export type PageUpsertWithWhereUniqueWithoutTagsInput = {
    where: PageWhereUniqueInput
    update: XOR<PageUpdateWithoutTagsInput, PageUncheckedUpdateWithoutTagsInput>
    create: XOR<PageCreateWithoutTagsInput, PageUncheckedCreateWithoutTagsInput>
  }

  export type PageUpdateWithWhereUniqueWithoutTagsInput = {
    where: PageWhereUniqueInput
    data: XOR<PageUpdateWithoutTagsInput, PageUncheckedUpdateWithoutTagsInput>
  }

  export type PageUpdateManyWithWhereWithoutTagsInput = {
    where: PageScalarWhereInput
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyWithoutTagsInput>
  }

  export type SeriesUpsertWithWhereUniqueWithoutTagsInput = {
    where: SeriesWhereUniqueInput
    update: XOR<SeriesUpdateWithoutTagsInput, SeriesUncheckedUpdateWithoutTagsInput>
    create: XOR<SeriesCreateWithoutTagsInput, SeriesUncheckedCreateWithoutTagsInput>
  }

  export type SeriesUpdateWithWhereUniqueWithoutTagsInput = {
    where: SeriesWhereUniqueInput
    data: XOR<SeriesUpdateWithoutTagsInput, SeriesUncheckedUpdateWithoutTagsInput>
  }

  export type SeriesUpdateManyWithWhereWithoutTagsInput = {
    where: SeriesScalarWhereInput
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyWithoutTagsInput>
  }

  export type ArtifactCreateWithoutRegionsInput = {
    id?: string
    slug: string
    content?: string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: number | null
    dateDisplay?: string | null
    dateSort?: Date | string | null
    excerpt?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: boolean
    displayTexts?: boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategory?: ArtifactCategoryCreateNestedOneWithoutArtifactsInput
    periods?: PeriodCreateNestedManyWithoutArtifactsInput
    places?: PlaceCreateNestedManyWithoutArtifactsInput
    tags?: TagCreateNestedManyWithoutArtifactsInput
    pages?: VolumePageCreateNestedManyWithoutArtifactsInput
  }

  export type ArtifactUncheckedCreateWithoutRegionsInput = {
    id?: string
    slug: string
    content?: string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: number | null
    dateDisplay?: string | null
    dateSort?: Date | string | null
    excerpt?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: boolean
    displayTexts?: boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategoryId?: string | null
    periods?: PeriodUncheckedCreateNestedManyWithoutArtifactsInput
    places?: PlaceUncheckedCreateNestedManyWithoutArtifactsInput
    tags?: TagUncheckedCreateNestedManyWithoutArtifactsInput
    pages?: VolumePageUncheckedCreateNestedManyWithoutArtifactsInput
  }

  export type ArtifactCreateOrConnectWithoutRegionsInput = {
    where: ArtifactWhereUniqueInput
    create: XOR<ArtifactCreateWithoutRegionsInput, ArtifactUncheckedCreateWithoutRegionsInput>
  }

  export type CollectionCreateWithoutRegionsInput = {
    id?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForCollectionsInput
    series?: SeriesCreateNestedManyWithoutCollectionInput
    tags?: TagCreateNestedManyWithoutCollectionsInput
  }

  export type CollectionUncheckedCreateWithoutRegionsInput = {
    id?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailId?: string | null
    name?: string
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    series?: SeriesUncheckedCreateNestedManyWithoutCollectionInput
    tags?: TagUncheckedCreateNestedManyWithoutCollectionsInput
  }

  export type CollectionCreateOrConnectWithoutRegionsInput = {
    where: CollectionWhereUniqueInput
    create: XOR<CollectionCreateWithoutRegionsInput, CollectionUncheckedCreateWithoutRegionsInput>
  }

  export type LayerCreateWithoutRegionsInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: string | null
    status?: $Enums.ContentStatus
    version?: string | null
    type?: $Enums.LayerType
    citationText?: string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: string | null
    maturity?: $Enums.DataMaturity
    minYear?: number | null
    maxYear?: number | null
    sourceType?: $Enums.LayerSourceType
    sourceUrl?: string | null
    downloadUrl?: string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutLayersInput
    maps?: MapLayerAssociationCreateNestedManyWithoutLayerInput
    tags?: TagCreateNestedManyWithoutLayersInput
  }

  export type LayerUncheckedCreateWithoutRegionsInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: string | null
    status?: $Enums.ContentStatus
    version?: string | null
    categoryId?: string | null
    type?: $Enums.LayerType
    citationText?: string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: string | null
    maturity?: $Enums.DataMaturity
    minYear?: number | null
    maxYear?: number | null
    sourceType?: $Enums.LayerSourceType
    sourceUrl?: string | null
    downloadUrl?: string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    maps?: MapLayerAssociationUncheckedCreateNestedManyWithoutLayerInput
    tags?: TagUncheckedCreateNestedManyWithoutLayersInput
  }

  export type LayerCreateOrConnectWithoutRegionsInput = {
    where: LayerWhereUniqueInput
    create: XOR<LayerCreateWithoutRegionsInput, LayerUncheckedCreateWithoutRegionsInput>
  }

  export type MapCreateWithoutRegionsInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: number | null
    version?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    period?: string | null
    title?: string
    yearMax?: number | null
    yearMin?: number | null
    status?: $Enums.ContentStatus
    resources?: DatasetResourceCreateNestedManyWithoutMapInput
    layers?: MapLayerAssociationCreateNestedManyWithoutMapInput
    category?: CategoryCreateNestedOneWithoutMapsInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForMapsInput
    tags?: TagCreateNestedManyWithoutMapsInput
  }

  export type MapUncheckedCreateWithoutRegionsInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: number | null
    version?: string | null
    thumbnailId?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    period?: string | null
    title?: string
    yearMax?: number | null
    yearMin?: number | null
    categoryId?: string | null
    status?: $Enums.ContentStatus
    resources?: DatasetResourceUncheckedCreateNestedManyWithoutMapInput
    layers?: MapLayerAssociationUncheckedCreateNestedManyWithoutMapInput
    tags?: TagUncheckedCreateNestedManyWithoutMapsInput
  }

  export type MapCreateOrConnectWithoutRegionsInput = {
    where: MapWhereUniqueInput
    create: XOR<MapCreateWithoutRegionsInput, MapUncheckedCreateWithoutRegionsInput>
  }

  export type PageCreateWithoutRegionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content?: string | null
    excerpt?: string | null
    sources?: string | null
    citations?: string | null
    language?: $Enums.AppLanguage
    translationGroupId?: string | null
    status?: $Enums.ContentStatus
    metaDescription?: string | null
    metaKeywords?: string | null
    template?: string | null
    menuOrder?: number
    showInMenu?: boolean
    author?: UserCreateNestedOneWithoutPagesInput
    parent?: PageCreateNestedOneWithoutChildrenInput
    children?: PageCreateNestedManyWithoutParentInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForPagesInput
    tags?: TagCreateNestedManyWithoutPagesInput
    menuItems?: MenuItemCreateNestedManyWithoutPageInput
    footerItems?: FooterColumnItemCreateNestedManyWithoutPageInput
  }

  export type PageUncheckedCreateWithoutRegionsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content?: string | null
    excerpt?: string | null
    sources?: string | null
    citations?: string | null
    language?: $Enums.AppLanguage
    translationGroupId?: string | null
    status?: $Enums.ContentStatus
    authorId?: string | null
    parentId?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    thumbnailId?: string | null
    template?: string | null
    menuOrder?: number
    showInMenu?: boolean
    children?: PageUncheckedCreateNestedManyWithoutParentInput
    tags?: TagUncheckedCreateNestedManyWithoutPagesInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutPageInput
    footerItems?: FooterColumnItemUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageCreateOrConnectWithoutRegionsInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutRegionsInput, PageUncheckedCreateWithoutRegionsInput>
  }

  export type PostCreateWithoutRegionsInput = {
    id?: string
    translationGroupId?: string
    language?: $Enums.AppLanguage
    title: string
    slug: string
    content?: string | null
    sources?: string | null
    excerpt?: string | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: PostTagCreateNestedManyWithoutPostInput
    author?: UserCreateNestedOneWithoutPostsInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForPostsInput
    categories?: CategoryCreateNestedManyWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutRegionsInput = {
    id?: string
    translationGroupId?: string
    language?: $Enums.AppLanguage
    title: string
    slug: string
    content?: string | null
    sources?: string | null
    excerpt?: string | null
    status?: $Enums.ContentStatus
    authorId?: string | null
    thumbnailId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    categories?: CategoryUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostCreateOrConnectWithoutRegionsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutRegionsInput, PostUncheckedCreateWithoutRegionsInput>
  }

  export type ResearchDatasetCreateWithoutRegionsInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ContentStatus
    maturity?: $Enums.DataMaturity
    version?: string | null
    license?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    title?: string
    citationText?: string | null
    codebookText?: string | null
    maxYear?: number | null
    minYear?: number | null
    sources?: string | null
    isVisible?: boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    resources?: DatasetResourceCreateNestedManyWithoutDatasetInput
    category?: CategoryCreateNestedOneWithoutDatasetsInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForDatasetInput
  }

  export type ResearchDatasetUncheckedCreateWithoutRegionsInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ContentStatus
    maturity?: $Enums.DataMaturity
    version?: string | null
    license?: string | null
    thumbnailId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    title?: string
    categoryId?: string | null
    citationText?: string | null
    codebookText?: string | null
    maxYear?: number | null
    minYear?: number | null
    sources?: string | null
    isVisible?: boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    resources?: DatasetResourceUncheckedCreateNestedManyWithoutDatasetInput
  }

  export type ResearchDatasetCreateOrConnectWithoutRegionsInput = {
    where: ResearchDatasetWhereUniqueInput
    create: XOR<ResearchDatasetCreateWithoutRegionsInput, ResearchDatasetUncheckedCreateWithoutRegionsInput>
  }

  export type SeriesCreateWithoutRegionsInput = {
    id?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: number | null
    volumeLabelFormat?: string | null
    createdAt?: Date | string
    slug: string
    name?: string
    description?: string | null
    license?: string | null
    period?: string | null
    sourceLink?: string | null
    sources?: string | null
    author?: string | null
    editor?: string | null
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    languages?: SeriesCreatelanguagesInput | $Enums.ContentLanguage[]
    collection?: CollectionCreateNestedOneWithoutSeriesInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForSeriesInput
    volumes?: VolumeCreateNestedManyWithoutSeriesInput
    categories?: CategoryCreateNestedManyWithoutSeriesInput
    tags?: TagCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUncheckedCreateWithoutRegionsInput = {
    id?: string
    collectionId?: string | null
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: number | null
    volumeLabelFormat?: string | null
    thumbnailId?: string | null
    createdAt?: Date | string
    slug: string
    name?: string
    description?: string | null
    license?: string | null
    period?: string | null
    sourceLink?: string | null
    sources?: string | null
    author?: string | null
    editor?: string | null
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    languages?: SeriesCreatelanguagesInput | $Enums.ContentLanguage[]
    volumes?: VolumeUncheckedCreateNestedManyWithoutSeriesInput
    categories?: CategoryUncheckedCreateNestedManyWithoutSeriesInput
    tags?: TagUncheckedCreateNestedManyWithoutSeriesInput
  }

  export type SeriesCreateOrConnectWithoutRegionsInput = {
    where: SeriesWhereUniqueInput
    create: XOR<SeriesCreateWithoutRegionsInput, SeriesUncheckedCreateWithoutRegionsInput>
  }

  export type VolumeCreateWithoutRegionsInput = {
    id?: string
    indexNumber?: number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: string | null
    yearContent?: number | null
    createdAt?: Date | string
    slug: string
    title?: string
    description?: string | null
    license?: string | null
    sourceLink?: string | null
    sources?: string | null
    year?: number | null
    author?: string | null
    editor?: string | null
    languages?: VolumeCreatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: number | null
    yearMin?: number | null
    pages?: VolumePageCreateNestedManyWithoutVolumeInput
    series?: SeriesCreateNestedOneWithoutVolumesInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForVolumesInput
  }

  export type VolumeUncheckedCreateWithoutRegionsInput = {
    id?: string
    seriesId?: string | null
    indexNumber?: number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: string | null
    yearContent?: number | null
    thumbnailId?: string | null
    createdAt?: Date | string
    slug: string
    title?: string
    description?: string | null
    license?: string | null
    sourceLink?: string | null
    sources?: string | null
    year?: number | null
    author?: string | null
    editor?: string | null
    languages?: VolumeCreatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: number | null
    yearMin?: number | null
    pages?: VolumePageUncheckedCreateNestedManyWithoutVolumeInput
  }

  export type VolumeCreateOrConnectWithoutRegionsInput = {
    where: VolumeWhereUniqueInput
    create: XOR<VolumeCreateWithoutRegionsInput, VolumeUncheckedCreateWithoutRegionsInput>
  }

  export type ArtifactUpsertWithWhereUniqueWithoutRegionsInput = {
    where: ArtifactWhereUniqueInput
    update: XOR<ArtifactUpdateWithoutRegionsInput, ArtifactUncheckedUpdateWithoutRegionsInput>
    create: XOR<ArtifactCreateWithoutRegionsInput, ArtifactUncheckedCreateWithoutRegionsInput>
  }

  export type ArtifactUpdateWithWhereUniqueWithoutRegionsInput = {
    where: ArtifactWhereUniqueInput
    data: XOR<ArtifactUpdateWithoutRegionsInput, ArtifactUncheckedUpdateWithoutRegionsInput>
  }

  export type ArtifactUpdateManyWithWhereWithoutRegionsInput = {
    where: ArtifactScalarWhereInput
    data: XOR<ArtifactUpdateManyMutationInput, ArtifactUncheckedUpdateManyWithoutRegionsInput>
  }

  export type CollectionUpsertWithWhereUniqueWithoutRegionsInput = {
    where: CollectionWhereUniqueInput
    update: XOR<CollectionUpdateWithoutRegionsInput, CollectionUncheckedUpdateWithoutRegionsInput>
    create: XOR<CollectionCreateWithoutRegionsInput, CollectionUncheckedCreateWithoutRegionsInput>
  }

  export type CollectionUpdateWithWhereUniqueWithoutRegionsInput = {
    where: CollectionWhereUniqueInput
    data: XOR<CollectionUpdateWithoutRegionsInput, CollectionUncheckedUpdateWithoutRegionsInput>
  }

  export type CollectionUpdateManyWithWhereWithoutRegionsInput = {
    where: CollectionScalarWhereInput
    data: XOR<CollectionUpdateManyMutationInput, CollectionUncheckedUpdateManyWithoutRegionsInput>
  }

  export type LayerUpsertWithWhereUniqueWithoutRegionsInput = {
    where: LayerWhereUniqueInput
    update: XOR<LayerUpdateWithoutRegionsInput, LayerUncheckedUpdateWithoutRegionsInput>
    create: XOR<LayerCreateWithoutRegionsInput, LayerUncheckedCreateWithoutRegionsInput>
  }

  export type LayerUpdateWithWhereUniqueWithoutRegionsInput = {
    where: LayerWhereUniqueInput
    data: XOR<LayerUpdateWithoutRegionsInput, LayerUncheckedUpdateWithoutRegionsInput>
  }

  export type LayerUpdateManyWithWhereWithoutRegionsInput = {
    where: LayerScalarWhereInput
    data: XOR<LayerUpdateManyMutationInput, LayerUncheckedUpdateManyWithoutRegionsInput>
  }

  export type MapUpsertWithWhereUniqueWithoutRegionsInput = {
    where: MapWhereUniqueInput
    update: XOR<MapUpdateWithoutRegionsInput, MapUncheckedUpdateWithoutRegionsInput>
    create: XOR<MapCreateWithoutRegionsInput, MapUncheckedCreateWithoutRegionsInput>
  }

  export type MapUpdateWithWhereUniqueWithoutRegionsInput = {
    where: MapWhereUniqueInput
    data: XOR<MapUpdateWithoutRegionsInput, MapUncheckedUpdateWithoutRegionsInput>
  }

  export type MapUpdateManyWithWhereWithoutRegionsInput = {
    where: MapScalarWhereInput
    data: XOR<MapUpdateManyMutationInput, MapUncheckedUpdateManyWithoutRegionsInput>
  }

  export type PageUpsertWithWhereUniqueWithoutRegionsInput = {
    where: PageWhereUniqueInput
    update: XOR<PageUpdateWithoutRegionsInput, PageUncheckedUpdateWithoutRegionsInput>
    create: XOR<PageCreateWithoutRegionsInput, PageUncheckedCreateWithoutRegionsInput>
  }

  export type PageUpdateWithWhereUniqueWithoutRegionsInput = {
    where: PageWhereUniqueInput
    data: XOR<PageUpdateWithoutRegionsInput, PageUncheckedUpdateWithoutRegionsInput>
  }

  export type PageUpdateManyWithWhereWithoutRegionsInput = {
    where: PageScalarWhereInput
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyWithoutRegionsInput>
  }

  export type PostUpsertWithWhereUniqueWithoutRegionsInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutRegionsInput, PostUncheckedUpdateWithoutRegionsInput>
    create: XOR<PostCreateWithoutRegionsInput, PostUncheckedCreateWithoutRegionsInput>
  }

  export type PostUpdateWithWhereUniqueWithoutRegionsInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutRegionsInput, PostUncheckedUpdateWithoutRegionsInput>
  }

  export type PostUpdateManyWithWhereWithoutRegionsInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutRegionsInput>
  }

  export type ResearchDatasetUpsertWithWhereUniqueWithoutRegionsInput = {
    where: ResearchDatasetWhereUniqueInput
    update: XOR<ResearchDatasetUpdateWithoutRegionsInput, ResearchDatasetUncheckedUpdateWithoutRegionsInput>
    create: XOR<ResearchDatasetCreateWithoutRegionsInput, ResearchDatasetUncheckedCreateWithoutRegionsInput>
  }

  export type ResearchDatasetUpdateWithWhereUniqueWithoutRegionsInput = {
    where: ResearchDatasetWhereUniqueInput
    data: XOR<ResearchDatasetUpdateWithoutRegionsInput, ResearchDatasetUncheckedUpdateWithoutRegionsInput>
  }

  export type ResearchDatasetUpdateManyWithWhereWithoutRegionsInput = {
    where: ResearchDatasetScalarWhereInput
    data: XOR<ResearchDatasetUpdateManyMutationInput, ResearchDatasetUncheckedUpdateManyWithoutRegionsInput>
  }

  export type SeriesUpsertWithWhereUniqueWithoutRegionsInput = {
    where: SeriesWhereUniqueInput
    update: XOR<SeriesUpdateWithoutRegionsInput, SeriesUncheckedUpdateWithoutRegionsInput>
    create: XOR<SeriesCreateWithoutRegionsInput, SeriesUncheckedCreateWithoutRegionsInput>
  }

  export type SeriesUpdateWithWhereUniqueWithoutRegionsInput = {
    where: SeriesWhereUniqueInput
    data: XOR<SeriesUpdateWithoutRegionsInput, SeriesUncheckedUpdateWithoutRegionsInput>
  }

  export type SeriesUpdateManyWithWhereWithoutRegionsInput = {
    where: SeriesScalarWhereInput
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyWithoutRegionsInput>
  }

  export type VolumeUpsertWithWhereUniqueWithoutRegionsInput = {
    where: VolumeWhereUniqueInput
    update: XOR<VolumeUpdateWithoutRegionsInput, VolumeUncheckedUpdateWithoutRegionsInput>
    create: XOR<VolumeCreateWithoutRegionsInput, VolumeUncheckedCreateWithoutRegionsInput>
  }

  export type VolumeUpdateWithWhereUniqueWithoutRegionsInput = {
    where: VolumeWhereUniqueInput
    data: XOR<VolumeUpdateWithoutRegionsInput, VolumeUncheckedUpdateWithoutRegionsInput>
  }

  export type VolumeUpdateManyWithWhereWithoutRegionsInput = {
    where: VolumeScalarWhereInput
    data: XOR<VolumeUpdateManyMutationInput, VolumeUncheckedUpdateManyWithoutRegionsInput>
  }

  export type MediaCreateWithoutThumbnailForCategoryInput = {
    id?: string
    filename: string
    url: string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailForCollections?: CollectionCreateNestedManyWithoutThumbnailInput
    thumbnailForMaps?: MapCreateNestedManyWithoutThumbnailInput
    storageFile?: StorageFileCreateNestedOneWithoutMediaInput
    thumbnailForPages?: PageCreateNestedManyWithoutThumbnailInput
    thumbnailForPosts?: PostCreateNestedManyWithoutThumbnailInput
    thumbnailForDataset?: ResearchDatasetCreateNestedManyWithoutThumbnailInput
    thumbnailForSeries?: SeriesCreateNestedManyWithoutThumbnailInput
    thumbnailForVolumes?: VolumeCreateNestedManyWithoutThumbnailInput
  }

  export type MediaUncheckedCreateWithoutThumbnailForCategoryInput = {
    id?: string
    filename: string
    url: string
    storageFileId?: string | null
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    thumbnailForCollections?: CollectionUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForMaps?: MapUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForPages?: PageUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForPosts?: PostUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForDataset?: ResearchDatasetUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForSeries?: SeriesUncheckedCreateNestedManyWithoutThumbnailInput
    thumbnailForVolumes?: VolumeUncheckedCreateNestedManyWithoutThumbnailInput
  }

  export type MediaCreateOrConnectWithoutThumbnailForCategoryInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutThumbnailForCategoryInput, MediaUncheckedCreateWithoutThumbnailForCategoryInput>
  }

  export type LayerCreateWithoutCategoryInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: string | null
    status?: $Enums.ContentStatus
    version?: string | null
    type?: $Enums.LayerType
    citationText?: string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: string | null
    maturity?: $Enums.DataMaturity
    minYear?: number | null
    maxYear?: number | null
    sourceType?: $Enums.LayerSourceType
    sourceUrl?: string | null
    downloadUrl?: string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    maps?: MapLayerAssociationCreateNestedManyWithoutLayerInput
    regions?: RegionCreateNestedManyWithoutLayersInput
    tags?: TagCreateNestedManyWithoutLayersInput
  }

  export type LayerUncheckedCreateWithoutCategoryInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: string | null
    status?: $Enums.ContentStatus
    version?: string | null
    type?: $Enums.LayerType
    citationText?: string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: string | null
    maturity?: $Enums.DataMaturity
    minYear?: number | null
    maxYear?: number | null
    sourceType?: $Enums.LayerSourceType
    sourceUrl?: string | null
    downloadUrl?: string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    maps?: MapLayerAssociationUncheckedCreateNestedManyWithoutLayerInput
    regions?: RegionUncheckedCreateNestedManyWithoutLayersInput
    tags?: TagUncheckedCreateNestedManyWithoutLayersInput
  }

  export type LayerCreateOrConnectWithoutCategoryInput = {
    where: LayerWhereUniqueInput
    create: XOR<LayerCreateWithoutCategoryInput, LayerUncheckedCreateWithoutCategoryInput>
  }

  export type LayerCreateManyCategoryInputEnvelope = {
    data: LayerCreateManyCategoryInput | LayerCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type MapCreateWithoutCategoryInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: number | null
    version?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    period?: string | null
    title?: string
    yearMax?: number | null
    yearMin?: number | null
    status?: $Enums.ContentStatus
    resources?: DatasetResourceCreateNestedManyWithoutMapInput
    layers?: MapLayerAssociationCreateNestedManyWithoutMapInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForMapsInput
    regions?: RegionCreateNestedManyWithoutMapsInput
    tags?: TagCreateNestedManyWithoutMapsInput
  }

  export type MapUncheckedCreateWithoutCategoryInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: number | null
    version?: string | null
    thumbnailId?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    period?: string | null
    title?: string
    yearMax?: number | null
    yearMin?: number | null
    status?: $Enums.ContentStatus
    resources?: DatasetResourceUncheckedCreateNestedManyWithoutMapInput
    layers?: MapLayerAssociationUncheckedCreateNestedManyWithoutMapInput
    regions?: RegionUncheckedCreateNestedManyWithoutMapsInput
    tags?: TagUncheckedCreateNestedManyWithoutMapsInput
  }

  export type MapCreateOrConnectWithoutCategoryInput = {
    where: MapWhereUniqueInput
    create: XOR<MapCreateWithoutCategoryInput, MapUncheckedCreateWithoutCategoryInput>
  }

  export type MapCreateManyCategoryInputEnvelope = {
    data: MapCreateManyCategoryInput | MapCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ResearchDatasetCreateWithoutCategoryInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ContentStatus
    maturity?: $Enums.DataMaturity
    version?: string | null
    license?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    title?: string
    citationText?: string | null
    codebookText?: string | null
    maxYear?: number | null
    minYear?: number | null
    sources?: string | null
    isVisible?: boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    resources?: DatasetResourceCreateNestedManyWithoutDatasetInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForDatasetInput
    regions?: RegionCreateNestedManyWithoutDatasetsInput
  }

  export type ResearchDatasetUncheckedCreateWithoutCategoryInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ContentStatus
    maturity?: $Enums.DataMaturity
    version?: string | null
    license?: string | null
    thumbnailId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    title?: string
    citationText?: string | null
    codebookText?: string | null
    maxYear?: number | null
    minYear?: number | null
    sources?: string | null
    isVisible?: boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    resources?: DatasetResourceUncheckedCreateNestedManyWithoutDatasetInput
    regions?: RegionUncheckedCreateNestedManyWithoutDatasetsInput
  }

  export type ResearchDatasetCreateOrConnectWithoutCategoryInput = {
    where: ResearchDatasetWhereUniqueInput
    create: XOR<ResearchDatasetCreateWithoutCategoryInput, ResearchDatasetUncheckedCreateWithoutCategoryInput>
  }

  export type ResearchDatasetCreateManyCategoryInputEnvelope = {
    data: ResearchDatasetCreateManyCategoryInput | ResearchDatasetCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutCategoriesInput = {
    id?: string
    translationGroupId?: string
    language?: $Enums.AppLanguage
    title: string
    slug: string
    content?: string | null
    sources?: string | null
    excerpt?: string | null
    status?: $Enums.ContentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: PostTagCreateNestedManyWithoutPostInput
    author?: UserCreateNestedOneWithoutPostsInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForPostsInput
    regions?: RegionCreateNestedManyWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutCategoriesInput = {
    id?: string
    translationGroupId?: string
    language?: $Enums.AppLanguage
    title: string
    slug: string
    content?: string | null
    sources?: string | null
    excerpt?: string | null
    status?: $Enums.ContentStatus
    authorId?: string | null
    thumbnailId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
    regions?: RegionUncheckedCreateNestedManyWithoutPostsInput
  }

  export type PostCreateOrConnectWithoutCategoriesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCategoriesInput, PostUncheckedCreateWithoutCategoriesInput>
  }

  export type SeriesCreateWithoutCategoriesInput = {
    id?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: number | null
    volumeLabelFormat?: string | null
    createdAt?: Date | string
    slug: string
    name?: string
    description?: string | null
    license?: string | null
    period?: string | null
    sourceLink?: string | null
    sources?: string | null
    author?: string | null
    editor?: string | null
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    languages?: SeriesCreatelanguagesInput | $Enums.ContentLanguage[]
    collection?: CollectionCreateNestedOneWithoutSeriesInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForSeriesInput
    volumes?: VolumeCreateNestedManyWithoutSeriesInput
    regions?: RegionCreateNestedManyWithoutSeriesInput
    tags?: TagCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUncheckedCreateWithoutCategoriesInput = {
    id?: string
    collectionId?: string | null
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: number | null
    volumeLabelFormat?: string | null
    thumbnailId?: string | null
    createdAt?: Date | string
    slug: string
    name?: string
    description?: string | null
    license?: string | null
    period?: string | null
    sourceLink?: string | null
    sources?: string | null
    author?: string | null
    editor?: string | null
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    languages?: SeriesCreatelanguagesInput | $Enums.ContentLanguage[]
    volumes?: VolumeUncheckedCreateNestedManyWithoutSeriesInput
    regions?: RegionUncheckedCreateNestedManyWithoutSeriesInput
    tags?: TagUncheckedCreateNestedManyWithoutSeriesInput
  }

  export type SeriesCreateOrConnectWithoutCategoriesInput = {
    where: SeriesWhereUniqueInput
    create: XOR<SeriesCreateWithoutCategoriesInput, SeriesUncheckedCreateWithoutCategoriesInput>
  }

  export type MediaUpsertWithoutThumbnailForCategoryInput = {
    update: XOR<MediaUpdateWithoutThumbnailForCategoryInput, MediaUncheckedUpdateWithoutThumbnailForCategoryInput>
    create: XOR<MediaCreateWithoutThumbnailForCategoryInput, MediaUncheckedCreateWithoutThumbnailForCategoryInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutThumbnailForCategoryInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutThumbnailForCategoryInput, MediaUncheckedUpdateWithoutThumbnailForCategoryInput>
  }

  export type MediaUpdateWithoutThumbnailForCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailForCollections?: CollectionUpdateManyWithoutThumbnailNestedInput
    thumbnailForMaps?: MapUpdateManyWithoutThumbnailNestedInput
    storageFile?: StorageFileUpdateOneWithoutMediaNestedInput
    thumbnailForPages?: PageUpdateManyWithoutThumbnailNestedInput
    thumbnailForPosts?: PostUpdateManyWithoutThumbnailNestedInput
    thumbnailForDataset?: ResearchDatasetUpdateManyWithoutThumbnailNestedInput
    thumbnailForSeries?: SeriesUpdateManyWithoutThumbnailNestedInput
    thumbnailForVolumes?: VolumeUpdateManyWithoutThumbnailNestedInput
  }

  export type MediaUncheckedUpdateWithoutThumbnailForCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    storageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailForCollections?: CollectionUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForMaps?: MapUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForPages?: PageUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForPosts?: PostUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForDataset?: ResearchDatasetUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForSeries?: SeriesUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForVolumes?: VolumeUncheckedUpdateManyWithoutThumbnailNestedInput
  }

  export type LayerUpsertWithWhereUniqueWithoutCategoryInput = {
    where: LayerWhereUniqueInput
    update: XOR<LayerUpdateWithoutCategoryInput, LayerUncheckedUpdateWithoutCategoryInput>
    create: XOR<LayerCreateWithoutCategoryInput, LayerUncheckedCreateWithoutCategoryInput>
  }

  export type LayerUpdateWithWhereUniqueWithoutCategoryInput = {
    where: LayerWhereUniqueInput
    data: XOR<LayerUpdateWithoutCategoryInput, LayerUncheckedUpdateWithoutCategoryInput>
  }

  export type LayerUpdateManyWithWhereWithoutCategoryInput = {
    where: LayerScalarWhereInput
    data: XOR<LayerUpdateManyMutationInput, LayerUncheckedUpdateManyWithoutCategoryInput>
  }

  export type MapUpsertWithWhereUniqueWithoutCategoryInput = {
    where: MapWhereUniqueInput
    update: XOR<MapUpdateWithoutCategoryInput, MapUncheckedUpdateWithoutCategoryInput>
    create: XOR<MapCreateWithoutCategoryInput, MapUncheckedCreateWithoutCategoryInput>
  }

  export type MapUpdateWithWhereUniqueWithoutCategoryInput = {
    where: MapWhereUniqueInput
    data: XOR<MapUpdateWithoutCategoryInput, MapUncheckedUpdateWithoutCategoryInput>
  }

  export type MapUpdateManyWithWhereWithoutCategoryInput = {
    where: MapScalarWhereInput
    data: XOR<MapUpdateManyMutationInput, MapUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ResearchDatasetUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ResearchDatasetWhereUniqueInput
    update: XOR<ResearchDatasetUpdateWithoutCategoryInput, ResearchDatasetUncheckedUpdateWithoutCategoryInput>
    create: XOR<ResearchDatasetCreateWithoutCategoryInput, ResearchDatasetUncheckedCreateWithoutCategoryInput>
  }

  export type ResearchDatasetUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ResearchDatasetWhereUniqueInput
    data: XOR<ResearchDatasetUpdateWithoutCategoryInput, ResearchDatasetUncheckedUpdateWithoutCategoryInput>
  }

  export type ResearchDatasetUpdateManyWithWhereWithoutCategoryInput = {
    where: ResearchDatasetScalarWhereInput
    data: XOR<ResearchDatasetUpdateManyMutationInput, ResearchDatasetUncheckedUpdateManyWithoutCategoryInput>
  }

  export type PostUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutCategoriesInput, PostUncheckedUpdateWithoutCategoriesInput>
    create: XOR<PostCreateWithoutCategoriesInput, PostUncheckedCreateWithoutCategoriesInput>
  }

  export type PostUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutCategoriesInput, PostUncheckedUpdateWithoutCategoriesInput>
  }

  export type PostUpdateManyWithWhereWithoutCategoriesInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type SeriesUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: SeriesWhereUniqueInput
    update: XOR<SeriesUpdateWithoutCategoriesInput, SeriesUncheckedUpdateWithoutCategoriesInput>
    create: XOR<SeriesCreateWithoutCategoriesInput, SeriesUncheckedCreateWithoutCategoriesInput>
  }

  export type SeriesUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: SeriesWhereUniqueInput
    data: XOR<SeriesUpdateWithoutCategoriesInput, SeriesUncheckedUpdateWithoutCategoriesInput>
  }

  export type SeriesUpdateManyWithWhereWithoutCategoriesInput = {
    where: SeriesScalarWhereInput
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type ArtifactCreateWithoutArtifactCategoryInput = {
    id?: string
    slug: string
    content?: string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: number | null
    dateDisplay?: string | null
    dateSort?: Date | string | null
    excerpt?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: boolean
    displayTexts?: boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    periods?: PeriodCreateNestedManyWithoutArtifactsInput
    places?: PlaceCreateNestedManyWithoutArtifactsInput
    regions?: RegionCreateNestedManyWithoutArtifactsInput
    tags?: TagCreateNestedManyWithoutArtifactsInput
    pages?: VolumePageCreateNestedManyWithoutArtifactsInput
  }

  export type ArtifactUncheckedCreateWithoutArtifactCategoryInput = {
    id?: string
    slug: string
    content?: string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: number | null
    dateDisplay?: string | null
    dateSort?: Date | string | null
    excerpt?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: boolean
    displayTexts?: boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    periods?: PeriodUncheckedCreateNestedManyWithoutArtifactsInput
    places?: PlaceUncheckedCreateNestedManyWithoutArtifactsInput
    regions?: RegionUncheckedCreateNestedManyWithoutArtifactsInput
    tags?: TagUncheckedCreateNestedManyWithoutArtifactsInput
    pages?: VolumePageUncheckedCreateNestedManyWithoutArtifactsInput
  }

  export type ArtifactCreateOrConnectWithoutArtifactCategoryInput = {
    where: ArtifactWhereUniqueInput
    create: XOR<ArtifactCreateWithoutArtifactCategoryInput, ArtifactUncheckedCreateWithoutArtifactCategoryInput>
  }

  export type ArtifactCreateManyArtifactCategoryInputEnvelope = {
    data: ArtifactCreateManyArtifactCategoryInput | ArtifactCreateManyArtifactCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ArtifactUpsertWithWhereUniqueWithoutArtifactCategoryInput = {
    where: ArtifactWhereUniqueInput
    update: XOR<ArtifactUpdateWithoutArtifactCategoryInput, ArtifactUncheckedUpdateWithoutArtifactCategoryInput>
    create: XOR<ArtifactCreateWithoutArtifactCategoryInput, ArtifactUncheckedCreateWithoutArtifactCategoryInput>
  }

  export type ArtifactUpdateWithWhereUniqueWithoutArtifactCategoryInput = {
    where: ArtifactWhereUniqueInput
    data: XOR<ArtifactUpdateWithoutArtifactCategoryInput, ArtifactUncheckedUpdateWithoutArtifactCategoryInput>
  }

  export type ArtifactUpdateManyWithWhereWithoutArtifactCategoryInput = {
    where: ArtifactScalarWhereInput
    data: XOR<ArtifactUpdateManyMutationInput, ArtifactUncheckedUpdateManyWithoutArtifactCategoryInput>
  }

  export type ArtifactCreateWithoutPeriodsInput = {
    id?: string
    slug: string
    content?: string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: number | null
    dateDisplay?: string | null
    dateSort?: Date | string | null
    excerpt?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: boolean
    displayTexts?: boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategory?: ArtifactCategoryCreateNestedOneWithoutArtifactsInput
    places?: PlaceCreateNestedManyWithoutArtifactsInput
    regions?: RegionCreateNestedManyWithoutArtifactsInput
    tags?: TagCreateNestedManyWithoutArtifactsInput
    pages?: VolumePageCreateNestedManyWithoutArtifactsInput
  }

  export type ArtifactUncheckedCreateWithoutPeriodsInput = {
    id?: string
    slug: string
    content?: string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: number | null
    dateDisplay?: string | null
    dateSort?: Date | string | null
    excerpt?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: boolean
    displayTexts?: boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategoryId?: string | null
    places?: PlaceUncheckedCreateNestedManyWithoutArtifactsInput
    regions?: RegionUncheckedCreateNestedManyWithoutArtifactsInput
    tags?: TagUncheckedCreateNestedManyWithoutArtifactsInput
    pages?: VolumePageUncheckedCreateNestedManyWithoutArtifactsInput
  }

  export type ArtifactCreateOrConnectWithoutPeriodsInput = {
    where: ArtifactWhereUniqueInput
    create: XOR<ArtifactCreateWithoutPeriodsInput, ArtifactUncheckedCreateWithoutPeriodsInput>
  }

  export type ArtifactUpsertWithWhereUniqueWithoutPeriodsInput = {
    where: ArtifactWhereUniqueInput
    update: XOR<ArtifactUpdateWithoutPeriodsInput, ArtifactUncheckedUpdateWithoutPeriodsInput>
    create: XOR<ArtifactCreateWithoutPeriodsInput, ArtifactUncheckedCreateWithoutPeriodsInput>
  }

  export type ArtifactUpdateWithWhereUniqueWithoutPeriodsInput = {
    where: ArtifactWhereUniqueInput
    data: XOR<ArtifactUpdateWithoutPeriodsInput, ArtifactUncheckedUpdateWithoutPeriodsInput>
  }

  export type ArtifactUpdateManyWithWhereWithoutPeriodsInput = {
    where: ArtifactScalarWhereInput
    data: XOR<ArtifactUpdateManyMutationInput, ArtifactUncheckedUpdateManyWithoutPeriodsInput>
  }

  export type MenuItemCreateWithoutMenuInput = {
    id?: string
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    variant?: $Enums.ItemVariant
    order?: number
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: MenuItemCreateNestedOneWithoutChildrenInput
    children?: MenuItemCreateNestedManyWithoutParentInput
    page?: PageCreateNestedOneWithoutMenuItemsInput
  }

  export type MenuItemUncheckedCreateWithoutMenuInput = {
    id?: string
    parentId?: string | null
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    variant?: $Enums.ItemVariant
    order?: number
    pageId?: string | null
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: MenuItemUncheckedCreateNestedManyWithoutParentInput
  }

  export type MenuItemCreateOrConnectWithoutMenuInput = {
    where: MenuItemWhereUniqueInput
    create: XOR<MenuItemCreateWithoutMenuInput, MenuItemUncheckedCreateWithoutMenuInput>
  }

  export type MenuItemCreateManyMenuInputEnvelope = {
    data: MenuItemCreateManyMenuInput | MenuItemCreateManyMenuInput[]
    skipDuplicates?: boolean
  }

  export type MenuItemUpsertWithWhereUniqueWithoutMenuInput = {
    where: MenuItemWhereUniqueInput
    update: XOR<MenuItemUpdateWithoutMenuInput, MenuItemUncheckedUpdateWithoutMenuInput>
    create: XOR<MenuItemCreateWithoutMenuInput, MenuItemUncheckedCreateWithoutMenuInput>
  }

  export type MenuItemUpdateWithWhereUniqueWithoutMenuInput = {
    where: MenuItemWhereUniqueInput
    data: XOR<MenuItemUpdateWithoutMenuInput, MenuItemUncheckedUpdateWithoutMenuInput>
  }

  export type MenuItemUpdateManyWithWhereWithoutMenuInput = {
    where: MenuItemScalarWhereInput
    data: XOR<MenuItemUpdateManyMutationInput, MenuItemUncheckedUpdateManyWithoutMenuInput>
  }

  export type MenuCreateWithoutItemsInput = {
    id?: string
    location: $Enums.MenuLocation
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuUncheckedCreateWithoutItemsInput = {
    id?: string
    location: $Enums.MenuLocation
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuCreateOrConnectWithoutItemsInput = {
    where: MenuWhereUniqueInput
    create: XOR<MenuCreateWithoutItemsInput, MenuUncheckedCreateWithoutItemsInput>
  }

  export type MenuItemCreateWithoutChildrenInput = {
    id?: string
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    variant?: $Enums.ItemVariant
    order?: number
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    menu: MenuCreateNestedOneWithoutItemsInput
    parent?: MenuItemCreateNestedOneWithoutChildrenInput
    page?: PageCreateNestedOneWithoutMenuItemsInput
  }

  export type MenuItemUncheckedCreateWithoutChildrenInput = {
    id?: string
    menuId: string
    parentId?: string | null
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    variant?: $Enums.ItemVariant
    order?: number
    pageId?: string | null
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuItemCreateOrConnectWithoutChildrenInput = {
    where: MenuItemWhereUniqueInput
    create: XOR<MenuItemCreateWithoutChildrenInput, MenuItemUncheckedCreateWithoutChildrenInput>
  }

  export type MenuItemCreateWithoutParentInput = {
    id?: string
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    variant?: $Enums.ItemVariant
    order?: number
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    menu: MenuCreateNestedOneWithoutItemsInput
    children?: MenuItemCreateNestedManyWithoutParentInput
    page?: PageCreateNestedOneWithoutMenuItemsInput
  }

  export type MenuItemUncheckedCreateWithoutParentInput = {
    id?: string
    menuId: string
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    variant?: $Enums.ItemVariant
    order?: number
    pageId?: string | null
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: MenuItemUncheckedCreateNestedManyWithoutParentInput
  }

  export type MenuItemCreateOrConnectWithoutParentInput = {
    where: MenuItemWhereUniqueInput
    create: XOR<MenuItemCreateWithoutParentInput, MenuItemUncheckedCreateWithoutParentInput>
  }

  export type MenuItemCreateManyParentInputEnvelope = {
    data: MenuItemCreateManyParentInput | MenuItemCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type PageCreateWithoutMenuItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content?: string | null
    excerpt?: string | null
    sources?: string | null
    citations?: string | null
    language?: $Enums.AppLanguage
    translationGroupId?: string | null
    status?: $Enums.ContentStatus
    metaDescription?: string | null
    metaKeywords?: string | null
    template?: string | null
    menuOrder?: number
    showInMenu?: boolean
    author?: UserCreateNestedOneWithoutPagesInput
    parent?: PageCreateNestedOneWithoutChildrenInput
    children?: PageCreateNestedManyWithoutParentInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForPagesInput
    regions?: RegionCreateNestedManyWithoutPagesInput
    tags?: TagCreateNestedManyWithoutPagesInput
    footerItems?: FooterColumnItemCreateNestedManyWithoutPageInput
  }

  export type PageUncheckedCreateWithoutMenuItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content?: string | null
    excerpt?: string | null
    sources?: string | null
    citations?: string | null
    language?: $Enums.AppLanguage
    translationGroupId?: string | null
    status?: $Enums.ContentStatus
    authorId?: string | null
    parentId?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    thumbnailId?: string | null
    template?: string | null
    menuOrder?: number
    showInMenu?: boolean
    children?: PageUncheckedCreateNestedManyWithoutParentInput
    regions?: RegionUncheckedCreateNestedManyWithoutPagesInput
    tags?: TagUncheckedCreateNestedManyWithoutPagesInput
    footerItems?: FooterColumnItemUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageCreateOrConnectWithoutMenuItemsInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutMenuItemsInput, PageUncheckedCreateWithoutMenuItemsInput>
  }

  export type MenuUpsertWithoutItemsInput = {
    update: XOR<MenuUpdateWithoutItemsInput, MenuUncheckedUpdateWithoutItemsInput>
    create: XOR<MenuCreateWithoutItemsInput, MenuUncheckedCreateWithoutItemsInput>
    where?: MenuWhereInput
  }

  export type MenuUpdateToOneWithWhereWithoutItemsInput = {
    where?: MenuWhereInput
    data: XOR<MenuUpdateWithoutItemsInput, MenuUncheckedUpdateWithoutItemsInput>
  }

  export type MenuUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: EnumMenuLocationFieldUpdateOperationsInput | $Enums.MenuLocation
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    location?: EnumMenuLocationFieldUpdateOperationsInput | $Enums.MenuLocation
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemUpsertWithoutChildrenInput = {
    update: XOR<MenuItemUpdateWithoutChildrenInput, MenuItemUncheckedUpdateWithoutChildrenInput>
    create: XOR<MenuItemCreateWithoutChildrenInput, MenuItemUncheckedCreateWithoutChildrenInput>
    where?: MenuItemWhereInput
  }

  export type MenuItemUpdateToOneWithWhereWithoutChildrenInput = {
    where?: MenuItemWhereInput
    data: XOR<MenuItemUpdateWithoutChildrenInput, MenuItemUncheckedUpdateWithoutChildrenInput>
  }

  export type MenuItemUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    variant?: EnumItemVariantFieldUpdateOperationsInput | $Enums.ItemVariant
    order?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: MenuUpdateOneRequiredWithoutItemsNestedInput
    parent?: MenuItemUpdateOneWithoutChildrenNestedInput
    page?: PageUpdateOneWithoutMenuItemsNestedInput
  }

  export type MenuItemUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    variant?: EnumItemVariantFieldUpdateOperationsInput | $Enums.ItemVariant
    order?: IntFieldUpdateOperationsInput | number
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemUpsertWithWhereUniqueWithoutParentInput = {
    where: MenuItemWhereUniqueInput
    update: XOR<MenuItemUpdateWithoutParentInput, MenuItemUncheckedUpdateWithoutParentInput>
    create: XOR<MenuItemCreateWithoutParentInput, MenuItemUncheckedCreateWithoutParentInput>
  }

  export type MenuItemUpdateWithWhereUniqueWithoutParentInput = {
    where: MenuItemWhereUniqueInput
    data: XOR<MenuItemUpdateWithoutParentInput, MenuItemUncheckedUpdateWithoutParentInput>
  }

  export type MenuItemUpdateManyWithWhereWithoutParentInput = {
    where: MenuItemScalarWhereInput
    data: XOR<MenuItemUpdateManyMutationInput, MenuItemUncheckedUpdateManyWithoutParentInput>
  }

  export type PageUpsertWithoutMenuItemsInput = {
    update: XOR<PageUpdateWithoutMenuItemsInput, PageUncheckedUpdateWithoutMenuItemsInput>
    create: XOR<PageCreateWithoutMenuItemsInput, PageUncheckedCreateWithoutMenuItemsInput>
    where?: PageWhereInput
  }

  export type PageUpdateToOneWithWhereWithoutMenuItemsInput = {
    where?: PageWhereInput
    data: XOR<PageUpdateWithoutMenuItemsInput, PageUncheckedUpdateWithoutMenuItemsInput>
  }

  export type PageUpdateWithoutMenuItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
    author?: UserUpdateOneWithoutPagesNestedInput
    parent?: PageUpdateOneWithoutChildrenNestedInput
    children?: PageUpdateManyWithoutParentNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForPagesNestedInput
    regions?: RegionUpdateManyWithoutPagesNestedInput
    tags?: TagUpdateManyWithoutPagesNestedInput
    footerItems?: FooterColumnItemUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateWithoutMenuItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
    children?: PageUncheckedUpdateManyWithoutParentNestedInput
    regions?: RegionUncheckedUpdateManyWithoutPagesNestedInput
    tags?: TagUncheckedUpdateManyWithoutPagesNestedInput
    footerItems?: FooterColumnItemUncheckedUpdateManyWithoutPageNestedInput
  }

  export type FooterColumnItemCreateWithoutFooterColumnInput = {
    id?: string
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    order?: number
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    page?: PageCreateNestedOneWithoutFooterItemsInput
  }

  export type FooterColumnItemUncheckedCreateWithoutFooterColumnInput = {
    id?: string
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    order?: number
    pageId?: string | null
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FooterColumnItemCreateOrConnectWithoutFooterColumnInput = {
    where: FooterColumnItemWhereUniqueInput
    create: XOR<FooterColumnItemCreateWithoutFooterColumnInput, FooterColumnItemUncheckedCreateWithoutFooterColumnInput>
  }

  export type FooterColumnItemCreateManyFooterColumnInputEnvelope = {
    data: FooterColumnItemCreateManyFooterColumnInput | FooterColumnItemCreateManyFooterColumnInput[]
    skipDuplicates?: boolean
  }

  export type FooterColumnItemUpsertWithWhereUniqueWithoutFooterColumnInput = {
    where: FooterColumnItemWhereUniqueInput
    update: XOR<FooterColumnItemUpdateWithoutFooterColumnInput, FooterColumnItemUncheckedUpdateWithoutFooterColumnInput>
    create: XOR<FooterColumnItemCreateWithoutFooterColumnInput, FooterColumnItemUncheckedCreateWithoutFooterColumnInput>
  }

  export type FooterColumnItemUpdateWithWhereUniqueWithoutFooterColumnInput = {
    where: FooterColumnItemWhereUniqueInput
    data: XOR<FooterColumnItemUpdateWithoutFooterColumnInput, FooterColumnItemUncheckedUpdateWithoutFooterColumnInput>
  }

  export type FooterColumnItemUpdateManyWithWhereWithoutFooterColumnInput = {
    where: FooterColumnItemScalarWhereInput
    data: XOR<FooterColumnItemUpdateManyMutationInput, FooterColumnItemUncheckedUpdateManyWithoutFooterColumnInput>
  }

  export type FooterColumnCreateWithoutItemsInput = {
    id?: string
    type: $Enums.MenuType
    order?: number
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    content?: string | null
    contentI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FooterColumnUncheckedCreateWithoutItemsInput = {
    id?: string
    type: $Enums.MenuType
    order?: number
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
    content?: string | null
    contentI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FooterColumnCreateOrConnectWithoutItemsInput = {
    where: FooterColumnWhereUniqueInput
    create: XOR<FooterColumnCreateWithoutItemsInput, FooterColumnUncheckedCreateWithoutItemsInput>
  }

  export type PageCreateWithoutFooterItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content?: string | null
    excerpt?: string | null
    sources?: string | null
    citations?: string | null
    language?: $Enums.AppLanguage
    translationGroupId?: string | null
    status?: $Enums.ContentStatus
    metaDescription?: string | null
    metaKeywords?: string | null
    template?: string | null
    menuOrder?: number
    showInMenu?: boolean
    author?: UserCreateNestedOneWithoutPagesInput
    parent?: PageCreateNestedOneWithoutChildrenInput
    children?: PageCreateNestedManyWithoutParentInput
    thumbnail?: MediaCreateNestedOneWithoutThumbnailForPagesInput
    regions?: RegionCreateNestedManyWithoutPagesInput
    tags?: TagCreateNestedManyWithoutPagesInput
    menuItems?: MenuItemCreateNestedManyWithoutPageInput
  }

  export type PageUncheckedCreateWithoutFooterItemsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content?: string | null
    excerpt?: string | null
    sources?: string | null
    citations?: string | null
    language?: $Enums.AppLanguage
    translationGroupId?: string | null
    status?: $Enums.ContentStatus
    authorId?: string | null
    parentId?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    thumbnailId?: string | null
    template?: string | null
    menuOrder?: number
    showInMenu?: boolean
    children?: PageUncheckedCreateNestedManyWithoutParentInput
    regions?: RegionUncheckedCreateNestedManyWithoutPagesInput
    tags?: TagUncheckedCreateNestedManyWithoutPagesInput
    menuItems?: MenuItemUncheckedCreateNestedManyWithoutPageInput
  }

  export type PageCreateOrConnectWithoutFooterItemsInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutFooterItemsInput, PageUncheckedCreateWithoutFooterItemsInput>
  }

  export type FooterColumnUpsertWithoutItemsInput = {
    update: XOR<FooterColumnUpdateWithoutItemsInput, FooterColumnUncheckedUpdateWithoutItemsInput>
    create: XOR<FooterColumnCreateWithoutItemsInput, FooterColumnUncheckedCreateWithoutItemsInput>
    where?: FooterColumnWhereInput
  }

  export type FooterColumnUpdateToOneWithWhereWithoutItemsInput = {
    where?: FooterColumnWhereInput
    data: XOR<FooterColumnUpdateWithoutItemsInput, FooterColumnUncheckedUpdateWithoutItemsInput>
  }

  export type FooterColumnUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    contentI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FooterColumnUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMenuTypeFieldUpdateOperationsInput | $Enums.MenuType
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    contentI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageUpsertWithoutFooterItemsInput = {
    update: XOR<PageUpdateWithoutFooterItemsInput, PageUncheckedUpdateWithoutFooterItemsInput>
    create: XOR<PageCreateWithoutFooterItemsInput, PageUncheckedCreateWithoutFooterItemsInput>
    where?: PageWhereInput
  }

  export type PageUpdateToOneWithWhereWithoutFooterItemsInput = {
    where?: PageWhereInput
    data: XOR<PageUpdateWithoutFooterItemsInput, PageUncheckedUpdateWithoutFooterItemsInput>
  }

  export type PageUpdateWithoutFooterItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
    author?: UserUpdateOneWithoutPagesNestedInput
    parent?: PageUpdateOneWithoutChildrenNestedInput
    children?: PageUpdateManyWithoutParentNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForPagesNestedInput
    regions?: RegionUpdateManyWithoutPagesNestedInput
    tags?: TagUpdateManyWithoutPagesNestedInput
    menuItems?: MenuItemUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateWithoutFooterItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
    children?: PageUncheckedUpdateManyWithoutParentNestedInput
    regions?: RegionUncheckedUpdateManyWithoutPagesNestedInput
    tags?: TagUncheckedUpdateManyWithoutPagesNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutPageNestedInput
  }

  export type DocumentPageCreateWithoutDocumentInput = {
    id?: string
    index: number
    content: string
    contentHe?: string | null
    contentEn?: string | null
    filename?: string | null
    bookmark?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentPageUncheckedCreateWithoutDocumentInput = {
    id?: string
    index: number
    content: string
    contentHe?: string | null
    contentEn?: string | null
    filename?: string | null
    bookmark?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentPageCreateOrConnectWithoutDocumentInput = {
    where: DocumentPageWhereUniqueInput
    create: XOR<DocumentPageCreateWithoutDocumentInput, DocumentPageUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentPageCreateManyDocumentInputEnvelope = {
    data: DocumentPageCreateManyDocumentInput | DocumentPageCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type DocumentPageUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DocumentPageWhereUniqueInput
    update: XOR<DocumentPageUpdateWithoutDocumentInput, DocumentPageUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentPageCreateWithoutDocumentInput, DocumentPageUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentPageUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DocumentPageWhereUniqueInput
    data: XOR<DocumentPageUpdateWithoutDocumentInput, DocumentPageUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentPageUpdateManyWithWhereWithoutDocumentInput = {
    where: DocumentPageScalarWhereInput
    data: XOR<DocumentPageUpdateManyMutationInput, DocumentPageUncheckedUpdateManyWithoutDocumentInput>
  }

  export type DocumentPageScalarWhereInput = {
    AND?: DocumentPageScalarWhereInput | DocumentPageScalarWhereInput[]
    OR?: DocumentPageScalarWhereInput[]
    NOT?: DocumentPageScalarWhereInput | DocumentPageScalarWhereInput[]
    id?: UuidFilter<"DocumentPage"> | string
    documentId?: UuidFilter<"DocumentPage"> | string
    index?: IntFilter<"DocumentPage"> | number
    content?: StringFilter<"DocumentPage"> | string
    contentHe?: StringNullableFilter<"DocumentPage"> | string | null
    contentEn?: StringNullableFilter<"DocumentPage"> | string | null
    filename?: StringNullableFilter<"DocumentPage"> | string | null
    bookmark?: StringNullableFilter<"DocumentPage"> | string | null
    highlights?: JsonNullableFilter<"DocumentPage">
    createdAt?: DateTimeFilter<"DocumentPage"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentPage"> | Date | string
  }

  export type DocumentCreateWithoutPagesInput = {
    id?: string
    slug: string
    title: string
    titleEn?: string | null
    description?: string | null
    descriptionEn?: string | null
    category?: string | null
    year?: number | null
    reference?: string | null
    referenceUrl?: string | null
    scanUrl?: string | null
    scanZip?: string | null
    lang?: $Enums.ContentLanguage
    status?: $Enums.ContentStatus
    license?: string | null
    volume?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUncheckedCreateWithoutPagesInput = {
    id?: string
    slug: string
    title: string
    titleEn?: string | null
    description?: string | null
    descriptionEn?: string | null
    category?: string | null
    year?: number | null
    reference?: string | null
    referenceUrl?: string | null
    scanUrl?: string | null
    scanZip?: string | null
    lang?: $Enums.ContentLanguage
    status?: $Enums.ContentStatus
    license?: string | null
    volume?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutPagesInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutPagesInput, DocumentUncheckedCreateWithoutPagesInput>
  }

  export type DocumentUpsertWithoutPagesInput = {
    update: XOR<DocumentUpdateWithoutPagesInput, DocumentUncheckedUpdateWithoutPagesInput>
    create: XOR<DocumentCreateWithoutPagesInput, DocumentUncheckedCreateWithoutPagesInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutPagesInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutPagesInput, DocumentUncheckedUpdateWithoutPagesInput>
  }

  export type DocumentUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scanUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scanZip?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: EnumContentLanguageFieldUpdateOperationsInput | $Enums.ContentLanguage
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    license?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    titleEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    referenceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scanUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scanZip?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: EnumContentLanguageFieldUpdateOperationsInput | $Enums.ContentLanguage
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    license?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageCreateManyParentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content?: string | null
    excerpt?: string | null
    sources?: string | null
    citations?: string | null
    language?: $Enums.AppLanguage
    translationGroupId?: string | null
    status?: $Enums.ContentStatus
    authorId?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    thumbnailId?: string | null
    template?: string | null
    menuOrder?: number
    showInMenu?: boolean
  }

  export type MenuItemCreateManyPageInput = {
    id?: string
    menuId: string
    parentId?: string | null
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    variant?: $Enums.ItemVariant
    order?: number
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FooterColumnItemCreateManyPageInput = {
    id?: string
    footerColumnId: string
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    order?: number
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
    author?: UserUpdateOneWithoutPagesNestedInput
    children?: PageUpdateManyWithoutParentNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForPagesNestedInput
    regions?: RegionUpdateManyWithoutPagesNestedInput
    tags?: TagUpdateManyWithoutPagesNestedInput
    menuItems?: MenuItemUpdateManyWithoutPageNestedInput
    footerItems?: FooterColumnItemUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
    children?: PageUncheckedUpdateManyWithoutParentNestedInput
    regions?: RegionUncheckedUpdateManyWithoutPagesNestedInput
    tags?: TagUncheckedUpdateManyWithoutPagesNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutPageNestedInput
    footerItems?: FooterColumnItemUncheckedUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RegionUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactUpdateManyWithoutRegionsNestedInput
    collections?: CollectionUpdateManyWithoutRegionsNestedInput
    layers?: LayerUpdateManyWithoutRegionsNestedInput
    maps?: MapUpdateManyWithoutRegionsNestedInput
    posts?: PostUpdateManyWithoutRegionsNestedInput
    datasets?: ResearchDatasetUpdateManyWithoutRegionsNestedInput
    series?: SeriesUpdateManyWithoutRegionsNestedInput
    volumes?: VolumeUpdateManyWithoutRegionsNestedInput
  }

  export type RegionUncheckedUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactUncheckedUpdateManyWithoutRegionsNestedInput
    collections?: CollectionUncheckedUpdateManyWithoutRegionsNestedInput
    layers?: LayerUncheckedUpdateManyWithoutRegionsNestedInput
    maps?: MapUncheckedUpdateManyWithoutRegionsNestedInput
    posts?: PostUncheckedUpdateManyWithoutRegionsNestedInput
    datasets?: ResearchDatasetUncheckedUpdateManyWithoutRegionsNestedInput
    series?: SeriesUncheckedUpdateManyWithoutRegionsNestedInput
    volumes?: VolumeUncheckedUpdateManyWithoutRegionsNestedInput
  }

  export type RegionUncheckedUpdateManyWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUpdateManyWithoutTagNestedInput
    artifacts?: ArtifactUpdateManyWithoutTagsNestedInput
    collections?: CollectionUpdateManyWithoutTagsNestedInput
    layers?: LayerUpdateManyWithoutTagsNestedInput
    maps?: MapUpdateManyWithoutTagsNestedInput
    series?: SeriesUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUncheckedUpdateManyWithoutTagNestedInput
    artifacts?: ArtifactUncheckedUpdateManyWithoutTagsNestedInput
    collections?: CollectionUncheckedUpdateManyWithoutTagsNestedInput
    layers?: LayerUncheckedUpdateManyWithoutTagsNestedInput
    maps?: MapUncheckedUpdateManyWithoutTagsNestedInput
    series?: SeriesUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MenuItemUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    variant?: EnumItemVariantFieldUpdateOperationsInput | $Enums.ItemVariant
    order?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: MenuUpdateOneRequiredWithoutItemsNestedInput
    parent?: MenuItemUpdateOneWithoutChildrenNestedInput
    children?: MenuItemUpdateManyWithoutParentNestedInput
  }

  export type MenuItemUncheckedUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    variant?: EnumItemVariantFieldUpdateOperationsInput | $Enums.ItemVariant
    order?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: MenuItemUncheckedUpdateManyWithoutParentNestedInput
  }

  export type MenuItemUncheckedUpdateManyWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    variant?: EnumItemVariantFieldUpdateOperationsInput | $Enums.ItemVariant
    order?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FooterColumnItemUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    footerColumn?: FooterColumnUpdateOneRequiredWithoutItemsNestedInput
  }

  export type FooterColumnItemUncheckedUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    footerColumnId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FooterColumnItemUncheckedUpdateManyWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    footerColumnId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostTagCreateManyPostInput = {
    tagId: string
  }

  export type PostTagUpdateWithoutPostInput = {
    tag?: TagUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostTagUncheckedUpdateWithoutPostInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type PostTagUncheckedUpdateManyWithoutPostInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    thumbnail?: MediaUpdateOneWithoutThumbnailForCategoryNestedInput
    layers?: LayerUpdateManyWithoutCategoryNestedInput
    maps?: MapUpdateManyWithoutCategoryNestedInput
    datasets?: ResearchDatasetUpdateManyWithoutCategoryNestedInput
    series?: SeriesUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    layers?: LayerUncheckedUpdateManyWithoutCategoryNestedInput
    maps?: MapUncheckedUpdateManyWithoutCategoryNestedInput
    datasets?: ResearchDatasetUncheckedUpdateManyWithoutCategoryNestedInput
    series?: SeriesUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
  }

  export type RegionUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactUpdateManyWithoutRegionsNestedInput
    collections?: CollectionUpdateManyWithoutRegionsNestedInput
    layers?: LayerUpdateManyWithoutRegionsNestedInput
    maps?: MapUpdateManyWithoutRegionsNestedInput
    pages?: PageUpdateManyWithoutRegionsNestedInput
    datasets?: ResearchDatasetUpdateManyWithoutRegionsNestedInput
    series?: SeriesUpdateManyWithoutRegionsNestedInput
    volumes?: VolumeUpdateManyWithoutRegionsNestedInput
  }

  export type RegionUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactUncheckedUpdateManyWithoutRegionsNestedInput
    collections?: CollectionUncheckedUpdateManyWithoutRegionsNestedInput
    layers?: LayerUncheckedUpdateManyWithoutRegionsNestedInput
    maps?: MapUncheckedUpdateManyWithoutRegionsNestedInput
    pages?: PageUncheckedUpdateManyWithoutRegionsNestedInput
    datasets?: ResearchDatasetUncheckedUpdateManyWithoutRegionsNestedInput
    series?: SeriesUncheckedUpdateManyWithoutRegionsNestedInput
    volumes?: VolumeUncheckedUpdateManyWithoutRegionsNestedInput
  }

  export type RegionUncheckedUpdateManyWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type PageTextCreateManyContributorInput = {
    id?: string
    pageId: string
    content: string
    type?: $Enums.TextType
    language: $Enums.AppLanguage
    textAccuracy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageCreateManyAuthorInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content?: string | null
    excerpt?: string | null
    sources?: string | null
    citations?: string | null
    language?: $Enums.AppLanguage
    translationGroupId?: string | null
    status?: $Enums.ContentStatus
    parentId?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    thumbnailId?: string | null
    template?: string | null
    menuOrder?: number
    showInMenu?: boolean
  }

  export type PostCreateManyAuthorInput = {
    id?: string
    translationGroupId?: string
    language?: $Enums.AppLanguage
    title: string
    slug: string
    content?: string | null
    sources?: string | null
    excerpt?: string | null
    status?: $Enums.ContentStatus
    thumbnailId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PageTextUpdateWithoutContributorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTextTypeFieldUpdateOperationsInput | $Enums.TextType
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    textAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    page?: VolumePageUpdateOneRequiredWithoutTextsNestedInput
  }

  export type PageTextUncheckedUpdateWithoutContributorInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTextTypeFieldUpdateOperationsInput | $Enums.TextType
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    textAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageTextUncheckedUpdateManyWithoutContributorInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTextTypeFieldUpdateOperationsInput | $Enums.TextType
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    textAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
    parent?: PageUpdateOneWithoutChildrenNestedInput
    children?: PageUpdateManyWithoutParentNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForPagesNestedInput
    regions?: RegionUpdateManyWithoutPagesNestedInput
    tags?: TagUpdateManyWithoutPagesNestedInput
    menuItems?: MenuItemUpdateManyWithoutPageNestedInput
    footerItems?: FooterColumnItemUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
    children?: PageUncheckedUpdateManyWithoutParentNestedInput
    regions?: RegionUncheckedUpdateManyWithoutPagesNestedInput
    tags?: TagUncheckedUpdateManyWithoutPagesNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutPageNestedInput
    footerItems?: FooterColumnItemUncheckedUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationGroupId?: StringFieldUpdateOperationsInput | string
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: PostTagUpdateManyWithoutPostNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForPostsNestedInput
    categories?: CategoryUpdateManyWithoutPostsNestedInput
    regions?: RegionUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationGroupId?: StringFieldUpdateOperationsInput | string
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutPostsNestedInput
    regions?: RegionUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationGroupId?: StringFieldUpdateOperationsInput | string
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetResourceCreateManyDatasetInput = {
    id?: string
    url: string
    isMainFile?: boolean
    createdAt?: Date | string
    name: string
    slug: string
    format?: $Enums.ResouceType
    filename?: string | null
    mimeType?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    mapId?: string | null
  }

  export type DatasetResourceUpdateWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    isMainFile?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    format?: EnumResouceTypeFieldUpdateOperationsInput | $Enums.ResouceType
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    map?: MapUpdateOneWithoutResourcesNestedInput
  }

  export type DatasetResourceUncheckedUpdateWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    isMainFile?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    format?: EnumResouceTypeFieldUpdateOperationsInput | $Enums.ResouceType
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    mapId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DatasetResourceUncheckedUpdateManyWithoutDatasetInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    isMainFile?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    format?: EnumResouceTypeFieldUpdateOperationsInput | $Enums.ResouceType
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    mapId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RegionUpdateWithoutDatasetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactUpdateManyWithoutRegionsNestedInput
    collections?: CollectionUpdateManyWithoutRegionsNestedInput
    layers?: LayerUpdateManyWithoutRegionsNestedInput
    maps?: MapUpdateManyWithoutRegionsNestedInput
    pages?: PageUpdateManyWithoutRegionsNestedInput
    posts?: PostUpdateManyWithoutRegionsNestedInput
    series?: SeriesUpdateManyWithoutRegionsNestedInput
    volumes?: VolumeUpdateManyWithoutRegionsNestedInput
  }

  export type RegionUncheckedUpdateWithoutDatasetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactUncheckedUpdateManyWithoutRegionsNestedInput
    collections?: CollectionUncheckedUpdateManyWithoutRegionsNestedInput
    layers?: LayerUncheckedUpdateManyWithoutRegionsNestedInput
    maps?: MapUncheckedUpdateManyWithoutRegionsNestedInput
    pages?: PageUncheckedUpdateManyWithoutRegionsNestedInput
    posts?: PostUncheckedUpdateManyWithoutRegionsNestedInput
    series?: SeriesUncheckedUpdateManyWithoutRegionsNestedInput
    volumes?: VolumeUncheckedUpdateManyWithoutRegionsNestedInput
  }

  export type RegionUncheckedUpdateManyWithoutDatasetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatasetResourceCreateManyMapInput = {
    id?: string
    datasetId?: string | null
    url: string
    isMainFile?: boolean
    createdAt?: Date | string
    name: string
    slug: string
    format?: $Enums.ResouceType
    filename?: string | null
    mimeType?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MapLayerAssociationCreateManyMapInput = {
    id?: string
    layerId: string
    zIndex?: number
    isVisible?: boolean
    isVisibleByDefault?: boolean
    styleOverride?: NullableJsonNullValueInput | InputJsonValue
    interactionConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DatasetResourceUpdateWithoutMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    isMainFile?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    format?: EnumResouceTypeFieldUpdateOperationsInput | $Enums.ResouceType
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    dataset?: ResearchDatasetUpdateOneWithoutResourcesNestedInput
  }

  export type DatasetResourceUncheckedUpdateWithoutMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    datasetId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    isMainFile?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    format?: EnumResouceTypeFieldUpdateOperationsInput | $Enums.ResouceType
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DatasetResourceUncheckedUpdateManyWithoutMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    datasetId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    isMainFile?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    format?: EnumResouceTypeFieldUpdateOperationsInput | $Enums.ResouceType
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MapLayerAssociationUpdateWithoutMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    zIndex?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    isVisibleByDefault?: BoolFieldUpdateOperationsInput | boolean
    styleOverride?: NullableJsonNullValueInput | InputJsonValue
    interactionConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    layer?: LayerUpdateOneRequiredWithoutMapsNestedInput
  }

  export type MapLayerAssociationUncheckedUpdateWithoutMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    layerId?: StringFieldUpdateOperationsInput | string
    zIndex?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    isVisibleByDefault?: BoolFieldUpdateOperationsInput | boolean
    styleOverride?: NullableJsonNullValueInput | InputJsonValue
    interactionConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapLayerAssociationUncheckedUpdateManyWithoutMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    layerId?: StringFieldUpdateOperationsInput | string
    zIndex?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    isVisibleByDefault?: BoolFieldUpdateOperationsInput | boolean
    styleOverride?: NullableJsonNullValueInput | InputJsonValue
    interactionConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUpdateWithoutMapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactUpdateManyWithoutRegionsNestedInput
    collections?: CollectionUpdateManyWithoutRegionsNestedInput
    layers?: LayerUpdateManyWithoutRegionsNestedInput
    pages?: PageUpdateManyWithoutRegionsNestedInput
    posts?: PostUpdateManyWithoutRegionsNestedInput
    datasets?: ResearchDatasetUpdateManyWithoutRegionsNestedInput
    series?: SeriesUpdateManyWithoutRegionsNestedInput
    volumes?: VolumeUpdateManyWithoutRegionsNestedInput
  }

  export type RegionUncheckedUpdateWithoutMapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactUncheckedUpdateManyWithoutRegionsNestedInput
    collections?: CollectionUncheckedUpdateManyWithoutRegionsNestedInput
    layers?: LayerUncheckedUpdateManyWithoutRegionsNestedInput
    pages?: PageUncheckedUpdateManyWithoutRegionsNestedInput
    posts?: PostUncheckedUpdateManyWithoutRegionsNestedInput
    datasets?: ResearchDatasetUncheckedUpdateManyWithoutRegionsNestedInput
    series?: SeriesUncheckedUpdateManyWithoutRegionsNestedInput
    volumes?: VolumeUncheckedUpdateManyWithoutRegionsNestedInput
  }

  export type RegionUncheckedUpdateManyWithoutMapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutMapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUpdateManyWithoutTagNestedInput
    artifacts?: ArtifactUpdateManyWithoutTagsNestedInput
    collections?: CollectionUpdateManyWithoutTagsNestedInput
    layers?: LayerUpdateManyWithoutTagsNestedInput
    pages?: PageUpdateManyWithoutTagsNestedInput
    series?: SeriesUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutMapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUncheckedUpdateManyWithoutTagNestedInput
    artifacts?: ArtifactUncheckedUpdateManyWithoutTagsNestedInput
    collections?: CollectionUncheckedUpdateManyWithoutTagsNestedInput
    layers?: LayerUncheckedUpdateManyWithoutTagsNestedInput
    pages?: PageUncheckedUpdateManyWithoutTagsNestedInput
    series?: SeriesUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutMapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MapLayerAssociationCreateManyLayerInput = {
    id?: string
    mapId: string
    zIndex?: number
    isVisible?: boolean
    isVisibleByDefault?: boolean
    styleOverride?: NullableJsonNullValueInput | InputJsonValue
    interactionConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MapLayerAssociationUpdateWithoutLayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    zIndex?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    isVisibleByDefault?: BoolFieldUpdateOperationsInput | boolean
    styleOverride?: NullableJsonNullValueInput | InputJsonValue
    interactionConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    map?: MapUpdateOneRequiredWithoutLayersNestedInput
  }

  export type MapLayerAssociationUncheckedUpdateWithoutLayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    zIndex?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    isVisibleByDefault?: BoolFieldUpdateOperationsInput | boolean
    styleOverride?: NullableJsonNullValueInput | InputJsonValue
    interactionConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapLayerAssociationUncheckedUpdateManyWithoutLayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    mapId?: StringFieldUpdateOperationsInput | string
    zIndex?: IntFieldUpdateOperationsInput | number
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    isVisibleByDefault?: BoolFieldUpdateOperationsInput | boolean
    styleOverride?: NullableJsonNullValueInput | InputJsonValue
    interactionConfig?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionUpdateWithoutLayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactUpdateManyWithoutRegionsNestedInput
    collections?: CollectionUpdateManyWithoutRegionsNestedInput
    maps?: MapUpdateManyWithoutRegionsNestedInput
    pages?: PageUpdateManyWithoutRegionsNestedInput
    posts?: PostUpdateManyWithoutRegionsNestedInput
    datasets?: ResearchDatasetUpdateManyWithoutRegionsNestedInput
    series?: SeriesUpdateManyWithoutRegionsNestedInput
    volumes?: VolumeUpdateManyWithoutRegionsNestedInput
  }

  export type RegionUncheckedUpdateWithoutLayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactUncheckedUpdateManyWithoutRegionsNestedInput
    collections?: CollectionUncheckedUpdateManyWithoutRegionsNestedInput
    maps?: MapUncheckedUpdateManyWithoutRegionsNestedInput
    pages?: PageUncheckedUpdateManyWithoutRegionsNestedInput
    posts?: PostUncheckedUpdateManyWithoutRegionsNestedInput
    datasets?: ResearchDatasetUncheckedUpdateManyWithoutRegionsNestedInput
    series?: SeriesUncheckedUpdateManyWithoutRegionsNestedInput
    volumes?: VolumeUncheckedUpdateManyWithoutRegionsNestedInput
  }

  export type RegionUncheckedUpdateManyWithoutLayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutLayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUpdateManyWithoutTagNestedInput
    artifacts?: ArtifactUpdateManyWithoutTagsNestedInput
    collections?: CollectionUpdateManyWithoutTagsNestedInput
    maps?: MapUpdateManyWithoutTagsNestedInput
    pages?: PageUpdateManyWithoutTagsNestedInput
    series?: SeriesUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutLayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUncheckedUpdateManyWithoutTagNestedInput
    artifacts?: ArtifactUncheckedUpdateManyWithoutTagsNestedInput
    collections?: CollectionUncheckedUpdateManyWithoutTagsNestedInput
    maps?: MapUncheckedUpdateManyWithoutTagsNestedInput
    pages?: PageUncheckedUpdateManyWithoutTagsNestedInput
    series?: SeriesUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutLayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SeriesCreateManyCollectionInput = {
    id?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: number | null
    volumeLabelFormat?: string | null
    thumbnailId?: string | null
    createdAt?: Date | string
    slug: string
    name?: string
    description?: string | null
    license?: string | null
    period?: string | null
    sourceLink?: string | null
    sources?: string | null
    author?: string | null
    editor?: string | null
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    languages?: SeriesCreatelanguagesInput | $Enums.ContentLanguage[]
  }

  export type SeriesUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    volumeLabelFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    languages?: SeriesUpdatelanguagesInput | $Enums.ContentLanguage[]
    thumbnail?: MediaUpdateOneWithoutThumbnailForSeriesNestedInput
    volumes?: VolumeUpdateManyWithoutSeriesNestedInput
    categories?: CategoryUpdateManyWithoutSeriesNestedInput
    regions?: RegionUpdateManyWithoutSeriesNestedInput
    tags?: TagUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    volumeLabelFormat?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    languages?: SeriesUpdatelanguagesInput | $Enums.ContentLanguage[]
    volumes?: VolumeUncheckedUpdateManyWithoutSeriesNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutSeriesNestedInput
    regions?: RegionUncheckedUpdateManyWithoutSeriesNestedInput
    tags?: TagUncheckedUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateManyWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    volumeLabelFormat?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    languages?: SeriesUpdatelanguagesInput | $Enums.ContentLanguage[]
  }

  export type RegionUpdateWithoutCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactUpdateManyWithoutRegionsNestedInput
    layers?: LayerUpdateManyWithoutRegionsNestedInput
    maps?: MapUpdateManyWithoutRegionsNestedInput
    pages?: PageUpdateManyWithoutRegionsNestedInput
    posts?: PostUpdateManyWithoutRegionsNestedInput
    datasets?: ResearchDatasetUpdateManyWithoutRegionsNestedInput
    series?: SeriesUpdateManyWithoutRegionsNestedInput
    volumes?: VolumeUpdateManyWithoutRegionsNestedInput
  }

  export type RegionUncheckedUpdateWithoutCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactUncheckedUpdateManyWithoutRegionsNestedInput
    layers?: LayerUncheckedUpdateManyWithoutRegionsNestedInput
    maps?: MapUncheckedUpdateManyWithoutRegionsNestedInput
    pages?: PageUncheckedUpdateManyWithoutRegionsNestedInput
    posts?: PostUncheckedUpdateManyWithoutRegionsNestedInput
    datasets?: ResearchDatasetUncheckedUpdateManyWithoutRegionsNestedInput
    series?: SeriesUncheckedUpdateManyWithoutRegionsNestedInput
    volumes?: VolumeUncheckedUpdateManyWithoutRegionsNestedInput
  }

  export type RegionUncheckedUpdateManyWithoutCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUpdateManyWithoutTagNestedInput
    artifacts?: ArtifactUpdateManyWithoutTagsNestedInput
    layers?: LayerUpdateManyWithoutTagsNestedInput
    maps?: MapUpdateManyWithoutTagsNestedInput
    pages?: PageUpdateManyWithoutTagsNestedInput
    series?: SeriesUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUncheckedUpdateManyWithoutTagNestedInput
    artifacts?: ArtifactUncheckedUpdateManyWithoutTagsNestedInput
    layers?: LayerUncheckedUpdateManyWithoutTagsNestedInput
    maps?: MapUncheckedUpdateManyWithoutTagsNestedInput
    pages?: PageUncheckedUpdateManyWithoutTagsNestedInput
    series?: SeriesUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VolumeCreateManySeriesInput = {
    id?: string
    indexNumber?: number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: string | null
    yearContent?: number | null
    thumbnailId?: string | null
    createdAt?: Date | string
    slug: string
    title?: string
    description?: string | null
    license?: string | null
    sourceLink?: string | null
    sources?: string | null
    year?: number | null
    author?: string | null
    editor?: string | null
    languages?: VolumeCreatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: number | null
    yearMin?: number | null
  }

  export type VolumeUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: NullableStringFieldUpdateOperationsInput | string | null
    yearContent?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: VolumeUpdatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    pages?: VolumePageUpdateManyWithoutVolumeNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForVolumesNestedInput
    regions?: RegionUpdateManyWithoutVolumesNestedInput
  }

  export type VolumeUncheckedUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: NullableStringFieldUpdateOperationsInput | string | null
    yearContent?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: VolumeUpdatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    pages?: VolumePageUncheckedUpdateManyWithoutVolumeNestedInput
    regions?: RegionUncheckedUpdateManyWithoutVolumesNestedInput
  }

  export type VolumeUncheckedUpdateManyWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: NullableStringFieldUpdateOperationsInput | string | null
    yearContent?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: VolumeUpdatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CategoryUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    thumbnail?: MediaUpdateOneWithoutThumbnailForCategoryNestedInput
    layers?: LayerUpdateManyWithoutCategoryNestedInput
    maps?: MapUpdateManyWithoutCategoryNestedInput
    datasets?: ResearchDatasetUpdateManyWithoutCategoryNestedInput
    posts?: PostUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    layers?: LayerUncheckedUpdateManyWithoutCategoryNestedInput
    maps?: MapUncheckedUpdateManyWithoutCategoryNestedInput
    datasets?: ResearchDatasetUncheckedUpdateManyWithoutCategoryNestedInput
    posts?: PostUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
  }

  export type RegionUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactUpdateManyWithoutRegionsNestedInput
    collections?: CollectionUpdateManyWithoutRegionsNestedInput
    layers?: LayerUpdateManyWithoutRegionsNestedInput
    maps?: MapUpdateManyWithoutRegionsNestedInput
    pages?: PageUpdateManyWithoutRegionsNestedInput
    posts?: PostUpdateManyWithoutRegionsNestedInput
    datasets?: ResearchDatasetUpdateManyWithoutRegionsNestedInput
    volumes?: VolumeUpdateManyWithoutRegionsNestedInput
  }

  export type RegionUncheckedUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactUncheckedUpdateManyWithoutRegionsNestedInput
    collections?: CollectionUncheckedUpdateManyWithoutRegionsNestedInput
    layers?: LayerUncheckedUpdateManyWithoutRegionsNestedInput
    maps?: MapUncheckedUpdateManyWithoutRegionsNestedInput
    pages?: PageUncheckedUpdateManyWithoutRegionsNestedInput
    posts?: PostUncheckedUpdateManyWithoutRegionsNestedInput
    datasets?: ResearchDatasetUncheckedUpdateManyWithoutRegionsNestedInput
    volumes?: VolumeUncheckedUpdateManyWithoutRegionsNestedInput
  }

  export type RegionUncheckedUpdateManyWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUpdateManyWithoutTagNestedInput
    artifacts?: ArtifactUpdateManyWithoutTagsNestedInput
    collections?: CollectionUpdateManyWithoutTagsNestedInput
    layers?: LayerUpdateManyWithoutTagsNestedInput
    maps?: MapUpdateManyWithoutTagsNestedInput
    pages?: PageUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUncheckedUpdateManyWithoutTagNestedInput
    artifacts?: ArtifactUncheckedUpdateManyWithoutTagsNestedInput
    collections?: CollectionUncheckedUpdateManyWithoutTagsNestedInput
    layers?: LayerUncheckedUpdateManyWithoutTagsNestedInput
    maps?: MapUncheckedUpdateManyWithoutTagsNestedInput
    pages?: PageUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutSeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VolumePageCreateManyVolumeInput = {
    id?: string
    sequenceIndex: number
    label?: string
    createdAt?: Date | string
    isVisible?: boolean
  }

  export type VolumePageUpdateWithoutVolumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequenceIndex?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    data?: PageDataUpdateOneWithoutPageNestedInput
    images?: PageImageUpdateManyWithoutPageNestedInput
    texts?: PageTextUpdateManyWithoutPageNestedInput
    artifacts?: ArtifactUpdateManyWithoutPagesNestedInput
  }

  export type VolumePageUncheckedUpdateWithoutVolumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequenceIndex?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    data?: PageDataUncheckedUpdateOneWithoutPageNestedInput
    images?: PageImageUncheckedUpdateManyWithoutPageNestedInput
    texts?: PageTextUncheckedUpdateManyWithoutPageNestedInput
    artifacts?: ArtifactUncheckedUpdateManyWithoutPagesNestedInput
  }

  export type VolumePageUncheckedUpdateManyWithoutVolumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequenceIndex?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RegionUpdateWithoutVolumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactUpdateManyWithoutRegionsNestedInput
    collections?: CollectionUpdateManyWithoutRegionsNestedInput
    layers?: LayerUpdateManyWithoutRegionsNestedInput
    maps?: MapUpdateManyWithoutRegionsNestedInput
    pages?: PageUpdateManyWithoutRegionsNestedInput
    posts?: PostUpdateManyWithoutRegionsNestedInput
    datasets?: ResearchDatasetUpdateManyWithoutRegionsNestedInput
    series?: SeriesUpdateManyWithoutRegionsNestedInput
  }

  export type RegionUncheckedUpdateWithoutVolumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactUncheckedUpdateManyWithoutRegionsNestedInput
    collections?: CollectionUncheckedUpdateManyWithoutRegionsNestedInput
    layers?: LayerUncheckedUpdateManyWithoutRegionsNestedInput
    maps?: MapUncheckedUpdateManyWithoutRegionsNestedInput
    pages?: PageUncheckedUpdateManyWithoutRegionsNestedInput
    posts?: PostUncheckedUpdateManyWithoutRegionsNestedInput
    datasets?: ResearchDatasetUncheckedUpdateManyWithoutRegionsNestedInput
    series?: SeriesUncheckedUpdateManyWithoutRegionsNestedInput
  }

  export type RegionUncheckedUpdateManyWithoutVolumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageImageCreateManyPageInput = {
    id?: string
    storageFileId: string
    useType?: $Enums.ImageUseType
    createdAt?: Date | string
  }

  export type PageTextCreateManyPageInput = {
    id?: string
    content: string
    type?: $Enums.TextType
    language: $Enums.AppLanguage
    textAccuracy?: number | null
    contributorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageImageUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    useType?: EnumImageUseTypeFieldUpdateOperationsInput | $Enums.ImageUseType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    storageFile?: StorageFileUpdateOneRequiredWithoutPageImagesNestedInput
  }

  export type PageImageUncheckedUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageFileId?: StringFieldUpdateOperationsInput | string
    useType?: EnumImageUseTypeFieldUpdateOperationsInput | $Enums.ImageUseType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageImageUncheckedUpdateManyWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    storageFileId?: StringFieldUpdateOperationsInput | string
    useType?: EnumImageUseTypeFieldUpdateOperationsInput | $Enums.ImageUseType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageTextUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTextTypeFieldUpdateOperationsInput | $Enums.TextType
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    textAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contributor?: UserUpdateOneWithoutPageTextsNestedInput
  }

  export type PageTextUncheckedUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTextTypeFieldUpdateOperationsInput | $Enums.TextType
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    textAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageTextUncheckedUpdateManyWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumTextTypeFieldUpdateOperationsInput | $Enums.TextType
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    textAccuracy?: NullableIntFieldUpdateOperationsInput | number | null
    contributorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtifactUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    dateDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    dateSort?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: BoolFieldUpdateOperationsInput | boolean
    displayTexts?: BoolFieldUpdateOperationsInput | boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategory?: ArtifactCategoryUpdateOneWithoutArtifactsNestedInput
    periods?: PeriodUpdateManyWithoutArtifactsNestedInput
    places?: PlaceUpdateManyWithoutArtifactsNestedInput
    regions?: RegionUpdateManyWithoutArtifactsNestedInput
    tags?: TagUpdateManyWithoutArtifactsNestedInput
  }

  export type ArtifactUncheckedUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    dateDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    dateSort?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: BoolFieldUpdateOperationsInput | boolean
    displayTexts?: BoolFieldUpdateOperationsInput | boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    periods?: PeriodUncheckedUpdateManyWithoutArtifactsNestedInput
    places?: PlaceUncheckedUpdateManyWithoutArtifactsNestedInput
    regions?: RegionUncheckedUpdateManyWithoutArtifactsNestedInput
    tags?: TagUncheckedUpdateManyWithoutArtifactsNestedInput
  }

  export type ArtifactUncheckedUpdateManyWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    dateDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    dateSort?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: BoolFieldUpdateOperationsInput | boolean
    displayTexts?: BoolFieldUpdateOperationsInput | boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PeriodUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PeriodUncheckedUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PeriodUncheckedUpdateManyWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    dateStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlaceUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    geoname?: StringFieldUpdateOperationsInput | string
    geocode?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    countryCode?: StringFieldUpdateOperationsInput | string
    admin1?: NullableStringFieldUpdateOperationsInput | string | null
    admin2?: NullableStringFieldUpdateOperationsInput | string | null
    administrativePlaces?: AdministrativePlaceUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceUncheckedUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    geoname?: StringFieldUpdateOperationsInput | string
    geocode?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    countryCode?: StringFieldUpdateOperationsInput | string
    admin1?: NullableStringFieldUpdateOperationsInput | string | null
    admin2?: NullableStringFieldUpdateOperationsInput | string | null
    administrativePlaces?: AdministrativePlaceUncheckedUpdateManyWithoutPlaceNestedInput
  }

  export type PlaceUncheckedUpdateManyWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    geoname?: StringFieldUpdateOperationsInput | string
    geocode?: StringFieldUpdateOperationsInput | string
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lon?: NullableFloatFieldUpdateOperationsInput | number | null
    countryCode?: StringFieldUpdateOperationsInput | string
    admin1?: NullableStringFieldUpdateOperationsInput | string | null
    admin2?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RegionUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collections?: CollectionUpdateManyWithoutRegionsNestedInput
    layers?: LayerUpdateManyWithoutRegionsNestedInput
    maps?: MapUpdateManyWithoutRegionsNestedInput
    pages?: PageUpdateManyWithoutRegionsNestedInput
    posts?: PostUpdateManyWithoutRegionsNestedInput
    datasets?: ResearchDatasetUpdateManyWithoutRegionsNestedInput
    series?: SeriesUpdateManyWithoutRegionsNestedInput
    volumes?: VolumeUpdateManyWithoutRegionsNestedInput
  }

  export type RegionUncheckedUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collections?: CollectionUncheckedUpdateManyWithoutRegionsNestedInput
    layers?: LayerUncheckedUpdateManyWithoutRegionsNestedInput
    maps?: MapUncheckedUpdateManyWithoutRegionsNestedInput
    pages?: PageUncheckedUpdateManyWithoutRegionsNestedInput
    posts?: PostUncheckedUpdateManyWithoutRegionsNestedInput
    datasets?: ResearchDatasetUncheckedUpdateManyWithoutRegionsNestedInput
    series?: SeriesUncheckedUpdateManyWithoutRegionsNestedInput
    volumes?: VolumeUncheckedUpdateManyWithoutRegionsNestedInput
  }

  export type RegionUncheckedUpdateManyWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUpdateManyWithoutTagNestedInput
    collections?: CollectionUpdateManyWithoutTagsNestedInput
    layers?: LayerUpdateManyWithoutTagsNestedInput
    maps?: MapUpdateManyWithoutTagsNestedInput
    pages?: PageUpdateManyWithoutTagsNestedInput
    series?: SeriesUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUncheckedUpdateManyWithoutTagNestedInput
    collections?: CollectionUncheckedUpdateManyWithoutTagsNestedInput
    layers?: LayerUncheckedUpdateManyWithoutTagsNestedInput
    maps?: MapUncheckedUpdateManyWithoutTagsNestedInput
    pages?: PageUncheckedUpdateManyWithoutTagsNestedInput
    series?: SeriesUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VolumePageUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequenceIndex?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    data?: PageDataUpdateOneWithoutPageNestedInput
    images?: PageImageUpdateManyWithoutPageNestedInput
    texts?: PageTextUpdateManyWithoutPageNestedInput
    volume?: VolumeUpdateOneWithoutPagesNestedInput
  }

  export type VolumePageUncheckedUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    volumeId?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceIndex?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    data?: PageDataUncheckedUpdateOneWithoutPageNestedInput
    images?: PageImageUncheckedUpdateManyWithoutPageNestedInput
    texts?: PageTextUncheckedUpdateManyWithoutPageNestedInput
  }

  export type VolumePageUncheckedUpdateManyWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    volumeId?: NullableStringFieldUpdateOperationsInput | string | null
    sequenceIndex?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isVisible?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MediaCreateManyStorageFileInput = {
    id?: string
    filename: string
    url: string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PageImageCreateManyStorageFileInput = {
    id?: string
    pageId: string
    useType?: $Enums.ImageUseType
    createdAt?: Date | string
  }

  export type MediaUpdateWithoutStorageFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailForCategory?: CategoryUpdateManyWithoutThumbnailNestedInput
    thumbnailForCollections?: CollectionUpdateManyWithoutThumbnailNestedInput
    thumbnailForMaps?: MapUpdateManyWithoutThumbnailNestedInput
    thumbnailForPages?: PageUpdateManyWithoutThumbnailNestedInput
    thumbnailForPosts?: PostUpdateManyWithoutThumbnailNestedInput
    thumbnailForDataset?: ResearchDatasetUpdateManyWithoutThumbnailNestedInput
    thumbnailForSeries?: SeriesUpdateManyWithoutThumbnailNestedInput
    thumbnailForVolumes?: VolumeUpdateManyWithoutThumbnailNestedInput
  }

  export type MediaUncheckedUpdateWithoutStorageFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailForCategory?: CategoryUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForCollections?: CollectionUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForMaps?: MapUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForPages?: PageUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForPosts?: PostUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForDataset?: ResearchDatasetUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForSeries?: SeriesUncheckedUpdateManyWithoutThumbnailNestedInput
    thumbnailForVolumes?: VolumeUncheckedUpdateManyWithoutThumbnailNestedInput
  }

  export type MediaUncheckedUpdateManyWithoutStorageFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altTextI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageImageUpdateWithoutStorageFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    useType?: EnumImageUseTypeFieldUpdateOperationsInput | $Enums.ImageUseType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    page?: VolumePageUpdateOneRequiredWithoutImagesNestedInput
  }

  export type PageImageUncheckedUpdateWithoutStorageFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    useType?: EnumImageUseTypeFieldUpdateOperationsInput | $Enums.ImageUseType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageImageUncheckedUpdateManyWithoutStorageFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    useType?: EnumImageUseTypeFieldUpdateOperationsInput | $Enums.ImageUseType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateManyThumbnailInput = {
    id?: string
    title: string
    slug: string
    createdAt?: Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
  }

  export type CollectionCreateManyThumbnailInput = {
    id?: string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    name?: string
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
  }

  export type MapCreateManyThumbnailInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: number | null
    version?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    period?: string | null
    title?: string
    yearMax?: number | null
    yearMin?: number | null
    categoryId?: string | null
    status?: $Enums.ContentStatus
  }

  export type PageCreateManyThumbnailInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content?: string | null
    excerpt?: string | null
    sources?: string | null
    citations?: string | null
    language?: $Enums.AppLanguage
    translationGroupId?: string | null
    status?: $Enums.ContentStatus
    authorId?: string | null
    parentId?: string | null
    metaDescription?: string | null
    metaKeywords?: string | null
    template?: string | null
    menuOrder?: number
    showInMenu?: boolean
  }

  export type PostCreateManyThumbnailInput = {
    id?: string
    translationGroupId?: string
    language?: $Enums.AppLanguage
    title: string
    slug: string
    content?: string | null
    sources?: string | null
    excerpt?: string | null
    status?: $Enums.ContentStatus
    authorId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResearchDatasetCreateManyThumbnailInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ContentStatus
    maturity?: $Enums.DataMaturity
    version?: string | null
    license?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    title?: string
    categoryId?: string | null
    citationText?: string | null
    codebookText?: string | null
    maxYear?: number | null
    minYear?: number | null
    sources?: string | null
    isVisible?: boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SeriesCreateManyThumbnailInput = {
    id?: string
    collectionId?: string | null
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: number | null
    volumeLabelFormat?: string | null
    createdAt?: Date | string
    slug: string
    name?: string
    description?: string | null
    license?: string | null
    period?: string | null
    sourceLink?: string | null
    sources?: string | null
    author?: string | null
    editor?: string | null
    referenceCode?: string | null
    yearMax?: number | null
    yearMin?: number | null
    languages?: SeriesCreatelanguagesInput | $Enums.ContentLanguage[]
  }

  export type VolumeCreateManyThumbnailInput = {
    id?: string
    seriesId?: string | null
    indexNumber?: number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: string | null
    yearContent?: number | null
    createdAt?: Date | string
    slug: string
    title?: string
    description?: string | null
    license?: string | null
    sourceLink?: string | null
    sources?: string | null
    year?: number | null
    author?: string | null
    editor?: string | null
    languages?: VolumeCreatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: number | null
    yearMin?: number | null
  }

  export type CategoryUpdateWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    layers?: LayerUpdateManyWithoutCategoryNestedInput
    maps?: MapUpdateManyWithoutCategoryNestedInput
    datasets?: ResearchDatasetUpdateManyWithoutCategoryNestedInput
    posts?: PostUpdateManyWithoutCategoriesNestedInput
    series?: SeriesUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    layers?: LayerUncheckedUpdateManyWithoutCategoryNestedInput
    maps?: MapUncheckedUpdateManyWithoutCategoryNestedInput
    datasets?: ResearchDatasetUncheckedUpdateManyWithoutCategoryNestedInput
    posts?: PostUncheckedUpdateManyWithoutCategoriesNestedInput
    series?: SeriesUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    titleI18n?: JsonNullValueInput | InputJsonValue
  }

  export type CollectionUpdateWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    series?: SeriesUpdateManyWithoutCollectionNestedInput
    regions?: RegionUpdateManyWithoutCollectionsNestedInput
    tags?: TagUpdateManyWithoutCollectionsNestedInput
  }

  export type CollectionUncheckedUpdateWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    series?: SeriesUncheckedUpdateManyWithoutCollectionNestedInput
    regions?: RegionUncheckedUpdateManyWithoutCollectionsNestedInput
    tags?: TagUncheckedUpdateManyWithoutCollectionsNestedInput
  }

  export type CollectionUncheckedUpdateManyWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MapUpdateWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    resources?: DatasetResourceUpdateManyWithoutMapNestedInput
    layers?: MapLayerAssociationUpdateManyWithoutMapNestedInput
    category?: CategoryUpdateOneWithoutMapsNestedInput
    regions?: RegionUpdateManyWithoutMapsNestedInput
    tags?: TagUpdateManyWithoutMapsNestedInput
  }

  export type MapUncheckedUpdateWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    resources?: DatasetResourceUncheckedUpdateManyWithoutMapNestedInput
    layers?: MapLayerAssociationUncheckedUpdateManyWithoutMapNestedInput
    regions?: RegionUncheckedUpdateManyWithoutMapsNestedInput
    tags?: TagUncheckedUpdateManyWithoutMapsNestedInput
  }

  export type MapUncheckedUpdateManyWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
  }

  export type PageUpdateWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
    author?: UserUpdateOneWithoutPagesNestedInput
    parent?: PageUpdateOneWithoutChildrenNestedInput
    children?: PageUpdateManyWithoutParentNestedInput
    regions?: RegionUpdateManyWithoutPagesNestedInput
    tags?: TagUpdateManyWithoutPagesNestedInput
    menuItems?: MenuItemUpdateManyWithoutPageNestedInput
    footerItems?: FooterColumnItemUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
    children?: PageUncheckedUpdateManyWithoutParentNestedInput
    regions?: RegionUncheckedUpdateManyWithoutPagesNestedInput
    tags?: TagUncheckedUpdateManyWithoutPagesNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutPageNestedInput
    footerItems?: FooterColumnItemUncheckedUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateManyWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PostUpdateWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationGroupId?: StringFieldUpdateOperationsInput | string
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: PostTagUpdateManyWithoutPostNestedInput
    author?: UserUpdateOneWithoutPostsNestedInput
    categories?: CategoryUpdateManyWithoutPostsNestedInput
    regions?: RegionUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationGroupId?: StringFieldUpdateOperationsInput | string
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutPostsNestedInput
    regions?: RegionUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateManyWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationGroupId?: StringFieldUpdateOperationsInput | string
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchDatasetUpdateWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    version?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    resources?: DatasetResourceUpdateManyWithoutDatasetNestedInput
    category?: CategoryUpdateOneWithoutDatasetsNestedInput
    regions?: RegionUpdateManyWithoutDatasetsNestedInput
  }

  export type ResearchDatasetUncheckedUpdateWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    version?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    resources?: DatasetResourceUncheckedUpdateManyWithoutDatasetNestedInput
    regions?: RegionUncheckedUpdateManyWithoutDatasetsNestedInput
  }

  export type ResearchDatasetUncheckedUpdateManyWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    version?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SeriesUpdateWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    volumeLabelFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    languages?: SeriesUpdatelanguagesInput | $Enums.ContentLanguage[]
    collection?: CollectionUpdateOneWithoutSeriesNestedInput
    volumes?: VolumeUpdateManyWithoutSeriesNestedInput
    categories?: CategoryUpdateManyWithoutSeriesNestedInput
    regions?: RegionUpdateManyWithoutSeriesNestedInput
    tags?: TagUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    volumeLabelFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    languages?: SeriesUpdatelanguagesInput | $Enums.ContentLanguage[]
    volumes?: VolumeUncheckedUpdateManyWithoutSeriesNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutSeriesNestedInput
    regions?: RegionUncheckedUpdateManyWithoutSeriesNestedInput
    tags?: TagUncheckedUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateManyWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    volumeLabelFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    languages?: SeriesUpdatelanguagesInput | $Enums.ContentLanguage[]
  }

  export type VolumeUpdateWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: NullableStringFieldUpdateOperationsInput | string | null
    yearContent?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: VolumeUpdatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    pages?: VolumePageUpdateManyWithoutVolumeNestedInput
    series?: SeriesUpdateOneWithoutVolumesNestedInput
    regions?: RegionUpdateManyWithoutVolumesNestedInput
  }

  export type VolumeUncheckedUpdateWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesId?: NullableStringFieldUpdateOperationsInput | string | null
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: NullableStringFieldUpdateOperationsInput | string | null
    yearContent?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: VolumeUpdatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    pages?: VolumePageUncheckedUpdateManyWithoutVolumeNestedInput
    regions?: RegionUncheckedUpdateManyWithoutVolumesNestedInput
  }

  export type VolumeUncheckedUpdateManyWithoutThumbnailInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesId?: NullableStringFieldUpdateOperationsInput | string | null
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: NullableStringFieldUpdateOperationsInput | string | null
    yearContent?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: VolumeUpdatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AdministrativePlaceCreateManyPlaceInput = {
    id?: string
    name: string
    year?: string | null
    source?: string | null
    admin1?: string | null
    admin2?: string | null
    jewishPop?: number | null
    totalPop?: number | null
  }

  export type AdministrativePlaceUpdateWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    year?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    admin1?: NullableStringFieldUpdateOperationsInput | string | null
    admin2?: NullableStringFieldUpdateOperationsInput | string | null
    jewishPop?: NullableIntFieldUpdateOperationsInput | number | null
    totalPop?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AdministrativePlaceUncheckedUpdateWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    year?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    admin1?: NullableStringFieldUpdateOperationsInput | string | null
    admin2?: NullableStringFieldUpdateOperationsInput | string | null
    jewishPop?: NullableIntFieldUpdateOperationsInput | number | null
    totalPop?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AdministrativePlaceUncheckedUpdateManyWithoutPlaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    year?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    admin1?: NullableStringFieldUpdateOperationsInput | string | null
    admin2?: NullableStringFieldUpdateOperationsInput | string | null
    jewishPop?: NullableIntFieldUpdateOperationsInput | number | null
    totalPop?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ArtifactUpdateWithoutPlacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    dateDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    dateSort?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: BoolFieldUpdateOperationsInput | boolean
    displayTexts?: BoolFieldUpdateOperationsInput | boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategory?: ArtifactCategoryUpdateOneWithoutArtifactsNestedInput
    periods?: PeriodUpdateManyWithoutArtifactsNestedInput
    regions?: RegionUpdateManyWithoutArtifactsNestedInput
    tags?: TagUpdateManyWithoutArtifactsNestedInput
    pages?: VolumePageUpdateManyWithoutArtifactsNestedInput
  }

  export type ArtifactUncheckedUpdateWithoutPlacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    dateDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    dateSort?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: BoolFieldUpdateOperationsInput | boolean
    displayTexts?: BoolFieldUpdateOperationsInput | boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    periods?: PeriodUncheckedUpdateManyWithoutArtifactsNestedInput
    regions?: RegionUncheckedUpdateManyWithoutArtifactsNestedInput
    tags?: TagUncheckedUpdateManyWithoutArtifactsNestedInput
    pages?: VolumePageUncheckedUpdateManyWithoutArtifactsNestedInput
  }

  export type ArtifactUncheckedUpdateManyWithoutPlacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    dateDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    dateSort?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: BoolFieldUpdateOperationsInput | boolean
    displayTexts?: BoolFieldUpdateOperationsInput | boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostTagCreateManyTagInput = {
    postId: string
  }

  export type PostTagUpdateWithoutTagInput = {
    post?: PostUpdateOneRequiredWithoutTagsNestedInput
  }

  export type PostTagUncheckedUpdateWithoutTagInput = {
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type PostTagUncheckedUpdateManyWithoutTagInput = {
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type ArtifactUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    dateDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    dateSort?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: BoolFieldUpdateOperationsInput | boolean
    displayTexts?: BoolFieldUpdateOperationsInput | boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategory?: ArtifactCategoryUpdateOneWithoutArtifactsNestedInput
    periods?: PeriodUpdateManyWithoutArtifactsNestedInput
    places?: PlaceUpdateManyWithoutArtifactsNestedInput
    regions?: RegionUpdateManyWithoutArtifactsNestedInput
    pages?: VolumePageUpdateManyWithoutArtifactsNestedInput
  }

  export type ArtifactUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    dateDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    dateSort?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: BoolFieldUpdateOperationsInput | boolean
    displayTexts?: BoolFieldUpdateOperationsInput | boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    periods?: PeriodUncheckedUpdateManyWithoutArtifactsNestedInput
    places?: PlaceUncheckedUpdateManyWithoutArtifactsNestedInput
    regions?: RegionUncheckedUpdateManyWithoutArtifactsNestedInput
    pages?: VolumePageUncheckedUpdateManyWithoutArtifactsNestedInput
  }

  export type ArtifactUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    dateDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    dateSort?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: BoolFieldUpdateOperationsInput | boolean
    displayTexts?: BoolFieldUpdateOperationsInput | boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CollectionUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnail?: MediaUpdateOneWithoutThumbnailForCollectionsNestedInput
    series?: SeriesUpdateManyWithoutCollectionNestedInput
    regions?: RegionUpdateManyWithoutCollectionsNestedInput
  }

  export type CollectionUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    series?: SeriesUncheckedUpdateManyWithoutCollectionNestedInput
    regions?: RegionUncheckedUpdateManyWithoutCollectionsNestedInput
  }

  export type CollectionUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LayerUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    version?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLayerTypeFieldUpdateOperationsInput | $Enums.LayerType
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: NullableStringFieldUpdateOperationsInput | string | null
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumLayerSourceTypeFieldUpdateOperationsInput | $Enums.LayerSourceType
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutLayersNestedInput
    maps?: MapLayerAssociationUpdateManyWithoutLayerNestedInput
    regions?: RegionUpdateManyWithoutLayersNestedInput
  }

  export type LayerUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    version?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLayerTypeFieldUpdateOperationsInput | $Enums.LayerType
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: NullableStringFieldUpdateOperationsInput | string | null
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumLayerSourceTypeFieldUpdateOperationsInput | $Enums.LayerSourceType
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maps?: MapLayerAssociationUncheckedUpdateManyWithoutLayerNestedInput
    regions?: RegionUncheckedUpdateManyWithoutLayersNestedInput
  }

  export type LayerUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    version?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLayerTypeFieldUpdateOperationsInput | $Enums.LayerType
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: NullableStringFieldUpdateOperationsInput | string | null
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumLayerSourceTypeFieldUpdateOperationsInput | $Enums.LayerSourceType
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    resources?: DatasetResourceUpdateManyWithoutMapNestedInput
    layers?: MapLayerAssociationUpdateManyWithoutMapNestedInput
    category?: CategoryUpdateOneWithoutMapsNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForMapsNestedInput
    regions?: RegionUpdateManyWithoutMapsNestedInput
  }

  export type MapUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    resources?: DatasetResourceUncheckedUpdateManyWithoutMapNestedInput
    layers?: MapLayerAssociationUncheckedUpdateManyWithoutMapNestedInput
    regions?: RegionUncheckedUpdateManyWithoutMapsNestedInput
  }

  export type MapUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
  }

  export type PageUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
    author?: UserUpdateOneWithoutPagesNestedInput
    parent?: PageUpdateOneWithoutChildrenNestedInput
    children?: PageUpdateManyWithoutParentNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForPagesNestedInput
    regions?: RegionUpdateManyWithoutPagesNestedInput
    menuItems?: MenuItemUpdateManyWithoutPageNestedInput
    footerItems?: FooterColumnItemUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
    children?: PageUncheckedUpdateManyWithoutParentNestedInput
    regions?: RegionUncheckedUpdateManyWithoutPagesNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutPageNestedInput
    footerItems?: FooterColumnItemUncheckedUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SeriesUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    volumeLabelFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    languages?: SeriesUpdatelanguagesInput | $Enums.ContentLanguage[]
    collection?: CollectionUpdateOneWithoutSeriesNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForSeriesNestedInput
    volumes?: VolumeUpdateManyWithoutSeriesNestedInput
    categories?: CategoryUpdateManyWithoutSeriesNestedInput
    regions?: RegionUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    volumeLabelFormat?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    languages?: SeriesUpdatelanguagesInput | $Enums.ContentLanguage[]
    volumes?: VolumeUncheckedUpdateManyWithoutSeriesNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutSeriesNestedInput
    regions?: RegionUncheckedUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    volumeLabelFormat?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    languages?: SeriesUpdatelanguagesInput | $Enums.ContentLanguage[]
  }

  export type ArtifactUpdateWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    dateDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    dateSort?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: BoolFieldUpdateOperationsInput | boolean
    displayTexts?: BoolFieldUpdateOperationsInput | boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategory?: ArtifactCategoryUpdateOneWithoutArtifactsNestedInput
    periods?: PeriodUpdateManyWithoutArtifactsNestedInput
    places?: PlaceUpdateManyWithoutArtifactsNestedInput
    tags?: TagUpdateManyWithoutArtifactsNestedInput
    pages?: VolumePageUpdateManyWithoutArtifactsNestedInput
  }

  export type ArtifactUncheckedUpdateWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    dateDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    dateSort?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: BoolFieldUpdateOperationsInput | boolean
    displayTexts?: BoolFieldUpdateOperationsInput | boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    periods?: PeriodUncheckedUpdateManyWithoutArtifactsNestedInput
    places?: PlaceUncheckedUpdateManyWithoutArtifactsNestedInput
    tags?: TagUncheckedUpdateManyWithoutArtifactsNestedInput
    pages?: VolumePageUncheckedUpdateManyWithoutArtifactsNestedInput
  }

  export type ArtifactUncheckedUpdateManyWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    dateDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    dateSort?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: BoolFieldUpdateOperationsInput | boolean
    displayTexts?: BoolFieldUpdateOperationsInput | boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CollectionUpdateWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnail?: MediaUpdateOneWithoutThumbnailForCollectionsNestedInput
    series?: SeriesUpdateManyWithoutCollectionNestedInput
    tags?: TagUpdateManyWithoutCollectionsNestedInput
  }

  export type CollectionUncheckedUpdateWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    series?: SeriesUncheckedUpdateManyWithoutCollectionNestedInput
    tags?: TagUncheckedUpdateManyWithoutCollectionsNestedInput
  }

  export type CollectionUncheckedUpdateManyWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LayerUpdateWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    version?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLayerTypeFieldUpdateOperationsInput | $Enums.LayerType
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: NullableStringFieldUpdateOperationsInput | string | null
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumLayerSourceTypeFieldUpdateOperationsInput | $Enums.LayerSourceType
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutLayersNestedInput
    maps?: MapLayerAssociationUpdateManyWithoutLayerNestedInput
    tags?: TagUpdateManyWithoutLayersNestedInput
  }

  export type LayerUncheckedUpdateWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    version?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLayerTypeFieldUpdateOperationsInput | $Enums.LayerType
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: NullableStringFieldUpdateOperationsInput | string | null
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumLayerSourceTypeFieldUpdateOperationsInput | $Enums.LayerSourceType
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maps?: MapLayerAssociationUncheckedUpdateManyWithoutLayerNestedInput
    tags?: TagUncheckedUpdateManyWithoutLayersNestedInput
  }

  export type LayerUncheckedUpdateManyWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    version?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLayerTypeFieldUpdateOperationsInput | $Enums.LayerType
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: NullableStringFieldUpdateOperationsInput | string | null
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumLayerSourceTypeFieldUpdateOperationsInput | $Enums.LayerSourceType
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapUpdateWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    resources?: DatasetResourceUpdateManyWithoutMapNestedInput
    layers?: MapLayerAssociationUpdateManyWithoutMapNestedInput
    category?: CategoryUpdateOneWithoutMapsNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForMapsNestedInput
    tags?: TagUpdateManyWithoutMapsNestedInput
  }

  export type MapUncheckedUpdateWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    resources?: DatasetResourceUncheckedUpdateManyWithoutMapNestedInput
    layers?: MapLayerAssociationUncheckedUpdateManyWithoutMapNestedInput
    tags?: TagUncheckedUpdateManyWithoutMapsNestedInput
  }

  export type MapUncheckedUpdateManyWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
  }

  export type PageUpdateWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
    author?: UserUpdateOneWithoutPagesNestedInput
    parent?: PageUpdateOneWithoutChildrenNestedInput
    children?: PageUpdateManyWithoutParentNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForPagesNestedInput
    tags?: TagUpdateManyWithoutPagesNestedInput
    menuItems?: MenuItemUpdateManyWithoutPageNestedInput
    footerItems?: FooterColumnItemUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
    children?: PageUncheckedUpdateManyWithoutParentNestedInput
    tags?: TagUncheckedUpdateManyWithoutPagesNestedInput
    menuItems?: MenuItemUncheckedUpdateManyWithoutPageNestedInput
    footerItems?: FooterColumnItemUncheckedUpdateManyWithoutPageNestedInput
  }

  export type PageUncheckedUpdateManyWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    citations?: NullableStringFieldUpdateOperationsInput | string | null
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    translationGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    metaKeywords?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    menuOrder?: IntFieldUpdateOperationsInput | number
    showInMenu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PostUpdateWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationGroupId?: StringFieldUpdateOperationsInput | string
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: PostTagUpdateManyWithoutPostNestedInput
    author?: UserUpdateOneWithoutPostsNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForPostsNestedInput
    categories?: CategoryUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationGroupId?: StringFieldUpdateOperationsInput | string
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateManyWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationGroupId?: StringFieldUpdateOperationsInput | string
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResearchDatasetUpdateWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    version?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    resources?: DatasetResourceUpdateManyWithoutDatasetNestedInput
    category?: CategoryUpdateOneWithoutDatasetsNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForDatasetNestedInput
  }

  export type ResearchDatasetUncheckedUpdateWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    version?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    resources?: DatasetResourceUncheckedUpdateManyWithoutDatasetNestedInput
  }

  export type ResearchDatasetUncheckedUpdateManyWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    version?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SeriesUpdateWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    volumeLabelFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    languages?: SeriesUpdatelanguagesInput | $Enums.ContentLanguage[]
    collection?: CollectionUpdateOneWithoutSeriesNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForSeriesNestedInput
    volumes?: VolumeUpdateManyWithoutSeriesNestedInput
    categories?: CategoryUpdateManyWithoutSeriesNestedInput
    tags?: TagUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    volumeLabelFormat?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    languages?: SeriesUpdatelanguagesInput | $Enums.ContentLanguage[]
    volumes?: VolumeUncheckedUpdateManyWithoutSeriesNestedInput
    categories?: CategoryUncheckedUpdateManyWithoutSeriesNestedInput
    tags?: TagUncheckedUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateManyWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    volumeLabelFormat?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    languages?: SeriesUpdatelanguagesInput | $Enums.ContentLanguage[]
  }

  export type VolumeUpdateWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: NullableStringFieldUpdateOperationsInput | string | null
    yearContent?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: VolumeUpdatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    pages?: VolumePageUpdateManyWithoutVolumeNestedInput
    series?: SeriesUpdateOneWithoutVolumesNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForVolumesNestedInput
  }

  export type VolumeUncheckedUpdateWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesId?: NullableStringFieldUpdateOperationsInput | string | null
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: NullableStringFieldUpdateOperationsInput | string | null
    yearContent?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: VolumeUpdatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    pages?: VolumePageUncheckedUpdateManyWithoutVolumeNestedInput
  }

  export type VolumeUncheckedUpdateManyWithoutRegionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    seriesId?: NullableStringFieldUpdateOperationsInput | string | null
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    titleI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    languageOfContent?: NullableStringFieldUpdateOperationsInput | string | null
    yearContent?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    languages?: VolumeUpdatelanguagesInput | $Enums.ContentLanguage[]
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LayerCreateManyCategoryInput = {
    id?: string
    slug: string
    name?: string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: string | null
    status?: $Enums.ContentStatus
    version?: string | null
    type?: $Enums.LayerType
    citationText?: string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: string | null
    maturity?: $Enums.DataMaturity
    minYear?: number | null
    maxYear?: number | null
    sourceType?: $Enums.LayerSourceType
    sourceUrl?: string | null
    downloadUrl?: string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MapCreateManyCategoryInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: number | null
    version?: string | null
    thumbnailId?: string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    period?: string | null
    title?: string
    yearMax?: number | null
    yearMin?: number | null
    status?: $Enums.ContentStatus
  }

  export type ResearchDatasetCreateManyCategoryInput = {
    id?: string
    slug: string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ContentStatus
    maturity?: $Enums.DataMaturity
    version?: string | null
    license?: string | null
    thumbnailId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    title?: string
    citationText?: string | null
    codebookText?: string | null
    maxYear?: number | null
    minYear?: number | null
    sources?: string | null
    isVisible?: boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
  }

  export type LayerUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    version?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLayerTypeFieldUpdateOperationsInput | $Enums.LayerType
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: NullableStringFieldUpdateOperationsInput | string | null
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumLayerSourceTypeFieldUpdateOperationsInput | $Enums.LayerSourceType
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maps?: MapLayerAssociationUpdateManyWithoutLayerNestedInput
    regions?: RegionUpdateManyWithoutLayersNestedInput
    tags?: TagUpdateManyWithoutLayersNestedInput
  }

  export type LayerUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    version?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLayerTypeFieldUpdateOperationsInput | $Enums.LayerType
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: NullableStringFieldUpdateOperationsInput | string | null
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumLayerSourceTypeFieldUpdateOperationsInput | $Enums.LayerSourceType
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maps?: MapLayerAssociationUncheckedUpdateManyWithoutLayerNestedInput
    regions?: RegionUncheckedUpdateManyWithoutLayersNestedInput
    tags?: TagUncheckedUpdateManyWithoutLayersNestedInput
  }

  export type LayerUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameI18n?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    version?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLayerTypeFieldUpdateOperationsInput | $Enums.LayerType
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    citationTextI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    license?: NullableStringFieldUpdateOperationsInput | string | null
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    sourceType?: EnumLayerSourceTypeFieldUpdateOperationsInput | $Enums.LayerSourceType
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    geoJsonData?: NullableJsonNullValueInput | InputJsonValue
    styleConfig?: JsonNullValueInput | InputJsonValue
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MapUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    resources?: DatasetResourceUpdateManyWithoutMapNestedInput
    layers?: MapLayerAssociationUpdateManyWithoutMapNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForMapsNestedInput
    regions?: RegionUpdateManyWithoutMapsNestedInput
    tags?: TagUpdateManyWithoutMapsNestedInput
  }

  export type MapUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    resources?: DatasetResourceUncheckedUpdateManyWithoutMapNestedInput
    layers?: MapLayerAssociationUncheckedUpdateManyWithoutMapNestedInput
    regions?: RegionUncheckedUpdateManyWithoutMapsNestedInput
    tags?: TagUncheckedUpdateManyWithoutMapsNestedInput
  }

  export type MapUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    version?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    config?: NullableJsonNullValueInput | InputJsonValue
    globalStyleConfig?: NullableJsonNullValueInput | InputJsonValue
    referenceLinks?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
  }

  export type ResearchDatasetUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    version?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    resources?: DatasetResourceUpdateManyWithoutDatasetNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForDatasetNestedInput
    regions?: RegionUpdateManyWithoutDatasetsNestedInput
  }

  export type ResearchDatasetUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    version?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    resources?: DatasetResourceUncheckedUpdateManyWithoutDatasetNestedInput
    regions?: RegionUncheckedUpdateManyWithoutDatasetsNestedInput
  }

  export type ResearchDatasetUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    titleI18n?: NullableJsonNullValueInput | InputJsonValue
    codebookTextI18n?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    maturity?: EnumDataMaturityFieldUpdateOperationsInput | $Enums.DataMaturity
    version?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    citationText?: NullableStringFieldUpdateOperationsInput | string | null
    codebookText?: NullableStringFieldUpdateOperationsInput | string | null
    maxYear?: NullableIntFieldUpdateOperationsInput | number | null
    minYear?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    isVisible?: BoolFieldUpdateOperationsInput | boolean
    sourcesI18n?: NullableJsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PostUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationGroupId?: StringFieldUpdateOperationsInput | string
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: PostTagUpdateManyWithoutPostNestedInput
    author?: UserUpdateOneWithoutPostsNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForPostsNestedInput
    regions?: RegionUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationGroupId?: StringFieldUpdateOperationsInput | string
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
    regions?: RegionUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    translationGroupId?: StringFieldUpdateOperationsInput | string
    language?: EnumAppLanguageFieldUpdateOperationsInput | $Enums.AppLanguage
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeriesUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    volumeLabelFormat?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    languages?: SeriesUpdatelanguagesInput | $Enums.ContentLanguage[]
    collection?: CollectionUpdateOneWithoutSeriesNestedInput
    thumbnail?: MediaUpdateOneWithoutThumbnailForSeriesNestedInput
    volumes?: VolumeUpdateManyWithoutSeriesNestedInput
    regions?: RegionUpdateManyWithoutSeriesNestedInput
    tags?: TagUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    volumeLabelFormat?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    languages?: SeriesUpdatelanguagesInput | $Enums.ContentLanguage[]
    volumes?: VolumeUncheckedUpdateManyWithoutSeriesNestedInput
    regions?: RegionUncheckedUpdateManyWithoutSeriesNestedInput
    tags?: TagUncheckedUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    collectionId?: NullableStringFieldUpdateOperationsInput | string | null
    nameI18n?: JsonNullValueInput | InputJsonValue
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    indexNumber?: NullableIntFieldUpdateOperationsInput | number | null
    volumeLabelFormat?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    license?: NullableStringFieldUpdateOperationsInput | string | null
    period?: NullableStringFieldUpdateOperationsInput | string | null
    sourceLink?: NullableStringFieldUpdateOperationsInput | string | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    editor?: NullableStringFieldUpdateOperationsInput | string | null
    referenceCode?: NullableStringFieldUpdateOperationsInput | string | null
    yearMax?: NullableIntFieldUpdateOperationsInput | number | null
    yearMin?: NullableIntFieldUpdateOperationsInput | number | null
    languages?: SeriesUpdatelanguagesInput | $Enums.ContentLanguage[]
  }

  export type ArtifactCreateManyArtifactCategoryInput = {
    id?: string
    slug: string
    content?: string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: number | null
    dateDisplay?: string | null
    dateSort?: Date | string | null
    excerpt?: string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    description?: string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: boolean
    displayTexts?: boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: string
    titleI18n?: JsonNullValueInput | InputJsonValue
  }

  export type ArtifactUpdateWithoutArtifactCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    dateDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    dateSort?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: BoolFieldUpdateOperationsInput | boolean
    displayTexts?: BoolFieldUpdateOperationsInput | boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    periods?: PeriodUpdateManyWithoutArtifactsNestedInput
    places?: PlaceUpdateManyWithoutArtifactsNestedInput
    regions?: RegionUpdateManyWithoutArtifactsNestedInput
    tags?: TagUpdateManyWithoutArtifactsNestedInput
    pages?: VolumePageUpdateManyWithoutArtifactsNestedInput
  }

  export type ArtifactUncheckedUpdateWithoutArtifactCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    dateDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    dateSort?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: BoolFieldUpdateOperationsInput | boolean
    displayTexts?: BoolFieldUpdateOperationsInput | boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    periods?: PeriodUncheckedUpdateManyWithoutArtifactsNestedInput
    places?: PlaceUncheckedUpdateManyWithoutArtifactsNestedInput
    regions?: RegionUncheckedUpdateManyWithoutArtifactsNestedInput
    tags?: TagUncheckedUpdateManyWithoutArtifactsNestedInput
    pages?: VolumePageUncheckedUpdateManyWithoutArtifactsNestedInput
  }

  export type ArtifactUncheckedUpdateManyWithoutArtifactCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    dateDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    dateSort?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: BoolFieldUpdateOperationsInput | boolean
    displayTexts?: BoolFieldUpdateOperationsInput | boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
  }

  export type ArtifactUpdateWithoutPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    dateDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    dateSort?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: BoolFieldUpdateOperationsInput | boolean
    displayTexts?: BoolFieldUpdateOperationsInput | boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategory?: ArtifactCategoryUpdateOneWithoutArtifactsNestedInput
    places?: PlaceUpdateManyWithoutArtifactsNestedInput
    regions?: RegionUpdateManyWithoutArtifactsNestedInput
    tags?: TagUpdateManyWithoutArtifactsNestedInput
    pages?: VolumePageUpdateManyWithoutArtifactsNestedInput
  }

  export type ArtifactUncheckedUpdateWithoutPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    dateDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    dateSort?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: BoolFieldUpdateOperationsInput | boolean
    displayTexts?: BoolFieldUpdateOperationsInput | boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    places?: PlaceUncheckedUpdateManyWithoutArtifactsNestedInput
    regions?: RegionUncheckedUpdateManyWithoutArtifactsNestedInput
    tags?: TagUncheckedUpdateManyWithoutArtifactsNestedInput
    pages?: VolumePageUncheckedUpdateManyWithoutArtifactsNestedInput
  }

  export type ArtifactUncheckedUpdateManyWithoutPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentI18n?: JsonNullValueInput | InputJsonValue
    year?: NullableIntFieldUpdateOperationsInput | number | null
    dateDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    dateSort?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    excerptI18n?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionI18n?: NullableJsonNullValueInput | InputJsonValue
    displayScans?: BoolFieldUpdateOperationsInput | boolean
    displayTexts?: BoolFieldUpdateOperationsInput | boolean
    sources?: JsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    titleI18n?: JsonNullValueInput | InputJsonValue
    artifactCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MenuItemCreateManyMenuInput = {
    id?: string
    parentId?: string | null
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    variant?: $Enums.ItemVariant
    order?: number
    pageId?: string | null
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuItemUpdateWithoutMenuInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    variant?: EnumItemVariantFieldUpdateOperationsInput | $Enums.ItemVariant
    order?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: MenuItemUpdateOneWithoutChildrenNestedInput
    children?: MenuItemUpdateManyWithoutParentNestedInput
    page?: PageUpdateOneWithoutMenuItemsNestedInput
  }

  export type MenuItemUncheckedUpdateWithoutMenuInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    variant?: EnumItemVariantFieldUpdateOperationsInput | $Enums.ItemVariant
    order?: IntFieldUpdateOperationsInput | number
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: MenuItemUncheckedUpdateManyWithoutParentNestedInput
  }

  export type MenuItemUncheckedUpdateManyWithoutMenuInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    variant?: EnumItemVariantFieldUpdateOperationsInput | $Enums.ItemVariant
    order?: IntFieldUpdateOperationsInput | number
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MenuItemCreateManyParentInput = {
    id?: string
    menuId: string
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    variant?: $Enums.ItemVariant
    order?: number
    pageId?: string | null
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MenuItemUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    variant?: EnumItemVariantFieldUpdateOperationsInput | $Enums.ItemVariant
    order?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    menu?: MenuUpdateOneRequiredWithoutItemsNestedInput
    children?: MenuItemUpdateManyWithoutParentNestedInput
    page?: PageUpdateOneWithoutMenuItemsNestedInput
  }

  export type MenuItemUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    variant?: EnumItemVariantFieldUpdateOperationsInput | $Enums.ItemVariant
    order?: IntFieldUpdateOperationsInput | number
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: MenuItemUncheckedUpdateManyWithoutParentNestedInput
  }

  export type MenuItemUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    menuId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    variant?: EnumItemVariantFieldUpdateOperationsInput | $Enums.ItemVariant
    order?: IntFieldUpdateOperationsInput | number
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FooterColumnItemCreateManyFooterColumnInput = {
    id?: string
    label?: string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: string | null
    order?: number
    pageId?: string | null
    url?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FooterColumnItemUpdateWithoutFooterColumnInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    page?: PageUpdateOneWithoutFooterItemsNestedInput
  }

  export type FooterColumnItemUncheckedUpdateWithoutFooterColumnInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FooterColumnItemUncheckedUpdateManyWithoutFooterColumnInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    labelI18n?: JsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    pageId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentPageCreateManyDocumentInput = {
    id?: string
    index: number
    content: string
    contentHe?: string | null
    contentEn?: string | null
    filename?: string | null
    bookmark?: string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentPageUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentHe?: NullableStringFieldUpdateOperationsInput | string | null
    contentEn?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    bookmark?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentPageUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentHe?: NullableStringFieldUpdateOperationsInput | string | null
    contentEn?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    bookmark?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentPageUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    index?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    contentHe?: NullableStringFieldUpdateOperationsInput | string | null
    contentEn?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    bookmark?: NullableStringFieldUpdateOperationsInput | string | null
    highlights?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}